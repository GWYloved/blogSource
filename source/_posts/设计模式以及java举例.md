---
title: 设计模式以及java举例
date: 2019-02-15 00:13:47
tags: 设计模式
---

# 设计模式原则

1. 开闭原则

对拓展开放，对修改关闭。

2. 里氏替换原则

只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正的被复用，而衍生类也能在基类的基础上增加新的行为。

3. 依赖倒转原则

对接口编程，依赖于抽象而不依赖于具体。

4. 接口隔离原则

使用多个隔离的接口来降低耦合度

5. 迪米特法则

一个实体应该尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立

6. 合成复用原则

尽量使用合成/聚合的方式，而不是使用继承，继承实际上破坏了类的封装性，超类的方法可能被子类修改

# 三大类

基于6个设计原则，衍生为3大类23种设计模式

## 创造型模式

- 工厂方法模式

- 抽象工厂模式

- 单例模式

- 建造者模式

- 原型模式

## 结构型模式

- 适配器模式

- 装饰器模式

- 代理模式

- 外观模式

- 桥接模式

- 组合模式

- 享元模式

## 行为型模式

- 策略模式

- 模版方法模式

- 观察者模式

- 迭代子模式

- 责任链模式

- 命令模式

- 备忘录模式

- 状态模式

- 访问者模式

- 中介者模式

- 解释器模式

# 详解

## 工厂模式

通过new创建一个对象，大部分时候需要传入构造参数，或者生成对象之前需要先生成一些辅助功能的对象。
这样可以抽象的认为一个对象的构建如同机器中的齿轮转动，最后通过生成了很多对象之后，生成了一个最终的对象。

### 解决的问题

不关心对象实例构造的细节和复杂过程，而轻松的创建实例

### 抽象工厂模式

实例构建过程
```
//声明抽象接口类
interface food{}

//需要的实体类需要继承该接口
class A implements food{}
class B implements food{}
```

工厂过程
```
interface produce{ food get();}

class FactoryForA implements produce{
    @Override
    public food get() {
        return new A();
    }
}
class FactoryForB implements produce{
    @Override
    public food get() {
        return new B();
    }
}
```

抽象工厂过程
```
public class AbstractFactory {
    public void ClientCode(String name){
        if(name.equals("A")){
            food x= new FactoryForA().get();
            x = new FactoryForB().get();
        }
    }
}
```

工厂过程其实可以直接合成一个Factory使用，但是工厂过程一般都是静态方法，不支持动态更改。
而转变为抽象工厂模式，每次需要增加一个实例的话只需要增加一个工厂类，然后抽象工厂方法可以直接
























