---
title: 动态代理的好处
date: 2019-01-05 00:00:42
tags: java
---

> 先有设计的思想，后才有设计的手段

# 代理

代理模式是java设计模式的一种。代理类具有和委托类相同的接口，代理类主要负责为委托类预处理消息、过滤消息、消息转发、以及事后处理消息等。

## 静态代理

由程序员创建或由特定工具自动生成源代码，在对其编译。在程序运行前，代理类的.class文件就已经存在

静态代理通常只代理一个类。同时静态代理需要明白代理的是什么

sample:

```
//定义代理接口
public interface ProxyInterface{
	void doSomething();
}

public class A implements ProxyInterface{
	@Override
	void doSomething(){
		...
	}
}

public class AProxy implements ProxyInterface{
	private ProxyInterface a;
	public AProxy(ProxyInterface a){
		this.a = a;
	}

	@Override
	void doSomething(){
		a.doSomething();
	}
}
```

## 优点

静态代理从我们日常开发的角度来看，就是一个封装类，比较简单

## 缺点

局限性很大，尤其是限于对代理类的了解。在接手一个项目，发生问题的时候或许可以使用这种代理方式来进行优化

# 动态代理

动态代理类的字节码由java反射机制动态生成，无需手动编写源代码。

sample:

```
//创建InvocationHandler
InvocationHandler handler = new MyInvocationHandler(...);
//创建动态代理类
Class proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(),new Class[]{Foo.class});
//创建动态代理类的实例
Foo foo = (Foo)proxyClass.getConstructor(new Class[]{InvocationHandler.class}).newInstance(new Object[]{handler});
```

这样就获取了类了。

## 原理


### newProxyInstance
```
 public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
        Objects.requireNonNull(h);

        final Class<?>[] intfs = interfaces.clone();
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
        }

        /*
         * Look up or generate the designated proxy class.
         */
        Class<?> cl = getProxyClass0(loader, intfs);

        /*
         * Invoke its constructor with the designated invocation handler.
         */
        try {
            if (sm != null) {
                checkNewProxyPermission(Reflection.getCallerClass(), cl);
            }

            final Constructor<?> cons = cl.getConstructor(constructorParams);
            final InvocationHandler ih = h;
            if (!Modifier.isPublic(cl.getModifiers())) {
                AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    public Void run() {
                        cons.setAccessible(true);
                        return null;
                    }
                });
            }
            return cons.newInstance(new Object[]{h});
        } catch (IllegalAccessException|InstantiationException e) {
            throw new InternalError(e.toString(), e);
        } catch (InvocationTargetException e) {
            Throwable t = e.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            } else {
                throw new InternalError(t.toString(), t);
            }
        } catch (NoSuchMethodException e) {
            throw new InternalError(e.toString(), e);
        }
    }
```















