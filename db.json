{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/算法/希尔排序.png","path":"images/算法/希尔排序.png","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"source/images/爬虫相关/正则.jpg","path":"images/爬虫相关/正则.jpg","modified":1,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"0b257458886d69f9d1d0dfa0779ad07af07c189e","modified":1515466841000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1514172418000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1514172418000},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1514172418000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1514172418000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1514172418000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1514172418000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1514172418000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1514172418000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1514172418000},{"_id":"themes/next/README.cn.md","hash":"58ffe752bc4b7f0069fcd6304bbc2d5ff7b80f89","modified":1514172418000},{"_id":"themes/next/README.md","hash":"aa2fb15ef016074b10755323c99025df506d5ca3","modified":1514172418000},{"_id":"themes/next/bower.json","hash":"6d6ae7531cf3fedc97c58cdad664f5793eb3cc88","modified":1514172418000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1514172418000},{"_id":"themes/next/package.json","hash":"93a74dbc0fe3a1208a02e9cec3c15c2375339cc1","modified":1514172418000},{"_id":"themes/next/_config.yml","hash":"5f09577b11337f32f1fdf662f6537778015cc8f7","modified":1514172974000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1514172418000},{"_id":"source/_posts/.DS_Store","hash":"8c6569433b72237c37bca211614e8e6d4a8d1993","modified":1515466841000},{"_id":"source/images/.DS_Store","hash":"0f2773811b503d1606776267c8c1f4db79e4fa7c","modified":1515466841000},{"_id":"source/_posts/2018开年愿景.md","hash":"c1bb8335aace0208cf0f992486341cba2bf02cc4","modified":1515466841000},{"_id":"source/_posts/2018第一周工作小结.md","hash":"5600b026710f78fffaff100e28833785d0bdcc82","modified":1515466841000},{"_id":"source/_posts/android事件分发机制.md","hash":"0c22de1de2c578f596fb56d57b70c4a01d75f7f7","modified":1515466841000},{"_id":"source/_posts/android事件拦截机制分析.md","hash":"5cd8fe2060043449d78336dd0eabcda8a2033398","modified":1515466841000},{"_id":"source/_posts/android持久化存储.md","hash":"747a6a5e5786073761c3aebc462dc6b684f0990c","modified":1515466841000},{"_id":"source/_posts/android消息推送.md","hash":"ac1610479ed9f45c21e2b24a2033584fae392cb5","modified":1515466841000},{"_id":"source/_posts/2018第二周工作小结.md","hash":"70890750d2ea1d10cde0a31eecf354b39cb63f75","modified":1516093089000},{"_id":"source/_posts/androidscroll分析笔记.md","hash":"2d561c2ff23296fdff0a102abbe3722639c8e30c","modified":1516093089000},{"_id":"source/_posts/ios-stanford-1.md","hash":"4c2fda5290b37e4a0ab455261358461869a8417e","modified":1515466841000},{"_id":"source/_posts/retrofit2-post.md","hash":"f50126aea2a1128c5cd31b95149415da79bf0240","modified":1515466841000},{"_id":"source/_posts/test-appveyor.md","hash":"572b01d5c8f4153dcff51265b6cb4c238354d1d6","modified":1515466841000},{"_id":"source/_posts/Android绘图机制与处理技巧.md","hash":"0ad2d6f60c3c8f9380a1d6d96947e4de926be124","modified":1516275346000},{"_id":"source/_posts/viewgroup测量.md","hash":"57966cead6d1fa33850103f366ee0090d2156940","modified":1515466841000},{"_id":"source/_posts/view的测量和绘制.md","hash":"282881f7d0c8e81c343bc55756c94dc55bd3e62f","modified":1515466841000},{"_id":"source/_posts/“rxjava2-0”.md","hash":"409b3a1256c37d3dddc271b9ebb46d2799992d18","modified":1515466841000},{"_id":"source/_posts/使用appveyor-xml-进行双端部署hexo.md","hash":"7669678aea2bcd13ad1747fdefb491d8492d569e","modified":1515466841000},{"_id":"source/_posts/使用浏览器唤起app.md","hash":"a33d570d556bb7fe633569b58f125d2a78e257f6","modified":1515466841000},{"_id":"source/_posts/冒泡排序.md","hash":"fbd7e6b9d74eba1d26e6e69df4ad017189c5fca0","modified":1516093089000},{"_id":"source/_posts/希尔排序.md","hash":"39e7d990c9fcc5e91f728f5420839d858c7c3a96","modified":1515466841000},{"_id":"source/_posts/堆排序.md","hash":"c9994c1582ae185da01a35ba6dcce8bf386573d0","modified":1516093089000},{"_id":"source/_posts/快速排序.md","hash":"188a662642eb5c070d8de87b32563f7f350b1d31","modified":1516093089000},{"_id":"source/_posts/某金融公司面试小记.md","hash":"56f31ceba418094c6ba85d9a792d65ab61f30aa9","modified":1516093089000},{"_id":"source/_posts/爬虫相关.md","hash":"85019633b497c58e7dba3dbf737477e6d55be97e","modified":1515466841000},{"_id":"source/_posts/简单选择排序.md","hash":"2870bc3aa80dea92de790f0c0e3c67c2a1923f96","modified":1516093089000},{"_id":"source/_posts/直接插入排序.md","hash":"ebdc754408c79c661c9de5b22e34a1370d0cc5f0","modified":1515466841000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1514172418000},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1514172418000},{"_id":"themes/next/.git/index","hash":"56361b361c1a1900155333fbc20d35259ab272c4","modified":1514172418000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1514172328000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1514172418000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1514172418000},{"_id":"themes/next/.git/packed-refs","hash":"f4d7e4a6f59a2abdcdcdd1733b89d4d72e9136d6","modified":1514172418000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1514172418000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1514172418000},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1514172418000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1514172418000},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1514172418000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1514172418000},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1514172418000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1514172418000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1514172418000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1514172418000},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1514172418000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1514172418000},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1514172418000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1514172418000},{"_id":"themes/next/languages/zh-CN.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1514172418000},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1514172418000},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1514172418000},{"_id":"themes/next/scripts/merge-configs.js","hash":"cb617ddf692f56e6b6129564d52e302f50b28243","modified":1514172418000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1514172418000},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1514172418000},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1514172418000},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1514172418000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1514172418000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1514172418000},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1514172418000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1514172418000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1514172418000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1514172418000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1514172418000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1514172418000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1514172418000},{"_id":"source/images/算法/.DS_Store","hash":"9552d5178a745483796d140c5090aaa456768a5f","modified":1516093089000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514172418000},{"_id":"themes/next/.git/logs/HEAD","hash":"4031248090512d1b2d6692e98dab93322b100200","modified":1514172418000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1514172328000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1514172328000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1514172328000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1514172328000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1514172328000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1514172328000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1514172328000},{"_id":"source/images/算法/希尔排序.png","hash":"42b8dff82d3e13b1c771640fd73ca18426294a97","modified":1515466841000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1514172328000},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1514172328000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1514172328000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1514172328000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1514172418000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1514172418000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1514172418000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1514172418000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1514172418000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1514172418000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1514172418000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1514172418000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1514172418000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1514172418000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1514172418000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1514172418000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1514172418000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1514172418000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1514172418000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1514172418000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1514172418000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1514172418000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1514172418000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1514172418000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1514172418000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1514172418000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1514172418000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1514172418000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1514172418000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1514172418000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1514172418000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1514172418000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1514172418000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1514172418000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1514172418000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1514172418000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1514172418000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9efc455894921a66bbc074055d3b39c8a34a48a4","modified":1514172418000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1514172418000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1514172418000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1514172418000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1514172418000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1514172418000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1514172418000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1514172418000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1514172418000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1514172418000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1514172418000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1514172418000},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1514172418000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1514172418000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1514172418000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1514172418000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1514172418000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1514172418000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1514172418000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1514172418000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514172418000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514172418000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514172418000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514172418000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514172418000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514172418000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514172418000},{"_id":"themes/next/.git/refs/heads/master","hash":"d022a9d44457f7717004a8c765a92e0305245725","modified":1514172418000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1514172418000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1514172418000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1514172418000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1514172418000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1514172418000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1514172418000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1514172418000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1514172418000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1514172418000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1514172418000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1514172418000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1514172418000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1514172418000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1514172418000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1514172418000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1514172418000},{"_id":"source/images/爬虫相关/正则.jpg","hash":"41904e45cf2faf0600b802e342d6e6959bf9ff7e","modified":1514169055000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1514172418000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1514172418000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1514172418000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1514172418000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1514172418000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1514172418000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1514172418000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1514172418000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1514172418000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1514172418000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1514172418000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1514172418000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1514172418000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1514172418000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1514172418000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1514172418000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1514172418000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1514172418000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1514172418000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1514172418000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1514172418000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1514172418000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1514172418000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1514172418000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1514172418000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1514172418000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1514172418000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1514172418000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1514172418000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1514172418000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1514172418000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1514172418000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1514172418000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1514172418000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1514172418000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1514172418000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1514172418000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1514172418000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1514172418000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1514172418000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1514172418000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1514172418000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1514172418000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1514172418000},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1514172418000},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1514172418000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1514172418000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1514172418000},{"_id":"themes/next/source/js/src/utils.js","hash":"dbdc3d1300eec7da9632608ebc0e5b697779dad7","modified":1514172418000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1514172418000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1514172418000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1514172418000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1514172418000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1514172418000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1514172418000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1514172418000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1514172418000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1514172418000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1514172418000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1514172418000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1514172418000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1514172418000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1514172418000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1514172418000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1514172418000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1514172418000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1514172418000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1514172418000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1514172418000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1514172418000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1514172418000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1514172418000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1514172418000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1514172418000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1514172418000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1514172418000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1514172418000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1514172418000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1514172418000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1514172418000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1514172418000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1514172418000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1514172418000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1514172418000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1514172418000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1514172418000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1514172418000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1514172418000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"4031248090512d1b2d6692e98dab93322b100200","modified":1514172418000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1514172418000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1514172418000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1514172418000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1514172418000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1514172418000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1514172418000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1514172418000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1514172418000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1514172418000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1514172418000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"02fb8fa6b6c252b6bed469539cd057716606a787","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"bcf52192942c0afc410c74a0fb458e7936ddc3d5","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1514172418000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1514172418000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1514172418000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1514172418000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1514172418000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1514172418000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1514172418000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1514172418000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1514172418000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1514172418000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1514172418000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1514172418000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1514172418000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1514172418000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1514172418000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1514172418000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1514172418000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1514172418000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1514172418000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1514172418000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1514172418000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1514172418000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1514172418000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1514172418000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"4031248090512d1b2d6692e98dab93322b100200","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1514172418000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1514172418000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1514172418000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1514172418000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1514172418000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1514172418000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1514172418000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1514172418000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1514172418000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1514172418000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1514172418000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1514172418000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1514172418000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1514172418000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1514172418000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1514172418000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1514172418000},{"_id":"themes/next/.git/objects/pack/pack-56f59ba9f389a4cda4cead7e9750cfdc648d3144.idx","hash":"4d6e4ee22505e885703a49238eed6829dc6f7775","modified":1514172418000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1514172418000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1514172418000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1514172418000},{"_id":"themes/next/.git/objects/pack/pack-56f59ba9f389a4cda4cead7e9750cfdc648d3144.pack","hash":"6a9ce64118b1a4fd20b09758dfbff133121a4125","modified":1514172418000},{"_id":"public/2018/01/14/2018第二周工作小结/index.html","hash":"65bc64d0727eab57840cffd0d4e63f9be7aa92ec","modified":1516275373483},{"_id":"public/2018/01/07/android消息推送/index.html","hash":"cfb13bd8252644a35df497ef870677a73282bbd1","modified":1516275373483},{"_id":"public/2018/01/06/使用浏览器唤起app/index.html","hash":"6d21b97940d042600ce17004c4e6588d7ed4d017","modified":1516275373483},{"_id":"public/2018/01/02/viewgroup测量/index.html","hash":"ec5aa112dfa6aebaa696730ca2cb38e26bd592a6","modified":1516275373483},{"_id":"public/2017/12/31/ios-stanford-1/index.html","hash":"d70d9cbb378f539ca34853431db90954110b7a3f","modified":1516275373483},{"_id":"public/2017/12/21/test-appveyor/index.html","hash":"ec08f4b7ce94f69417175d15d347be9903983e2b","modified":1516275373483},{"_id":"public/2017/12/21/使用appveyor-xml-进行双端部署hexo/index.html","hash":"62bc7f72d269ed45a7a07fd2a0eb1b15a58e0014","modified":1516275373483},{"_id":"public/archives/index.html","hash":"29cb44f3921782ba84d3146556e88a4a83f751e8","modified":1516275373483},{"_id":"public/archives/page/2/index.html","hash":"8adcd473a92057f4bf0cfbdfaa57a03d5f0d9daf","modified":1516275373483},{"_id":"public/archives/page/3/index.html","hash":"a904a0b2beac5eb032a42dad3030a198aec2f9de","modified":1516275373483},{"_id":"public/archives/2017/index.html","hash":"c46c48c11e843a2402966090586b2c07f4fd76bd","modified":1516275373483},{"_id":"public/archives/2017/12/index.html","hash":"8574207e819ab95e97d8ca970a97ea0b8bff3adc","modified":1516275373483},{"_id":"public/archives/2018/index.html","hash":"091756a37b00daa3a0ba264dda8d0e5c5251582c","modified":1516275373483},{"_id":"public/archives/2018/page/2/index.html","hash":"5083ffb5f96fe120b9b9a83fdac24c53fc6446ff","modified":1516275373483},{"_id":"public/archives/2018/01/index.html","hash":"174daae2f6c4b30b95fff7d2a0b6aaf934681015","modified":1516275373483},{"_id":"public/archives/2018/01/page/2/index.html","hash":"f1d80f3a3b52cdd83ddade5c0a22b9ce9c85c27b","modified":1516275373483},{"_id":"public/tags/计划/index.html","hash":"96dc7ca36f7859e0e07045c1f26d3699500c8d81","modified":1516275373483},{"_id":"public/tags/工作小结/index.html","hash":"6d238e246c50a6ae08cddad0a3f3e1ad8b96f75e","modified":1516275373483},{"_id":"public/tags/android/index.html","hash":"9675983f966876ccac95fdb87199e4eb171d6edb","modified":1516275373484},{"_id":"public/tags/android/page/2/index.html","hash":"c60669d99ceb61442409916aa9e2a3c5cb8e227a","modified":1516275373484},{"_id":"public/tags/ios/index.html","hash":"ea711eb06c56de1c21ca1c5c92d5082ae6d13a24","modified":1516275373484},{"_id":"public/tags/hexo/index.html","hash":"aaa9dd152acd7e47c36725b65bf63de651bac1c4","modified":1516275373484},{"_id":"public/tags/算法/index.html","hash":"fd05f09838cd599f7308aa2396626e1aab531e31","modified":1516275373484},{"_id":"public/tags/生活/index.html","hash":"80aa4116f2a732454145b0195fbf2cdba43371a6","modified":1516275373484},{"_id":"public/tags/python/index.html","hash":"f321e318689e3b8351fb017ceaa2279eae49bff1","modified":1516275373484},{"_id":"public/2018/01/16/Android绘图机制与处理技巧/index.html","hash":"9a1cad1e57e4918422edda92f1c015505a0565ea","modified":1516275373484},{"_id":"public/2018/01/13/androidscroll分析笔记/index.html","hash":"fd15b850c1eccd2b5f3cd5f8261d30627d2940ba","modified":1516275373484},{"_id":"public/2018/01/12/某金融公司面试小记/index.html","hash":"c803e45a144803e07fc74ea85696dc7c090f35bf","modified":1516275373484},{"_id":"public/2018/01/11/快速排序/index.html","hash":"99fedd56d2ad09696848eaf7780e89ee5c5d8c7b","modified":1516275373484},{"_id":"public/2018/01/11/冒泡排序/index.html","hash":"b77867f9a863cb4dc567ed505425fe213d07b0b1","modified":1516275373484},{"_id":"public/2018/01/09/堆排序/index.html","hash":"41c29a270cbc91f1ffa9f3faf7e98dfa02409a36","modified":1516275373484},{"_id":"public/2018/01/09/简单选择排序/index.html","hash":"12ebb21b1e88231660ae885e1188ce28bc50f50d","modified":1516275373484},{"_id":"public/2018/01/08/希尔排序/index.html","hash":"292a2ba600526c8ef725a64c870f24914df76ccc","modified":1516275373484},{"_id":"public/2018/01/08/直接插入排序/index.html","hash":"f5dfaa009fe007fdc353c4b8c849984eedefd207","modified":1516275373484},{"_id":"public/2018/01/05/2018第一周工作小结/index.html","hash":"4213d1873191152f0dc8cbc90d3aeb85243d4b0e","modified":1516275373484},{"_id":"public/2018/01/03/android事件分发机制/index.html","hash":"907a385c31786e9bbeba26833fcafca9c6e39bb5","modified":1516275373484},{"_id":"public/2018/01/03/android事件拦截机制分析/index.html","hash":"b51e5b84aa193428f0775c86a543db2a8b7146da","modified":1516275373484},{"_id":"public/2018/01/03/android持久化存储/index.html","hash":"dfa43c990edb43251a1961bca9e1b5bf4fe44df8","modified":1516275373484},{"_id":"public/2018/01/02/view的测量和绘制/index.html","hash":"4b1439b802d5ee768923463e6007b8e5ca6fd14c","modified":1516275373484},{"_id":"public/2018/01/01/2018开年愿景/index.html","hash":"75ff1b77d428c79e1ed07c1db82af5b30369d704","modified":1516275373485},{"_id":"public/2017/12/23/爬虫相关/index.html","hash":"8735de1de78f83dfaa1e592909cc06e3899f0bb8","modified":1516275373485},{"_id":"public/2017/12/21/“rxjava2-0”/index.html","hash":"8371c5113153110ff5d530f491bdb5032764c6ff","modified":1516275373485},{"_id":"public/2017/12/21/retrofit2-post/index.html","hash":"6a8bbadf2984885919d322cf617648bb5c471369","modified":1516275373485},{"_id":"public/index.html","hash":"70fcf28fec4a2e5795c1e05756034aa8f6996589","modified":1516275373485},{"_id":"public/page/2/index.html","hash":"ec21ba806743cb655e4ffdeafae39eda6b6c4652","modified":1516275373485},{"_id":"public/page/3/index.html","hash":"49a466b3aae199a50576d89f46803efc7ed43451","modified":1516275373485},{"_id":"public/images/算法/希尔排序.png","hash":"42b8dff82d3e13b1c771640fd73ca18426294a97","modified":1516275373490},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1516275373490},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1516275373490},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1516275373490},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1516275373490},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1516275373490},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1516275373490},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1516275373490},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1516275373490},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1516275373490},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1516275373490},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1516275373490},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1516275373490},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1516275373490},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1516275373490},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1516275373490},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1516275373490},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1516275373490},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1516275373491},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1516275373491},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1516275373491},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1516275373491},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1516275373491},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1516275373491},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1516275373491},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1516275373491},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1516275373491},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1516275373491},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1516275373491},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1516275373491},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1516275373491},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1516275373491},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1516275373491},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1516275373491},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1516275375968},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1516275375973},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1516275375981},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1516275375982},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1516275375982},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1516275375982},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1516275375982},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1516275375982},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1516275375982},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1516275375982},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1516275375982},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1516275375982},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1516275375982},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1516275375982},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1516275375982},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1516275375982},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1516275375982},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1516275375982},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1516275375982},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1516275375982},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1516275375982},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1516275375982},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1516275375982},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1516275375982},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1516275375982},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1516275375982},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1516275375982},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1516275375982},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1516275375982},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1516275375983},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1516275375983},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1516275375983},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1516275375983},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1516275375983},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1516275375983},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1516275375983},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1516275375983},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1516275375983},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1516275375983},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1516275375983},{"_id":"public/js/src/utils.js","hash":"dbdc3d1300eec7da9632608ebc0e5b697779dad7","modified":1516275375983},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1516275375983},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1516275375983},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1516275375983},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1516275375983},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1516275375983},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1516275375983},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1516275375983},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1516275375983},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1516275375983},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1516275375983},{"_id":"public/css/main.css","hash":"5a09750ca02922010d6bb3a64c64d4e5aa1ee2c6","modified":1516275375983},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1516275375983},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1516275375983},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1516275375983},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1516275375983},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1516275375984},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1516275375984},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1516275375984},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1516275375984},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1516275375984},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1516275375984},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1516275375984},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1516275375984},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1516275375984},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1516275375984},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1516275375984},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1516275375984},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1516275375984},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1516275375984},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1516275375984},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1516275375984},{"_id":"public/images/爬虫相关/正则.jpg","hash":"41904e45cf2faf0600b802e342d6e6959bf9ff7e","modified":1516275375984},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1516275375985},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1516275375985},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1516275375985},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1516275375996}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"2018开年愿景","date":"2018-01-01T07:47:32.000Z","_content":"# 凡事欲则立，不预则废\n\n在此2018年的开端，也是我人生的第25个年头开始之际，回顾一下2017年发生的事情，同时也为自己2018年的计划写下一个开端。\n古话说的好，“凡事欲则立，不预则废”，万事开头难，难在一个完善完整理性的计划。凡事都可以量化，足够完美的量化计划，可以将事情完整的捋清，这样之后行动的时候便有一个完整的大纲，这也是此篇文章的初心。\n\n# 2017回顾\n\n> 人生在世，太多事情身不由己。在其位必谋其政，有所得，也必有所失。\n\n2016年毕业，2017是我进入社会的第二个年头。\n\n## 传音\n1月-6月，我仍然在传音工作，也是我技术的一个打磨期。这段时间对我的影响还是比较大的，包括并不局限于身体，三观，但我仍然会从这两方面来解析事情的发生。\n\n首先是技术方面。由于此阶段，我仍然从事于android-framework-systemui部分，未接触app层开发，因此工作任务仍然是处理bug。此阶段处理了大量的statusbar,navigationbar,keyguard,recents,volume等部分的bug，熟练了bug处理的技术，能够及时快速的定位bug发生点然后进行规模测试复现等，之后进行补丁更改，这一阶段给我阅读代码的能力带来了很大的提升，但是问题也出现了。\n\n### 技术问题方面。\n\n由于掌握的开发技术过少，经常遇到遇到bug问题，不知道如何高效正确的处理。换言之，仍然使用的是死方法，例如有一次遇到一个线程更新监听导致的ui刷新不及时问题，由于对线程的掌握不足，对监听器的使用不足，导致我修改策略竟然是在此处加一个固定延时，虽然解决了问题，但是明显是下下之策，造成了固定的性能浪费。我也因此被批评了一顿。这件事情的发生，给我之后决定转型下了一个决心。\n\n### 三观-世界观。\n\n我曾经以为这个世界是黑暗的，但是在传音工作的时间，让我改变了很多。\n首先是我的导师-韦灵春，作为传音导师制下我的导师，她对我的能力提升做了很大的努力。她教导我，应该如何去解决问题，对我的职业规划也进行了很多的指点。最感谢的，还是在我辞职之后，她对我的鼓励，给我很大的动力去解决当时的困境。导师于17年结婚了，祝福。\n之后是我遇到的同事，瑞辰，莫通，宇杰，春孟，汪涵，德华，还有当时的老大，凯旋。大家都是年轻人，对我这么一个新人，都有很大的关照。在没有利益面前，大家其实都愿意对新人给予关怀的。之后小组更改，凯旋哥走了，来了新的老大，新的同事，我和新的老大没有什么沟通，不过新的同事倒是有交流。新同事叫权力，他也给我很多的指导。\n在这么多人的指点下，我也成为了应届生当中较为出色的人。\n人在这个世界上，终归不是孤独的，只要姿态不高调，事实上很多人会愿意给予帮助。将来我若是组建团队，或者面对新人的时候，也要尽量给予足够的帮助。让这份温暖能够流转下去。\n\n### 三观-价值观\n\n我曾经以为，每个公司的升职制度都是约定俗成的。当然在传音的这一阶段，完全摧毁了这个设想。\n我们这一届，加薪的只有一个人。而且还是瞒着加薪的。也就是说，实际上给我们承诺的加薪，就是一句空话。\n在传音的时候，我的工资转正之后，只有5400多的到手工资，当然，额外还有大约1000多的五险一金和根据加班时间来提供的大约540-840的补贴。\n这份工资实在是摧毁了我的自信心。我原本从事程序这个行业，就是冲着高薪而去。但是这份到手甚至略低于上海平均工资的薪水，让我一时间自信心沮丧到极点。\n\n> 会叫的孩子有奶吃\n\n我一瞬间意识到了这句话的意义。\n\n### 三观-人生观\n\n在传音的时候我下了一个巨大的决心，买房子。\n\n人生究竟是为了什么？\n1. 家庭\n2. 事业\n3. 社会责任\n\n家庭的成立因素是什么？\n1. 妻子\n2. 父母\n3. 子女\n\n妻子的满足因素是什么？\n1. 女朋友\n2. 婚姻\n\n女朋友的满足因素是什么？\n1. 人品\n2. 情商\n3. 房子/车子\n\n因此，房子是一个死路，是必须要走的路。\n房子在哪儿买？这个问题思考了很久，原本决定是在南京，但是南京的房价实在是太贵了，当时估价一下，首付在30%，尚且需要大约80万的首付，同时之后需要每个月背负大约6000的房贷持续20年或者5000多持续30年。实在是一笔沉重的负担。\n之后南京政府发布限购令，一瞬间把我在南京定居的想法给摧毁了，按照当时的市价，一年后的房价大约会涨30%，这就代表了总价大约70万的增长，首付大约需要多出20万。这是压死骆驼的最后一根稻草，何况当时我在上海工作，根本无法获得一年的南京的社保。\n之后便思考回去购买，考虑了一圈，最后决定买在城北。城北一是靠家，二是靠近北车站，三是靠近宽广的马路，当然最重要的是，价格可以接受。\n最后是首付25万加上商贷16万和公积金贷8万，便买下了第一个属于自己的房子，124平。\n事实上现在也已经验证了我决定的重要性。在2月份，高铁尚且没有定论是否会落地大丰的时候，房价仍然处于动荡期，当时的价格可以4800左右一平。而在我购买之后，高铁落户大丰，房价一通猛涨，站在18年年初来看，算上了活动诱惑，仍然超过了6000一平。\n这一个决定，站在如今的立场上，我少付出了156000+的总价，这是我2年能存下来的钱。\n另外，由于月供只需要3700，这笔钱我如果拖到10年期，是获得利息甚至大于付出利息的。\n之所以把这段话写在在传音的期间，是因为在传音导致的思虑决定的。当然，也因为过于孤独导致的思考，来决定的。\n孤独是17年整年的格局。\n工资低导致的自我怀疑，让我的性格产生了严重的变化。我失去了当时关系特别好的黄琦，很难过。之后人生便如同一条江的两条分流，从此再也没有可能汇合的可能。这是我17年最大的遗憾，也许会成为我人生的遗憾。\n在传音的时间，我规划好了将来。当然是一个虚拟的规划。大致计划了一个五年。\n16-18 技术沉淀 -24周岁\n18-19 技术深化 -25周岁 \n19-21 自我事业 -27周岁\n这个时间需要跟随着时间来不断细化，但是有个起步的计划，将来会少走很多弯路。\n\n传音的段落告结，总而言之，虽然传音压榨了我的价值，但也同时锻炼了我的技术。仍然感恩。\n在17年5月19日我提交了离职报告，并于6月19日离开了传音。\n\n## 崇杏\n\n原本接受了华勤通讯的offer，却由华勤单方面毁约，于是17年6月19日离职之后，我便参与了各大公司的面试，在电话面试了2家，正式面试了一家之后，顺利的拿到了两个offer，一个是崇杏，一个某博彩公司。最后\n于17年6月27日顺利入职崇杏。\n在崇杏我遇到了新的同事，新的老大，从事的也是和framework截然不同的app开发，薪资也总体提升了大约40%，到手直接接近翻倍。很开心，完成了我跳槽的愿望。\n新公司的氛围就是放手去干，独立开发给我带来了技术上很大的进步，响应式，aop，mvp，等等，几个月学到了传音一年都没有学到的东西。\n但是问题也很大，独立开发，我遇到的所有的问题，都需要自己解决。我的技术沉浸于一种“不了解就只能用死办法”的程度，没有人指点的情况下，技术其实是停滞不前的。\n我缺少了信息获取的渠道，这是很致命的。我因此加入了android developer群，关注了技术社区，使用github进行技术搜索，虽然对最新技术能有一定的获取渠道了，但是新的问题就暴露出来了。\n对新技术的学习需要长时间持久的投入，我很缺少耐心，长时间的专注力。\n17年我开读了《概率论》，《算法导论》，《head first html》，《数据结构与算法（java实现）》，公务员公考系列书籍。无一例外，全部没有读完。\n这个缺点是致命的，学习没有长久的投入，没有技术上面的厚积薄发，而浅尝辄止无疑会带来崩溃。\n\n> 一个人会n份初级开发技能，并不能带来n份初级开发工资\n\n这个问题暴露的很严重，对我将来的发展将有很大的干扰。\n\n## 反思总结\n\n17年可谓收获满满，整个人是顺利的变成了社会人。放弃了幻想，而拥抱了实际。\n\n### 问题暴露\n\n#### 收入仍需提高\n\n在目前阶段，这个收入尚且满足，但是若是战线拉开到五年计划之中，便不足够了。因此新的一年，仍然要密切把握赚钱的方面。\n\n1. 工资提高\n毋庸置疑，这是最直接的方法。但是我对崇信能否给我加薪抱有一种怀疑的态度，这个需要在第一季度总结里面来进行反馈。\n\n2. 理财投入\n最近买的是支付宝的招行人寿理财，年化接近5%，新的一年需要继续开源，希望能够将一些钱进行分化投入。股市是我一直想进去而不敢进去的领域，新的一年我需要多和汝昌交流，了解这个领域，从而决定是否进行投入。\n\n3. 积蓄\n节流是个很好的方法。在上海的消费较高，尤其是吃饭方面，若是每顿都在外面吃，馆子还好，若是外卖的话，是在是太贵，而且不够干净。\n新的一年要在厨艺方面有些投入，最好伙食能够自给自足，这样能省很多的钱下来。\n目前争取一个月固定开销，1200房租+200水电和公共投入+200的通行+400的额外支出。其余的节省下来用于别的地方。\n\n#### 学习需要抓紧\n1. 把握好地铁上的时间，每天早一小时，晚一小时，这些时间段用于阅读技术代码和学习新的语言。\n\n2. 晚上回来要保持一小时的学习时间，会很累，但是要戒掉斗鱼，戒掉不良的习惯。\n\n3. 周末时间不能过度用于浪费了，周末时间需要进行技术的实战。macbookpro已经买了，一定要用到实处。\n\n#### 身体健康\n\n1. 戒烟。\n\n2. 健身房一周去2-3次。\n\n3. 不能晚于23：00之前上床，23：30入睡。\n\n4. 每日早饭必须要吃\n\n5. 每日晚上19:00之后不可以在入食。\n\n## 18年计划安排\n\n1. 阅读10本书，并做详细的读书笔记。\n书单目前是：《Android群英传》《数据结构与算法（java）》《算法导论》《python核心卷2》《javascript dom编程艺术》《博弈论》《运筹学教程》《运筹学习题》。\n暂定8本，酌情添加。\n\n2. 掌握一门新的语言。\n暂定是俄语。能够达到会说简单口语的地步。\n\n3. 体重减轻到140。\n这个一定要成功。\n\n4. github每日更新。\n可以把读书笔记放上去，最好是技术的锻炼。\n\n5. 戒烟/酒。\n\n## 细分量化计划安排\n\n2018年，全年共365天，四个季度12个月共52周余一天。\n每本书平均阅读5周，体重平均一周减一斤。抛去不可抗力，进行下列理想化安排。\n\n### 工作日\n8:00起床->8:30洗漱完毕->8:50到地铁站:背一小时单词\n12:00吃饭->12:20看书40分钟->13:00休息半小时\n19:00下班->19:30到地铁站:学习一小时pdf版书籍\n工作日周二和周四：\n20:30出站->健身房力量锻炼15分钟+30分钟慢跑+洗澡->10:20回家->做饭20分钟->洗漱20分钟->上床\n工作日1，3，5:\n20:30出战->20:50回家->做饭20分钟->整理笔记一小时->洗漱20分钟->上床看书20分钟->睡觉\n\n### 节假日\n8:00起床->8:30洗漱完毕->20分钟煮粥->吃完早饭9:00\n看书2小时->11:00->做午饭20分钟吃午饭->11：40午休\n12:30起床看书2小时->娱乐2小时->健身房力量锻炼30分钟+慢跑30分钟+洗澡->17:30回家\n18:00做晚饭20分钟+吃饭->18:30读书1小时+整理笔记1小时->娱乐2小时->23:00上床睡觉\n\n每一季度一次反馈，视成果和问题进行调整。同时记录不可抗力影响因素。","source":"_posts/2018开年愿景.md","raw":"---\ntitle: 2018开年愿景\ndate: 2018-01-01 15:47:32\ntags: 计划\n---\n# 凡事欲则立，不预则废\n\n在此2018年的开端，也是我人生的第25个年头开始之际，回顾一下2017年发生的事情，同时也为自己2018年的计划写下一个开端。\n古话说的好，“凡事欲则立，不预则废”，万事开头难，难在一个完善完整理性的计划。凡事都可以量化，足够完美的量化计划，可以将事情完整的捋清，这样之后行动的时候便有一个完整的大纲，这也是此篇文章的初心。\n\n# 2017回顾\n\n> 人生在世，太多事情身不由己。在其位必谋其政，有所得，也必有所失。\n\n2016年毕业，2017是我进入社会的第二个年头。\n\n## 传音\n1月-6月，我仍然在传音工作，也是我技术的一个打磨期。这段时间对我的影响还是比较大的，包括并不局限于身体，三观，但我仍然会从这两方面来解析事情的发生。\n\n首先是技术方面。由于此阶段，我仍然从事于android-framework-systemui部分，未接触app层开发，因此工作任务仍然是处理bug。此阶段处理了大量的statusbar,navigationbar,keyguard,recents,volume等部分的bug，熟练了bug处理的技术，能够及时快速的定位bug发生点然后进行规模测试复现等，之后进行补丁更改，这一阶段给我阅读代码的能力带来了很大的提升，但是问题也出现了。\n\n### 技术问题方面。\n\n由于掌握的开发技术过少，经常遇到遇到bug问题，不知道如何高效正确的处理。换言之，仍然使用的是死方法，例如有一次遇到一个线程更新监听导致的ui刷新不及时问题，由于对线程的掌握不足，对监听器的使用不足，导致我修改策略竟然是在此处加一个固定延时，虽然解决了问题，但是明显是下下之策，造成了固定的性能浪费。我也因此被批评了一顿。这件事情的发生，给我之后决定转型下了一个决心。\n\n### 三观-世界观。\n\n我曾经以为这个世界是黑暗的，但是在传音工作的时间，让我改变了很多。\n首先是我的导师-韦灵春，作为传音导师制下我的导师，她对我的能力提升做了很大的努力。她教导我，应该如何去解决问题，对我的职业规划也进行了很多的指点。最感谢的，还是在我辞职之后，她对我的鼓励，给我很大的动力去解决当时的困境。导师于17年结婚了，祝福。\n之后是我遇到的同事，瑞辰，莫通，宇杰，春孟，汪涵，德华，还有当时的老大，凯旋。大家都是年轻人，对我这么一个新人，都有很大的关照。在没有利益面前，大家其实都愿意对新人给予关怀的。之后小组更改，凯旋哥走了，来了新的老大，新的同事，我和新的老大没有什么沟通，不过新的同事倒是有交流。新同事叫权力，他也给我很多的指导。\n在这么多人的指点下，我也成为了应届生当中较为出色的人。\n人在这个世界上，终归不是孤独的，只要姿态不高调，事实上很多人会愿意给予帮助。将来我若是组建团队，或者面对新人的时候，也要尽量给予足够的帮助。让这份温暖能够流转下去。\n\n### 三观-价值观\n\n我曾经以为，每个公司的升职制度都是约定俗成的。当然在传音的这一阶段，完全摧毁了这个设想。\n我们这一届，加薪的只有一个人。而且还是瞒着加薪的。也就是说，实际上给我们承诺的加薪，就是一句空话。\n在传音的时候，我的工资转正之后，只有5400多的到手工资，当然，额外还有大约1000多的五险一金和根据加班时间来提供的大约540-840的补贴。\n这份工资实在是摧毁了我的自信心。我原本从事程序这个行业，就是冲着高薪而去。但是这份到手甚至略低于上海平均工资的薪水，让我一时间自信心沮丧到极点。\n\n> 会叫的孩子有奶吃\n\n我一瞬间意识到了这句话的意义。\n\n### 三观-人生观\n\n在传音的时候我下了一个巨大的决心，买房子。\n\n人生究竟是为了什么？\n1. 家庭\n2. 事业\n3. 社会责任\n\n家庭的成立因素是什么？\n1. 妻子\n2. 父母\n3. 子女\n\n妻子的满足因素是什么？\n1. 女朋友\n2. 婚姻\n\n女朋友的满足因素是什么？\n1. 人品\n2. 情商\n3. 房子/车子\n\n因此，房子是一个死路，是必须要走的路。\n房子在哪儿买？这个问题思考了很久，原本决定是在南京，但是南京的房价实在是太贵了，当时估价一下，首付在30%，尚且需要大约80万的首付，同时之后需要每个月背负大约6000的房贷持续20年或者5000多持续30年。实在是一笔沉重的负担。\n之后南京政府发布限购令，一瞬间把我在南京定居的想法给摧毁了，按照当时的市价，一年后的房价大约会涨30%，这就代表了总价大约70万的增长，首付大约需要多出20万。这是压死骆驼的最后一根稻草，何况当时我在上海工作，根本无法获得一年的南京的社保。\n之后便思考回去购买，考虑了一圈，最后决定买在城北。城北一是靠家，二是靠近北车站，三是靠近宽广的马路，当然最重要的是，价格可以接受。\n最后是首付25万加上商贷16万和公积金贷8万，便买下了第一个属于自己的房子，124平。\n事实上现在也已经验证了我决定的重要性。在2月份，高铁尚且没有定论是否会落地大丰的时候，房价仍然处于动荡期，当时的价格可以4800左右一平。而在我购买之后，高铁落户大丰，房价一通猛涨，站在18年年初来看，算上了活动诱惑，仍然超过了6000一平。\n这一个决定，站在如今的立场上，我少付出了156000+的总价，这是我2年能存下来的钱。\n另外，由于月供只需要3700，这笔钱我如果拖到10年期，是获得利息甚至大于付出利息的。\n之所以把这段话写在在传音的期间，是因为在传音导致的思虑决定的。当然，也因为过于孤独导致的思考，来决定的。\n孤独是17年整年的格局。\n工资低导致的自我怀疑，让我的性格产生了严重的变化。我失去了当时关系特别好的黄琦，很难过。之后人生便如同一条江的两条分流，从此再也没有可能汇合的可能。这是我17年最大的遗憾，也许会成为我人生的遗憾。\n在传音的时间，我规划好了将来。当然是一个虚拟的规划。大致计划了一个五年。\n16-18 技术沉淀 -24周岁\n18-19 技术深化 -25周岁 \n19-21 自我事业 -27周岁\n这个时间需要跟随着时间来不断细化，但是有个起步的计划，将来会少走很多弯路。\n\n传音的段落告结，总而言之，虽然传音压榨了我的价值，但也同时锻炼了我的技术。仍然感恩。\n在17年5月19日我提交了离职报告，并于6月19日离开了传音。\n\n## 崇杏\n\n原本接受了华勤通讯的offer，却由华勤单方面毁约，于是17年6月19日离职之后，我便参与了各大公司的面试，在电话面试了2家，正式面试了一家之后，顺利的拿到了两个offer，一个是崇杏，一个某博彩公司。最后\n于17年6月27日顺利入职崇杏。\n在崇杏我遇到了新的同事，新的老大，从事的也是和framework截然不同的app开发，薪资也总体提升了大约40%，到手直接接近翻倍。很开心，完成了我跳槽的愿望。\n新公司的氛围就是放手去干，独立开发给我带来了技术上很大的进步，响应式，aop，mvp，等等，几个月学到了传音一年都没有学到的东西。\n但是问题也很大，独立开发，我遇到的所有的问题，都需要自己解决。我的技术沉浸于一种“不了解就只能用死办法”的程度，没有人指点的情况下，技术其实是停滞不前的。\n我缺少了信息获取的渠道，这是很致命的。我因此加入了android developer群，关注了技术社区，使用github进行技术搜索，虽然对最新技术能有一定的获取渠道了，但是新的问题就暴露出来了。\n对新技术的学习需要长时间持久的投入，我很缺少耐心，长时间的专注力。\n17年我开读了《概率论》，《算法导论》，《head first html》，《数据结构与算法（java实现）》，公务员公考系列书籍。无一例外，全部没有读完。\n这个缺点是致命的，学习没有长久的投入，没有技术上面的厚积薄发，而浅尝辄止无疑会带来崩溃。\n\n> 一个人会n份初级开发技能，并不能带来n份初级开发工资\n\n这个问题暴露的很严重，对我将来的发展将有很大的干扰。\n\n## 反思总结\n\n17年可谓收获满满，整个人是顺利的变成了社会人。放弃了幻想，而拥抱了实际。\n\n### 问题暴露\n\n#### 收入仍需提高\n\n在目前阶段，这个收入尚且满足，但是若是战线拉开到五年计划之中，便不足够了。因此新的一年，仍然要密切把握赚钱的方面。\n\n1. 工资提高\n毋庸置疑，这是最直接的方法。但是我对崇信能否给我加薪抱有一种怀疑的态度，这个需要在第一季度总结里面来进行反馈。\n\n2. 理财投入\n最近买的是支付宝的招行人寿理财，年化接近5%，新的一年需要继续开源，希望能够将一些钱进行分化投入。股市是我一直想进去而不敢进去的领域，新的一年我需要多和汝昌交流，了解这个领域，从而决定是否进行投入。\n\n3. 积蓄\n节流是个很好的方法。在上海的消费较高，尤其是吃饭方面，若是每顿都在外面吃，馆子还好，若是外卖的话，是在是太贵，而且不够干净。\n新的一年要在厨艺方面有些投入，最好伙食能够自给自足，这样能省很多的钱下来。\n目前争取一个月固定开销，1200房租+200水电和公共投入+200的通行+400的额外支出。其余的节省下来用于别的地方。\n\n#### 学习需要抓紧\n1. 把握好地铁上的时间，每天早一小时，晚一小时，这些时间段用于阅读技术代码和学习新的语言。\n\n2. 晚上回来要保持一小时的学习时间，会很累，但是要戒掉斗鱼，戒掉不良的习惯。\n\n3. 周末时间不能过度用于浪费了，周末时间需要进行技术的实战。macbookpro已经买了，一定要用到实处。\n\n#### 身体健康\n\n1. 戒烟。\n\n2. 健身房一周去2-3次。\n\n3. 不能晚于23：00之前上床，23：30入睡。\n\n4. 每日早饭必须要吃\n\n5. 每日晚上19:00之后不可以在入食。\n\n## 18年计划安排\n\n1. 阅读10本书，并做详细的读书笔记。\n书单目前是：《Android群英传》《数据结构与算法（java）》《算法导论》《python核心卷2》《javascript dom编程艺术》《博弈论》《运筹学教程》《运筹学习题》。\n暂定8本，酌情添加。\n\n2. 掌握一门新的语言。\n暂定是俄语。能够达到会说简单口语的地步。\n\n3. 体重减轻到140。\n这个一定要成功。\n\n4. github每日更新。\n可以把读书笔记放上去，最好是技术的锻炼。\n\n5. 戒烟/酒。\n\n## 细分量化计划安排\n\n2018年，全年共365天，四个季度12个月共52周余一天。\n每本书平均阅读5周，体重平均一周减一斤。抛去不可抗力，进行下列理想化安排。\n\n### 工作日\n8:00起床->8:30洗漱完毕->8:50到地铁站:背一小时单词\n12:00吃饭->12:20看书40分钟->13:00休息半小时\n19:00下班->19:30到地铁站:学习一小时pdf版书籍\n工作日周二和周四：\n20:30出站->健身房力量锻炼15分钟+30分钟慢跑+洗澡->10:20回家->做饭20分钟->洗漱20分钟->上床\n工作日1，3，5:\n20:30出战->20:50回家->做饭20分钟->整理笔记一小时->洗漱20分钟->上床看书20分钟->睡觉\n\n### 节假日\n8:00起床->8:30洗漱完毕->20分钟煮粥->吃完早饭9:00\n看书2小时->11:00->做午饭20分钟吃午饭->11：40午休\n12:30起床看书2小时->娱乐2小时->健身房力量锻炼30分钟+慢跑30分钟+洗澡->17:30回家\n18:00做晚饭20分钟+吃饭->18:30读书1小时+整理笔记1小时->娱乐2小时->23:00上床睡觉\n\n每一季度一次反馈，视成果和问题进行调整。同时记录不可抗力影响因素。","slug":"2018开年愿景","published":1,"updated":"2018-01-09T03:00:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7f9q0000d41ig7hj9479","content":"<h1 id=\"凡事欲则立，不预则废\"><a href=\"#凡事欲则立，不预则废\" class=\"headerlink\" title=\"凡事欲则立，不预则废\"></a>凡事欲则立，不预则废</h1><p>在此2018年的开端，也是我人生的第25个年头开始之际，回顾一下2017年发生的事情，同时也为自己2018年的计划写下一个开端。<br>古话说的好，“凡事欲则立，不预则废”，万事开头难，难在一个完善完整理性的计划。凡事都可以量化，足够完美的量化计划，可以将事情完整的捋清，这样之后行动的时候便有一个完整的大纲，这也是此篇文章的初心。</p>\n<h1 id=\"2017回顾\"><a href=\"#2017回顾\" class=\"headerlink\" title=\"2017回顾\"></a>2017回顾</h1><blockquote>\n<p>人生在世，太多事情身不由己。在其位必谋其政，有所得，也必有所失。</p>\n</blockquote>\n<p>2016年毕业，2017是我进入社会的第二个年头。</p>\n<h2 id=\"传音\"><a href=\"#传音\" class=\"headerlink\" title=\"传音\"></a>传音</h2><p>1月-6月，我仍然在传音工作，也是我技术的一个打磨期。这段时间对我的影响还是比较大的，包括并不局限于身体，三观，但我仍然会从这两方面来解析事情的发生。</p>\n<p>首先是技术方面。由于此阶段，我仍然从事于android-framework-systemui部分，未接触app层开发，因此工作任务仍然是处理bug。此阶段处理了大量的statusbar,navigationbar,keyguard,recents,volume等部分的bug，熟练了bug处理的技术，能够及时快速的定位bug发生点然后进行规模测试复现等，之后进行补丁更改，这一阶段给我阅读代码的能力带来了很大的提升，但是问题也出现了。</p>\n<h3 id=\"技术问题方面。\"><a href=\"#技术问题方面。\" class=\"headerlink\" title=\"技术问题方面。\"></a>技术问题方面。</h3><p>由于掌握的开发技术过少，经常遇到遇到bug问题，不知道如何高效正确的处理。换言之，仍然使用的是死方法，例如有一次遇到一个线程更新监听导致的ui刷新不及时问题，由于对线程的掌握不足，对监听器的使用不足，导致我修改策略竟然是在此处加一个固定延时，虽然解决了问题，但是明显是下下之策，造成了固定的性能浪费。我也因此被批评了一顿。这件事情的发生，给我之后决定转型下了一个决心。</p>\n<h3 id=\"三观-世界观。\"><a href=\"#三观-世界观。\" class=\"headerlink\" title=\"三观-世界观。\"></a>三观-世界观。</h3><p>我曾经以为这个世界是黑暗的，但是在传音工作的时间，让我改变了很多。<br>首先是我的导师-韦灵春，作为传音导师制下我的导师，她对我的能力提升做了很大的努力。她教导我，应该如何去解决问题，对我的职业规划也进行了很多的指点。最感谢的，还是在我辞职之后，她对我的鼓励，给我很大的动力去解决当时的困境。导师于17年结婚了，祝福。<br>之后是我遇到的同事，瑞辰，莫通，宇杰，春孟，汪涵，德华，还有当时的老大，凯旋。大家都是年轻人，对我这么一个新人，都有很大的关照。在没有利益面前，大家其实都愿意对新人给予关怀的。之后小组更改，凯旋哥走了，来了新的老大，新的同事，我和新的老大没有什么沟通，不过新的同事倒是有交流。新同事叫权力，他也给我很多的指导。<br>在这么多人的指点下，我也成为了应届生当中较为出色的人。<br>人在这个世界上，终归不是孤独的，只要姿态不高调，事实上很多人会愿意给予帮助。将来我若是组建团队，或者面对新人的时候，也要尽量给予足够的帮助。让这份温暖能够流转下去。</p>\n<h3 id=\"三观-价值观\"><a href=\"#三观-价值观\" class=\"headerlink\" title=\"三观-价值观\"></a>三观-价值观</h3><p>我曾经以为，每个公司的升职制度都是约定俗成的。当然在传音的这一阶段，完全摧毁了这个设想。<br>我们这一届，加薪的只有一个人。而且还是瞒着加薪的。也就是说，实际上给我们承诺的加薪，就是一句空话。<br>在传音的时候，我的工资转正之后，只有5400多的到手工资，当然，额外还有大约1000多的五险一金和根据加班时间来提供的大约540-840的补贴。<br>这份工资实在是摧毁了我的自信心。我原本从事程序这个行业，就是冲着高薪而去。但是这份到手甚至略低于上海平均工资的薪水，让我一时间自信心沮丧到极点。</p>\n<blockquote>\n<p>会叫的孩子有奶吃</p>\n</blockquote>\n<p>我一瞬间意识到了这句话的意义。</p>\n<h3 id=\"三观-人生观\"><a href=\"#三观-人生观\" class=\"headerlink\" title=\"三观-人生观\"></a>三观-人生观</h3><p>在传音的时候我下了一个巨大的决心，买房子。</p>\n<p>人生究竟是为了什么？</p>\n<ol>\n<li>家庭</li>\n<li>事业</li>\n<li>社会责任</li>\n</ol>\n<p>家庭的成立因素是什么？</p>\n<ol>\n<li>妻子</li>\n<li>父母</li>\n<li>子女</li>\n</ol>\n<p>妻子的满足因素是什么？</p>\n<ol>\n<li>女朋友</li>\n<li>婚姻</li>\n</ol>\n<p>女朋友的满足因素是什么？</p>\n<ol>\n<li>人品</li>\n<li>情商</li>\n<li>房子/车子</li>\n</ol>\n<p>因此，房子是一个死路，是必须要走的路。<br>房子在哪儿买？这个问题思考了很久，原本决定是在南京，但是南京的房价实在是太贵了，当时估价一下，首付在30%，尚且需要大约80万的首付，同时之后需要每个月背负大约6000的房贷持续20年或者5000多持续30年。实在是一笔沉重的负担。<br>之后南京政府发布限购令，一瞬间把我在南京定居的想法给摧毁了，按照当时的市价，一年后的房价大约会涨30%，这就代表了总价大约70万的增长，首付大约需要多出20万。这是压死骆驼的最后一根稻草，何况当时我在上海工作，根本无法获得一年的南京的社保。<br>之后便思考回去购买，考虑了一圈，最后决定买在城北。城北一是靠家，二是靠近北车站，三是靠近宽广的马路，当然最重要的是，价格可以接受。<br>最后是首付25万加上商贷16万和公积金贷8万，便买下了第一个属于自己的房子，124平。<br>事实上现在也已经验证了我决定的重要性。在2月份，高铁尚且没有定论是否会落地大丰的时候，房价仍然处于动荡期，当时的价格可以4800左右一平。而在我购买之后，高铁落户大丰，房价一通猛涨，站在18年年初来看，算上了活动诱惑，仍然超过了6000一平。<br>这一个决定，站在如今的立场上，我少付出了156000+的总价，这是我2年能存下来的钱。<br>另外，由于月供只需要3700，这笔钱我如果拖到10年期，是获得利息甚至大于付出利息的。<br>之所以把这段话写在在传音的期间，是因为在传音导致的思虑决定的。当然，也因为过于孤独导致的思考，来决定的。<br>孤独是17年整年的格局。<br>工资低导致的自我怀疑，让我的性格产生了严重的变化。我失去了当时关系特别好的黄琦，很难过。之后人生便如同一条江的两条分流，从此再也没有可能汇合的可能。这是我17年最大的遗憾，也许会成为我人生的遗憾。<br>在传音的时间，我规划好了将来。当然是一个虚拟的规划。大致计划了一个五年。<br>16-18 技术沉淀 -24周岁<br>18-19 技术深化 -25周岁<br>19-21 自我事业 -27周岁<br>这个时间需要跟随着时间来不断细化，但是有个起步的计划，将来会少走很多弯路。</p>\n<p>传音的段落告结，总而言之，虽然传音压榨了我的价值，但也同时锻炼了我的技术。仍然感恩。<br>在17年5月19日我提交了离职报告，并于6月19日离开了传音。</p>\n<h2 id=\"崇杏\"><a href=\"#崇杏\" class=\"headerlink\" title=\"崇杏\"></a>崇杏</h2><p>原本接受了华勤通讯的offer，却由华勤单方面毁约，于是17年6月19日离职之后，我便参与了各大公司的面试，在电话面试了2家，正式面试了一家之后，顺利的拿到了两个offer，一个是崇杏，一个某博彩公司。最后<br>于17年6月27日顺利入职崇杏。<br>在崇杏我遇到了新的同事，新的老大，从事的也是和framework截然不同的app开发，薪资也总体提升了大约40%，到手直接接近翻倍。很开心，完成了我跳槽的愿望。<br>新公司的氛围就是放手去干，独立开发给我带来了技术上很大的进步，响应式，aop，mvp，等等，几个月学到了传音一年都没有学到的东西。<br>但是问题也很大，独立开发，我遇到的所有的问题，都需要自己解决。我的技术沉浸于一种“不了解就只能用死办法”的程度，没有人指点的情况下，技术其实是停滞不前的。<br>我缺少了信息获取的渠道，这是很致命的。我因此加入了android developer群，关注了技术社区，使用github进行技术搜索，虽然对最新技术能有一定的获取渠道了，但是新的问题就暴露出来了。<br>对新技术的学习需要长时间持久的投入，我很缺少耐心，长时间的专注力。<br>17年我开读了《概率论》，《算法导论》，《head first html》，《数据结构与算法（java实现）》，公务员公考系列书籍。无一例外，全部没有读完。<br>这个缺点是致命的，学习没有长久的投入，没有技术上面的厚积薄发，而浅尝辄止无疑会带来崩溃。</p>\n<blockquote>\n<p>一个人会n份初级开发技能，并不能带来n份初级开发工资</p>\n</blockquote>\n<p>这个问题暴露的很严重，对我将来的发展将有很大的干扰。</p>\n<h2 id=\"反思总结\"><a href=\"#反思总结\" class=\"headerlink\" title=\"反思总结\"></a>反思总结</h2><p>17年可谓收获满满，整个人是顺利的变成了社会人。放弃了幻想，而拥抱了实际。</p>\n<h3 id=\"问题暴露\"><a href=\"#问题暴露\" class=\"headerlink\" title=\"问题暴露\"></a>问题暴露</h3><h4 id=\"收入仍需提高\"><a href=\"#收入仍需提高\" class=\"headerlink\" title=\"收入仍需提高\"></a>收入仍需提高</h4><p>在目前阶段，这个收入尚且满足，但是若是战线拉开到五年计划之中，便不足够了。因此新的一年，仍然要密切把握赚钱的方面。</p>\n<ol>\n<li><p>工资提高<br>毋庸置疑，这是最直接的方法。但是我对崇信能否给我加薪抱有一种怀疑的态度，这个需要在第一季度总结里面来进行反馈。</p>\n</li>\n<li><p>理财投入<br>最近买的是支付宝的招行人寿理财，年化接近5%，新的一年需要继续开源，希望能够将一些钱进行分化投入。股市是我一直想进去而不敢进去的领域，新的一年我需要多和汝昌交流，了解这个领域，从而决定是否进行投入。</p>\n</li>\n<li><p>积蓄<br>节流是个很好的方法。在上海的消费较高，尤其是吃饭方面，若是每顿都在外面吃，馆子还好，若是外卖的话，是在是太贵，而且不够干净。<br>新的一年要在厨艺方面有些投入，最好伙食能够自给自足，这样能省很多的钱下来。<br>目前争取一个月固定开销，1200房租+200水电和公共投入+200的通行+400的额外支出。其余的节省下来用于别的地方。</p>\n</li>\n</ol>\n<h4 id=\"学习需要抓紧\"><a href=\"#学习需要抓紧\" class=\"headerlink\" title=\"学习需要抓紧\"></a>学习需要抓紧</h4><ol>\n<li><p>把握好地铁上的时间，每天早一小时，晚一小时，这些时间段用于阅读技术代码和学习新的语言。</p>\n</li>\n<li><p>晚上回来要保持一小时的学习时间，会很累，但是要戒掉斗鱼，戒掉不良的习惯。</p>\n</li>\n<li><p>周末时间不能过度用于浪费了，周末时间需要进行技术的实战。macbookpro已经买了，一定要用到实处。</p>\n</li>\n</ol>\n<h4 id=\"身体健康\"><a href=\"#身体健康\" class=\"headerlink\" title=\"身体健康\"></a>身体健康</h4><ol>\n<li><p>戒烟。</p>\n</li>\n<li><p>健身房一周去2-3次。</p>\n</li>\n<li><p>不能晚于23：00之前上床，23：30入睡。</p>\n</li>\n<li><p>每日早饭必须要吃</p>\n</li>\n<li><p>每日晚上19:00之后不可以在入食。</p>\n</li>\n</ol>\n<h2 id=\"18年计划安排\"><a href=\"#18年计划安排\" class=\"headerlink\" title=\"18年计划安排\"></a>18年计划安排</h2><ol>\n<li><p>阅读10本书，并做详细的读书笔记。<br>书单目前是：《Android群英传》《数据结构与算法（java）》《算法导论》《python核心卷2》《javascript dom编程艺术》《博弈论》《运筹学教程》《运筹学习题》。<br>暂定8本，酌情添加。</p>\n</li>\n<li><p>掌握一门新的语言。<br>暂定是俄语。能够达到会说简单口语的地步。</p>\n</li>\n<li><p>体重减轻到140。<br>这个一定要成功。</p>\n</li>\n<li><p>github每日更新。<br>可以把读书笔记放上去，最好是技术的锻炼。</p>\n</li>\n<li><p>戒烟/酒。</p>\n</li>\n</ol>\n<h2 id=\"细分量化计划安排\"><a href=\"#细分量化计划安排\" class=\"headerlink\" title=\"细分量化计划安排\"></a>细分量化计划安排</h2><p>2018年，全年共365天，四个季度12个月共52周余一天。<br>每本书平均阅读5周，体重平均一周减一斤。抛去不可抗力，进行下列理想化安排。</p>\n<h3 id=\"工作日\"><a href=\"#工作日\" class=\"headerlink\" title=\"工作日\"></a>工作日</h3><p>8:00起床-&gt;8:30洗漱完毕-&gt;8:50到地铁站:背一小时单词<br>12:00吃饭-&gt;12:20看书40分钟-&gt;13:00休息半小时<br>19:00下班-&gt;19:30到地铁站:学习一小时pdf版书籍<br>工作日周二和周四：<br>20:30出站-&gt;健身房力量锻炼15分钟+30分钟慢跑+洗澡-&gt;10:20回家-&gt;做饭20分钟-&gt;洗漱20分钟-&gt;上床<br>工作日1，3，5:<br>20:30出战-&gt;20:50回家-&gt;做饭20分钟-&gt;整理笔记一小时-&gt;洗漱20分钟-&gt;上床看书20分钟-&gt;睡觉</p>\n<h3 id=\"节假日\"><a href=\"#节假日\" class=\"headerlink\" title=\"节假日\"></a>节假日</h3><p>8:00起床-&gt;8:30洗漱完毕-&gt;20分钟煮粥-&gt;吃完早饭9:00<br>看书2小时-&gt;11:00-&gt;做午饭20分钟吃午饭-&gt;11：40午休<br>12:30起床看书2小时-&gt;娱乐2小时-&gt;健身房力量锻炼30分钟+慢跑30分钟+洗澡-&gt;17:30回家<br>18:00做晚饭20分钟+吃饭-&gt;18:30读书1小时+整理笔记1小时-&gt;娱乐2小时-&gt;23:00上床睡觉</p>\n<p>每一季度一次反馈，视成果和问题进行调整。同时记录不可抗力影响因素。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"凡事欲则立，不预则废\"><a href=\"#凡事欲则立，不预则废\" class=\"headerlink\" title=\"凡事欲则立，不预则废\"></a>凡事欲则立，不预则废</h1><p>在此2018年的开端，也是我人生的第25个年头开始之际，回顾一下2017年发生的事情，同时也为自己2018年的计划写下一个开端。<br>古话说的好，“凡事欲则立，不预则废”，万事开头难，难在一个完善完整理性的计划。凡事都可以量化，足够完美的量化计划，可以将事情完整的捋清，这样之后行动的时候便有一个完整的大纲，这也是此篇文章的初心。</p>\n<h1 id=\"2017回顾\"><a href=\"#2017回顾\" class=\"headerlink\" title=\"2017回顾\"></a>2017回顾</h1><blockquote>\n<p>人生在世，太多事情身不由己。在其位必谋其政，有所得，也必有所失。</p>\n</blockquote>\n<p>2016年毕业，2017是我进入社会的第二个年头。</p>\n<h2 id=\"传音\"><a href=\"#传音\" class=\"headerlink\" title=\"传音\"></a>传音</h2><p>1月-6月，我仍然在传音工作，也是我技术的一个打磨期。这段时间对我的影响还是比较大的，包括并不局限于身体，三观，但我仍然会从这两方面来解析事情的发生。</p>\n<p>首先是技术方面。由于此阶段，我仍然从事于android-framework-systemui部分，未接触app层开发，因此工作任务仍然是处理bug。此阶段处理了大量的statusbar,navigationbar,keyguard,recents,volume等部分的bug，熟练了bug处理的技术，能够及时快速的定位bug发生点然后进行规模测试复现等，之后进行补丁更改，这一阶段给我阅读代码的能力带来了很大的提升，但是问题也出现了。</p>\n<h3 id=\"技术问题方面。\"><a href=\"#技术问题方面。\" class=\"headerlink\" title=\"技术问题方面。\"></a>技术问题方面。</h3><p>由于掌握的开发技术过少，经常遇到遇到bug问题，不知道如何高效正确的处理。换言之，仍然使用的是死方法，例如有一次遇到一个线程更新监听导致的ui刷新不及时问题，由于对线程的掌握不足，对监听器的使用不足，导致我修改策略竟然是在此处加一个固定延时，虽然解决了问题，但是明显是下下之策，造成了固定的性能浪费。我也因此被批评了一顿。这件事情的发生，给我之后决定转型下了一个决心。</p>\n<h3 id=\"三观-世界观。\"><a href=\"#三观-世界观。\" class=\"headerlink\" title=\"三观-世界观。\"></a>三观-世界观。</h3><p>我曾经以为这个世界是黑暗的，但是在传音工作的时间，让我改变了很多。<br>首先是我的导师-韦灵春，作为传音导师制下我的导师，她对我的能力提升做了很大的努力。她教导我，应该如何去解决问题，对我的职业规划也进行了很多的指点。最感谢的，还是在我辞职之后，她对我的鼓励，给我很大的动力去解决当时的困境。导师于17年结婚了，祝福。<br>之后是我遇到的同事，瑞辰，莫通，宇杰，春孟，汪涵，德华，还有当时的老大，凯旋。大家都是年轻人，对我这么一个新人，都有很大的关照。在没有利益面前，大家其实都愿意对新人给予关怀的。之后小组更改，凯旋哥走了，来了新的老大，新的同事，我和新的老大没有什么沟通，不过新的同事倒是有交流。新同事叫权力，他也给我很多的指导。<br>在这么多人的指点下，我也成为了应届生当中较为出色的人。<br>人在这个世界上，终归不是孤独的，只要姿态不高调，事实上很多人会愿意给予帮助。将来我若是组建团队，或者面对新人的时候，也要尽量给予足够的帮助。让这份温暖能够流转下去。</p>\n<h3 id=\"三观-价值观\"><a href=\"#三观-价值观\" class=\"headerlink\" title=\"三观-价值观\"></a>三观-价值观</h3><p>我曾经以为，每个公司的升职制度都是约定俗成的。当然在传音的这一阶段，完全摧毁了这个设想。<br>我们这一届，加薪的只有一个人。而且还是瞒着加薪的。也就是说，实际上给我们承诺的加薪，就是一句空话。<br>在传音的时候，我的工资转正之后，只有5400多的到手工资，当然，额外还有大约1000多的五险一金和根据加班时间来提供的大约540-840的补贴。<br>这份工资实在是摧毁了我的自信心。我原本从事程序这个行业，就是冲着高薪而去。但是这份到手甚至略低于上海平均工资的薪水，让我一时间自信心沮丧到极点。</p>\n<blockquote>\n<p>会叫的孩子有奶吃</p>\n</blockquote>\n<p>我一瞬间意识到了这句话的意义。</p>\n<h3 id=\"三观-人生观\"><a href=\"#三观-人生观\" class=\"headerlink\" title=\"三观-人生观\"></a>三观-人生观</h3><p>在传音的时候我下了一个巨大的决心，买房子。</p>\n<p>人生究竟是为了什么？</p>\n<ol>\n<li>家庭</li>\n<li>事业</li>\n<li>社会责任</li>\n</ol>\n<p>家庭的成立因素是什么？</p>\n<ol>\n<li>妻子</li>\n<li>父母</li>\n<li>子女</li>\n</ol>\n<p>妻子的满足因素是什么？</p>\n<ol>\n<li>女朋友</li>\n<li>婚姻</li>\n</ol>\n<p>女朋友的满足因素是什么？</p>\n<ol>\n<li>人品</li>\n<li>情商</li>\n<li>房子/车子</li>\n</ol>\n<p>因此，房子是一个死路，是必须要走的路。<br>房子在哪儿买？这个问题思考了很久，原本决定是在南京，但是南京的房价实在是太贵了，当时估价一下，首付在30%，尚且需要大约80万的首付，同时之后需要每个月背负大约6000的房贷持续20年或者5000多持续30年。实在是一笔沉重的负担。<br>之后南京政府发布限购令，一瞬间把我在南京定居的想法给摧毁了，按照当时的市价，一年后的房价大约会涨30%，这就代表了总价大约70万的增长，首付大约需要多出20万。这是压死骆驼的最后一根稻草，何况当时我在上海工作，根本无法获得一年的南京的社保。<br>之后便思考回去购买，考虑了一圈，最后决定买在城北。城北一是靠家，二是靠近北车站，三是靠近宽广的马路，当然最重要的是，价格可以接受。<br>最后是首付25万加上商贷16万和公积金贷8万，便买下了第一个属于自己的房子，124平。<br>事实上现在也已经验证了我决定的重要性。在2月份，高铁尚且没有定论是否会落地大丰的时候，房价仍然处于动荡期，当时的价格可以4800左右一平。而在我购买之后，高铁落户大丰，房价一通猛涨，站在18年年初来看，算上了活动诱惑，仍然超过了6000一平。<br>这一个决定，站在如今的立场上，我少付出了156000+的总价，这是我2年能存下来的钱。<br>另外，由于月供只需要3700，这笔钱我如果拖到10年期，是获得利息甚至大于付出利息的。<br>之所以把这段话写在在传音的期间，是因为在传音导致的思虑决定的。当然，也因为过于孤独导致的思考，来决定的。<br>孤独是17年整年的格局。<br>工资低导致的自我怀疑，让我的性格产生了严重的变化。我失去了当时关系特别好的黄琦，很难过。之后人生便如同一条江的两条分流，从此再也没有可能汇合的可能。这是我17年最大的遗憾，也许会成为我人生的遗憾。<br>在传音的时间，我规划好了将来。当然是一个虚拟的规划。大致计划了一个五年。<br>16-18 技术沉淀 -24周岁<br>18-19 技术深化 -25周岁<br>19-21 自我事业 -27周岁<br>这个时间需要跟随着时间来不断细化，但是有个起步的计划，将来会少走很多弯路。</p>\n<p>传音的段落告结，总而言之，虽然传音压榨了我的价值，但也同时锻炼了我的技术。仍然感恩。<br>在17年5月19日我提交了离职报告，并于6月19日离开了传音。</p>\n<h2 id=\"崇杏\"><a href=\"#崇杏\" class=\"headerlink\" title=\"崇杏\"></a>崇杏</h2><p>原本接受了华勤通讯的offer，却由华勤单方面毁约，于是17年6月19日离职之后，我便参与了各大公司的面试，在电话面试了2家，正式面试了一家之后，顺利的拿到了两个offer，一个是崇杏，一个某博彩公司。最后<br>于17年6月27日顺利入职崇杏。<br>在崇杏我遇到了新的同事，新的老大，从事的也是和framework截然不同的app开发，薪资也总体提升了大约40%，到手直接接近翻倍。很开心，完成了我跳槽的愿望。<br>新公司的氛围就是放手去干，独立开发给我带来了技术上很大的进步，响应式，aop，mvp，等等，几个月学到了传音一年都没有学到的东西。<br>但是问题也很大，独立开发，我遇到的所有的问题，都需要自己解决。我的技术沉浸于一种“不了解就只能用死办法”的程度，没有人指点的情况下，技术其实是停滞不前的。<br>我缺少了信息获取的渠道，这是很致命的。我因此加入了android developer群，关注了技术社区，使用github进行技术搜索，虽然对最新技术能有一定的获取渠道了，但是新的问题就暴露出来了。<br>对新技术的学习需要长时间持久的投入，我很缺少耐心，长时间的专注力。<br>17年我开读了《概率论》，《算法导论》，《head first html》，《数据结构与算法（java实现）》，公务员公考系列书籍。无一例外，全部没有读完。<br>这个缺点是致命的，学习没有长久的投入，没有技术上面的厚积薄发，而浅尝辄止无疑会带来崩溃。</p>\n<blockquote>\n<p>一个人会n份初级开发技能，并不能带来n份初级开发工资</p>\n</blockquote>\n<p>这个问题暴露的很严重，对我将来的发展将有很大的干扰。</p>\n<h2 id=\"反思总结\"><a href=\"#反思总结\" class=\"headerlink\" title=\"反思总结\"></a>反思总结</h2><p>17年可谓收获满满，整个人是顺利的变成了社会人。放弃了幻想，而拥抱了实际。</p>\n<h3 id=\"问题暴露\"><a href=\"#问题暴露\" class=\"headerlink\" title=\"问题暴露\"></a>问题暴露</h3><h4 id=\"收入仍需提高\"><a href=\"#收入仍需提高\" class=\"headerlink\" title=\"收入仍需提高\"></a>收入仍需提高</h4><p>在目前阶段，这个收入尚且满足，但是若是战线拉开到五年计划之中，便不足够了。因此新的一年，仍然要密切把握赚钱的方面。</p>\n<ol>\n<li><p>工资提高<br>毋庸置疑，这是最直接的方法。但是我对崇信能否给我加薪抱有一种怀疑的态度，这个需要在第一季度总结里面来进行反馈。</p>\n</li>\n<li><p>理财投入<br>最近买的是支付宝的招行人寿理财，年化接近5%，新的一年需要继续开源，希望能够将一些钱进行分化投入。股市是我一直想进去而不敢进去的领域，新的一年我需要多和汝昌交流，了解这个领域，从而决定是否进行投入。</p>\n</li>\n<li><p>积蓄<br>节流是个很好的方法。在上海的消费较高，尤其是吃饭方面，若是每顿都在外面吃，馆子还好，若是外卖的话，是在是太贵，而且不够干净。<br>新的一年要在厨艺方面有些投入，最好伙食能够自给自足，这样能省很多的钱下来。<br>目前争取一个月固定开销，1200房租+200水电和公共投入+200的通行+400的额外支出。其余的节省下来用于别的地方。</p>\n</li>\n</ol>\n<h4 id=\"学习需要抓紧\"><a href=\"#学习需要抓紧\" class=\"headerlink\" title=\"学习需要抓紧\"></a>学习需要抓紧</h4><ol>\n<li><p>把握好地铁上的时间，每天早一小时，晚一小时，这些时间段用于阅读技术代码和学习新的语言。</p>\n</li>\n<li><p>晚上回来要保持一小时的学习时间，会很累，但是要戒掉斗鱼，戒掉不良的习惯。</p>\n</li>\n<li><p>周末时间不能过度用于浪费了，周末时间需要进行技术的实战。macbookpro已经买了，一定要用到实处。</p>\n</li>\n</ol>\n<h4 id=\"身体健康\"><a href=\"#身体健康\" class=\"headerlink\" title=\"身体健康\"></a>身体健康</h4><ol>\n<li><p>戒烟。</p>\n</li>\n<li><p>健身房一周去2-3次。</p>\n</li>\n<li><p>不能晚于23：00之前上床，23：30入睡。</p>\n</li>\n<li><p>每日早饭必须要吃</p>\n</li>\n<li><p>每日晚上19:00之后不可以在入食。</p>\n</li>\n</ol>\n<h2 id=\"18年计划安排\"><a href=\"#18年计划安排\" class=\"headerlink\" title=\"18年计划安排\"></a>18年计划安排</h2><ol>\n<li><p>阅读10本书，并做详细的读书笔记。<br>书单目前是：《Android群英传》《数据结构与算法（java）》《算法导论》《python核心卷2》《javascript dom编程艺术》《博弈论》《运筹学教程》《运筹学习题》。<br>暂定8本，酌情添加。</p>\n</li>\n<li><p>掌握一门新的语言。<br>暂定是俄语。能够达到会说简单口语的地步。</p>\n</li>\n<li><p>体重减轻到140。<br>这个一定要成功。</p>\n</li>\n<li><p>github每日更新。<br>可以把读书笔记放上去，最好是技术的锻炼。</p>\n</li>\n<li><p>戒烟/酒。</p>\n</li>\n</ol>\n<h2 id=\"细分量化计划安排\"><a href=\"#细分量化计划安排\" class=\"headerlink\" title=\"细分量化计划安排\"></a>细分量化计划安排</h2><p>2018年，全年共365天，四个季度12个月共52周余一天。<br>每本书平均阅读5周，体重平均一周减一斤。抛去不可抗力，进行下列理想化安排。</p>\n<h3 id=\"工作日\"><a href=\"#工作日\" class=\"headerlink\" title=\"工作日\"></a>工作日</h3><p>8:00起床-&gt;8:30洗漱完毕-&gt;8:50到地铁站:背一小时单词<br>12:00吃饭-&gt;12:20看书40分钟-&gt;13:00休息半小时<br>19:00下班-&gt;19:30到地铁站:学习一小时pdf版书籍<br>工作日周二和周四：<br>20:30出站-&gt;健身房力量锻炼15分钟+30分钟慢跑+洗澡-&gt;10:20回家-&gt;做饭20分钟-&gt;洗漱20分钟-&gt;上床<br>工作日1，3，5:<br>20:30出战-&gt;20:50回家-&gt;做饭20分钟-&gt;整理笔记一小时-&gt;洗漱20分钟-&gt;上床看书20分钟-&gt;睡觉</p>\n<h3 id=\"节假日\"><a href=\"#节假日\" class=\"headerlink\" title=\"节假日\"></a>节假日</h3><p>8:00起床-&gt;8:30洗漱完毕-&gt;20分钟煮粥-&gt;吃完早饭9:00<br>看书2小时-&gt;11:00-&gt;做午饭20分钟吃午饭-&gt;11：40午休<br>12:30起床看书2小时-&gt;娱乐2小时-&gt;健身房力量锻炼30分钟+慢跑30分钟+洗澡-&gt;17:30回家<br>18:00做晚饭20分钟+吃饭-&gt;18:30读书1小时+整理笔记1小时-&gt;娱乐2小时-&gt;23:00上床睡觉</p>\n<p>每一季度一次反馈，视成果和问题进行调整。同时记录不可抗力影响因素。</p>\n"},{"title":"2018第一周工作小结","date":"2018-01-05T14:18:49.000Z","_content":"这一周由于元旦的关系，只上了四天班。2017上半年的时候在传音工作，那时候每天都要写日报，然后周五要写周报，当时写的实在是痛苦，结果来崇杏之后，一天日报都没有写过。\n\n刚开始的确很爽，可是年底总结的时候发现写不出什么来了，对于半年多的工作只有一个浅薄的印象，大致知道做了哪些项目，可是项目相关都有些模糊了。因此重拾写周报的习惯，希望今年能够有一些改变。\n\n这周由于spirtMonitor项目需要重新制作ui，前几天陈哥还没有做完效果，因此先将之前做的肺科医院订餐管理后台先进行微信登陆的集成。\n\n微信的集成刚开始准备我这边获取相关的token，然后直接与服务器对接。但是当我获取了openid之后，后端说微信开放平台的openid与公众平台的openid不同，只可以使用unionid来对接。同时还有个问题，就是我这边无法直接使用获取的unionid来进行对接，不可以把appid和secretid放在app里面，防止别人抓包。\n\n因此需要重新设置一个模式，使用appid加微信登陆获取的一次性code，将code传回服务器，在服务器里面进行处理，之后返回一个处理完毕的token，我在app这边做一个持久化，这个token有效期三天，我根据token是否过期进行重新获取code，重复之上的行为即可。因此等待张凯把后端处理完我才可以进行之后的行动。\n\n关于token，我和张凯交流的时候有个设想，我这边将code，使用query的方式添加到url的末尾，然后使用浏览器传出去，之后浏览器走之前微信公众号的那个端口，走完之后浏览器返回值，然后浏览器吊起我的程序。这个方法感觉是可行的，但是当时考虑到跨域的问题没有实现。\n\n晚上关于这个问题搜索了一下，主要针对是如何使用webview来吊起activity。\n\n结果显示，的确如果直接发intent吊起webview会出现跨域的问题，但是可以本地写一个html页面来解决跨域的问题。\n\n[使用webview吊起activity](http://www.cnblogs.com/yejiurui/p/3413796.html)\n\n这样给我一个想法。由于安卓跨域保护的问题，很多和浏览器协作的方面，比如说之前做的，hybirdapp调用本地视频的功能，可以截取webview的url，然后吊起本地的html来加载视频。不过这个方式对于那种内嵌的视频可能不好用，内嵌的视频还是需要使用webserver来进行视频的提供。但是也是一种思路。\n\n明天做一下相关的demo。\n\n微信集成搞了2天，之后陈总那边的ui好了，因此需要重新更改ui。\n\n之前使用animation的方式，对textview进行动画的设置，这样会在更新的时候触发动画，但是动画的效果不是很好看，之后恰好看到了一个app，使用的是每次更新的时候数字从小到大的方式。刚好找到了一个库，单纯的一个自定义view，直接继承了textview，使用的一个valueAmatior动画，这个动画里面添加了一个animationListener，在这个监听器里面进行了textview的设值。值的范围从设置的开端到末端。这个设置的动画和我之前设置的对比就完全不同了，感觉十分好。\n\n周四周五大概就做了这几件事。晚上回来的路上，在想关于借口查询的问题，我之前使用的是定时去查询接口的方式，但是之前了解了一个关于http长连接的方式，实时聊天软件就是使用的长连接的效果，这方面也需要了解一下。\n\n因此本周的收获如下：\n1. 了解了如何使用valueAmator来进行动画的更新。\n2. 了解了如何集成微信\n\n遗留未解决的问题如下：\n1. 使用本地静态html来进行get操作，对返回值过滤来吊起app并且获取返回值\n2. 学习使用长链接的方式来进行接口的查询\n\n周末的任务：\n1. 解决遗留问题\n2. 处理一下williamchart的ui更改\n3. 研究一下安卓的渐变色，圆心渐变和直线渐变\n\n有时间的话：\n1. 学习一下常用的排序算法\n2. 继续学习安卓群英传","source":"_posts/2018第一周工作小结.md","raw":"---\ntitle: 2018第一周工作小结\ndate: 2018-01-05 22:18:49\ntags: 工作小结\n---\n这一周由于元旦的关系，只上了四天班。2017上半年的时候在传音工作，那时候每天都要写日报，然后周五要写周报，当时写的实在是痛苦，结果来崇杏之后，一天日报都没有写过。\n\n刚开始的确很爽，可是年底总结的时候发现写不出什么来了，对于半年多的工作只有一个浅薄的印象，大致知道做了哪些项目，可是项目相关都有些模糊了。因此重拾写周报的习惯，希望今年能够有一些改变。\n\n这周由于spirtMonitor项目需要重新制作ui，前几天陈哥还没有做完效果，因此先将之前做的肺科医院订餐管理后台先进行微信登陆的集成。\n\n微信的集成刚开始准备我这边获取相关的token，然后直接与服务器对接。但是当我获取了openid之后，后端说微信开放平台的openid与公众平台的openid不同，只可以使用unionid来对接。同时还有个问题，就是我这边无法直接使用获取的unionid来进行对接，不可以把appid和secretid放在app里面，防止别人抓包。\n\n因此需要重新设置一个模式，使用appid加微信登陆获取的一次性code，将code传回服务器，在服务器里面进行处理，之后返回一个处理完毕的token，我在app这边做一个持久化，这个token有效期三天，我根据token是否过期进行重新获取code，重复之上的行为即可。因此等待张凯把后端处理完我才可以进行之后的行动。\n\n关于token，我和张凯交流的时候有个设想，我这边将code，使用query的方式添加到url的末尾，然后使用浏览器传出去，之后浏览器走之前微信公众号的那个端口，走完之后浏览器返回值，然后浏览器吊起我的程序。这个方法感觉是可行的，但是当时考虑到跨域的问题没有实现。\n\n晚上关于这个问题搜索了一下，主要针对是如何使用webview来吊起activity。\n\n结果显示，的确如果直接发intent吊起webview会出现跨域的问题，但是可以本地写一个html页面来解决跨域的问题。\n\n[使用webview吊起activity](http://www.cnblogs.com/yejiurui/p/3413796.html)\n\n这样给我一个想法。由于安卓跨域保护的问题，很多和浏览器协作的方面，比如说之前做的，hybirdapp调用本地视频的功能，可以截取webview的url，然后吊起本地的html来加载视频。不过这个方式对于那种内嵌的视频可能不好用，内嵌的视频还是需要使用webserver来进行视频的提供。但是也是一种思路。\n\n明天做一下相关的demo。\n\n微信集成搞了2天，之后陈总那边的ui好了，因此需要重新更改ui。\n\n之前使用animation的方式，对textview进行动画的设置，这样会在更新的时候触发动画，但是动画的效果不是很好看，之后恰好看到了一个app，使用的是每次更新的时候数字从小到大的方式。刚好找到了一个库，单纯的一个自定义view，直接继承了textview，使用的一个valueAmatior动画，这个动画里面添加了一个animationListener，在这个监听器里面进行了textview的设值。值的范围从设置的开端到末端。这个设置的动画和我之前设置的对比就完全不同了，感觉十分好。\n\n周四周五大概就做了这几件事。晚上回来的路上，在想关于借口查询的问题，我之前使用的是定时去查询接口的方式，但是之前了解了一个关于http长连接的方式，实时聊天软件就是使用的长连接的效果，这方面也需要了解一下。\n\n因此本周的收获如下：\n1. 了解了如何使用valueAmator来进行动画的更新。\n2. 了解了如何集成微信\n\n遗留未解决的问题如下：\n1. 使用本地静态html来进行get操作，对返回值过滤来吊起app并且获取返回值\n2. 学习使用长链接的方式来进行接口的查询\n\n周末的任务：\n1. 解决遗留问题\n2. 处理一下williamchart的ui更改\n3. 研究一下安卓的渐变色，圆心渐变和直线渐变\n\n有时间的话：\n1. 学习一下常用的排序算法\n2. 继续学习安卓群英传","slug":"2018第一周工作小结","published":1,"updated":"2018-01-09T03:00:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7f9u0001d41inq9znmda","content":"<p>这一周由于元旦的关系，只上了四天班。2017上半年的时候在传音工作，那时候每天都要写日报，然后周五要写周报，当时写的实在是痛苦，结果来崇杏之后，一天日报都没有写过。</p>\n<p>刚开始的确很爽，可是年底总结的时候发现写不出什么来了，对于半年多的工作只有一个浅薄的印象，大致知道做了哪些项目，可是项目相关都有些模糊了。因此重拾写周报的习惯，希望今年能够有一些改变。</p>\n<p>这周由于spirtMonitor项目需要重新制作ui，前几天陈哥还没有做完效果，因此先将之前做的肺科医院订餐管理后台先进行微信登陆的集成。</p>\n<p>微信的集成刚开始准备我这边获取相关的token，然后直接与服务器对接。但是当我获取了openid之后，后端说微信开放平台的openid与公众平台的openid不同，只可以使用unionid来对接。同时还有个问题，就是我这边无法直接使用获取的unionid来进行对接，不可以把appid和secretid放在app里面，防止别人抓包。</p>\n<p>因此需要重新设置一个模式，使用appid加微信登陆获取的一次性code，将code传回服务器，在服务器里面进行处理，之后返回一个处理完毕的token，我在app这边做一个持久化，这个token有效期三天，我根据token是否过期进行重新获取code，重复之上的行为即可。因此等待张凯把后端处理完我才可以进行之后的行动。</p>\n<p>关于token，我和张凯交流的时候有个设想，我这边将code，使用query的方式添加到url的末尾，然后使用浏览器传出去，之后浏览器走之前微信公众号的那个端口，走完之后浏览器返回值，然后浏览器吊起我的程序。这个方法感觉是可行的，但是当时考虑到跨域的问题没有实现。</p>\n<p>晚上关于这个问题搜索了一下，主要针对是如何使用webview来吊起activity。</p>\n<p>结果显示，的确如果直接发intent吊起webview会出现跨域的问题，但是可以本地写一个html页面来解决跨域的问题。</p>\n<p><a href=\"http://www.cnblogs.com/yejiurui/p/3413796.html\" target=\"_blank\" rel=\"noopener\">使用webview吊起activity</a></p>\n<p>这样给我一个想法。由于安卓跨域保护的问题，很多和浏览器协作的方面，比如说之前做的，hybirdapp调用本地视频的功能，可以截取webview的url，然后吊起本地的html来加载视频。不过这个方式对于那种内嵌的视频可能不好用，内嵌的视频还是需要使用webserver来进行视频的提供。但是也是一种思路。</p>\n<p>明天做一下相关的demo。</p>\n<p>微信集成搞了2天，之后陈总那边的ui好了，因此需要重新更改ui。</p>\n<p>之前使用animation的方式，对textview进行动画的设置，这样会在更新的时候触发动画，但是动画的效果不是很好看，之后恰好看到了一个app，使用的是每次更新的时候数字从小到大的方式。刚好找到了一个库，单纯的一个自定义view，直接继承了textview，使用的一个valueAmatior动画，这个动画里面添加了一个animationListener，在这个监听器里面进行了textview的设值。值的范围从设置的开端到末端。这个设置的动画和我之前设置的对比就完全不同了，感觉十分好。</p>\n<p>周四周五大概就做了这几件事。晚上回来的路上，在想关于借口查询的问题，我之前使用的是定时去查询接口的方式，但是之前了解了一个关于http长连接的方式，实时聊天软件就是使用的长连接的效果，这方面也需要了解一下。</p>\n<p>因此本周的收获如下：</p>\n<ol>\n<li>了解了如何使用valueAmator来进行动画的更新。</li>\n<li>了解了如何集成微信</li>\n</ol>\n<p>遗留未解决的问题如下：</p>\n<ol>\n<li>使用本地静态html来进行get操作，对返回值过滤来吊起app并且获取返回值</li>\n<li>学习使用长链接的方式来进行接口的查询</li>\n</ol>\n<p>周末的任务：</p>\n<ol>\n<li>解决遗留问题</li>\n<li>处理一下williamchart的ui更改</li>\n<li>研究一下安卓的渐变色，圆心渐变和直线渐变</li>\n</ol>\n<p>有时间的话：</p>\n<ol>\n<li>学习一下常用的排序算法</li>\n<li>继续学习安卓群英传</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>这一周由于元旦的关系，只上了四天班。2017上半年的时候在传音工作，那时候每天都要写日报，然后周五要写周报，当时写的实在是痛苦，结果来崇杏之后，一天日报都没有写过。</p>\n<p>刚开始的确很爽，可是年底总结的时候发现写不出什么来了，对于半年多的工作只有一个浅薄的印象，大致知道做了哪些项目，可是项目相关都有些模糊了。因此重拾写周报的习惯，希望今年能够有一些改变。</p>\n<p>这周由于spirtMonitor项目需要重新制作ui，前几天陈哥还没有做完效果，因此先将之前做的肺科医院订餐管理后台先进行微信登陆的集成。</p>\n<p>微信的集成刚开始准备我这边获取相关的token，然后直接与服务器对接。但是当我获取了openid之后，后端说微信开放平台的openid与公众平台的openid不同，只可以使用unionid来对接。同时还有个问题，就是我这边无法直接使用获取的unionid来进行对接，不可以把appid和secretid放在app里面，防止别人抓包。</p>\n<p>因此需要重新设置一个模式，使用appid加微信登陆获取的一次性code，将code传回服务器，在服务器里面进行处理，之后返回一个处理完毕的token，我在app这边做一个持久化，这个token有效期三天，我根据token是否过期进行重新获取code，重复之上的行为即可。因此等待张凯把后端处理完我才可以进行之后的行动。</p>\n<p>关于token，我和张凯交流的时候有个设想，我这边将code，使用query的方式添加到url的末尾，然后使用浏览器传出去，之后浏览器走之前微信公众号的那个端口，走完之后浏览器返回值，然后浏览器吊起我的程序。这个方法感觉是可行的，但是当时考虑到跨域的问题没有实现。</p>\n<p>晚上关于这个问题搜索了一下，主要针对是如何使用webview来吊起activity。</p>\n<p>结果显示，的确如果直接发intent吊起webview会出现跨域的问题，但是可以本地写一个html页面来解决跨域的问题。</p>\n<p><a href=\"http://www.cnblogs.com/yejiurui/p/3413796.html\" target=\"_blank\" rel=\"noopener\">使用webview吊起activity</a></p>\n<p>这样给我一个想法。由于安卓跨域保护的问题，很多和浏览器协作的方面，比如说之前做的，hybirdapp调用本地视频的功能，可以截取webview的url，然后吊起本地的html来加载视频。不过这个方式对于那种内嵌的视频可能不好用，内嵌的视频还是需要使用webserver来进行视频的提供。但是也是一种思路。</p>\n<p>明天做一下相关的demo。</p>\n<p>微信集成搞了2天，之后陈总那边的ui好了，因此需要重新更改ui。</p>\n<p>之前使用animation的方式，对textview进行动画的设置，这样会在更新的时候触发动画，但是动画的效果不是很好看，之后恰好看到了一个app，使用的是每次更新的时候数字从小到大的方式。刚好找到了一个库，单纯的一个自定义view，直接继承了textview，使用的一个valueAmatior动画，这个动画里面添加了一个animationListener，在这个监听器里面进行了textview的设值。值的范围从设置的开端到末端。这个设置的动画和我之前设置的对比就完全不同了，感觉十分好。</p>\n<p>周四周五大概就做了这几件事。晚上回来的路上，在想关于借口查询的问题，我之前使用的是定时去查询接口的方式，但是之前了解了一个关于http长连接的方式，实时聊天软件就是使用的长连接的效果，这方面也需要了解一下。</p>\n<p>因此本周的收获如下：</p>\n<ol>\n<li>了解了如何使用valueAmator来进行动画的更新。</li>\n<li>了解了如何集成微信</li>\n</ol>\n<p>遗留未解决的问题如下：</p>\n<ol>\n<li>使用本地静态html来进行get操作，对返回值过滤来吊起app并且获取返回值</li>\n<li>学习使用长链接的方式来进行接口的查询</li>\n</ol>\n<p>周末的任务：</p>\n<ol>\n<li>解决遗留问题</li>\n<li>处理一下williamchart的ui更改</li>\n<li>研究一下安卓的渐变色，圆心渐变和直线渐变</li>\n</ol>\n<p>有时间的话：</p>\n<ol>\n<li>学习一下常用的排序算法</li>\n<li>继续学习安卓群英传</li>\n</ol>\n"},{"title":"android事件分发机制","date":"2018-01-03T15:10:07.000Z","_content":"\n假如一个button\n```\n\tbutton.setOnClickListener(new OnClickListener(){\n\t\t@Override\n\t\tpublic void onClick(View v){\n\t\t\tLog.d(\"TAG\",\"onClick execute\");\n\t\t}\n\t})\n```\n\n同时设置ontouch事件\n\n```\n\tbutton.setOnTouchListener(new OnTouchListener(){\n\t\t@Override\n\t\tpublic boolean onTouch(View v, MotionEvent event){\n\t\t\tLog.d(\"TAG\",\"onTouch execute, action \"+ event.getAction());\n\t\t\treturn false;\n\t\t}\n\t})\n```\n\n点击按钮log如下\n```\nonTouch execute, action 0\nonTouch execute, action 1\nonClick execute\n```\n\nonTouch是优先于onClick执行的，并且onTouch执行了2次，一次是ACTION_DOWN,一次是ACTION_UP。\n顺序是先经过onTouch，在传递到onClick。\n\n将ontouch返回值改为true，在运行一次，会发现onClick不再执行，这就是拦截了。\n\n# dispatchTouchEvent\n\n任何view被触摸，一定会执行dispatchTouchEvent这个方法。\n\n```\npublic boolean dispatchTouchEvent(MotionEvent event) {  \n    if (mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED &&  \n            mOnTouchListener.onTouch(this, event)) {  \n        return true;  \n    }  \n    return onTouchEvent(event);  \n}  \n```\n\n这段代码很明显的指出了，首先会执行的是set的onTouchListener的onTouch事件，之后才会执行自身的onTouchEvent事件。\n\n```\npublic boolean onTouchEvent(MotionEvent event) {  \n    final int viewFlags = mViewFlags;  \n    if ((viewFlags & ENABLED_MASK) == DISABLED) {  \n        // A disabled view that is clickable still consumes the touch  \n        // events, it just doesn't respond to them.  \n        return (((viewFlags & CLICKABLE) == CLICKABLE ||  \n                (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE));  \n    }  \n    if (mTouchDelegate != null) {  \n        if (mTouchDelegate.onTouchEvent(event)) {  \n            return true;  \n        }  \n    }  \n    if (((viewFlags & CLICKABLE) == CLICKABLE ||  \n            (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {  \n        switch (event.getAction()) {  \n            case MotionEvent.ACTION_UP:  \n                boolean prepressed = (mPrivateFlags & PREPRESSED) != 0;  \n                if ((mPrivateFlags & PRESSED) != 0 || prepressed) {  \n                    // take focus if we don't have it already and we should in  \n                    // touch mode.  \n                    boolean focusTaken = false;  \n                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {  \n                        focusTaken = requestFocus();  \n                    }  \n                    if (!mHasPerformedLongPress) {  \n                        // This is a tap, so remove the longpress check  \n                        removeLongPressCallback();  \n                        // Only perform take click actions if we were in the pressed state  \n                        if (!focusTaken) {  \n                            // Use a Runnable and post this rather than calling  \n                            // performClick directly. This lets other visual state  \n                            // of the view update before click actions start.  \n                            if (mPerformClick == null) {  \n                                mPerformClick = new PerformClick();  \n                            }  \n                            if (!post(mPerformClick)) {  \n                                performClick();  \n                            }  \n                        }  \n                    }  \n                    if (mUnsetPressedState == null) {  \n                        mUnsetPressedState = new UnsetPressedState();  \n                    }  \n                    if (prepressed) {  \n                        mPrivateFlags |= PRESSED;  \n                        refreshDrawableState();  \n                        postDelayed(mUnsetPressedState,  \n                                ViewConfiguration.getPressedStateDuration());  \n                    } else if (!post(mUnsetPressedState)) {  \n                        // If the post failed, unpress right now  \n                        mUnsetPressedState.run();  \n                    }  \n                    removeTapCallback();  \n                }  \n                break;  \n            case MotionEvent.ACTION_DOWN:  \n                if (mPendingCheckForTap == null) {  \n                    mPendingCheckForTap = new CheckForTap();  \n                }  \n                mPrivateFlags |= PREPRESSED;  \n                mHasPerformedLongPress = false;  \n                postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());  \n                break;  \n            case MotionEvent.ACTION_CANCEL:  \n                mPrivateFlags &= ~PRESSED;  \n                refreshDrawableState();  \n                removeTapCallback();  \n                break;  \n            case MotionEvent.ACTION_MOVE:  \n                final int x = (int) event.getX();  \n                final int y = (int) event.getY();  \n                // Be lenient about moving outside of buttons  \n                int slop = mTouchSlop;  \n                if ((x < 0 - slop) || (x >= getWidth() + slop) ||  \n                        (y < 0 - slop) || (y >= getHeight() + slop)) {  \n                    // Outside button  \n                    removeTapCallback();  \n                    if ((mPrivateFlags & PRESSED) != 0) {  \n                        // Remove any future long press/tap checks  \n                        removeLongPressCallback();  \n                        // Need to switch from pressed to not pressed  \n                        mPrivateFlags &= ~PRESSED;  \n                        refreshDrawableState();  \n                    }  \n                }  \n                break;  \n        }  \n        return true;  \n    }  \n    return false;  \n}  \n```\n\n当事件为MotionEvent.ACTION_UP时，如果该控件可点击，会执行performClick()\n\n```\npublic boolean performClick() {  \n    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);  \n    if (mOnClickListener != null) {  \n        playSoundEffect(SoundEffectConstants.CLICK);  \n        mOnClickListener.onClick(this);  \n        return true;  \n    }  \n    return false;  \n}\n```\n\n从源码可以看出，基本上每一次事件，都会return 一个true，也就是消耗掉这次事件了。而之后的事件会重新进入，这也和之前的截断事件机制符合。\n\n# onTouch和onTouchEvent有什么区别，又该如何使用？\n\n从源码中可以看出，这两个方法都是在View的dispatchTouchEvent中调用的，onTouch优先于onTouchEvent执行。如果在onTouch方法中通过返回true将事件消费掉，onTouchEvent将不会再执行。\n另外需要注意的是，onTouch能够得到执行需要两个前提条件，第一mOnTouchListener的值不能为空，第二当前点击的控件必须是enable的。因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。\n\n# 为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？\n比如说左右滑的时候，还是正常的左右滑。\n但是上下滑的时候，会出现一个问题，就是listview无法上下滑动，这主要是事件被scrollview给消耗掉了，需要在触摸的时候，scrollview不进行截断操作，让事件能够传递下去。","source":"_posts/android事件分发机制.md","raw":"---\ntitle: android事件分发机制\ndate: 2018-01-03 23:10:07\ntags: android\n---\n\n假如一个button\n```\n\tbutton.setOnClickListener(new OnClickListener(){\n\t\t@Override\n\t\tpublic void onClick(View v){\n\t\t\tLog.d(\"TAG\",\"onClick execute\");\n\t\t}\n\t})\n```\n\n同时设置ontouch事件\n\n```\n\tbutton.setOnTouchListener(new OnTouchListener(){\n\t\t@Override\n\t\tpublic boolean onTouch(View v, MotionEvent event){\n\t\t\tLog.d(\"TAG\",\"onTouch execute, action \"+ event.getAction());\n\t\t\treturn false;\n\t\t}\n\t})\n```\n\n点击按钮log如下\n```\nonTouch execute, action 0\nonTouch execute, action 1\nonClick execute\n```\n\nonTouch是优先于onClick执行的，并且onTouch执行了2次，一次是ACTION_DOWN,一次是ACTION_UP。\n顺序是先经过onTouch，在传递到onClick。\n\n将ontouch返回值改为true，在运行一次，会发现onClick不再执行，这就是拦截了。\n\n# dispatchTouchEvent\n\n任何view被触摸，一定会执行dispatchTouchEvent这个方法。\n\n```\npublic boolean dispatchTouchEvent(MotionEvent event) {  \n    if (mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED &&  \n            mOnTouchListener.onTouch(this, event)) {  \n        return true;  \n    }  \n    return onTouchEvent(event);  \n}  \n```\n\n这段代码很明显的指出了，首先会执行的是set的onTouchListener的onTouch事件，之后才会执行自身的onTouchEvent事件。\n\n```\npublic boolean onTouchEvent(MotionEvent event) {  \n    final int viewFlags = mViewFlags;  \n    if ((viewFlags & ENABLED_MASK) == DISABLED) {  \n        // A disabled view that is clickable still consumes the touch  \n        // events, it just doesn't respond to them.  \n        return (((viewFlags & CLICKABLE) == CLICKABLE ||  \n                (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE));  \n    }  \n    if (mTouchDelegate != null) {  \n        if (mTouchDelegate.onTouchEvent(event)) {  \n            return true;  \n        }  \n    }  \n    if (((viewFlags & CLICKABLE) == CLICKABLE ||  \n            (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {  \n        switch (event.getAction()) {  \n            case MotionEvent.ACTION_UP:  \n                boolean prepressed = (mPrivateFlags & PREPRESSED) != 0;  \n                if ((mPrivateFlags & PRESSED) != 0 || prepressed) {  \n                    // take focus if we don't have it already and we should in  \n                    // touch mode.  \n                    boolean focusTaken = false;  \n                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {  \n                        focusTaken = requestFocus();  \n                    }  \n                    if (!mHasPerformedLongPress) {  \n                        // This is a tap, so remove the longpress check  \n                        removeLongPressCallback();  \n                        // Only perform take click actions if we were in the pressed state  \n                        if (!focusTaken) {  \n                            // Use a Runnable and post this rather than calling  \n                            // performClick directly. This lets other visual state  \n                            // of the view update before click actions start.  \n                            if (mPerformClick == null) {  \n                                mPerformClick = new PerformClick();  \n                            }  \n                            if (!post(mPerformClick)) {  \n                                performClick();  \n                            }  \n                        }  \n                    }  \n                    if (mUnsetPressedState == null) {  \n                        mUnsetPressedState = new UnsetPressedState();  \n                    }  \n                    if (prepressed) {  \n                        mPrivateFlags |= PRESSED;  \n                        refreshDrawableState();  \n                        postDelayed(mUnsetPressedState,  \n                                ViewConfiguration.getPressedStateDuration());  \n                    } else if (!post(mUnsetPressedState)) {  \n                        // If the post failed, unpress right now  \n                        mUnsetPressedState.run();  \n                    }  \n                    removeTapCallback();  \n                }  \n                break;  \n            case MotionEvent.ACTION_DOWN:  \n                if (mPendingCheckForTap == null) {  \n                    mPendingCheckForTap = new CheckForTap();  \n                }  \n                mPrivateFlags |= PREPRESSED;  \n                mHasPerformedLongPress = false;  \n                postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());  \n                break;  \n            case MotionEvent.ACTION_CANCEL:  \n                mPrivateFlags &= ~PRESSED;  \n                refreshDrawableState();  \n                removeTapCallback();  \n                break;  \n            case MotionEvent.ACTION_MOVE:  \n                final int x = (int) event.getX();  \n                final int y = (int) event.getY();  \n                // Be lenient about moving outside of buttons  \n                int slop = mTouchSlop;  \n                if ((x < 0 - slop) || (x >= getWidth() + slop) ||  \n                        (y < 0 - slop) || (y >= getHeight() + slop)) {  \n                    // Outside button  \n                    removeTapCallback();  \n                    if ((mPrivateFlags & PRESSED) != 0) {  \n                        // Remove any future long press/tap checks  \n                        removeLongPressCallback();  \n                        // Need to switch from pressed to not pressed  \n                        mPrivateFlags &= ~PRESSED;  \n                        refreshDrawableState();  \n                    }  \n                }  \n                break;  \n        }  \n        return true;  \n    }  \n    return false;  \n}  \n```\n\n当事件为MotionEvent.ACTION_UP时，如果该控件可点击，会执行performClick()\n\n```\npublic boolean performClick() {  \n    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);  \n    if (mOnClickListener != null) {  \n        playSoundEffect(SoundEffectConstants.CLICK);  \n        mOnClickListener.onClick(this);  \n        return true;  \n    }  \n    return false;  \n}\n```\n\n从源码可以看出，基本上每一次事件，都会return 一个true，也就是消耗掉这次事件了。而之后的事件会重新进入，这也和之前的截断事件机制符合。\n\n# onTouch和onTouchEvent有什么区别，又该如何使用？\n\n从源码中可以看出，这两个方法都是在View的dispatchTouchEvent中调用的，onTouch优先于onTouchEvent执行。如果在onTouch方法中通过返回true将事件消费掉，onTouchEvent将不会再执行。\n另外需要注意的是，onTouch能够得到执行需要两个前提条件，第一mOnTouchListener的值不能为空，第二当前点击的控件必须是enable的。因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。\n\n# 为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？\n比如说左右滑的时候，还是正常的左右滑。\n但是上下滑的时候，会出现一个问题，就是listview无法上下滑动，这主要是事件被scrollview给消耗掉了，需要在触摸的时候，scrollview不进行截断操作，让事件能够传递下去。","slug":"android事件分发机制","published":1,"updated":"2018-01-09T03:00:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7f9y0003d41i1hiehmdq","content":"<p>假如一个button<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.setOnClickListener(new OnClickListener()&#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onClick(View v)&#123;</span><br><span class=\"line\">\t\tLog.d(&quot;TAG&quot;,&quot;onClick execute&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>同时设置ontouch事件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.setOnTouchListener(new OnTouchListener()&#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic boolean onTouch(View v, MotionEvent event)&#123;</span><br><span class=\"line\">\t\tLog.d(&quot;TAG&quot;,&quot;onTouch execute, action &quot;+ event.getAction());</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>点击按钮log如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onTouch execute, action 0</span><br><span class=\"line\">onTouch execute, action 1</span><br><span class=\"line\">onClick execute</span><br></pre></td></tr></table></figure></p>\n<p>onTouch是优先于onClick执行的，并且onTouch执行了2次，一次是ACTION_DOWN,一次是ACTION_UP。<br>顺序是先经过onTouch，在传递到onClick。</p>\n<p>将ontouch返回值改为true，在运行一次，会发现onClick不再执行，这就是拦截了。</p>\n<h1 id=\"dispatchTouchEvent\"><a href=\"#dispatchTouchEvent\" class=\"headerlink\" title=\"dispatchTouchEvent\"></a>dispatchTouchEvent</h1><p>任何view被触摸，一定会执行dispatchTouchEvent这个方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean dispatchTouchEvent(MotionEvent event) &#123;  </span><br><span class=\"line\">    if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;  </span><br><span class=\"line\">            mOnTouchListener.onTouch(this, event)) &#123;  </span><br><span class=\"line\">        return true;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return onTouchEvent(event);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码很明显的指出了，首先会执行的是set的onTouchListener的onTouch事件，之后才会执行自身的onTouchEvent事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean onTouchEvent(MotionEvent event) &#123;  </span><br><span class=\"line\">    final int viewFlags = mViewFlags;  </span><br><span class=\"line\">    if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;  </span><br><span class=\"line\">        // A disabled view that is clickable still consumes the touch  </span><br><span class=\"line\">        // events, it just doesn&apos;t respond to them.  </span><br><span class=\"line\">        return (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  </span><br><span class=\"line\">                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    if (mTouchDelegate != null) &#123;  </span><br><span class=\"line\">        if (mTouchDelegate.onTouchEvent(event)) &#123;  </span><br><span class=\"line\">            return true;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  </span><br><span class=\"line\">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;  </span><br><span class=\"line\">        switch (event.getAction()) &#123;  </span><br><span class=\"line\">            case MotionEvent.ACTION_UP:  </span><br><span class=\"line\">                boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0;  </span><br><span class=\"line\">                if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) &#123;  </span><br><span class=\"line\">                    // take focus if we don&apos;t have it already and we should in  </span><br><span class=\"line\">                    // touch mode.  </span><br><span class=\"line\">                    boolean focusTaken = false;  </span><br><span class=\"line\">                    if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;  </span><br><span class=\"line\">                        focusTaken = requestFocus();  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    if (!mHasPerformedLongPress) &#123;  </span><br><span class=\"line\">                        // This is a tap, so remove the longpress check  </span><br><span class=\"line\">                        removeLongPressCallback();  </span><br><span class=\"line\">                        // Only perform take click actions if we were in the pressed state  </span><br><span class=\"line\">                        if (!focusTaken) &#123;  </span><br><span class=\"line\">                            // Use a Runnable and post this rather than calling  </span><br><span class=\"line\">                            // performClick directly. This lets other visual state  </span><br><span class=\"line\">                            // of the view update before click actions start.  </span><br><span class=\"line\">                            if (mPerformClick == null) &#123;  </span><br><span class=\"line\">                                mPerformClick = new PerformClick();  </span><br><span class=\"line\">                            &#125;  </span><br><span class=\"line\">                            if (!post(mPerformClick)) &#123;  </span><br><span class=\"line\">                                performClick();  </span><br><span class=\"line\">                            &#125;  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    if (mUnsetPressedState == null) &#123;  </span><br><span class=\"line\">                        mUnsetPressedState = new UnsetPressedState();  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    if (prepressed) &#123;  </span><br><span class=\"line\">                        mPrivateFlags |= PRESSED;  </span><br><span class=\"line\">                        refreshDrawableState();  </span><br><span class=\"line\">                        postDelayed(mUnsetPressedState,  </span><br><span class=\"line\">                                ViewConfiguration.getPressedStateDuration());  </span><br><span class=\"line\">                    &#125; else if (!post(mUnsetPressedState)) &#123;  </span><br><span class=\"line\">                        // If the post failed, unpress right now  </span><br><span class=\"line\">                        mUnsetPressedState.run();  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    removeTapCallback();  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">            case MotionEvent.ACTION_DOWN:  </span><br><span class=\"line\">                if (mPendingCheckForTap == null) &#123;  </span><br><span class=\"line\">                    mPendingCheckForTap = new CheckForTap();  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                mPrivateFlags |= PREPRESSED;  </span><br><span class=\"line\">                mHasPerformedLongPress = false;  </span><br><span class=\"line\">                postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">            case MotionEvent.ACTION_CANCEL:  </span><br><span class=\"line\">                mPrivateFlags &amp;= ~PRESSED;  </span><br><span class=\"line\">                refreshDrawableState();  </span><br><span class=\"line\">                removeTapCallback();  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">            case MotionEvent.ACTION_MOVE:  </span><br><span class=\"line\">                final int x = (int) event.getX();  </span><br><span class=\"line\">                final int y = (int) event.getY();  </span><br><span class=\"line\">                // Be lenient about moving outside of buttons  </span><br><span class=\"line\">                int slop = mTouchSlop;  </span><br><span class=\"line\">                if ((x &lt; 0 - slop) || (x &gt;= getWidth() + slop) ||  </span><br><span class=\"line\">                        (y &lt; 0 - slop) || (y &gt;= getHeight() + slop)) &#123;  </span><br><span class=\"line\">                    // Outside button  </span><br><span class=\"line\">                    removeTapCallback();  </span><br><span class=\"line\">                    if ((mPrivateFlags &amp; PRESSED) != 0) &#123;  </span><br><span class=\"line\">                        // Remove any future long press/tap checks  </span><br><span class=\"line\">                        removeLongPressCallback();  </span><br><span class=\"line\">                        // Need to switch from pressed to not pressed  </span><br><span class=\"line\">                        mPrivateFlags &amp;= ~PRESSED;  </span><br><span class=\"line\">                        refreshDrawableState();  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        return true;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return false;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当事件为MotionEvent.ACTION_UP时，如果该控件可点击，会执行performClick()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean performClick() &#123;  </span><br><span class=\"line\">    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);  </span><br><span class=\"line\">    if (mOnClickListener != null) &#123;  </span><br><span class=\"line\">        playSoundEffect(SoundEffectConstants.CLICK);  </span><br><span class=\"line\">        mOnClickListener.onClick(this);  </span><br><span class=\"line\">        return true;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return false;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从源码可以看出，基本上每一次事件，都会return 一个true，也就是消耗掉这次事件了。而之后的事件会重新进入，这也和之前的截断事件机制符合。</p>\n<h1 id=\"onTouch和onTouchEvent有什么区别，又该如何使用？\"><a href=\"#onTouch和onTouchEvent有什么区别，又该如何使用？\" class=\"headerlink\" title=\"onTouch和onTouchEvent有什么区别，又该如何使用？\"></a>onTouch和onTouchEvent有什么区别，又该如何使用？</h1><p>从源码中可以看出，这两个方法都是在View的dispatchTouchEvent中调用的，onTouch优先于onTouchEvent执行。如果在onTouch方法中通过返回true将事件消费掉，onTouchEvent将不会再执行。<br>另外需要注意的是，onTouch能够得到执行需要两个前提条件，第一mOnTouchListener的值不能为空，第二当前点击的控件必须是enable的。因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。</p>\n<h1 id=\"为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？\"><a href=\"#为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？\" class=\"headerlink\" title=\"为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？\"></a>为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？</h1><p>比如说左右滑的时候，还是正常的左右滑。<br>但是上下滑的时候，会出现一个问题，就是listview无法上下滑动，这主要是事件被scrollview给消耗掉了，需要在触摸的时候，scrollview不进行截断操作，让事件能够传递下去。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>假如一个button<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.setOnClickListener(new OnClickListener()&#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onClick(View v)&#123;</span><br><span class=\"line\">\t\tLog.d(&quot;TAG&quot;,&quot;onClick execute&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>同时设置ontouch事件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.setOnTouchListener(new OnTouchListener()&#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic boolean onTouch(View v, MotionEvent event)&#123;</span><br><span class=\"line\">\t\tLog.d(&quot;TAG&quot;,&quot;onTouch execute, action &quot;+ event.getAction());</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>点击按钮log如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onTouch execute, action 0</span><br><span class=\"line\">onTouch execute, action 1</span><br><span class=\"line\">onClick execute</span><br></pre></td></tr></table></figure></p>\n<p>onTouch是优先于onClick执行的，并且onTouch执行了2次，一次是ACTION_DOWN,一次是ACTION_UP。<br>顺序是先经过onTouch，在传递到onClick。</p>\n<p>将ontouch返回值改为true，在运行一次，会发现onClick不再执行，这就是拦截了。</p>\n<h1 id=\"dispatchTouchEvent\"><a href=\"#dispatchTouchEvent\" class=\"headerlink\" title=\"dispatchTouchEvent\"></a>dispatchTouchEvent</h1><p>任何view被触摸，一定会执行dispatchTouchEvent这个方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean dispatchTouchEvent(MotionEvent event) &#123;  </span><br><span class=\"line\">    if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;  </span><br><span class=\"line\">            mOnTouchListener.onTouch(this, event)) &#123;  </span><br><span class=\"line\">        return true;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return onTouchEvent(event);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码很明显的指出了，首先会执行的是set的onTouchListener的onTouch事件，之后才会执行自身的onTouchEvent事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean onTouchEvent(MotionEvent event) &#123;  </span><br><span class=\"line\">    final int viewFlags = mViewFlags;  </span><br><span class=\"line\">    if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;  </span><br><span class=\"line\">        // A disabled view that is clickable still consumes the touch  </span><br><span class=\"line\">        // events, it just doesn&apos;t respond to them.  </span><br><span class=\"line\">        return (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  </span><br><span class=\"line\">                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    if (mTouchDelegate != null) &#123;  </span><br><span class=\"line\">        if (mTouchDelegate.onTouchEvent(event)) &#123;  </span><br><span class=\"line\">            return true;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  </span><br><span class=\"line\">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;  </span><br><span class=\"line\">        switch (event.getAction()) &#123;  </span><br><span class=\"line\">            case MotionEvent.ACTION_UP:  </span><br><span class=\"line\">                boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0;  </span><br><span class=\"line\">                if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) &#123;  </span><br><span class=\"line\">                    // take focus if we don&apos;t have it already and we should in  </span><br><span class=\"line\">                    // touch mode.  </span><br><span class=\"line\">                    boolean focusTaken = false;  </span><br><span class=\"line\">                    if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;  </span><br><span class=\"line\">                        focusTaken = requestFocus();  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    if (!mHasPerformedLongPress) &#123;  </span><br><span class=\"line\">                        // This is a tap, so remove the longpress check  </span><br><span class=\"line\">                        removeLongPressCallback();  </span><br><span class=\"line\">                        // Only perform take click actions if we were in the pressed state  </span><br><span class=\"line\">                        if (!focusTaken) &#123;  </span><br><span class=\"line\">                            // Use a Runnable and post this rather than calling  </span><br><span class=\"line\">                            // performClick directly. This lets other visual state  </span><br><span class=\"line\">                            // of the view update before click actions start.  </span><br><span class=\"line\">                            if (mPerformClick == null) &#123;  </span><br><span class=\"line\">                                mPerformClick = new PerformClick();  </span><br><span class=\"line\">                            &#125;  </span><br><span class=\"line\">                            if (!post(mPerformClick)) &#123;  </span><br><span class=\"line\">                                performClick();  </span><br><span class=\"line\">                            &#125;  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    if (mUnsetPressedState == null) &#123;  </span><br><span class=\"line\">                        mUnsetPressedState = new UnsetPressedState();  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    if (prepressed) &#123;  </span><br><span class=\"line\">                        mPrivateFlags |= PRESSED;  </span><br><span class=\"line\">                        refreshDrawableState();  </span><br><span class=\"line\">                        postDelayed(mUnsetPressedState,  </span><br><span class=\"line\">                                ViewConfiguration.getPressedStateDuration());  </span><br><span class=\"line\">                    &#125; else if (!post(mUnsetPressedState)) &#123;  </span><br><span class=\"line\">                        // If the post failed, unpress right now  </span><br><span class=\"line\">                        mUnsetPressedState.run();  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    removeTapCallback();  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">            case MotionEvent.ACTION_DOWN:  </span><br><span class=\"line\">                if (mPendingCheckForTap == null) &#123;  </span><br><span class=\"line\">                    mPendingCheckForTap = new CheckForTap();  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                mPrivateFlags |= PREPRESSED;  </span><br><span class=\"line\">                mHasPerformedLongPress = false;  </span><br><span class=\"line\">                postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">            case MotionEvent.ACTION_CANCEL:  </span><br><span class=\"line\">                mPrivateFlags &amp;= ~PRESSED;  </span><br><span class=\"line\">                refreshDrawableState();  </span><br><span class=\"line\">                removeTapCallback();  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">            case MotionEvent.ACTION_MOVE:  </span><br><span class=\"line\">                final int x = (int) event.getX();  </span><br><span class=\"line\">                final int y = (int) event.getY();  </span><br><span class=\"line\">                // Be lenient about moving outside of buttons  </span><br><span class=\"line\">                int slop = mTouchSlop;  </span><br><span class=\"line\">                if ((x &lt; 0 - slop) || (x &gt;= getWidth() + slop) ||  </span><br><span class=\"line\">                        (y &lt; 0 - slop) || (y &gt;= getHeight() + slop)) &#123;  </span><br><span class=\"line\">                    // Outside button  </span><br><span class=\"line\">                    removeTapCallback();  </span><br><span class=\"line\">                    if ((mPrivateFlags &amp; PRESSED) != 0) &#123;  </span><br><span class=\"line\">                        // Remove any future long press/tap checks  </span><br><span class=\"line\">                        removeLongPressCallback();  </span><br><span class=\"line\">                        // Need to switch from pressed to not pressed  </span><br><span class=\"line\">                        mPrivateFlags &amp;= ~PRESSED;  </span><br><span class=\"line\">                        refreshDrawableState();  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        return true;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return false;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当事件为MotionEvent.ACTION_UP时，如果该控件可点击，会执行performClick()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean performClick() &#123;  </span><br><span class=\"line\">    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);  </span><br><span class=\"line\">    if (mOnClickListener != null) &#123;  </span><br><span class=\"line\">        playSoundEffect(SoundEffectConstants.CLICK);  </span><br><span class=\"line\">        mOnClickListener.onClick(this);  </span><br><span class=\"line\">        return true;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return false;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从源码可以看出，基本上每一次事件，都会return 一个true，也就是消耗掉这次事件了。而之后的事件会重新进入，这也和之前的截断事件机制符合。</p>\n<h1 id=\"onTouch和onTouchEvent有什么区别，又该如何使用？\"><a href=\"#onTouch和onTouchEvent有什么区别，又该如何使用？\" class=\"headerlink\" title=\"onTouch和onTouchEvent有什么区别，又该如何使用？\"></a>onTouch和onTouchEvent有什么区别，又该如何使用？</h1><p>从源码中可以看出，这两个方法都是在View的dispatchTouchEvent中调用的，onTouch优先于onTouchEvent执行。如果在onTouch方法中通过返回true将事件消费掉，onTouchEvent将不会再执行。<br>另外需要注意的是，onTouch能够得到执行需要两个前提条件，第一mOnTouchListener的值不能为空，第二当前点击的控件必须是enable的。因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。</p>\n<h1 id=\"为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？\"><a href=\"#为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？\" class=\"headerlink\" title=\"为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？\"></a>为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？</h1><p>比如说左右滑的时候，还是正常的左右滑。<br>但是上下滑的时候，会出现一个问题，就是listview无法上下滑动，这主要是事件被scrollview给消耗掉了，需要在触摸的时候，scrollview不进行截断操作，让事件能够传递下去。</p>\n"},{"title":"android事件拦截机制分析","date":"2018-01-03T11:04:36.000Z","_content":"由于Android是树状结构，嵌套会导致事件发生区域重叠，针对重叠区域的处理，就叫事件拦截机制。\n\n我们现在假设有一个嵌套结构\n\n第一层： a-ViewGroup\n第二层： b-ViewGroup\n第三层： c-View\n\n重写viewgroup的三个方法：\n```\n@Override\npublic boolean dispatchTouchEvent(MotionEvent ev){\n\tLogUtil.i(name+\"dispatch\");\n\treturn super.dispatchTouchEvent(ev);\n}\n```\n\n```\n@Override\npublic boolean onInterceptTouchEvent(MotionEvent ev){\n\tLogUtil.i(name+\"intecept\");\n\treturn super.onInterceptTouchEvent(ev);\n}\n```\n\n```\n@Override\npublic boolean onTouchEvent(MotionEvent ev){\n\tLogUtil.i(name+\"onTouch\");\n\treturn super.onTouchEvent(ev);\n}\n```\n\n由于view不需要重写onInterceptTouchEvent,只需要重写另外的两个事件即可。\n\n# 点击c --正常情况\n\nLog显示为\n```\na dispatch\na intercept\nb dispatch\nb intercept\nc dispatch\nc ontouch\nb ontouch\na ontouch\n```\n\n事件的传递顺序为a->b->c， 事件传递的时候是先执行dispatchTouchEvent()方法，之后在执行onInterceptTouchEvent()方法。\n事件处理的顺序为c->b->a\n\n事件传递的返回值很容易理解：True,拦截，不继续;False,不拦截，继续流程。\n事件处理的返回值也类似：True,处理了，不用审核了;False,给上级处理。\n\n初始情况下，返回值都是false。\n\n# 让a的onInterceptTouchEvent()返回true\n\n```\na dispatch\na intercept\na ontouch\n```\n\n很明显是a处截断了。\n\n# 让b的onInterceptTouchEvent()返回true\n\n```\na dispatch\na intercept\nb dispatch\nb intercept\nb ontouch\na ontouch\n```\n\n很明显是b处截断了。\n\n# 让c的onInterceptTouchEvent()返回true\n\n```\na dispatch\na intercept\nb dispatch\nb intercept\nc dispatch\nc ontouch\n```\n\n解释一下ontouchevent为true的意义。\n假如ontouchevent为false，代表这个ontouch事件没有结束，因此还会继续找别的事件来进行处理直到返回的ontouchevent为true。有一些view自己写了默认的ontouch事件，因此假如想继承一个有功能的view而又不想它产生ontouch效果，可以返回true来截断默认的ontouch事件。\n一般情况下false可以起到添加额外效果的功能。","source":"_posts/android事件拦截机制分析.md","raw":"---\ntitle: android事件拦截机制分析\ndate: 2018-01-03 19:04:36\ntags: android\n---\n由于Android是树状结构，嵌套会导致事件发生区域重叠，针对重叠区域的处理，就叫事件拦截机制。\n\n我们现在假设有一个嵌套结构\n\n第一层： a-ViewGroup\n第二层： b-ViewGroup\n第三层： c-View\n\n重写viewgroup的三个方法：\n```\n@Override\npublic boolean dispatchTouchEvent(MotionEvent ev){\n\tLogUtil.i(name+\"dispatch\");\n\treturn super.dispatchTouchEvent(ev);\n}\n```\n\n```\n@Override\npublic boolean onInterceptTouchEvent(MotionEvent ev){\n\tLogUtil.i(name+\"intecept\");\n\treturn super.onInterceptTouchEvent(ev);\n}\n```\n\n```\n@Override\npublic boolean onTouchEvent(MotionEvent ev){\n\tLogUtil.i(name+\"onTouch\");\n\treturn super.onTouchEvent(ev);\n}\n```\n\n由于view不需要重写onInterceptTouchEvent,只需要重写另外的两个事件即可。\n\n# 点击c --正常情况\n\nLog显示为\n```\na dispatch\na intercept\nb dispatch\nb intercept\nc dispatch\nc ontouch\nb ontouch\na ontouch\n```\n\n事件的传递顺序为a->b->c， 事件传递的时候是先执行dispatchTouchEvent()方法，之后在执行onInterceptTouchEvent()方法。\n事件处理的顺序为c->b->a\n\n事件传递的返回值很容易理解：True,拦截，不继续;False,不拦截，继续流程。\n事件处理的返回值也类似：True,处理了，不用审核了;False,给上级处理。\n\n初始情况下，返回值都是false。\n\n# 让a的onInterceptTouchEvent()返回true\n\n```\na dispatch\na intercept\na ontouch\n```\n\n很明显是a处截断了。\n\n# 让b的onInterceptTouchEvent()返回true\n\n```\na dispatch\na intercept\nb dispatch\nb intercept\nb ontouch\na ontouch\n```\n\n很明显是b处截断了。\n\n# 让c的onInterceptTouchEvent()返回true\n\n```\na dispatch\na intercept\nb dispatch\nb intercept\nc dispatch\nc ontouch\n```\n\n解释一下ontouchevent为true的意义。\n假如ontouchevent为false，代表这个ontouch事件没有结束，因此还会继续找别的事件来进行处理直到返回的ontouchevent为true。有一些view自己写了默认的ontouch事件，因此假如想继承一个有功能的view而又不想它产生ontouch效果，可以返回true来截断默认的ontouch事件。\n一般情况下false可以起到添加额外效果的功能。","slug":"android事件拦截机制分析","published":1,"updated":"2018-01-09T03:00:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7f9z0004d41il2tcg1vx","content":"<p>由于Android是树状结构，嵌套会导致事件发生区域重叠，针对重叠区域的处理，就叫事件拦截机制。</p>\n<p>我们现在假设有一个嵌套结构</p>\n<p>第一层： a-ViewGroup<br>第二层： b-ViewGroup<br>第三层： c-View</p>\n<p>重写viewgroup的三个方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean dispatchTouchEvent(MotionEvent ev)&#123;</span><br><span class=\"line\">\tLogUtil.i(name+&quot;dispatch&quot;);</span><br><span class=\"line\">\treturn super.dispatchTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onInterceptTouchEvent(MotionEvent ev)&#123;</span><br><span class=\"line\">\tLogUtil.i(name+&quot;intecept&quot;);</span><br><span class=\"line\">\treturn super.onInterceptTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onTouchEvent(MotionEvent ev)&#123;</span><br><span class=\"line\">\tLogUtil.i(name+&quot;onTouch&quot;);</span><br><span class=\"line\">\treturn super.onTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于view不需要重写onInterceptTouchEvent,只需要重写另外的两个事件即可。</p>\n<h1 id=\"点击c-–正常情况\"><a href=\"#点击c-–正常情况\" class=\"headerlink\" title=\"点击c –正常情况\"></a>点击c –正常情况</h1><p>Log显示为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a dispatch</span><br><span class=\"line\">a intercept</span><br><span class=\"line\">b dispatch</span><br><span class=\"line\">b intercept</span><br><span class=\"line\">c dispatch</span><br><span class=\"line\">c ontouch</span><br><span class=\"line\">b ontouch</span><br><span class=\"line\">a ontouch</span><br></pre></td></tr></table></figure></p>\n<p>事件的传递顺序为a-&gt;b-&gt;c， 事件传递的时候是先执行dispatchTouchEvent()方法，之后在执行onInterceptTouchEvent()方法。<br>事件处理的顺序为c-&gt;b-&gt;a</p>\n<p>事件传递的返回值很容易理解：True,拦截，不继续;False,不拦截，继续流程。<br>事件处理的返回值也类似：True,处理了，不用审核了;False,给上级处理。</p>\n<p>初始情况下，返回值都是false。</p>\n<h1 id=\"让a的onInterceptTouchEvent-返回true\"><a href=\"#让a的onInterceptTouchEvent-返回true\" class=\"headerlink\" title=\"让a的onInterceptTouchEvent()返回true\"></a>让a的onInterceptTouchEvent()返回true</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a dispatch</span><br><span class=\"line\">a intercept</span><br><span class=\"line\">a ontouch</span><br></pre></td></tr></table></figure>\n<p>很明显是a处截断了。</p>\n<h1 id=\"让b的onInterceptTouchEvent-返回true\"><a href=\"#让b的onInterceptTouchEvent-返回true\" class=\"headerlink\" title=\"让b的onInterceptTouchEvent()返回true\"></a>让b的onInterceptTouchEvent()返回true</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a dispatch</span><br><span class=\"line\">a intercept</span><br><span class=\"line\">b dispatch</span><br><span class=\"line\">b intercept</span><br><span class=\"line\">b ontouch</span><br><span class=\"line\">a ontouch</span><br></pre></td></tr></table></figure>\n<p>很明显是b处截断了。</p>\n<h1 id=\"让c的onInterceptTouchEvent-返回true\"><a href=\"#让c的onInterceptTouchEvent-返回true\" class=\"headerlink\" title=\"让c的onInterceptTouchEvent()返回true\"></a>让c的onInterceptTouchEvent()返回true</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a dispatch</span><br><span class=\"line\">a intercept</span><br><span class=\"line\">b dispatch</span><br><span class=\"line\">b intercept</span><br><span class=\"line\">c dispatch</span><br><span class=\"line\">c ontouch</span><br></pre></td></tr></table></figure>\n<p>解释一下ontouchevent为true的意义。<br>假如ontouchevent为false，代表这个ontouch事件没有结束，因此还会继续找别的事件来进行处理直到返回的ontouchevent为true。有一些view自己写了默认的ontouch事件，因此假如想继承一个有功能的view而又不想它产生ontouch效果，可以返回true来截断默认的ontouch事件。<br>一般情况下false可以起到添加额外效果的功能。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>由于Android是树状结构，嵌套会导致事件发生区域重叠，针对重叠区域的处理，就叫事件拦截机制。</p>\n<p>我们现在假设有一个嵌套结构</p>\n<p>第一层： a-ViewGroup<br>第二层： b-ViewGroup<br>第三层： c-View</p>\n<p>重写viewgroup的三个方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean dispatchTouchEvent(MotionEvent ev)&#123;</span><br><span class=\"line\">\tLogUtil.i(name+&quot;dispatch&quot;);</span><br><span class=\"line\">\treturn super.dispatchTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onInterceptTouchEvent(MotionEvent ev)&#123;</span><br><span class=\"line\">\tLogUtil.i(name+&quot;intecept&quot;);</span><br><span class=\"line\">\treturn super.onInterceptTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onTouchEvent(MotionEvent ev)&#123;</span><br><span class=\"line\">\tLogUtil.i(name+&quot;onTouch&quot;);</span><br><span class=\"line\">\treturn super.onTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于view不需要重写onInterceptTouchEvent,只需要重写另外的两个事件即可。</p>\n<h1 id=\"点击c-–正常情况\"><a href=\"#点击c-–正常情况\" class=\"headerlink\" title=\"点击c –正常情况\"></a>点击c –正常情况</h1><p>Log显示为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a dispatch</span><br><span class=\"line\">a intercept</span><br><span class=\"line\">b dispatch</span><br><span class=\"line\">b intercept</span><br><span class=\"line\">c dispatch</span><br><span class=\"line\">c ontouch</span><br><span class=\"line\">b ontouch</span><br><span class=\"line\">a ontouch</span><br></pre></td></tr></table></figure></p>\n<p>事件的传递顺序为a-&gt;b-&gt;c， 事件传递的时候是先执行dispatchTouchEvent()方法，之后在执行onInterceptTouchEvent()方法。<br>事件处理的顺序为c-&gt;b-&gt;a</p>\n<p>事件传递的返回值很容易理解：True,拦截，不继续;False,不拦截，继续流程。<br>事件处理的返回值也类似：True,处理了，不用审核了;False,给上级处理。</p>\n<p>初始情况下，返回值都是false。</p>\n<h1 id=\"让a的onInterceptTouchEvent-返回true\"><a href=\"#让a的onInterceptTouchEvent-返回true\" class=\"headerlink\" title=\"让a的onInterceptTouchEvent()返回true\"></a>让a的onInterceptTouchEvent()返回true</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a dispatch</span><br><span class=\"line\">a intercept</span><br><span class=\"line\">a ontouch</span><br></pre></td></tr></table></figure>\n<p>很明显是a处截断了。</p>\n<h1 id=\"让b的onInterceptTouchEvent-返回true\"><a href=\"#让b的onInterceptTouchEvent-返回true\" class=\"headerlink\" title=\"让b的onInterceptTouchEvent()返回true\"></a>让b的onInterceptTouchEvent()返回true</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a dispatch</span><br><span class=\"line\">a intercept</span><br><span class=\"line\">b dispatch</span><br><span class=\"line\">b intercept</span><br><span class=\"line\">b ontouch</span><br><span class=\"line\">a ontouch</span><br></pre></td></tr></table></figure>\n<p>很明显是b处截断了。</p>\n<h1 id=\"让c的onInterceptTouchEvent-返回true\"><a href=\"#让c的onInterceptTouchEvent-返回true\" class=\"headerlink\" title=\"让c的onInterceptTouchEvent()返回true\"></a>让c的onInterceptTouchEvent()返回true</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a dispatch</span><br><span class=\"line\">a intercept</span><br><span class=\"line\">b dispatch</span><br><span class=\"line\">b intercept</span><br><span class=\"line\">c dispatch</span><br><span class=\"line\">c ontouch</span><br></pre></td></tr></table></figure>\n<p>解释一下ontouchevent为true的意义。<br>假如ontouchevent为false，代表这个ontouch事件没有结束，因此还会继续找别的事件来进行处理直到返回的ontouchevent为true。有一些view自己写了默认的ontouch事件，因此假如想继承一个有功能的view而又不想它产生ontouch效果，可以返回true来截断默认的ontouch事件。<br>一般情况下false可以起到添加额外效果的功能。</p>\n"},{"title":"android消息推送","date":"2018-01-07T10:48:46.000Z","_content":"之前与服务器通信的时候，使用的是handler轮询的机制，固定几秒来查一次接口数据。\n\n这样做有两个弊端，一个是当app被注销的时候，无法实现通知的功能。另一个是轮询无法达到实时性的地步。\n\n同时无法实现消息推送的功能。\n\nim通信的原理：客户端a发送消息->服务端处理->发送给客户端b\n\n消息推送的原理：客户端a发送消息->服务端处理->发送给客户端a\n\n\n# 长连接和短连接\n\n1. 长连接：客户端和服务器之间始终建立着一个通信连接，在连接没有中断之前，客户端和服务器之间可以随时通信\n典型范例 socket\n长连接实现的实时通讯，称作推送\n\n2. 短连接：通信双方有数据交互时，就建立一个连接，数据发送完成后，断开此连接\n典型范例 http\n短连接实现的实时通讯，称作轮询\n","source":"_posts/android消息推送.md","raw":"---\ntitle: android消息推送\ndate: 2018-01-07 18:48:46\ntags: android\n---\n之前与服务器通信的时候，使用的是handler轮询的机制，固定几秒来查一次接口数据。\n\n这样做有两个弊端，一个是当app被注销的时候，无法实现通知的功能。另一个是轮询无法达到实时性的地步。\n\n同时无法实现消息推送的功能。\n\nim通信的原理：客户端a发送消息->服务端处理->发送给客户端b\n\n消息推送的原理：客户端a发送消息->服务端处理->发送给客户端a\n\n\n# 长连接和短连接\n\n1. 长连接：客户端和服务器之间始终建立着一个通信连接，在连接没有中断之前，客户端和服务器之间可以随时通信\n典型范例 socket\n长连接实现的实时通讯，称作推送\n\n2. 短连接：通信双方有数据交互时，就建立一个连接，数据发送完成后，断开此连接\n典型范例 http\n短连接实现的实时通讯，称作轮询\n","slug":"android消息推送","published":1,"updated":"2018-01-09T03:00:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7fa10005d41ixannta37","content":"<p>之前与服务器通信的时候，使用的是handler轮询的机制，固定几秒来查一次接口数据。</p>\n<p>这样做有两个弊端，一个是当app被注销的时候，无法实现通知的功能。另一个是轮询无法达到实时性的地步。</p>\n<p>同时无法实现消息推送的功能。</p>\n<p>im通信的原理：客户端a发送消息-&gt;服务端处理-&gt;发送给客户端b</p>\n<p>消息推送的原理：客户端a发送消息-&gt;服务端处理-&gt;发送给客户端a</p>\n<h1 id=\"长连接和短连接\"><a href=\"#长连接和短连接\" class=\"headerlink\" title=\"长连接和短连接\"></a>长连接和短连接</h1><ol>\n<li><p>长连接：客户端和服务器之间始终建立着一个通信连接，在连接没有中断之前，客户端和服务器之间可以随时通信<br>典型范例 socket<br>长连接实现的实时通讯，称作推送</p>\n</li>\n<li><p>短连接：通信双方有数据交互时，就建立一个连接，数据发送完成后，断开此连接<br>典型范例 http<br>短连接实现的实时通讯，称作轮询</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>之前与服务器通信的时候，使用的是handler轮询的机制，固定几秒来查一次接口数据。</p>\n<p>这样做有两个弊端，一个是当app被注销的时候，无法实现通知的功能。另一个是轮询无法达到实时性的地步。</p>\n<p>同时无法实现消息推送的功能。</p>\n<p>im通信的原理：客户端a发送消息-&gt;服务端处理-&gt;发送给客户端b</p>\n<p>消息推送的原理：客户端a发送消息-&gt;服务端处理-&gt;发送给客户端a</p>\n<h1 id=\"长连接和短连接\"><a href=\"#长连接和短连接\" class=\"headerlink\" title=\"长连接和短连接\"></a>长连接和短连接</h1><ol>\n<li><p>长连接：客户端和服务器之间始终建立着一个通信连接，在连接没有中断之前，客户端和服务器之间可以随时通信<br>典型范例 socket<br>长连接实现的实时通讯，称作推送</p>\n</li>\n<li><p>短连接：通信双方有数据交互时，就建立一个连接，数据发送完成后，断开此连接<br>典型范例 http<br>短连接实现的实时通讯，称作轮询</p>\n</li>\n</ol>\n"},{"title":"android持久化存储","date":"2018-01-03T06:57:26.000Z","_content":"\n# 内部存储（internalStorage）\n\ndata文件夹就是我们常说的内部存储，其中有两个文件夹需要关注，一个是app文件夹，一个是data文件夹。\n\n## app文件夹\n\napp文件夹里存放着我们所有安装的app的apk文件。\n\n## data文件夹\n\n这个文件夹里面都是一些包名，打开这些包名会看到：\n\n1. data/data/包名/shared_prefs\n2. data/data/包名/databases\n3. data/data/包名/files\n4. data/data/包名/cache\n\nsharedPreferenced的时候，数据持久化存储于本地，其实就是存在这个文件中的xml文件里面。\n数据库文件就是存储于databases文件夹中。\n普通数据存储在files中。\n缓存文件存储在cache文件夹中。\n\n\n# 外部存储（externalStorage）\n\n外部存储是我们平时操作最多的，外部存储一般就是我们看到的storage文件夹，当然也有mnt文件夹，不同厂家有可能不一样。\n一般来讲storage文件夹中有一个sdcard文件夹，这个文件夹中的文件又分为两类，一类是公有目录，一类是私有目录。公有目录又分为九大类，比如说DCIM、DOWNLOAD等这种系统为我们创建的文件夹。私有目录就是android这种文件夹，这个文件夹打开之后里面有一个data文件夹，打开这个data文件夹，里面有许多包名组成的文件夹。\n\n# 存储操作\n\n## 文件存储\n\n文件存储的所有文件默认放在/data/data/<packagename>/file/目录下\n\n### 文件写入\n\n```\npublic void save(String inputText){\n\tFIleOutputStream out = null;\n\tBufferedWriter writer = null;\n\ttry{\n\t\tout = openFileOutput(\"data\", Context.MODE_PRIVATE);\n\t\twriter = new BufferedWriter(new OutputStreamWriter(out));\n\t\twriter.write(inputText);\n\t}catch(FileNotFoundException e){\n\t\te.printStackTrace();\n\t}catch(IOException e){\n\t\te.printStackTrace();\n\t}finally{\n\t\tif(writer != null){\n\t\t\ttry{\n\t\t\t\twriter.close();\n\t\t\t}catch(IOException e){\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### 文件读取\n\n```\npublic String load(){\n\tFileInputStream in = null;\n\tBufferedReader reader = null;\n\tStringBuilder content = new StringBuilder();\n\ttry{\n\t\tin = openFileInput(\"data\");\n\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\tString line = \"\";\n\t\twhile((line = reader.readLine()) != null){\n\t\t\tcontent.append(line);\n\t\t}\n\t}catch(FileNotFoundException e){\n\t\te.printStackTrace();\n\t}catch(IOException e){\n\t\te.printStackTrace();\n\t}finally{\n\t\tif(reader != null){\n\t\t\ttry{\n\t\t\t\treader.close();\n\t\t\t}catch(IOException e){\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\treturn content.toString();\n}\n```\n\n## SharePreferences\n\nSharepreference默认放在/data/data/<packagename>/file/目录下\n\n### SharedPreferences写入\n\n```\n\tSharedPreferences.Editor editor = getSharedPreferences(\"data\", MODE_PRIVATE).edit();\n\teditor.putString(\"et_inputText\", \"sharePreferences test\");\n\teditor.commit();\n```\n\n### SharedPreferences读取\n\n```\n\tSharedPreferences sp = getSharedPreferences(\"data\", MODE_PRIVATE);\n\tString input = sp.getString(\"et_inputText\", \"请输入用户名\");//第二个参数是为空的默认信息\n```\n\n## SQLite数据库存储\n\nsqlite文件默认放在/data/data/<packagename>/datanases/目录下\n\n```\npublic class MyDataBaseHelper extends SQLiteOpenHelper{\n\tprivate static final String CREATE_BOOK = \"create table Book(id integer primary key autoincrement, author text, price real, pages integer, name text)\";\n\tprivate static final String CREATE_CATEGORY = \"create table Category(id integer primary key autoincrement, category_name text, category_code integer)\";\n\tprivate Context mContext;\n\tpublic MyDataBaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version){\n\t\tsuper(context, name, factory, version);\n\t\tmContext = context;\n\t}\n\t@Override\n\tpublic void onCreate(SQLiteDatabase db){\n\t\tdb.execSQL(CREATE_BOOK);\n\t\tdb.execSQL(CREATE_CATEGORY);\n\t\tToast.makeText(mContext, \"create succeed\", Toast.LENGTH_SHORT).show();\n\t}\n\t@Override\n\tpublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion){\n\t\tdb.execSQL(\"drop table if exists Book\");\n\t\tdb.execSQL(\"drop table if exists Category\");\n\t\tonCreate(db);\n\t}\n}\n```\n\n### 创建数据库\n\n```\n\tdbHelper = new MyDataBaseHelper(this, \"BookStore.db\", null, 2);\n```\n\n\n### 插入数据\n\n```\n\tSQLiteDatabase db = dbHelper.getWritableDatabase();\n\tContentValues values = new ContentValues();\n\tvalues.put(\"name\", \"Effective Java\");\n\tvalues.put(\"author\", \"Joshua Bloch\");\n\tvalues.put(\"pages\", 454);\n\tvalues.put(\"price\", 16.96);\n\tdb.insert(\"Book\", null, values);\n```\n\n### 更新数据\n\n```\n\tContentValues values = new ContentValues();\n\tvalues.put(\"price\", 198.00);\n\tSQLiteDatabase db = dbHelper.getReadableDatabase();\n\tdb.updata(\"Book\", values, \"name=?\",new String[]{'Android Programme'});\n```\n\n### 删除行\n\n```\n\tSQLiteDatabase db = dbHelper.getWritableDatabase();\n\tdb.delete(\"Book\", \"pages > ?\", new String[]{\"500\"});\n```","source":"_posts/android持久化存储.md","raw":"---\ntitle: android持久化存储\ndate: 2018-01-03 14:57:26\ntags: android\n---\n\n# 内部存储（internalStorage）\n\ndata文件夹就是我们常说的内部存储，其中有两个文件夹需要关注，一个是app文件夹，一个是data文件夹。\n\n## app文件夹\n\napp文件夹里存放着我们所有安装的app的apk文件。\n\n## data文件夹\n\n这个文件夹里面都是一些包名，打开这些包名会看到：\n\n1. data/data/包名/shared_prefs\n2. data/data/包名/databases\n3. data/data/包名/files\n4. data/data/包名/cache\n\nsharedPreferenced的时候，数据持久化存储于本地，其实就是存在这个文件中的xml文件里面。\n数据库文件就是存储于databases文件夹中。\n普通数据存储在files中。\n缓存文件存储在cache文件夹中。\n\n\n# 外部存储（externalStorage）\n\n外部存储是我们平时操作最多的，外部存储一般就是我们看到的storage文件夹，当然也有mnt文件夹，不同厂家有可能不一样。\n一般来讲storage文件夹中有一个sdcard文件夹，这个文件夹中的文件又分为两类，一类是公有目录，一类是私有目录。公有目录又分为九大类，比如说DCIM、DOWNLOAD等这种系统为我们创建的文件夹。私有目录就是android这种文件夹，这个文件夹打开之后里面有一个data文件夹，打开这个data文件夹，里面有许多包名组成的文件夹。\n\n# 存储操作\n\n## 文件存储\n\n文件存储的所有文件默认放在/data/data/<packagename>/file/目录下\n\n### 文件写入\n\n```\npublic void save(String inputText){\n\tFIleOutputStream out = null;\n\tBufferedWriter writer = null;\n\ttry{\n\t\tout = openFileOutput(\"data\", Context.MODE_PRIVATE);\n\t\twriter = new BufferedWriter(new OutputStreamWriter(out));\n\t\twriter.write(inputText);\n\t}catch(FileNotFoundException e){\n\t\te.printStackTrace();\n\t}catch(IOException e){\n\t\te.printStackTrace();\n\t}finally{\n\t\tif(writer != null){\n\t\t\ttry{\n\t\t\t\twriter.close();\n\t\t\t}catch(IOException e){\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### 文件读取\n\n```\npublic String load(){\n\tFileInputStream in = null;\n\tBufferedReader reader = null;\n\tStringBuilder content = new StringBuilder();\n\ttry{\n\t\tin = openFileInput(\"data\");\n\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\tString line = \"\";\n\t\twhile((line = reader.readLine()) != null){\n\t\t\tcontent.append(line);\n\t\t}\n\t}catch(FileNotFoundException e){\n\t\te.printStackTrace();\n\t}catch(IOException e){\n\t\te.printStackTrace();\n\t}finally{\n\t\tif(reader != null){\n\t\t\ttry{\n\t\t\t\treader.close();\n\t\t\t}catch(IOException e){\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\treturn content.toString();\n}\n```\n\n## SharePreferences\n\nSharepreference默认放在/data/data/<packagename>/file/目录下\n\n### SharedPreferences写入\n\n```\n\tSharedPreferences.Editor editor = getSharedPreferences(\"data\", MODE_PRIVATE).edit();\n\teditor.putString(\"et_inputText\", \"sharePreferences test\");\n\teditor.commit();\n```\n\n### SharedPreferences读取\n\n```\n\tSharedPreferences sp = getSharedPreferences(\"data\", MODE_PRIVATE);\n\tString input = sp.getString(\"et_inputText\", \"请输入用户名\");//第二个参数是为空的默认信息\n```\n\n## SQLite数据库存储\n\nsqlite文件默认放在/data/data/<packagename>/datanases/目录下\n\n```\npublic class MyDataBaseHelper extends SQLiteOpenHelper{\n\tprivate static final String CREATE_BOOK = \"create table Book(id integer primary key autoincrement, author text, price real, pages integer, name text)\";\n\tprivate static final String CREATE_CATEGORY = \"create table Category(id integer primary key autoincrement, category_name text, category_code integer)\";\n\tprivate Context mContext;\n\tpublic MyDataBaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version){\n\t\tsuper(context, name, factory, version);\n\t\tmContext = context;\n\t}\n\t@Override\n\tpublic void onCreate(SQLiteDatabase db){\n\t\tdb.execSQL(CREATE_BOOK);\n\t\tdb.execSQL(CREATE_CATEGORY);\n\t\tToast.makeText(mContext, \"create succeed\", Toast.LENGTH_SHORT).show();\n\t}\n\t@Override\n\tpublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion){\n\t\tdb.execSQL(\"drop table if exists Book\");\n\t\tdb.execSQL(\"drop table if exists Category\");\n\t\tonCreate(db);\n\t}\n}\n```\n\n### 创建数据库\n\n```\n\tdbHelper = new MyDataBaseHelper(this, \"BookStore.db\", null, 2);\n```\n\n\n### 插入数据\n\n```\n\tSQLiteDatabase db = dbHelper.getWritableDatabase();\n\tContentValues values = new ContentValues();\n\tvalues.put(\"name\", \"Effective Java\");\n\tvalues.put(\"author\", \"Joshua Bloch\");\n\tvalues.put(\"pages\", 454);\n\tvalues.put(\"price\", 16.96);\n\tdb.insert(\"Book\", null, values);\n```\n\n### 更新数据\n\n```\n\tContentValues values = new ContentValues();\n\tvalues.put(\"price\", 198.00);\n\tSQLiteDatabase db = dbHelper.getReadableDatabase();\n\tdb.updata(\"Book\", values, \"name=?\",new String[]{'Android Programme'});\n```\n\n### 删除行\n\n```\n\tSQLiteDatabase db = dbHelper.getWritableDatabase();\n\tdb.delete(\"Book\", \"pages > ?\", new String[]{\"500\"});\n```","slug":"android持久化存储","published":1,"updated":"2018-01-09T03:00:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7fa20008d41imv8wkd46","content":"<h1 id=\"内部存储（internalStorage）\"><a href=\"#内部存储（internalStorage）\" class=\"headerlink\" title=\"内部存储（internalStorage）\"></a>内部存储（internalStorage）</h1><p>data文件夹就是我们常说的内部存储，其中有两个文件夹需要关注，一个是app文件夹，一个是data文件夹。</p>\n<h2 id=\"app文件夹\"><a href=\"#app文件夹\" class=\"headerlink\" title=\"app文件夹\"></a>app文件夹</h2><p>app文件夹里存放着我们所有安装的app的apk文件。</p>\n<h2 id=\"data文件夹\"><a href=\"#data文件夹\" class=\"headerlink\" title=\"data文件夹\"></a>data文件夹</h2><p>这个文件夹里面都是一些包名，打开这些包名会看到：</p>\n<ol>\n<li>data/data/包名/shared_prefs</li>\n<li>data/data/包名/databases</li>\n<li>data/data/包名/files</li>\n<li>data/data/包名/cache</li>\n</ol>\n<p>sharedPreferenced的时候，数据持久化存储于本地，其实就是存在这个文件中的xml文件里面。<br>数据库文件就是存储于databases文件夹中。<br>普通数据存储在files中。<br>缓存文件存储在cache文件夹中。</p>\n<h1 id=\"外部存储（externalStorage）\"><a href=\"#外部存储（externalStorage）\" class=\"headerlink\" title=\"外部存储（externalStorage）\"></a>外部存储（externalStorage）</h1><p>外部存储是我们平时操作最多的，外部存储一般就是我们看到的storage文件夹，当然也有mnt文件夹，不同厂家有可能不一样。<br>一般来讲storage文件夹中有一个sdcard文件夹，这个文件夹中的文件又分为两类，一类是公有目录，一类是私有目录。公有目录又分为九大类，比如说DCIM、DOWNLOAD等这种系统为我们创建的文件夹。私有目录就是android这种文件夹，这个文件夹打开之后里面有一个data文件夹，打开这个data文件夹，里面有许多包名组成的文件夹。</p>\n<h1 id=\"存储操作\"><a href=\"#存储操作\" class=\"headerlink\" title=\"存储操作\"></a>存储操作</h1><h2 id=\"文件存储\"><a href=\"#文件存储\" class=\"headerlink\" title=\"文件存储\"></a>文件存储</h2><p>文件存储的所有文件默认放在/data/data/<packagename>/file/目录下</packagename></p>\n<h3 id=\"文件写入\"><a href=\"#文件写入\" class=\"headerlink\" title=\"文件写入\"></a>文件写入</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void save(String inputText)&#123;</span><br><span class=\"line\">\tFIleOutputStream out = null;</span><br><span class=\"line\">\tBufferedWriter writer = null;</span><br><span class=\"line\">\ttry&#123;</span><br><span class=\"line\">\t\tout = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE);</span><br><span class=\"line\">\t\twriter = new BufferedWriter(new OutputStreamWriter(out));</span><br><span class=\"line\">\t\twriter.write(inputText);</span><br><span class=\"line\">\t&#125;catch(FileNotFoundException e)&#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;catch(IOException e)&#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;finally&#123;</span><br><span class=\"line\">\t\tif(writer != null)&#123;</span><br><span class=\"line\">\t\t\ttry&#123;</span><br><span class=\"line\">\t\t\t\twriter.close();</span><br><span class=\"line\">\t\t\t&#125;catch(IOException e)&#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"文件读取\"><a href=\"#文件读取\" class=\"headerlink\" title=\"文件读取\"></a>文件读取</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String load()&#123;</span><br><span class=\"line\">\tFileInputStream in = null;</span><br><span class=\"line\">\tBufferedReader reader = null;</span><br><span class=\"line\">\tStringBuilder content = new StringBuilder();</span><br><span class=\"line\">\ttry&#123;</span><br><span class=\"line\">\t\tin = openFileInput(&quot;data&quot;);</span><br><span class=\"line\">\t\treader = new BufferedReader(new InputStreamReader(in));</span><br><span class=\"line\">\t\tString line = &quot;&quot;;</span><br><span class=\"line\">\t\twhile((line = reader.readLine()) != null)&#123;</span><br><span class=\"line\">\t\t\tcontent.append(line);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;catch(FileNotFoundException e)&#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;catch(IOException e)&#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;finally&#123;</span><br><span class=\"line\">\t\tif(reader != null)&#123;</span><br><span class=\"line\">\t\t\ttry&#123;</span><br><span class=\"line\">\t\t\t\treader.close();</span><br><span class=\"line\">\t\t\t&#125;catch(IOException e)&#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn content.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"SharePreferences\"><a href=\"#SharePreferences\" class=\"headerlink\" title=\"SharePreferences\"></a>SharePreferences</h2><p>Sharepreference默认放在/data/data/<packagename>/file/目录下</packagename></p>\n<h3 id=\"SharedPreferences写入\"><a href=\"#SharedPreferences写入\" class=\"headerlink\" title=\"SharedPreferences写入\"></a>SharedPreferences写入</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SharedPreferences.Editor editor = getSharedPreferences(&quot;data&quot;, MODE_PRIVATE).edit();</span><br><span class=\"line\">editor.putString(&quot;et_inputText&quot;, &quot;sharePreferences test&quot;);</span><br><span class=\"line\">editor.commit();</span><br></pre></td></tr></table></figure>\n<h3 id=\"SharedPreferences读取\"><a href=\"#SharedPreferences读取\" class=\"headerlink\" title=\"SharedPreferences读取\"></a>SharedPreferences读取</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SharedPreferences sp = getSharedPreferences(&quot;data&quot;, MODE_PRIVATE);</span><br><span class=\"line\">String input = sp.getString(&quot;et_inputText&quot;, &quot;请输入用户名&quot;);//第二个参数是为空的默认信息</span><br></pre></td></tr></table></figure>\n<h2 id=\"SQLite数据库存储\"><a href=\"#SQLite数据库存储\" class=\"headerlink\" title=\"SQLite数据库存储\"></a>SQLite数据库存储</h2><p>sqlite文件默认放在/data/data/<packagename>/datanases/目录下</packagename></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyDataBaseHelper extends SQLiteOpenHelper&#123;</span><br><span class=\"line\">\tprivate static final String CREATE_BOOK = &quot;create table Book(id integer primary key autoincrement, author text, price real, pages integer, name text)&quot;;</span><br><span class=\"line\">\tprivate static final String CREATE_CATEGORY = &quot;create table Category(id integer primary key autoincrement, category_name text, category_code integer)&quot;;</span><br><span class=\"line\">\tprivate Context mContext;</span><br><span class=\"line\">\tpublic MyDataBaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version)&#123;</span><br><span class=\"line\">\t\tsuper(context, name, factory, version);</span><br><span class=\"line\">\t\tmContext = context;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onCreate(SQLiteDatabase db)&#123;</span><br><span class=\"line\">\t\tdb.execSQL(CREATE_BOOK);</span><br><span class=\"line\">\t\tdb.execSQL(CREATE_CATEGORY);</span><br><span class=\"line\">\t\tToast.makeText(mContext, &quot;create succeed&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)&#123;</span><br><span class=\"line\">\t\tdb.execSQL(&quot;drop table if exists Book&quot;);</span><br><span class=\"line\">\t\tdb.execSQL(&quot;drop table if exists Category&quot;);</span><br><span class=\"line\">\t\tonCreate(db);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dbHelper = new MyDataBaseHelper(this, &quot;BookStore.db&quot;, null, 2);</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class=\"line\">ContentValues values = new ContentValues();</span><br><span class=\"line\">values.put(&quot;name&quot;, &quot;Effective Java&quot;);</span><br><span class=\"line\">values.put(&quot;author&quot;, &quot;Joshua Bloch&quot;);</span><br><span class=\"line\">values.put(&quot;pages&quot;, 454);</span><br><span class=\"line\">values.put(&quot;price&quot;, 16.96);</span><br><span class=\"line\">db.insert(&quot;Book&quot;, null, values);</span><br></pre></td></tr></table></figure>\n<h3 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ContentValues values = new ContentValues();</span><br><span class=\"line\">values.put(&quot;price&quot;, 198.00);</span><br><span class=\"line\">SQLiteDatabase db = dbHelper.getReadableDatabase();</span><br><span class=\"line\">db.updata(&quot;Book&quot;, values, &quot;name=?&quot;,new String[]&#123;&apos;Android Programme&apos;&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除行\"><a href=\"#删除行\" class=\"headerlink\" title=\"删除行\"></a>删除行</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class=\"line\">db.delete(&quot;Book&quot;, &quot;pages &gt; ?&quot;, new String[]&#123;&quot;500&quot;&#125;);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"内部存储（internalStorage）\"><a href=\"#内部存储（internalStorage）\" class=\"headerlink\" title=\"内部存储（internalStorage）\"></a>内部存储（internalStorage）</h1><p>data文件夹就是我们常说的内部存储，其中有两个文件夹需要关注，一个是app文件夹，一个是data文件夹。</p>\n<h2 id=\"app文件夹\"><a href=\"#app文件夹\" class=\"headerlink\" title=\"app文件夹\"></a>app文件夹</h2><p>app文件夹里存放着我们所有安装的app的apk文件。</p>\n<h2 id=\"data文件夹\"><a href=\"#data文件夹\" class=\"headerlink\" title=\"data文件夹\"></a>data文件夹</h2><p>这个文件夹里面都是一些包名，打开这些包名会看到：</p>\n<ol>\n<li>data/data/包名/shared_prefs</li>\n<li>data/data/包名/databases</li>\n<li>data/data/包名/files</li>\n<li>data/data/包名/cache</li>\n</ol>\n<p>sharedPreferenced的时候，数据持久化存储于本地，其实就是存在这个文件中的xml文件里面。<br>数据库文件就是存储于databases文件夹中。<br>普通数据存储在files中。<br>缓存文件存储在cache文件夹中。</p>\n<h1 id=\"外部存储（externalStorage）\"><a href=\"#外部存储（externalStorage）\" class=\"headerlink\" title=\"外部存储（externalStorage）\"></a>外部存储（externalStorage）</h1><p>外部存储是我们平时操作最多的，外部存储一般就是我们看到的storage文件夹，当然也有mnt文件夹，不同厂家有可能不一样。<br>一般来讲storage文件夹中有一个sdcard文件夹，这个文件夹中的文件又分为两类，一类是公有目录，一类是私有目录。公有目录又分为九大类，比如说DCIM、DOWNLOAD等这种系统为我们创建的文件夹。私有目录就是android这种文件夹，这个文件夹打开之后里面有一个data文件夹，打开这个data文件夹，里面有许多包名组成的文件夹。</p>\n<h1 id=\"存储操作\"><a href=\"#存储操作\" class=\"headerlink\" title=\"存储操作\"></a>存储操作</h1><h2 id=\"文件存储\"><a href=\"#文件存储\" class=\"headerlink\" title=\"文件存储\"></a>文件存储</h2><p>文件存储的所有文件默认放在/data/data/<packagename>/file/目录下</packagename></p>\n<h3 id=\"文件写入\"><a href=\"#文件写入\" class=\"headerlink\" title=\"文件写入\"></a>文件写入</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void save(String inputText)&#123;</span><br><span class=\"line\">\tFIleOutputStream out = null;</span><br><span class=\"line\">\tBufferedWriter writer = null;</span><br><span class=\"line\">\ttry&#123;</span><br><span class=\"line\">\t\tout = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE);</span><br><span class=\"line\">\t\twriter = new BufferedWriter(new OutputStreamWriter(out));</span><br><span class=\"line\">\t\twriter.write(inputText);</span><br><span class=\"line\">\t&#125;catch(FileNotFoundException e)&#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;catch(IOException e)&#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;finally&#123;</span><br><span class=\"line\">\t\tif(writer != null)&#123;</span><br><span class=\"line\">\t\t\ttry&#123;</span><br><span class=\"line\">\t\t\t\twriter.close();</span><br><span class=\"line\">\t\t\t&#125;catch(IOException e)&#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"文件读取\"><a href=\"#文件读取\" class=\"headerlink\" title=\"文件读取\"></a>文件读取</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String load()&#123;</span><br><span class=\"line\">\tFileInputStream in = null;</span><br><span class=\"line\">\tBufferedReader reader = null;</span><br><span class=\"line\">\tStringBuilder content = new StringBuilder();</span><br><span class=\"line\">\ttry&#123;</span><br><span class=\"line\">\t\tin = openFileInput(&quot;data&quot;);</span><br><span class=\"line\">\t\treader = new BufferedReader(new InputStreamReader(in));</span><br><span class=\"line\">\t\tString line = &quot;&quot;;</span><br><span class=\"line\">\t\twhile((line = reader.readLine()) != null)&#123;</span><br><span class=\"line\">\t\t\tcontent.append(line);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;catch(FileNotFoundException e)&#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;catch(IOException e)&#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;finally&#123;</span><br><span class=\"line\">\t\tif(reader != null)&#123;</span><br><span class=\"line\">\t\t\ttry&#123;</span><br><span class=\"line\">\t\t\t\treader.close();</span><br><span class=\"line\">\t\t\t&#125;catch(IOException e)&#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn content.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"SharePreferences\"><a href=\"#SharePreferences\" class=\"headerlink\" title=\"SharePreferences\"></a>SharePreferences</h2><p>Sharepreference默认放在/data/data/<packagename>/file/目录下</packagename></p>\n<h3 id=\"SharedPreferences写入\"><a href=\"#SharedPreferences写入\" class=\"headerlink\" title=\"SharedPreferences写入\"></a>SharedPreferences写入</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SharedPreferences.Editor editor = getSharedPreferences(&quot;data&quot;, MODE_PRIVATE).edit();</span><br><span class=\"line\">editor.putString(&quot;et_inputText&quot;, &quot;sharePreferences test&quot;);</span><br><span class=\"line\">editor.commit();</span><br></pre></td></tr></table></figure>\n<h3 id=\"SharedPreferences读取\"><a href=\"#SharedPreferences读取\" class=\"headerlink\" title=\"SharedPreferences读取\"></a>SharedPreferences读取</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SharedPreferences sp = getSharedPreferences(&quot;data&quot;, MODE_PRIVATE);</span><br><span class=\"line\">String input = sp.getString(&quot;et_inputText&quot;, &quot;请输入用户名&quot;);//第二个参数是为空的默认信息</span><br></pre></td></tr></table></figure>\n<h2 id=\"SQLite数据库存储\"><a href=\"#SQLite数据库存储\" class=\"headerlink\" title=\"SQLite数据库存储\"></a>SQLite数据库存储</h2><p>sqlite文件默认放在/data/data/<packagename>/datanases/目录下</packagename></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyDataBaseHelper extends SQLiteOpenHelper&#123;</span><br><span class=\"line\">\tprivate static final String CREATE_BOOK = &quot;create table Book(id integer primary key autoincrement, author text, price real, pages integer, name text)&quot;;</span><br><span class=\"line\">\tprivate static final String CREATE_CATEGORY = &quot;create table Category(id integer primary key autoincrement, category_name text, category_code integer)&quot;;</span><br><span class=\"line\">\tprivate Context mContext;</span><br><span class=\"line\">\tpublic MyDataBaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version)&#123;</span><br><span class=\"line\">\t\tsuper(context, name, factory, version);</span><br><span class=\"line\">\t\tmContext = context;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onCreate(SQLiteDatabase db)&#123;</span><br><span class=\"line\">\t\tdb.execSQL(CREATE_BOOK);</span><br><span class=\"line\">\t\tdb.execSQL(CREATE_CATEGORY);</span><br><span class=\"line\">\t\tToast.makeText(mContext, &quot;create succeed&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)&#123;</span><br><span class=\"line\">\t\tdb.execSQL(&quot;drop table if exists Book&quot;);</span><br><span class=\"line\">\t\tdb.execSQL(&quot;drop table if exists Category&quot;);</span><br><span class=\"line\">\t\tonCreate(db);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dbHelper = new MyDataBaseHelper(this, &quot;BookStore.db&quot;, null, 2);</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class=\"line\">ContentValues values = new ContentValues();</span><br><span class=\"line\">values.put(&quot;name&quot;, &quot;Effective Java&quot;);</span><br><span class=\"line\">values.put(&quot;author&quot;, &quot;Joshua Bloch&quot;);</span><br><span class=\"line\">values.put(&quot;pages&quot;, 454);</span><br><span class=\"line\">values.put(&quot;price&quot;, 16.96);</span><br><span class=\"line\">db.insert(&quot;Book&quot;, null, values);</span><br></pre></td></tr></table></figure>\n<h3 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ContentValues values = new ContentValues();</span><br><span class=\"line\">values.put(&quot;price&quot;, 198.00);</span><br><span class=\"line\">SQLiteDatabase db = dbHelper.getReadableDatabase();</span><br><span class=\"line\">db.updata(&quot;Book&quot;, values, &quot;name=?&quot;,new String[]&#123;&apos;Android Programme&apos;&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除行\"><a href=\"#删除行\" class=\"headerlink\" title=\"删除行\"></a>删除行</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class=\"line\">db.delete(&quot;Book&quot;, &quot;pages &gt; ?&quot;, new String[]&#123;&quot;500&quot;&#125;);</span><br></pre></td></tr></table></figure>"},{"title":"2018第二周工作小结","date":"2018-01-14T14:15:58.000Z","_content":"\n这周的工作小结拖到了周末才写，不过还是写一下吧。\n\n这周的主要工作还是搞那个williamchart的图表，解决了数据填充的问题，中间组件传输仍然是使用了eventbus来传输。\n\n一个技术难点突破是，在响应式中做上游下游的响应操作，这次主要是了解了rxjava的map和flatmap的差别。map主要是直接将第一个参数传到下游，这有一个问题，就是假如上游是一个observable，那仍然会传一个observable。因此map的使用场景主要是用在由上游传递一些固定参数的。flatmap则是可以将上游的observable进行转换，将observable获得的东西传到下游。\n\n除此之外还学到一个就是emitter，这个可以控制下游的生命周期，但是只可以控制onnext和oncomplete。但是忽略了这点会导致oncomplete无法执行。\n\n大概就是学了上面两个技术点，其余大部分时间用于处理graphq的语句，返回数值的处理了，没想到居然用了一周的时间。不过周五请假也算就用了四天。\n\n之后的任务，数据是好了，但是需要改ui了，点击的ui要改，滑动曲线的ui也要改，还有一些杂七杂八的ui。\n\n给自己定了3天的工作计划，希望周三晚上能处理完毕吧。\n\n这周开始给自己打分，以后每周都是周日开始写本周总结，并且定下下周的任务，之后按照下周的任务完成度来给自己打分。\n\n本周开始的话，那我给上周打个98分吧，少两分怕自己骄傲～","source":"_posts/2018第二周工作小结.md","raw":"---\ntitle: 2018第二周工作小结\ndate: 2018-01-14 22:15:58\ntags: 工作小结\n---\n\n这周的工作小结拖到了周末才写，不过还是写一下吧。\n\n这周的主要工作还是搞那个williamchart的图表，解决了数据填充的问题，中间组件传输仍然是使用了eventbus来传输。\n\n一个技术难点突破是，在响应式中做上游下游的响应操作，这次主要是了解了rxjava的map和flatmap的差别。map主要是直接将第一个参数传到下游，这有一个问题，就是假如上游是一个observable，那仍然会传一个observable。因此map的使用场景主要是用在由上游传递一些固定参数的。flatmap则是可以将上游的observable进行转换，将observable获得的东西传到下游。\n\n除此之外还学到一个就是emitter，这个可以控制下游的生命周期，但是只可以控制onnext和oncomplete。但是忽略了这点会导致oncomplete无法执行。\n\n大概就是学了上面两个技术点，其余大部分时间用于处理graphq的语句，返回数值的处理了，没想到居然用了一周的时间。不过周五请假也算就用了四天。\n\n之后的任务，数据是好了，但是需要改ui了，点击的ui要改，滑动曲线的ui也要改，还有一些杂七杂八的ui。\n\n给自己定了3天的工作计划，希望周三晚上能处理完毕吧。\n\n这周开始给自己打分，以后每周都是周日开始写本周总结，并且定下下周的任务，之后按照下周的任务完成度来给自己打分。\n\n本周开始的话，那我给上周打个98分吧，少两分怕自己骄傲～","slug":"2018第二周工作小结","published":1,"updated":"2018-01-16T08:58:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7fa40009d41ibbncaeys","content":"<p>这周的工作小结拖到了周末才写，不过还是写一下吧。</p>\n<p>这周的主要工作还是搞那个williamchart的图表，解决了数据填充的问题，中间组件传输仍然是使用了eventbus来传输。</p>\n<p>一个技术难点突破是，在响应式中做上游下游的响应操作，这次主要是了解了rxjava的map和flatmap的差别。map主要是直接将第一个参数传到下游，这有一个问题，就是假如上游是一个observable，那仍然会传一个observable。因此map的使用场景主要是用在由上游传递一些固定参数的。flatmap则是可以将上游的observable进行转换，将observable获得的东西传到下游。</p>\n<p>除此之外还学到一个就是emitter，这个可以控制下游的生命周期，但是只可以控制onnext和oncomplete。但是忽略了这点会导致oncomplete无法执行。</p>\n<p>大概就是学了上面两个技术点，其余大部分时间用于处理graphq的语句，返回数值的处理了，没想到居然用了一周的时间。不过周五请假也算就用了四天。</p>\n<p>之后的任务，数据是好了，但是需要改ui了，点击的ui要改，滑动曲线的ui也要改，还有一些杂七杂八的ui。</p>\n<p>给自己定了3天的工作计划，希望周三晚上能处理完毕吧。</p>\n<p>这周开始给自己打分，以后每周都是周日开始写本周总结，并且定下下周的任务，之后按照下周的任务完成度来给自己打分。</p>\n<p>本周开始的话，那我给上周打个98分吧，少两分怕自己骄傲～</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这周的工作小结拖到了周末才写，不过还是写一下吧。</p>\n<p>这周的主要工作还是搞那个williamchart的图表，解决了数据填充的问题，中间组件传输仍然是使用了eventbus来传输。</p>\n<p>一个技术难点突破是，在响应式中做上游下游的响应操作，这次主要是了解了rxjava的map和flatmap的差别。map主要是直接将第一个参数传到下游，这有一个问题，就是假如上游是一个observable，那仍然会传一个observable。因此map的使用场景主要是用在由上游传递一些固定参数的。flatmap则是可以将上游的observable进行转换，将observable获得的东西传到下游。</p>\n<p>除此之外还学到一个就是emitter，这个可以控制下游的生命周期，但是只可以控制onnext和oncomplete。但是忽略了这点会导致oncomplete无法执行。</p>\n<p>大概就是学了上面两个技术点，其余大部分时间用于处理graphq的语句，返回数值的处理了，没想到居然用了一周的时间。不过周五请假也算就用了四天。</p>\n<p>之后的任务，数据是好了，但是需要改ui了，点击的ui要改，滑动曲线的ui也要改，还有一些杂七杂八的ui。</p>\n<p>给自己定了3天的工作计划，希望周三晚上能处理完毕吧。</p>\n<p>这周开始给自己打分，以后每周都是周日开始写本周总结，并且定下下周的任务，之后按照下周的任务完成度来给自己打分。</p>\n<p>本周开始的话，那我给上周打个98分吧，少两分怕自己骄傲～</p>\n"},{"title":"ios-stanford-1","date":"2017-12-31T13:44:56.000Z","_content":"\n# what‘s in iOS？\n\n## Core OS:\n\niOS基本就是一个基于Unix的操作系统，它大量借鉴了Mac OS X的内核部分。\n所以Core OS部分，包含了Sockets,Security,BSD,Mach 3.0,OSX Kernal, Power Management, Keychain Access, Certifications, File System Bonjour.这些实现一个操作系统的部分。\n\n## Core Services:\n\n这是一个能够让开发者使用大量的面向对象编程技术，但这层不包括ui，而是更多用于通过面向对象编程的方式访问硬件或者访问网络等等。我们需要耗费很多的时间，因为我们需要这些原始组件来建立更高的层。\n包括了Collections,Address Book,Networking,FileAccess, SQLite, CoreLocation,Net Services, Threading, Preferences, URL Utilities.\n\n## Media\n\nCore Audio, OpenAL, Audio Mixing, Audio Mixing, Audio Recording, Video Playback, JPEG/PNG/TIFF, PDF, Quartz(2D), Core Animation, OpenGL ES.\n\n## Cocoa Touch\n\nMulti-Touch, Alerts, Core Motion, Web View, View Hierarchy, Map kit, Localization, Image Picker, Controls, Camera\n使用这些与用户互动\n\n# MVC\n\nMVC是一种设计模式，更有利于阅读代码。而iOS从一开始就使用MVC设计，这是构建iOS的一种方法。\n\n# Demo\n\n","source":"_posts/ios-stanford-1.md","raw":"---\ntitle: ios-stanford-1\ndate: 2017-12-31 21:44:56\ntags: ios\n---\n\n# what‘s in iOS？\n\n## Core OS:\n\niOS基本就是一个基于Unix的操作系统，它大量借鉴了Mac OS X的内核部分。\n所以Core OS部分，包含了Sockets,Security,BSD,Mach 3.0,OSX Kernal, Power Management, Keychain Access, Certifications, File System Bonjour.这些实现一个操作系统的部分。\n\n## Core Services:\n\n这是一个能够让开发者使用大量的面向对象编程技术，但这层不包括ui，而是更多用于通过面向对象编程的方式访问硬件或者访问网络等等。我们需要耗费很多的时间，因为我们需要这些原始组件来建立更高的层。\n包括了Collections,Address Book,Networking,FileAccess, SQLite, CoreLocation,Net Services, Threading, Preferences, URL Utilities.\n\n## Media\n\nCore Audio, OpenAL, Audio Mixing, Audio Mixing, Audio Recording, Video Playback, JPEG/PNG/TIFF, PDF, Quartz(2D), Core Animation, OpenGL ES.\n\n## Cocoa Touch\n\nMulti-Touch, Alerts, Core Motion, Web View, View Hierarchy, Map kit, Localization, Image Picker, Controls, Camera\n使用这些与用户互动\n\n# MVC\n\nMVC是一种设计模式，更有利于阅读代码。而iOS从一开始就使用MVC设计，这是构建iOS的一种方法。\n\n# Demo\n\n","slug":"ios-stanford-1","published":1,"updated":"2018-01-09T03:00:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7fa5000bd41i8soks306","content":"<h1 id=\"what‘s-in-iOS？\"><a href=\"#what‘s-in-iOS？\" class=\"headerlink\" title=\"what‘s in iOS？\"></a>what‘s in iOS？</h1><h2 id=\"Core-OS\"><a href=\"#Core-OS\" class=\"headerlink\" title=\"Core OS:\"></a>Core OS:</h2><p>iOS基本就是一个基于Unix的操作系统，它大量借鉴了Mac OS X的内核部分。<br>所以Core OS部分，包含了Sockets,Security,BSD,Mach 3.0,OSX Kernal, Power Management, Keychain Access, Certifications, File System Bonjour.这些实现一个操作系统的部分。</p>\n<h2 id=\"Core-Services\"><a href=\"#Core-Services\" class=\"headerlink\" title=\"Core Services:\"></a>Core Services:</h2><p>这是一个能够让开发者使用大量的面向对象编程技术，但这层不包括ui，而是更多用于通过面向对象编程的方式访问硬件或者访问网络等等。我们需要耗费很多的时间，因为我们需要这些原始组件来建立更高的层。<br>包括了Collections,Address Book,Networking,FileAccess, SQLite, CoreLocation,Net Services, Threading, Preferences, URL Utilities.</p>\n<h2 id=\"Media\"><a href=\"#Media\" class=\"headerlink\" title=\"Media\"></a>Media</h2><p>Core Audio, OpenAL, Audio Mixing, Audio Mixing, Audio Recording, Video Playback, JPEG/PNG/TIFF, PDF, Quartz(2D), Core Animation, OpenGL ES.</p>\n<h2 id=\"Cocoa-Touch\"><a href=\"#Cocoa-Touch\" class=\"headerlink\" title=\"Cocoa Touch\"></a>Cocoa Touch</h2><p>Multi-Touch, Alerts, Core Motion, Web View, View Hierarchy, Map kit, Localization, Image Picker, Controls, Camera<br>使用这些与用户互动</p>\n<h1 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h1><p>MVC是一种设计模式，更有利于阅读代码。而iOS从一开始就使用MVC设计，这是构建iOS的一种方法。</p>\n<h1 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"what‘s-in-iOS？\"><a href=\"#what‘s-in-iOS？\" class=\"headerlink\" title=\"what‘s in iOS？\"></a>what‘s in iOS？</h1><h2 id=\"Core-OS\"><a href=\"#Core-OS\" class=\"headerlink\" title=\"Core OS:\"></a>Core OS:</h2><p>iOS基本就是一个基于Unix的操作系统，它大量借鉴了Mac OS X的内核部分。<br>所以Core OS部分，包含了Sockets,Security,BSD,Mach 3.0,OSX Kernal, Power Management, Keychain Access, Certifications, File System Bonjour.这些实现一个操作系统的部分。</p>\n<h2 id=\"Core-Services\"><a href=\"#Core-Services\" class=\"headerlink\" title=\"Core Services:\"></a>Core Services:</h2><p>这是一个能够让开发者使用大量的面向对象编程技术，但这层不包括ui，而是更多用于通过面向对象编程的方式访问硬件或者访问网络等等。我们需要耗费很多的时间，因为我们需要这些原始组件来建立更高的层。<br>包括了Collections,Address Book,Networking,FileAccess, SQLite, CoreLocation,Net Services, Threading, Preferences, URL Utilities.</p>\n<h2 id=\"Media\"><a href=\"#Media\" class=\"headerlink\" title=\"Media\"></a>Media</h2><p>Core Audio, OpenAL, Audio Mixing, Audio Mixing, Audio Recording, Video Playback, JPEG/PNG/TIFF, PDF, Quartz(2D), Core Animation, OpenGL ES.</p>\n<h2 id=\"Cocoa-Touch\"><a href=\"#Cocoa-Touch\" class=\"headerlink\" title=\"Cocoa Touch\"></a>Cocoa Touch</h2><p>Multi-Touch, Alerts, Core Motion, Web View, View Hierarchy, Map kit, Localization, Image Picker, Controls, Camera<br>使用这些与用户互动</p>\n<h1 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h1><p>MVC是一种设计模式，更有利于阅读代码。而iOS从一开始就使用MVC设计，这是构建iOS的一种方法。</p>\n<h1 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h1>"},{"title":"retrofit2 post","date":"2017-12-21T07:53:25.000Z","_content":"\n# retrofit的post方法\n\n## 简单的双参数上传，结果是ResponseBody\n```\n\t@FormUrlEncoded\n\t@POST(\"xxx.com\")\n\tObservable<ResponseBody> login(\n\t\t@Field(\"no\") String no,\n\t\t@Field(\"pass\") String pass);\n```\n\n## 文件上传 （ 多文件上传,使用 @PartMap Map<String, RequestBody> params 要注意在设置每一个RequestBody文件的时候，数组名不能一致，否则会覆 盖。）\n```\n\t@Multipart\n    @POST(\"xxx.com\")\n    Observable<ResponseBody> uploadFile(\n        @Part(\"file\\\"; filename=\\\"test.png\") RequestBody file\n     );\n\n```\n\n## 单文件上传\n```\n\t@Multipart\n    @POST(\"xxx.com\")\n    Observable<ResponseBody> uploadFile(\n            @Part MultipartBody.Part file );\n```\n\n## 多文件上传\n```\n\t@Multipart\n    @POST(\"xxx.com\")\n    Observable<ResponseBody> uploadFile(\n            @Part() List<MultipartBody.Part> files );\n```\n\n## 文件和参数共同上传  (参数也需要封装成MultipartBody.Part这样的类型，不然传递会出错，这个类型其实就是将这些数据封装成表单的类型，因为在这里不能使用FormUrlEncoded进行处理)\n```\n\t@Multipart\n    @POST(\"xxx.com\")\n    Observable<ResponseBody> uploadFile(\n         @Part() List<MultipartBody.Part > files );\n```","source":"_posts/retrofit2-post.md","raw":"---\ntitle: retrofit2 post\ndate: 2017-12-21 15:53:25\ntags: android\n---\n\n# retrofit的post方法\n\n## 简单的双参数上传，结果是ResponseBody\n```\n\t@FormUrlEncoded\n\t@POST(\"xxx.com\")\n\tObservable<ResponseBody> login(\n\t\t@Field(\"no\") String no,\n\t\t@Field(\"pass\") String pass);\n```\n\n## 文件上传 （ 多文件上传,使用 @PartMap Map<String, RequestBody> params 要注意在设置每一个RequestBody文件的时候，数组名不能一致，否则会覆 盖。）\n```\n\t@Multipart\n    @POST(\"xxx.com\")\n    Observable<ResponseBody> uploadFile(\n        @Part(\"file\\\"; filename=\\\"test.png\") RequestBody file\n     );\n\n```\n\n## 单文件上传\n```\n\t@Multipart\n    @POST(\"xxx.com\")\n    Observable<ResponseBody> uploadFile(\n            @Part MultipartBody.Part file );\n```\n\n## 多文件上传\n```\n\t@Multipart\n    @POST(\"xxx.com\")\n    Observable<ResponseBody> uploadFile(\n            @Part() List<MultipartBody.Part> files );\n```\n\n## 文件和参数共同上传  (参数也需要封装成MultipartBody.Part这样的类型，不然传递会出错，这个类型其实就是将这些数据封装成表单的类型，因为在这里不能使用FormUrlEncoded进行处理)\n```\n\t@Multipart\n    @POST(\"xxx.com\")\n    Observable<ResponseBody> uploadFile(\n         @Part() List<MultipartBody.Part > files );\n```","slug":"retrofit2-post","published":1,"updated":"2018-01-09T03:00:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7fa6000dd41iwkfpa0sa","content":"<h1 id=\"retrofit的post方法\"><a href=\"#retrofit的post方法\" class=\"headerlink\" title=\"retrofit的post方法\"></a>retrofit的post方法</h1><h2 id=\"简单的双参数上传，结果是ResponseBody\"><a href=\"#简单的双参数上传，结果是ResponseBody\" class=\"headerlink\" title=\"简单的双参数上传，结果是ResponseBody\"></a>简单的双参数上传，结果是ResponseBody</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FormUrlEncoded</span><br><span class=\"line\">@POST(&quot;xxx.com&quot;)</span><br><span class=\"line\">Observable&lt;ResponseBody&gt; login(</span><br><span class=\"line\">\t@Field(&quot;no&quot;) String no,</span><br><span class=\"line\">\t@Field(&quot;pass&quot;) String pass);</span><br></pre></td></tr></table></figure>\n<h2 id=\"文件上传-（-多文件上传-使用-PartMap-Map-params-要注意在设置每一个RequestBody文件的时候，数组名不能一致，否则会覆-盖。）\"><a href=\"#文件上传-（-多文件上传-使用-PartMap-Map-params-要注意在设置每一个RequestBody文件的时候，数组名不能一致，否则会覆-盖。）\" class=\"headerlink\" title=\"文件上传 （ 多文件上传,使用 @PartMap Map params 要注意在设置每一个RequestBody文件的时候，数组名不能一致，否则会覆 盖。）\"></a>文件上传 （ 多文件上传,使用 @PartMap Map<string, requestbody=\"\"> params 要注意在设置每一个RequestBody文件的时候，数组名不能一致，否则会覆 盖。）</string,></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Multipart</span><br><span class=\"line\">   @POST(&quot;xxx.com&quot;)</span><br><span class=\"line\">   Observable&lt;ResponseBody&gt; uploadFile(</span><br><span class=\"line\">       @Part(&quot;file\\&quot;; filename=\\&quot;test.png&quot;) RequestBody file</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure>\n<h2 id=\"单文件上传\"><a href=\"#单文件上传\" class=\"headerlink\" title=\"单文件上传\"></a>单文件上传</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Multipart</span><br><span class=\"line\">   @POST(&quot;xxx.com&quot;)</span><br><span class=\"line\">   Observable&lt;ResponseBody&gt; uploadFile(</span><br><span class=\"line\">           @Part MultipartBody.Part file );</span><br></pre></td></tr></table></figure>\n<h2 id=\"多文件上传\"><a href=\"#多文件上传\" class=\"headerlink\" title=\"多文件上传\"></a>多文件上传</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Multipart</span><br><span class=\"line\">   @POST(&quot;xxx.com&quot;)</span><br><span class=\"line\">   Observable&lt;ResponseBody&gt; uploadFile(</span><br><span class=\"line\">           @Part() List&lt;MultipartBody.Part&gt; files );</span><br></pre></td></tr></table></figure>\n<h2 id=\"文件和参数共同上传-参数也需要封装成MultipartBody-Part这样的类型，不然传递会出错，这个类型其实就是将这些数据封装成表单的类型，因为在这里不能使用FormUrlEncoded进行处理\"><a href=\"#文件和参数共同上传-参数也需要封装成MultipartBody-Part这样的类型，不然传递会出错，这个类型其实就是将这些数据封装成表单的类型，因为在这里不能使用FormUrlEncoded进行处理\" class=\"headerlink\" title=\"文件和参数共同上传  (参数也需要封装成MultipartBody.Part这样的类型，不然传递会出错，这个类型其实就是将这些数据封装成表单的类型，因为在这里不能使用FormUrlEncoded进行处理)\"></a>文件和参数共同上传  (参数也需要封装成MultipartBody.Part这样的类型，不然传递会出错，这个类型其实就是将这些数据封装成表单的类型，因为在这里不能使用FormUrlEncoded进行处理)</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Multipart</span><br><span class=\"line\">   @POST(&quot;xxx.com&quot;)</span><br><span class=\"line\">   Observable&lt;ResponseBody&gt; uploadFile(</span><br><span class=\"line\">        @Part() List&lt;MultipartBody.Part &gt; files );</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"retrofit的post方法\"><a href=\"#retrofit的post方法\" class=\"headerlink\" title=\"retrofit的post方法\"></a>retrofit的post方法</h1><h2 id=\"简单的双参数上传，结果是ResponseBody\"><a href=\"#简单的双参数上传，结果是ResponseBody\" class=\"headerlink\" title=\"简单的双参数上传，结果是ResponseBody\"></a>简单的双参数上传，结果是ResponseBody</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FormUrlEncoded</span><br><span class=\"line\">@POST(&quot;xxx.com&quot;)</span><br><span class=\"line\">Observable&lt;ResponseBody&gt; login(</span><br><span class=\"line\">\t@Field(&quot;no&quot;) String no,</span><br><span class=\"line\">\t@Field(&quot;pass&quot;) String pass);</span><br></pre></td></tr></table></figure>\n<h2 id=\"文件上传-（-多文件上传-使用-PartMap-Map-params-要注意在设置每一个RequestBody文件的时候，数组名不能一致，否则会覆-盖。）\"><a href=\"#文件上传-（-多文件上传-使用-PartMap-Map-params-要注意在设置每一个RequestBody文件的时候，数组名不能一致，否则会覆-盖。）\" class=\"headerlink\" title=\"文件上传 （ 多文件上传,使用 @PartMap Map params 要注意在设置每一个RequestBody文件的时候，数组名不能一致，否则会覆 盖。）\"></a>文件上传 （ 多文件上传,使用 @PartMap Map<string, requestbody=\"\"> params 要注意在设置每一个RequestBody文件的时候，数组名不能一致，否则会覆 盖。）</string,></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Multipart</span><br><span class=\"line\">   @POST(&quot;xxx.com&quot;)</span><br><span class=\"line\">   Observable&lt;ResponseBody&gt; uploadFile(</span><br><span class=\"line\">       @Part(&quot;file\\&quot;; filename=\\&quot;test.png&quot;) RequestBody file</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure>\n<h2 id=\"单文件上传\"><a href=\"#单文件上传\" class=\"headerlink\" title=\"单文件上传\"></a>单文件上传</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Multipart</span><br><span class=\"line\">   @POST(&quot;xxx.com&quot;)</span><br><span class=\"line\">   Observable&lt;ResponseBody&gt; uploadFile(</span><br><span class=\"line\">           @Part MultipartBody.Part file );</span><br></pre></td></tr></table></figure>\n<h2 id=\"多文件上传\"><a href=\"#多文件上传\" class=\"headerlink\" title=\"多文件上传\"></a>多文件上传</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Multipart</span><br><span class=\"line\">   @POST(&quot;xxx.com&quot;)</span><br><span class=\"line\">   Observable&lt;ResponseBody&gt; uploadFile(</span><br><span class=\"line\">           @Part() List&lt;MultipartBody.Part&gt; files );</span><br></pre></td></tr></table></figure>\n<h2 id=\"文件和参数共同上传-参数也需要封装成MultipartBody-Part这样的类型，不然传递会出错，这个类型其实就是将这些数据封装成表单的类型，因为在这里不能使用FormUrlEncoded进行处理\"><a href=\"#文件和参数共同上传-参数也需要封装成MultipartBody-Part这样的类型，不然传递会出错，这个类型其实就是将这些数据封装成表单的类型，因为在这里不能使用FormUrlEncoded进行处理\" class=\"headerlink\" title=\"文件和参数共同上传  (参数也需要封装成MultipartBody.Part这样的类型，不然传递会出错，这个类型其实就是将这些数据封装成表单的类型，因为在这里不能使用FormUrlEncoded进行处理)\"></a>文件和参数共同上传  (参数也需要封装成MultipartBody.Part这样的类型，不然传递会出错，这个类型其实就是将这些数据封装成表单的类型，因为在这里不能使用FormUrlEncoded进行处理)</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Multipart</span><br><span class=\"line\">   @POST(&quot;xxx.com&quot;)</span><br><span class=\"line\">   Observable&lt;ResponseBody&gt; uploadFile(</span><br><span class=\"line\">        @Part() List&lt;MultipartBody.Part &gt; files );</span><br></pre></td></tr></table></figure>"},{"title":"test appveyor","date":"2017-12-21T03:25:39.000Z","_content":"","source":"_posts/test-appveyor.md","raw":"---\ntitle: test appveyor\ndate: 2017-12-21 11:25:39\ntags: hexo\n---\n","slug":"test-appveyor","published":1,"updated":"2018-01-09T03:00:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7fac000gd41ihzdtkb3l","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"androidscroll分析笔记","date":"2018-01-13T07:42:18.000Z","_content":"\n# android坐标系\n\n在android中，将屏幕最左上角的顶点作为android坐标系的原点，往右是x轴正方向，往下是y轴正方向。\n\n# 视图坐标系\n\n视图坐标系原点以父视图左上角为坐标原点。\n\n# 触控事件 - MotionEvent\n\n```\n\tpublic static final int ACTION_DOWN = 0;//单击触摸按下动作\n\tpublic static final int ACTION_UP = 1;//单击触摸离开动作\n\tpublic static final int ACTION_MOVE = 2;//触摸点移动动作\n\tpublic static final int ACTION_CANCEL = 3;//触摸动作取消\n\tpublic static final int ACTION_OUTSIDE = 4;//触摸动作超出边界\n\tpublic static final int ACTION_POINTER_DOWN = 5;//多点触摸按下动作\n\tpublic static final int ACTION_POINTER_UP = 6;//多点离开动作\n```\n\n## ACTION_CANCEL\n\n当你的手指（或者其它）移动屏幕的时候会触发这个事件，比如当你的手指在屏幕上拖动一个listView或者一个ScrollView而不是去按上面的按钮时会触发这个事件。\n\n在设计设置页面的滑动开关时，如果不监听ACTION_CANCEL，在滑动到中间时，如果你手指上下移动，就是移动到开关控件之外，则此时会触发ACTION_CANCEL，而不是ACTION_UP，造成开关的按钮停顿在中间位置。\n\n意思就是，当用户保持按下操作，并从你的控件转移到外层控件时，会触发ACTION_CANCEL，建议进行处理～\n\n当前的手势被中断，不会再接收到关于它的记录。\n推荐将这个事件作为 ACTION_UP 来看待，但是要区别于普通的 ACTION_UP\n\n话说回来，平常还真碰不到这个事件，习惯上就直接当 ACTION_UP 处理了就\n\n例如：上层 View 是一个 RecyclerView，它收到了一个 ACTION_DOWN 事件，由于这个可能是点击事件，所以它先传递给对应 ItemView，询问 ItemView 是否需要这个事件，然而接下来又传递过来了一个 ACTION_MOVE 事件，且移动的方向和 RecyclerView 的可滑动方向一致，所以 RecyclerView 判断这个事件是滚动事件，于是要收回事件处理权，这时候对应的 ItemView 会收到一个 ACTION_CANCEL ，并且不会再收到后续事件。\n\n## ACTION_OUTSIDE\n\n一个触摸事件已经发生了UI元素的正常范围之外。因此不再提供完整的手势，只提供 运动/触摸 的初始位置。dialog,popupwindow中比较常见\n\n## ACTION_POINTER_DOWN\n\n这个代表用户的第二根手指（之后动手的一根）触摸了屏幕，可以getactionindex获取某一根手指的数字来判断\n\n## ACTION_POINTER_UP\n\n同第二根手指离开了屏幕\n\n# 获取坐标的方法\n\n## View提供的方法（以父布局为坐标系）\ngetTop():自身到其父布局顶点的距离\ngetLeft():\ngetRight():\ngetBottom():\n\n## MotionEvent提供的方法\ngetX():获取点击事件距离空间左边的距离\ngetY():\ngetRawX():获取点击事件距离整个屏幕左边的距离\ngetRawY():\n\n# 实现滑动效果的7种方法\n\n1. layout方法\n在ACTION_MOVE中计算偏移量，在action_down中记录触摸点的坐标，并且在move中进行计算偏移量，然后调用view的layout方法来进行调整。\n\n2. offsetLeftAndRight和offsetTopAndBottom\n使用方法和layout一样，差别是一个需要x的偏移一个需要y的偏移\n\n3. LayoutParams\n\nlayoutParams保留了一个view的参数，可以改变view的layoutParams然后setLayoutParams进行更改。\n\n4. scrollto和scrollby\n\nscrollby(offsetx，offsety)，该方法会造成所有子view移动。因此需要对view的父view使用这个方法，\n\n5. Scroller\n\nscroller可以通过重写view的computeScroll方法，通过获取当前滚动值，来进行不断的瞬间移动，实现整体上的平移效果\nps：computeScroll方法是不会自动调用的，只能通过invalidate() -> draw() -> computeScroll()来间接调用该方法。\n之后使用startScroll即可。\n\n6. 属性动画\n\n7. ViewDragHelper\n\nviewdraghelper是谷歌在support库中提供的drawerlayout和slidingpanelayout两个布局中使用的，用法较为复杂。\n\n1. 初始化viewdraghelper\n\n```\n\tmViewDragHelper = ViewDragHelper.create(this, callback);\n```\n\n2. 拦截事件\n\n将事件传递给viewdraghelper处理\n```\n\t@Override\n\tpublic boolean onInterceptTouchEvent(MotionEvent ev){\n\t\treturn mViewDragHelper.shouldInterceptTouchEvent(ev);\n\t}\n\t@Override\n\tpublic boolean onTouchEvent(MotionEvent ev){\n\t\tmViewDragHelper.processTouchEvent(event);\n\t\treturn true;\n\t}\n```\n\n3. 处理computeScroll()\n\n与scroller相似的，需要处理一个computescroll()方法，因为viewdraghelper内部也是使用scroller实现平滑移动的。\n\n```\n\t@Override\n\tpublic void computeScroll(){\n\t\tif(mViewdragHelper.continueSettling(true)){\n\t\t\tViewCompat.postInvalidateOnAnimation(this);\n\t\t}\n\t}\n```\n\n4. 处理回调\n\n```\n\tprivate ViewDragHelper.Callback callback = new ViewDragHelper.Callback(){\n\t\t@Override\n\t\tpublic boolean tryCaptureView(View child, int pointerId){\n\t\t\treturn false;\n\t\t}\n\t}\n```\n使用上述回调，对child进行判断，如果是需要拖动view，就可以返回true\n\n```\n\t@Override\n\tpublic int clampViewPositionVertical(View child, int top, int dy){\n\t\treturn top;\n\t}\n\t@Override\n\tpublic int clampViewPositionHorizontal(View child, int left, int dx){\n\t\treturn left;\n\t}\n```\n\n使用如上方法，来对滑动效果进行设置，返回的top和left为垂直和水平方向上面的距离。dy表示比较前一次的增量\n\n5. 拖动结束之后，子View回到原来的位置\n\n该效果可以通过监听action_up事件，并通过调用Scroller类来实现。\n在viewdraghelper中可以重写onViewRelased()方法来实现。\n\n```\n\t@Override\n\tpublic void onViewReleased(View releasedChild, float xvel, float yvel){\n\t\tsuper.onViewReleased(releasedChild, xvel, yvel);\n\t\tif(mMianView.getLeft()<500){\n\t\t\tmViewDragHelper.smoothSlideViewTo(mMainView, 0, 0);\n\t\t\tViewCompat.postInvalidateOnAnimation(DragViewGroup.this);\n\t\t}else{\n\t\t\tmViewDragHelper.smoothSlideViewTo(mMainView, 300, 0);\n\t\t\tViewCompat.postInvalidateOnAnimation(DragViewGroup.this);\n\t\t}\n\t}\n```\n\n这样就可以做到滑动距离小于500时回到原来的位置。\n\n除了以上内容，还有大量的监听事件可以用来处理各种事件。\nonViewCaptured():在用户触摸到view后回调\nonViewDragStateChanged():在拖拽状态改变时回调\nonViewPositionChanged():这个事件在位置改变时回调","source":"_posts/androidscroll分析笔记.md","raw":"---\ntitle: androidscroll分析笔记\ndate: 2018-01-13 15:42:18\ntags: android\n---\n\n# android坐标系\n\n在android中，将屏幕最左上角的顶点作为android坐标系的原点，往右是x轴正方向，往下是y轴正方向。\n\n# 视图坐标系\n\n视图坐标系原点以父视图左上角为坐标原点。\n\n# 触控事件 - MotionEvent\n\n```\n\tpublic static final int ACTION_DOWN = 0;//单击触摸按下动作\n\tpublic static final int ACTION_UP = 1;//单击触摸离开动作\n\tpublic static final int ACTION_MOVE = 2;//触摸点移动动作\n\tpublic static final int ACTION_CANCEL = 3;//触摸动作取消\n\tpublic static final int ACTION_OUTSIDE = 4;//触摸动作超出边界\n\tpublic static final int ACTION_POINTER_DOWN = 5;//多点触摸按下动作\n\tpublic static final int ACTION_POINTER_UP = 6;//多点离开动作\n```\n\n## ACTION_CANCEL\n\n当你的手指（或者其它）移动屏幕的时候会触发这个事件，比如当你的手指在屏幕上拖动一个listView或者一个ScrollView而不是去按上面的按钮时会触发这个事件。\n\n在设计设置页面的滑动开关时，如果不监听ACTION_CANCEL，在滑动到中间时，如果你手指上下移动，就是移动到开关控件之外，则此时会触发ACTION_CANCEL，而不是ACTION_UP，造成开关的按钮停顿在中间位置。\n\n意思就是，当用户保持按下操作，并从你的控件转移到外层控件时，会触发ACTION_CANCEL，建议进行处理～\n\n当前的手势被中断，不会再接收到关于它的记录。\n推荐将这个事件作为 ACTION_UP 来看待，但是要区别于普通的 ACTION_UP\n\n话说回来，平常还真碰不到这个事件，习惯上就直接当 ACTION_UP 处理了就\n\n例如：上层 View 是一个 RecyclerView，它收到了一个 ACTION_DOWN 事件，由于这个可能是点击事件，所以它先传递给对应 ItemView，询问 ItemView 是否需要这个事件，然而接下来又传递过来了一个 ACTION_MOVE 事件，且移动的方向和 RecyclerView 的可滑动方向一致，所以 RecyclerView 判断这个事件是滚动事件，于是要收回事件处理权，这时候对应的 ItemView 会收到一个 ACTION_CANCEL ，并且不会再收到后续事件。\n\n## ACTION_OUTSIDE\n\n一个触摸事件已经发生了UI元素的正常范围之外。因此不再提供完整的手势，只提供 运动/触摸 的初始位置。dialog,popupwindow中比较常见\n\n## ACTION_POINTER_DOWN\n\n这个代表用户的第二根手指（之后动手的一根）触摸了屏幕，可以getactionindex获取某一根手指的数字来判断\n\n## ACTION_POINTER_UP\n\n同第二根手指离开了屏幕\n\n# 获取坐标的方法\n\n## View提供的方法（以父布局为坐标系）\ngetTop():自身到其父布局顶点的距离\ngetLeft():\ngetRight():\ngetBottom():\n\n## MotionEvent提供的方法\ngetX():获取点击事件距离空间左边的距离\ngetY():\ngetRawX():获取点击事件距离整个屏幕左边的距离\ngetRawY():\n\n# 实现滑动效果的7种方法\n\n1. layout方法\n在ACTION_MOVE中计算偏移量，在action_down中记录触摸点的坐标，并且在move中进行计算偏移量，然后调用view的layout方法来进行调整。\n\n2. offsetLeftAndRight和offsetTopAndBottom\n使用方法和layout一样，差别是一个需要x的偏移一个需要y的偏移\n\n3. LayoutParams\n\nlayoutParams保留了一个view的参数，可以改变view的layoutParams然后setLayoutParams进行更改。\n\n4. scrollto和scrollby\n\nscrollby(offsetx，offsety)，该方法会造成所有子view移动。因此需要对view的父view使用这个方法，\n\n5. Scroller\n\nscroller可以通过重写view的computeScroll方法，通过获取当前滚动值，来进行不断的瞬间移动，实现整体上的平移效果\nps：computeScroll方法是不会自动调用的，只能通过invalidate() -> draw() -> computeScroll()来间接调用该方法。\n之后使用startScroll即可。\n\n6. 属性动画\n\n7. ViewDragHelper\n\nviewdraghelper是谷歌在support库中提供的drawerlayout和slidingpanelayout两个布局中使用的，用法较为复杂。\n\n1. 初始化viewdraghelper\n\n```\n\tmViewDragHelper = ViewDragHelper.create(this, callback);\n```\n\n2. 拦截事件\n\n将事件传递给viewdraghelper处理\n```\n\t@Override\n\tpublic boolean onInterceptTouchEvent(MotionEvent ev){\n\t\treturn mViewDragHelper.shouldInterceptTouchEvent(ev);\n\t}\n\t@Override\n\tpublic boolean onTouchEvent(MotionEvent ev){\n\t\tmViewDragHelper.processTouchEvent(event);\n\t\treturn true;\n\t}\n```\n\n3. 处理computeScroll()\n\n与scroller相似的，需要处理一个computescroll()方法，因为viewdraghelper内部也是使用scroller实现平滑移动的。\n\n```\n\t@Override\n\tpublic void computeScroll(){\n\t\tif(mViewdragHelper.continueSettling(true)){\n\t\t\tViewCompat.postInvalidateOnAnimation(this);\n\t\t}\n\t}\n```\n\n4. 处理回调\n\n```\n\tprivate ViewDragHelper.Callback callback = new ViewDragHelper.Callback(){\n\t\t@Override\n\t\tpublic boolean tryCaptureView(View child, int pointerId){\n\t\t\treturn false;\n\t\t}\n\t}\n```\n使用上述回调，对child进行判断，如果是需要拖动view，就可以返回true\n\n```\n\t@Override\n\tpublic int clampViewPositionVertical(View child, int top, int dy){\n\t\treturn top;\n\t}\n\t@Override\n\tpublic int clampViewPositionHorizontal(View child, int left, int dx){\n\t\treturn left;\n\t}\n```\n\n使用如上方法，来对滑动效果进行设置，返回的top和left为垂直和水平方向上面的距离。dy表示比较前一次的增量\n\n5. 拖动结束之后，子View回到原来的位置\n\n该效果可以通过监听action_up事件，并通过调用Scroller类来实现。\n在viewdraghelper中可以重写onViewRelased()方法来实现。\n\n```\n\t@Override\n\tpublic void onViewReleased(View releasedChild, float xvel, float yvel){\n\t\tsuper.onViewReleased(releasedChild, xvel, yvel);\n\t\tif(mMianView.getLeft()<500){\n\t\t\tmViewDragHelper.smoothSlideViewTo(mMainView, 0, 0);\n\t\t\tViewCompat.postInvalidateOnAnimation(DragViewGroup.this);\n\t\t}else{\n\t\t\tmViewDragHelper.smoothSlideViewTo(mMainView, 300, 0);\n\t\t\tViewCompat.postInvalidateOnAnimation(DragViewGroup.this);\n\t\t}\n\t}\n```\n\n这样就可以做到滑动距离小于500时回到原来的位置。\n\n除了以上内容，还有大量的监听事件可以用来处理各种事件。\nonViewCaptured():在用户触摸到view后回调\nonViewDragStateChanged():在拖拽状态改变时回调\nonViewPositionChanged():这个事件在位置改变时回调","slug":"androidscroll分析笔记","published":1,"updated":"2018-01-16T08:58:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7fad000id41i96moste7","content":"<h1 id=\"android坐标系\"><a href=\"#android坐标系\" class=\"headerlink\" title=\"android坐标系\"></a>android坐标系</h1><p>在android中，将屏幕最左上角的顶点作为android坐标系的原点，往右是x轴正方向，往下是y轴正方向。</p>\n<h1 id=\"视图坐标系\"><a href=\"#视图坐标系\" class=\"headerlink\" title=\"视图坐标系\"></a>视图坐标系</h1><p>视图坐标系原点以父视图左上角为坐标原点。</p>\n<h1 id=\"触控事件-MotionEvent\"><a href=\"#触控事件-MotionEvent\" class=\"headerlink\" title=\"触控事件 - MotionEvent\"></a>触控事件 - MotionEvent</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final int ACTION_DOWN = 0;//单击触摸按下动作</span><br><span class=\"line\">public static final int ACTION_UP = 1;//单击触摸离开动作</span><br><span class=\"line\">public static final int ACTION_MOVE = 2;//触摸点移动动作</span><br><span class=\"line\">public static final int ACTION_CANCEL = 3;//触摸动作取消</span><br><span class=\"line\">public static final int ACTION_OUTSIDE = 4;//触摸动作超出边界</span><br><span class=\"line\">public static final int ACTION_POINTER_DOWN = 5;//多点触摸按下动作</span><br><span class=\"line\">public static final int ACTION_POINTER_UP = 6;//多点离开动作</span><br></pre></td></tr></table></figure>\n<h2 id=\"ACTION-CANCEL\"><a href=\"#ACTION-CANCEL\" class=\"headerlink\" title=\"ACTION_CANCEL\"></a>ACTION_CANCEL</h2><p>当你的手指（或者其它）移动屏幕的时候会触发这个事件，比如当你的手指在屏幕上拖动一个listView或者一个ScrollView而不是去按上面的按钮时会触发这个事件。</p>\n<p>在设计设置页面的滑动开关时，如果不监听ACTION_CANCEL，在滑动到中间时，如果你手指上下移动，就是移动到开关控件之外，则此时会触发ACTION_CANCEL，而不是ACTION_UP，造成开关的按钮停顿在中间位置。</p>\n<p>意思就是，当用户保持按下操作，并从你的控件转移到外层控件时，会触发ACTION_CANCEL，建议进行处理～</p>\n<p>当前的手势被中断，不会再接收到关于它的记录。<br>推荐将这个事件作为 ACTION_UP 来看待，但是要区别于普通的 ACTION_UP</p>\n<p>话说回来，平常还真碰不到这个事件，习惯上就直接当 ACTION_UP 处理了就</p>\n<p>例如：上层 View 是一个 RecyclerView，它收到了一个 ACTION_DOWN 事件，由于这个可能是点击事件，所以它先传递给对应 ItemView，询问 ItemView 是否需要这个事件，然而接下来又传递过来了一个 ACTION_MOVE 事件，且移动的方向和 RecyclerView 的可滑动方向一致，所以 RecyclerView 判断这个事件是滚动事件，于是要收回事件处理权，这时候对应的 ItemView 会收到一个 ACTION_CANCEL ，并且不会再收到后续事件。</p>\n<h2 id=\"ACTION-OUTSIDE\"><a href=\"#ACTION-OUTSIDE\" class=\"headerlink\" title=\"ACTION_OUTSIDE\"></a>ACTION_OUTSIDE</h2><p>一个触摸事件已经发生了UI元素的正常范围之外。因此不再提供完整的手势，只提供 运动/触摸 的初始位置。dialog,popupwindow中比较常见</p>\n<h2 id=\"ACTION-POINTER-DOWN\"><a href=\"#ACTION-POINTER-DOWN\" class=\"headerlink\" title=\"ACTION_POINTER_DOWN\"></a>ACTION_POINTER_DOWN</h2><p>这个代表用户的第二根手指（之后动手的一根）触摸了屏幕，可以getactionindex获取某一根手指的数字来判断</p>\n<h2 id=\"ACTION-POINTER-UP\"><a href=\"#ACTION-POINTER-UP\" class=\"headerlink\" title=\"ACTION_POINTER_UP\"></a>ACTION_POINTER_UP</h2><p>同第二根手指离开了屏幕</p>\n<h1 id=\"获取坐标的方法\"><a href=\"#获取坐标的方法\" class=\"headerlink\" title=\"获取坐标的方法\"></a>获取坐标的方法</h1><h2 id=\"View提供的方法（以父布局为坐标系）\"><a href=\"#View提供的方法（以父布局为坐标系）\" class=\"headerlink\" title=\"View提供的方法（以父布局为坐标系）\"></a>View提供的方法（以父布局为坐标系）</h2><p>getTop():自身到其父布局顶点的距离<br>getLeft():<br>getRight():<br>getBottom():</p>\n<h2 id=\"MotionEvent提供的方法\"><a href=\"#MotionEvent提供的方法\" class=\"headerlink\" title=\"MotionEvent提供的方法\"></a>MotionEvent提供的方法</h2><p>getX():获取点击事件距离空间左边的距离<br>getY():<br>getRawX():获取点击事件距离整个屏幕左边的距离<br>getRawY():</p>\n<h1 id=\"实现滑动效果的7种方法\"><a href=\"#实现滑动效果的7种方法\" class=\"headerlink\" title=\"实现滑动效果的7种方法\"></a>实现滑动效果的7种方法</h1><ol>\n<li><p>layout方法<br>在ACTION_MOVE中计算偏移量，在action_down中记录触摸点的坐标，并且在move中进行计算偏移量，然后调用view的layout方法来进行调整。</p>\n</li>\n<li><p>offsetLeftAndRight和offsetTopAndBottom<br>使用方法和layout一样，差别是一个需要x的偏移一个需要y的偏移</p>\n</li>\n<li><p>LayoutParams</p>\n</li>\n</ol>\n<p>layoutParams保留了一个view的参数，可以改变view的layoutParams然后setLayoutParams进行更改。</p>\n<ol>\n<li>scrollto和scrollby</li>\n</ol>\n<p>scrollby(offsetx，offsety)，该方法会造成所有子view移动。因此需要对view的父view使用这个方法，</p>\n<ol>\n<li>Scroller</li>\n</ol>\n<p>scroller可以通过重写view的computeScroll方法，通过获取当前滚动值，来进行不断的瞬间移动，实现整体上的平移效果<br>ps：computeScroll方法是不会自动调用的，只能通过invalidate() -&gt; draw() -&gt; computeScroll()来间接调用该方法。<br>之后使用startScroll即可。</p>\n<ol>\n<li><p>属性动画</p>\n</li>\n<li><p>ViewDragHelper</p>\n</li>\n</ol>\n<p>viewdraghelper是谷歌在support库中提供的drawerlayout和slidingpanelayout两个布局中使用的，用法较为复杂。</p>\n<ol>\n<li>初始化viewdraghelper</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mViewDragHelper = ViewDragHelper.create(this, callback);</span><br></pre></td></tr></table></figure>\n<ol>\n<li>拦截事件</li>\n</ol>\n<p>将事件传递给viewdraghelper处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onInterceptTouchEvent(MotionEvent ev)&#123;</span><br><span class=\"line\">\treturn mViewDragHelper.shouldInterceptTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onTouchEvent(MotionEvent ev)&#123;</span><br><span class=\"line\">\tmViewDragHelper.processTouchEvent(event);</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>处理computeScroll()</li>\n</ol>\n<p>与scroller相似的，需要处理一个computescroll()方法，因为viewdraghelper内部也是使用scroller实现平滑移动的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void computeScroll()&#123;</span><br><span class=\"line\">\tif(mViewdragHelper.continueSettling(true))&#123;</span><br><span class=\"line\">\t\tViewCompat.postInvalidateOnAnimation(this);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>处理回调</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private ViewDragHelper.Callback callback = new ViewDragHelper.Callback()&#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic boolean tryCaptureView(View child, int pointerId)&#123;</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用上述回调，对child进行判断，如果是需要拖动view，就可以返回true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public int clampViewPositionVertical(View child, int top, int dy)&#123;</span><br><span class=\"line\">\treturn top;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public int clampViewPositionHorizontal(View child, int left, int dx)&#123;</span><br><span class=\"line\">\treturn left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用如上方法，来对滑动效果进行设置，返回的top和left为垂直和水平方向上面的距离。dy表示比较前一次的增量</p>\n<ol>\n<li>拖动结束之后，子View回到原来的位置</li>\n</ol>\n<p>该效果可以通过监听action_up事件，并通过调用Scroller类来实现。<br>在viewdraghelper中可以重写onViewRelased()方法来实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void onViewReleased(View releasedChild, float xvel, float yvel)&#123;</span><br><span class=\"line\">\tsuper.onViewReleased(releasedChild, xvel, yvel);</span><br><span class=\"line\">\tif(mMianView.getLeft()&lt;500)&#123;</span><br><span class=\"line\">\t\tmViewDragHelper.smoothSlideViewTo(mMainView, 0, 0);</span><br><span class=\"line\">\t\tViewCompat.postInvalidateOnAnimation(DragViewGroup.this);</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">\t\tmViewDragHelper.smoothSlideViewTo(mMainView, 300, 0);</span><br><span class=\"line\">\t\tViewCompat.postInvalidateOnAnimation(DragViewGroup.this);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就可以做到滑动距离小于500时回到原来的位置。</p>\n<p>除了以上内容，还有大量的监听事件可以用来处理各种事件。<br>onViewCaptured():在用户触摸到view后回调<br>onViewDragStateChanged():在拖拽状态改变时回调<br>onViewPositionChanged():这个事件在位置改变时回调</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"android坐标系\"><a href=\"#android坐标系\" class=\"headerlink\" title=\"android坐标系\"></a>android坐标系</h1><p>在android中，将屏幕最左上角的顶点作为android坐标系的原点，往右是x轴正方向，往下是y轴正方向。</p>\n<h1 id=\"视图坐标系\"><a href=\"#视图坐标系\" class=\"headerlink\" title=\"视图坐标系\"></a>视图坐标系</h1><p>视图坐标系原点以父视图左上角为坐标原点。</p>\n<h1 id=\"触控事件-MotionEvent\"><a href=\"#触控事件-MotionEvent\" class=\"headerlink\" title=\"触控事件 - MotionEvent\"></a>触控事件 - MotionEvent</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final int ACTION_DOWN = 0;//单击触摸按下动作</span><br><span class=\"line\">public static final int ACTION_UP = 1;//单击触摸离开动作</span><br><span class=\"line\">public static final int ACTION_MOVE = 2;//触摸点移动动作</span><br><span class=\"line\">public static final int ACTION_CANCEL = 3;//触摸动作取消</span><br><span class=\"line\">public static final int ACTION_OUTSIDE = 4;//触摸动作超出边界</span><br><span class=\"line\">public static final int ACTION_POINTER_DOWN = 5;//多点触摸按下动作</span><br><span class=\"line\">public static final int ACTION_POINTER_UP = 6;//多点离开动作</span><br></pre></td></tr></table></figure>\n<h2 id=\"ACTION-CANCEL\"><a href=\"#ACTION-CANCEL\" class=\"headerlink\" title=\"ACTION_CANCEL\"></a>ACTION_CANCEL</h2><p>当你的手指（或者其它）移动屏幕的时候会触发这个事件，比如当你的手指在屏幕上拖动一个listView或者一个ScrollView而不是去按上面的按钮时会触发这个事件。</p>\n<p>在设计设置页面的滑动开关时，如果不监听ACTION_CANCEL，在滑动到中间时，如果你手指上下移动，就是移动到开关控件之外，则此时会触发ACTION_CANCEL，而不是ACTION_UP，造成开关的按钮停顿在中间位置。</p>\n<p>意思就是，当用户保持按下操作，并从你的控件转移到外层控件时，会触发ACTION_CANCEL，建议进行处理～</p>\n<p>当前的手势被中断，不会再接收到关于它的记录。<br>推荐将这个事件作为 ACTION_UP 来看待，但是要区别于普通的 ACTION_UP</p>\n<p>话说回来，平常还真碰不到这个事件，习惯上就直接当 ACTION_UP 处理了就</p>\n<p>例如：上层 View 是一个 RecyclerView，它收到了一个 ACTION_DOWN 事件，由于这个可能是点击事件，所以它先传递给对应 ItemView，询问 ItemView 是否需要这个事件，然而接下来又传递过来了一个 ACTION_MOVE 事件，且移动的方向和 RecyclerView 的可滑动方向一致，所以 RecyclerView 判断这个事件是滚动事件，于是要收回事件处理权，这时候对应的 ItemView 会收到一个 ACTION_CANCEL ，并且不会再收到后续事件。</p>\n<h2 id=\"ACTION-OUTSIDE\"><a href=\"#ACTION-OUTSIDE\" class=\"headerlink\" title=\"ACTION_OUTSIDE\"></a>ACTION_OUTSIDE</h2><p>一个触摸事件已经发生了UI元素的正常范围之外。因此不再提供完整的手势，只提供 运动/触摸 的初始位置。dialog,popupwindow中比较常见</p>\n<h2 id=\"ACTION-POINTER-DOWN\"><a href=\"#ACTION-POINTER-DOWN\" class=\"headerlink\" title=\"ACTION_POINTER_DOWN\"></a>ACTION_POINTER_DOWN</h2><p>这个代表用户的第二根手指（之后动手的一根）触摸了屏幕，可以getactionindex获取某一根手指的数字来判断</p>\n<h2 id=\"ACTION-POINTER-UP\"><a href=\"#ACTION-POINTER-UP\" class=\"headerlink\" title=\"ACTION_POINTER_UP\"></a>ACTION_POINTER_UP</h2><p>同第二根手指离开了屏幕</p>\n<h1 id=\"获取坐标的方法\"><a href=\"#获取坐标的方法\" class=\"headerlink\" title=\"获取坐标的方法\"></a>获取坐标的方法</h1><h2 id=\"View提供的方法（以父布局为坐标系）\"><a href=\"#View提供的方法（以父布局为坐标系）\" class=\"headerlink\" title=\"View提供的方法（以父布局为坐标系）\"></a>View提供的方法（以父布局为坐标系）</h2><p>getTop():自身到其父布局顶点的距离<br>getLeft():<br>getRight():<br>getBottom():</p>\n<h2 id=\"MotionEvent提供的方法\"><a href=\"#MotionEvent提供的方法\" class=\"headerlink\" title=\"MotionEvent提供的方法\"></a>MotionEvent提供的方法</h2><p>getX():获取点击事件距离空间左边的距离<br>getY():<br>getRawX():获取点击事件距离整个屏幕左边的距离<br>getRawY():</p>\n<h1 id=\"实现滑动效果的7种方法\"><a href=\"#实现滑动效果的7种方法\" class=\"headerlink\" title=\"实现滑动效果的7种方法\"></a>实现滑动效果的7种方法</h1><ol>\n<li><p>layout方法<br>在ACTION_MOVE中计算偏移量，在action_down中记录触摸点的坐标，并且在move中进行计算偏移量，然后调用view的layout方法来进行调整。</p>\n</li>\n<li><p>offsetLeftAndRight和offsetTopAndBottom<br>使用方法和layout一样，差别是一个需要x的偏移一个需要y的偏移</p>\n</li>\n<li><p>LayoutParams</p>\n</li>\n</ol>\n<p>layoutParams保留了一个view的参数，可以改变view的layoutParams然后setLayoutParams进行更改。</p>\n<ol>\n<li>scrollto和scrollby</li>\n</ol>\n<p>scrollby(offsetx，offsety)，该方法会造成所有子view移动。因此需要对view的父view使用这个方法，</p>\n<ol>\n<li>Scroller</li>\n</ol>\n<p>scroller可以通过重写view的computeScroll方法，通过获取当前滚动值，来进行不断的瞬间移动，实现整体上的平移效果<br>ps：computeScroll方法是不会自动调用的，只能通过invalidate() -&gt; draw() -&gt; computeScroll()来间接调用该方法。<br>之后使用startScroll即可。</p>\n<ol>\n<li><p>属性动画</p>\n</li>\n<li><p>ViewDragHelper</p>\n</li>\n</ol>\n<p>viewdraghelper是谷歌在support库中提供的drawerlayout和slidingpanelayout两个布局中使用的，用法较为复杂。</p>\n<ol>\n<li>初始化viewdraghelper</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mViewDragHelper = ViewDragHelper.create(this, callback);</span><br></pre></td></tr></table></figure>\n<ol>\n<li>拦截事件</li>\n</ol>\n<p>将事件传递给viewdraghelper处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onInterceptTouchEvent(MotionEvent ev)&#123;</span><br><span class=\"line\">\treturn mViewDragHelper.shouldInterceptTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onTouchEvent(MotionEvent ev)&#123;</span><br><span class=\"line\">\tmViewDragHelper.processTouchEvent(event);</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>处理computeScroll()</li>\n</ol>\n<p>与scroller相似的，需要处理一个computescroll()方法，因为viewdraghelper内部也是使用scroller实现平滑移动的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void computeScroll()&#123;</span><br><span class=\"line\">\tif(mViewdragHelper.continueSettling(true))&#123;</span><br><span class=\"line\">\t\tViewCompat.postInvalidateOnAnimation(this);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>处理回调</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private ViewDragHelper.Callback callback = new ViewDragHelper.Callback()&#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic boolean tryCaptureView(View child, int pointerId)&#123;</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用上述回调，对child进行判断，如果是需要拖动view，就可以返回true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public int clampViewPositionVertical(View child, int top, int dy)&#123;</span><br><span class=\"line\">\treturn top;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public int clampViewPositionHorizontal(View child, int left, int dx)&#123;</span><br><span class=\"line\">\treturn left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用如上方法，来对滑动效果进行设置，返回的top和left为垂直和水平方向上面的距离。dy表示比较前一次的增量</p>\n<ol>\n<li>拖动结束之后，子View回到原来的位置</li>\n</ol>\n<p>该效果可以通过监听action_up事件，并通过调用Scroller类来实现。<br>在viewdraghelper中可以重写onViewRelased()方法来实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void onViewReleased(View releasedChild, float xvel, float yvel)&#123;</span><br><span class=\"line\">\tsuper.onViewReleased(releasedChild, xvel, yvel);</span><br><span class=\"line\">\tif(mMianView.getLeft()&lt;500)&#123;</span><br><span class=\"line\">\t\tmViewDragHelper.smoothSlideViewTo(mMainView, 0, 0);</span><br><span class=\"line\">\t\tViewCompat.postInvalidateOnAnimation(DragViewGroup.this);</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">\t\tmViewDragHelper.smoothSlideViewTo(mMainView, 300, 0);</span><br><span class=\"line\">\t\tViewCompat.postInvalidateOnAnimation(DragViewGroup.this);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就可以做到滑动距离小于500时回到原来的位置。</p>\n<p>除了以上内容，还有大量的监听事件可以用来处理各种事件。<br>onViewCaptured():在用户触摸到view后回调<br>onViewDragStateChanged():在拖拽状态改变时回调<br>onViewPositionChanged():这个事件在位置改变时回调</p>\n"},{"title":"Android绘图机制与处理技巧","date":"2018-01-16T13:53:31.000Z","_content":"\n本章用于做群英传第六章《Android绘图机制与处理技巧》的学习笔记。主要是整理自己不熟悉的知识点。\n\n# 屏幕的尺寸信息\n\n1. 屏幕大小\n\n屏幕大小指对角线的长度，一般使用寸来度量，寸指英寸，一英寸为2.54cm\n\n2. 分辨率\n\n分辨率指手机屏幕的像素点个数。1920*1080指宽有1920个像素点，高有1080个像素点\n\n3. ppi\n\npixel per inch，每英寸像素，又称为dpi，为对角线的像素点除以屏幕大小得到。\n\n# 系统屏幕密度\n\n根据dpi大小来进行设置，系统定义了几个标准的dpi值。\n\n120: ldpi\n160: mdpi\n240: hdpi\n320: xhdpi\n480: xxhdpi\n\n# 独立像素密度 dp\n\n在mdpi，即dpi为160时， 1dp = 1px。之后顺推即可，xxhdpi为160的3倍，即1dp = 3px\n\ndp涉及到像素工具类的使用。\n\n```\npublic class DisplayUtil{\n\n\tpublic static int px2dp(Context context, float px){\n\t\tfinal float scale = context.getResource().getDisplayMetrics().density;\n\t\treturn (int)(px/scale + 0.5f);\n\t}\n\n\tpublic static int dp2px(Context context, float dp){\n\t\tfinal float scale = context.getResource().getDisplayMetrics().density;\n\t\treturn (int)(dp*scale + 0.5f);\n\t}\n\n\tpublic static int px2sp(Context context, float px){\n\t\tfinal float fontScale = context.getResource().getDisplayMetrics().scaledDensity;\n\t\treturn (int)(px/fontScale + 0.5f);\n\t}\n\n\tpublic static int sp2dp(Context context, float sp){\n\t\tfinal float fontScale = context.getResource().getDisplayMetrics().scaledDensity;\n\t\treturn (int)(sp*fontScale + 0.5f);\n\t}\n\n\t//以上为使用公式进行换算的\n\t//还可以使用TypedValue进行换算\n\n\tpublic static int dp2px(int dp){\n\t\treturn (int)TypedValue.applyDimension(\n\t\t\tTypedValue.COMPLEX_UNIT_DIP,\n\t\t\tdp,\n\t\t\tgetResources().getDisplayMetrics());\n\t}\n\n\tpublic static int sp2px(int sp){\n\t\treturn (int)TypeValue.applyDimension(\n\t\t\tTypedValue.COMPLEX_UNIT_SP,\n\t\t\tsp,\n\t\t\tgetResources().getDisplayMetrics());\n\t}\n\n}\n```\n\n# 2D绘图基础\n\n2d绘图即使用系统提供的Canvas对象来提供绘图方法，该章主要是复习一些常用的api。\n\n1. paint\n\nsetAntiAlias():设置抗锯齿效果\nsetColor():设置画笔的颜色\nsetARGB():设置画笔的啊a,r,g,b值\nsetAlpha():设置画笔透明度\nsetTextSize():设置字体的尺寸\nsetStyle():设置画笔的风格（空心或者实心）\nsetStrokeWidth():设置空心边框的宽度\n\n2. canvas\n\ncanvas.drawPoint(x, y, paint): 绘制点\n\ncanvas.drawLine(startX, startY, endX, endY, paint): 绘制直线\n\n```\n\tfloat[] pts = {\n\t\tstartX1, startY1, endX1, endY1,\n\t\t... ...\n\t\tstartXn, startYn, endXn, endYn\n\t};\n\tcanvas.drawLines(pts, paint);\n\t//画多条直线\n```\n\ncanvas.drawRect(left, top, right, bottom, paint): 绘制矩形\n\ncanvas.drawRoundRect(left, top, right, bottom, radiusX, radiuxY, paint):绘制圆角矩形\n\ncanvas.drawCircle(circleX, circleY, radius, paint):绘制圆\n\ncanvas.drawArc(left, top, right, bottom, startAngle, sweepAngle, useCenter, paint):绘制弧形，扇形，区别在于useCenter\n\ncanvas.drawOval(left, top, right, bottom, paint):画椭圆\n\ncanvas.drawText(text, startX, startY, paint):绘制文本\n\ncanvas.drawPosText(text, new float[]{X1, Y1, X2, Y2... ... Xn, Yn}, paint):在制定位置绘制文本\n\ncanvas.drawPath(path, paint):绘制路径\n\n# Android xml绘图\n\n1. Bitmap\n\n在xml中使用bitmap\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<bitmap xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\tandroid:src=\"@drawable/ic_launcher\"/>\n```\n\n2. Shape\n\n```\n<shape xmlns:android:\"http://schemas.android.com/apk/res/android\"\n\tandroid:shape=[\"rectangle\" | \"oval\" | \"line\" | \"ring\"]>\n\t//默认为rectangle\n\t<corners //shape = \"rectangle\" 有用\n\t\t// 半径，会被后面的单个半径属性覆盖，默认为1dp\n\t\tandroid:radius=\"integer\"\n\t\tandroid:topLeftRadius=\"integer\"\n\t\tandroid:topRightRadius=\"integer\"\n\t\tandroid:bottomLeftRadius=\"integer\"\n\t\tandroid:bottomRightRadius=\"integer\"/>\n\t<gradient //渐变\n\t\tandroid:angle=\"integer\"\n\t\tandroid:centerX=\"integer\"\n\t\tandroid:centerY=\"integer\"\n\t\tandroid:centerColor=\"integer\"\n\t\tandroid:endColor=\"color\"\n\t\tandroid:gradientRadius=\"integer\"\n\t\tandroid:startColor=\"color\"\n\t\tandroid:type=[\"linear\"| \"radius\" | \"sweep\"]\n\t\tandroid:useLevel=[\"true\" | \"false\"]/>\n\t<padding\n\t\tandroid:left=\"integer\"\n\t\tandroid:top=\"integer\"\n\t\tandroid:right=\"integer\"\n\t\tandroid:bottom=\"integer\"/>\n\t<size // 指定大小，一般用在imageview配合scaletype属性使用\n\t\tandroid:width=\"integer\"\n\t\tandroid:height=\"integer\"/>\n\t<solid // 填充颜色\n\t\tandroid:color=\"color\"/>\n\t<stroke //指定边框\n\t\tandroid:width=\"integer\"\n\t\tandroid:color=\"color\"\n\t\tandroid:dashWidth=\"integer\" //虚线宽度\n\t\tandroid:dashGap=\"integer\" // 虚线间隔宽度\n\t\t/>\n</shape>\n```\n\n3. Layer\n\nlayer中可以使用层级来进行叠加，主要是用item，item可以使用drawable，也可使用shape\n\n4. Selector\n\nSelector用于帮开发者实现静态绘图中的事件反馈，通过不同的事件设置不同的图像。\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\t//默认时的背景图片\n\t<item android:drawable=\"@drawable/x1\"/>\n\t//没有焦点时的图片\n\t<item android:state_window_focused=\"false\" android:drawable=\"@drawable/x2\"/>\n\t//非触摸模式下获得焦点并单击时的背景图片\n\t<item android:state_focuse=\"true\" android:state_pressed=\"true\" android:drawable=\"@drawable/x3\"/>\n\t//触摸模式下单击时的背景图片\n\t<item android:state_focuse=\"false\" android:state_pressed=\"true\" android:drawable=\"@drawable/x4\"/>\n\t//选中时的背景图片\n\t<item android:state_selected=\"true\" android:drawable=\"@drawable/x5\"/>\n\t//获得焦点时的背景图片\n\t<item android:state_focused=\"true\" android:drawable=\"@drawable/x6\"/>\n</selector>\n```\n\n以上可以用于制作view的触摸反馈。\n\n# android 绘图技巧\n\n之上的是基本绘图技巧，之下的是常用绘图技巧\n\n1. Canvas\n\nCanvas.save(): 将之前的所有绘制图像保存起来，之后的操作就好像在一个新的图层上面操作一样。\n\nCanvas.restore(): 用于合并图层，可以用于将save之后绘制的所有图像与save之前的图像合并\n\nCanvas.translate():调用translate(x, y)操作可以将原点(0, 0)移动到(x, y)之后的所有操作都将以(x, y)为原点执行\n\nCanvas.rotate():调用rotate(degree)之后可以将canvas调转一定的角度。\n\n2. Layer图层\n\nAndroid通过调用saveLayer()方法，saveLayerAlpha()方法将一个图层入栈，使用restore()方法,restoreToCount()方法将一个图层出栈。出栈的时候，会把图像绘制到上层Canvas上。\n\n# 画笔特效处理\n\n1. PorterDuffXferMode\n\n该模式控制的是两个图像间的混合显示模式。dst是先画的图形，src是后画的图形。\n\n2. Shader\n\nshader被称为着色器，渲染器。可以用来实现一系列的渐变、渲染效果。\n\n其中shader包括：\nBitmapShader   ---  位图shader\nLinearGradient ---  线性shader\nRadialGradient ---  光束shader\nSweepGradient  ---  梯度shader\nComposeShader  ---  混合shader\n\nshader的作用就是通过paint对画布进行指定的bitmap的填充，填充时有三种模式\n\nCLAMP  --- 拉伸的是图片最后的那一个像素，不断重复\nREPEAT --- 横向纵向不断重复\nMIRROR --- 横向不断翻转重复，纵向不断翻转重复\n\n3. PathEffect\n\npatheffect是指用各种笔触效果来绘制一个路径。\n\nCornerPathEffect:   将拐角处变的圆滑\nDiscretePathEffect:\t使用这个之后线段上会出现很多杂点\nDashPathEffect:\t\t使用这个可以绘制虚线，用一个数组来设置各个点之间的间隔，此后绘制虚线时就重复这样的间隔进行绘制，另一个参数phase可以用来绘制时数组的一个偏移量，可以通过设置值来实现路径的动态效果。\nPathDashPathEffect: 与dashpatheffect类似，不过功能更强大，可以设置点的图形，例如方形点的虚线，圆形点的虚线\nComposePathEffect   可以通过composepatheffect来组合patheffect，这个方法的功能就是将任意的两种路径特性组合起来形成一个新的效果。\n\n# SurfaceView\n\n1. surfaceview 和view的区别\n\n对view来说，android系统通过发出VSYNC信号来进行屏幕的重绘，刷新的间隔为16ms，如果在16ms内view完成了所需要执行的所有操作，那么用户在视觉上就不会产生卡顿的感觉。但是执行的操作逻辑太多，在需要频繁刷新的界面上，就会阻塞主线程，因此android提供了surfaceview。\n\nview主要适用于主动更新的情况下，而surfaceview主要适用于被动更新，例如频繁刷新\nview在主线程中对画面进行刷新，surfaceview则通常会通过一个子线程来进行页面的刷新\nview在绘图时没有使用双缓冲机制，而surfaceview在底层实现机制中就已经实现了双缓冲机制\n\n2. surfaceview的使用","source":"_posts/Android绘图机制与处理技巧.md","raw":"---\ntitle: Android绘图机制与处理技巧\ndate: 2018-01-16 21:53:31\ntags: android\n---\n\n本章用于做群英传第六章《Android绘图机制与处理技巧》的学习笔记。主要是整理自己不熟悉的知识点。\n\n# 屏幕的尺寸信息\n\n1. 屏幕大小\n\n屏幕大小指对角线的长度，一般使用寸来度量，寸指英寸，一英寸为2.54cm\n\n2. 分辨率\n\n分辨率指手机屏幕的像素点个数。1920*1080指宽有1920个像素点，高有1080个像素点\n\n3. ppi\n\npixel per inch，每英寸像素，又称为dpi，为对角线的像素点除以屏幕大小得到。\n\n# 系统屏幕密度\n\n根据dpi大小来进行设置，系统定义了几个标准的dpi值。\n\n120: ldpi\n160: mdpi\n240: hdpi\n320: xhdpi\n480: xxhdpi\n\n# 独立像素密度 dp\n\n在mdpi，即dpi为160时， 1dp = 1px。之后顺推即可，xxhdpi为160的3倍，即1dp = 3px\n\ndp涉及到像素工具类的使用。\n\n```\npublic class DisplayUtil{\n\n\tpublic static int px2dp(Context context, float px){\n\t\tfinal float scale = context.getResource().getDisplayMetrics().density;\n\t\treturn (int)(px/scale + 0.5f);\n\t}\n\n\tpublic static int dp2px(Context context, float dp){\n\t\tfinal float scale = context.getResource().getDisplayMetrics().density;\n\t\treturn (int)(dp*scale + 0.5f);\n\t}\n\n\tpublic static int px2sp(Context context, float px){\n\t\tfinal float fontScale = context.getResource().getDisplayMetrics().scaledDensity;\n\t\treturn (int)(px/fontScale + 0.5f);\n\t}\n\n\tpublic static int sp2dp(Context context, float sp){\n\t\tfinal float fontScale = context.getResource().getDisplayMetrics().scaledDensity;\n\t\treturn (int)(sp*fontScale + 0.5f);\n\t}\n\n\t//以上为使用公式进行换算的\n\t//还可以使用TypedValue进行换算\n\n\tpublic static int dp2px(int dp){\n\t\treturn (int)TypedValue.applyDimension(\n\t\t\tTypedValue.COMPLEX_UNIT_DIP,\n\t\t\tdp,\n\t\t\tgetResources().getDisplayMetrics());\n\t}\n\n\tpublic static int sp2px(int sp){\n\t\treturn (int)TypeValue.applyDimension(\n\t\t\tTypedValue.COMPLEX_UNIT_SP,\n\t\t\tsp,\n\t\t\tgetResources().getDisplayMetrics());\n\t}\n\n}\n```\n\n# 2D绘图基础\n\n2d绘图即使用系统提供的Canvas对象来提供绘图方法，该章主要是复习一些常用的api。\n\n1. paint\n\nsetAntiAlias():设置抗锯齿效果\nsetColor():设置画笔的颜色\nsetARGB():设置画笔的啊a,r,g,b值\nsetAlpha():设置画笔透明度\nsetTextSize():设置字体的尺寸\nsetStyle():设置画笔的风格（空心或者实心）\nsetStrokeWidth():设置空心边框的宽度\n\n2. canvas\n\ncanvas.drawPoint(x, y, paint): 绘制点\n\ncanvas.drawLine(startX, startY, endX, endY, paint): 绘制直线\n\n```\n\tfloat[] pts = {\n\t\tstartX1, startY1, endX1, endY1,\n\t\t... ...\n\t\tstartXn, startYn, endXn, endYn\n\t};\n\tcanvas.drawLines(pts, paint);\n\t//画多条直线\n```\n\ncanvas.drawRect(left, top, right, bottom, paint): 绘制矩形\n\ncanvas.drawRoundRect(left, top, right, bottom, radiusX, radiuxY, paint):绘制圆角矩形\n\ncanvas.drawCircle(circleX, circleY, radius, paint):绘制圆\n\ncanvas.drawArc(left, top, right, bottom, startAngle, sweepAngle, useCenter, paint):绘制弧形，扇形，区别在于useCenter\n\ncanvas.drawOval(left, top, right, bottom, paint):画椭圆\n\ncanvas.drawText(text, startX, startY, paint):绘制文本\n\ncanvas.drawPosText(text, new float[]{X1, Y1, X2, Y2... ... Xn, Yn}, paint):在制定位置绘制文本\n\ncanvas.drawPath(path, paint):绘制路径\n\n# Android xml绘图\n\n1. Bitmap\n\n在xml中使用bitmap\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<bitmap xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\tandroid:src=\"@drawable/ic_launcher\"/>\n```\n\n2. Shape\n\n```\n<shape xmlns:android:\"http://schemas.android.com/apk/res/android\"\n\tandroid:shape=[\"rectangle\" | \"oval\" | \"line\" | \"ring\"]>\n\t//默认为rectangle\n\t<corners //shape = \"rectangle\" 有用\n\t\t// 半径，会被后面的单个半径属性覆盖，默认为1dp\n\t\tandroid:radius=\"integer\"\n\t\tandroid:topLeftRadius=\"integer\"\n\t\tandroid:topRightRadius=\"integer\"\n\t\tandroid:bottomLeftRadius=\"integer\"\n\t\tandroid:bottomRightRadius=\"integer\"/>\n\t<gradient //渐变\n\t\tandroid:angle=\"integer\"\n\t\tandroid:centerX=\"integer\"\n\t\tandroid:centerY=\"integer\"\n\t\tandroid:centerColor=\"integer\"\n\t\tandroid:endColor=\"color\"\n\t\tandroid:gradientRadius=\"integer\"\n\t\tandroid:startColor=\"color\"\n\t\tandroid:type=[\"linear\"| \"radius\" | \"sweep\"]\n\t\tandroid:useLevel=[\"true\" | \"false\"]/>\n\t<padding\n\t\tandroid:left=\"integer\"\n\t\tandroid:top=\"integer\"\n\t\tandroid:right=\"integer\"\n\t\tandroid:bottom=\"integer\"/>\n\t<size // 指定大小，一般用在imageview配合scaletype属性使用\n\t\tandroid:width=\"integer\"\n\t\tandroid:height=\"integer\"/>\n\t<solid // 填充颜色\n\t\tandroid:color=\"color\"/>\n\t<stroke //指定边框\n\t\tandroid:width=\"integer\"\n\t\tandroid:color=\"color\"\n\t\tandroid:dashWidth=\"integer\" //虚线宽度\n\t\tandroid:dashGap=\"integer\" // 虚线间隔宽度\n\t\t/>\n</shape>\n```\n\n3. Layer\n\nlayer中可以使用层级来进行叠加，主要是用item，item可以使用drawable，也可使用shape\n\n4. Selector\n\nSelector用于帮开发者实现静态绘图中的事件反馈，通过不同的事件设置不同的图像。\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\t//默认时的背景图片\n\t<item android:drawable=\"@drawable/x1\"/>\n\t//没有焦点时的图片\n\t<item android:state_window_focused=\"false\" android:drawable=\"@drawable/x2\"/>\n\t//非触摸模式下获得焦点并单击时的背景图片\n\t<item android:state_focuse=\"true\" android:state_pressed=\"true\" android:drawable=\"@drawable/x3\"/>\n\t//触摸模式下单击时的背景图片\n\t<item android:state_focuse=\"false\" android:state_pressed=\"true\" android:drawable=\"@drawable/x4\"/>\n\t//选中时的背景图片\n\t<item android:state_selected=\"true\" android:drawable=\"@drawable/x5\"/>\n\t//获得焦点时的背景图片\n\t<item android:state_focused=\"true\" android:drawable=\"@drawable/x6\"/>\n</selector>\n```\n\n以上可以用于制作view的触摸反馈。\n\n# android 绘图技巧\n\n之上的是基本绘图技巧，之下的是常用绘图技巧\n\n1. Canvas\n\nCanvas.save(): 将之前的所有绘制图像保存起来，之后的操作就好像在一个新的图层上面操作一样。\n\nCanvas.restore(): 用于合并图层，可以用于将save之后绘制的所有图像与save之前的图像合并\n\nCanvas.translate():调用translate(x, y)操作可以将原点(0, 0)移动到(x, y)之后的所有操作都将以(x, y)为原点执行\n\nCanvas.rotate():调用rotate(degree)之后可以将canvas调转一定的角度。\n\n2. Layer图层\n\nAndroid通过调用saveLayer()方法，saveLayerAlpha()方法将一个图层入栈，使用restore()方法,restoreToCount()方法将一个图层出栈。出栈的时候，会把图像绘制到上层Canvas上。\n\n# 画笔特效处理\n\n1. PorterDuffXferMode\n\n该模式控制的是两个图像间的混合显示模式。dst是先画的图形，src是后画的图形。\n\n2. Shader\n\nshader被称为着色器，渲染器。可以用来实现一系列的渐变、渲染效果。\n\n其中shader包括：\nBitmapShader   ---  位图shader\nLinearGradient ---  线性shader\nRadialGradient ---  光束shader\nSweepGradient  ---  梯度shader\nComposeShader  ---  混合shader\n\nshader的作用就是通过paint对画布进行指定的bitmap的填充，填充时有三种模式\n\nCLAMP  --- 拉伸的是图片最后的那一个像素，不断重复\nREPEAT --- 横向纵向不断重复\nMIRROR --- 横向不断翻转重复，纵向不断翻转重复\n\n3. PathEffect\n\npatheffect是指用各种笔触效果来绘制一个路径。\n\nCornerPathEffect:   将拐角处变的圆滑\nDiscretePathEffect:\t使用这个之后线段上会出现很多杂点\nDashPathEffect:\t\t使用这个可以绘制虚线，用一个数组来设置各个点之间的间隔，此后绘制虚线时就重复这样的间隔进行绘制，另一个参数phase可以用来绘制时数组的一个偏移量，可以通过设置值来实现路径的动态效果。\nPathDashPathEffect: 与dashpatheffect类似，不过功能更强大，可以设置点的图形，例如方形点的虚线，圆形点的虚线\nComposePathEffect   可以通过composepatheffect来组合patheffect，这个方法的功能就是将任意的两种路径特性组合起来形成一个新的效果。\n\n# SurfaceView\n\n1. surfaceview 和view的区别\n\n对view来说，android系统通过发出VSYNC信号来进行屏幕的重绘，刷新的间隔为16ms，如果在16ms内view完成了所需要执行的所有操作，那么用户在视觉上就不会产生卡顿的感觉。但是执行的操作逻辑太多，在需要频繁刷新的界面上，就会阻塞主线程，因此android提供了surfaceview。\n\nview主要适用于主动更新的情况下，而surfaceview主要适用于被动更新，例如频繁刷新\nview在主线程中对画面进行刷新，surfaceview则通常会通过一个子线程来进行页面的刷新\nview在绘图时没有使用双缓冲机制，而surfaceview在底层实现机制中就已经实现了双缓冲机制\n\n2. surfaceview的使用","slug":"Android绘图机制与处理技巧","published":1,"updated":"2018-01-18T11:35:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7faf000ld41iw86mbcem","content":"<p>本章用于做群英传第六章《Android绘图机制与处理技巧》的学习笔记。主要是整理自己不熟悉的知识点。</p>\n<h1 id=\"屏幕的尺寸信息\"><a href=\"#屏幕的尺寸信息\" class=\"headerlink\" title=\"屏幕的尺寸信息\"></a>屏幕的尺寸信息</h1><ol>\n<li>屏幕大小</li>\n</ol>\n<p>屏幕大小指对角线的长度，一般使用寸来度量，寸指英寸，一英寸为2.54cm</p>\n<ol>\n<li>分辨率</li>\n</ol>\n<p>分辨率指手机屏幕的像素点个数。1920*1080指宽有1920个像素点，高有1080个像素点</p>\n<ol>\n<li>ppi</li>\n</ol>\n<p>pixel per inch，每英寸像素，又称为dpi，为对角线的像素点除以屏幕大小得到。</p>\n<h1 id=\"系统屏幕密度\"><a href=\"#系统屏幕密度\" class=\"headerlink\" title=\"系统屏幕密度\"></a>系统屏幕密度</h1><p>根据dpi大小来进行设置，系统定义了几个标准的dpi值。</p>\n<p>120: ldpi<br>160: mdpi<br>240: hdpi<br>320: xhdpi<br>480: xxhdpi</p>\n<h1 id=\"独立像素密度-dp\"><a href=\"#独立像素密度-dp\" class=\"headerlink\" title=\"独立像素密度 dp\"></a>独立像素密度 dp</h1><p>在mdpi，即dpi为160时， 1dp = 1px。之后顺推即可，xxhdpi为160的3倍，即1dp = 3px</p>\n<p>dp涉及到像素工具类的使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DisplayUtil&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int px2dp(Context context, float px)&#123;</span><br><span class=\"line\">\t\tfinal float scale = context.getResource().getDisplayMetrics().density;</span><br><span class=\"line\">\t\treturn (int)(px/scale + 0.5f);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int dp2px(Context context, float dp)&#123;</span><br><span class=\"line\">\t\tfinal float scale = context.getResource().getDisplayMetrics().density;</span><br><span class=\"line\">\t\treturn (int)(dp*scale + 0.5f);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int px2sp(Context context, float px)&#123;</span><br><span class=\"line\">\t\tfinal float fontScale = context.getResource().getDisplayMetrics().scaledDensity;</span><br><span class=\"line\">\t\treturn (int)(px/fontScale + 0.5f);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int sp2dp(Context context, float sp)&#123;</span><br><span class=\"line\">\t\tfinal float fontScale = context.getResource().getDisplayMetrics().scaledDensity;</span><br><span class=\"line\">\t\treturn (int)(sp*fontScale + 0.5f);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//以上为使用公式进行换算的</span><br><span class=\"line\">\t//还可以使用TypedValue进行换算</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int dp2px(int dp)&#123;</span><br><span class=\"line\">\t\treturn (int)TypedValue.applyDimension(</span><br><span class=\"line\">\t\t\tTypedValue.COMPLEX_UNIT_DIP,</span><br><span class=\"line\">\t\t\tdp,</span><br><span class=\"line\">\t\t\tgetResources().getDisplayMetrics());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int sp2px(int sp)&#123;</span><br><span class=\"line\">\t\treturn (int)TypeValue.applyDimension(</span><br><span class=\"line\">\t\t\tTypedValue.COMPLEX_UNIT_SP,</span><br><span class=\"line\">\t\t\tsp,</span><br><span class=\"line\">\t\t\tgetResources().getDisplayMetrics());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2D绘图基础\"><a href=\"#2D绘图基础\" class=\"headerlink\" title=\"2D绘图基础\"></a>2D绘图基础</h1><p>2d绘图即使用系统提供的Canvas对象来提供绘图方法，该章主要是复习一些常用的api。</p>\n<ol>\n<li>paint</li>\n</ol>\n<p>setAntiAlias():设置抗锯齿效果<br>setColor():设置画笔的颜色<br>setARGB():设置画笔的啊a,r,g,b值<br>setAlpha():设置画笔透明度<br>setTextSize():设置字体的尺寸<br>setStyle():设置画笔的风格（空心或者实心）<br>setStrokeWidth():设置空心边框的宽度</p>\n<ol>\n<li>canvas</li>\n</ol>\n<p>canvas.drawPoint(x, y, paint): 绘制点</p>\n<p>canvas.drawLine(startX, startY, endX, endY, paint): 绘制直线</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float[] pts = &#123;</span><br><span class=\"line\">\tstartX1, startY1, endX1, endY1,</span><br><span class=\"line\">\t... ...</span><br><span class=\"line\">\tstartXn, startYn, endXn, endYn</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">canvas.drawLines(pts, paint);</span><br><span class=\"line\">//画多条直线</span><br></pre></td></tr></table></figure>\n<p>canvas.drawRect(left, top, right, bottom, paint): 绘制矩形</p>\n<p>canvas.drawRoundRect(left, top, right, bottom, radiusX, radiuxY, paint):绘制圆角矩形</p>\n<p>canvas.drawCircle(circleX, circleY, radius, paint):绘制圆</p>\n<p>canvas.drawArc(left, top, right, bottom, startAngle, sweepAngle, useCenter, paint):绘制弧形，扇形，区别在于useCenter</p>\n<p>canvas.drawOval(left, top, right, bottom, paint):画椭圆</p>\n<p>canvas.drawText(text, startX, startY, paint):绘制文本</p>\n<p>canvas.drawPosText(text, new float[]{X1, Y1, X2, Y2… … Xn, Yn}, paint):在制定位置绘制文本</p>\n<p>canvas.drawPath(path, paint):绘制路径</p>\n<h1 id=\"Android-xml绘图\"><a href=\"#Android-xml绘图\" class=\"headerlink\" title=\"Android xml绘图\"></a>Android xml绘图</h1><ol>\n<li>Bitmap</li>\n</ol>\n<p>在xml中使用bitmap<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">\tandroid:src=&quot;@drawable/ic_launcher&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>Shape</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;shape xmlns:android:&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">\tandroid:shape=[&quot;rectangle&quot; | &quot;oval&quot; | &quot;line&quot; | &quot;ring&quot;]&gt;</span><br><span class=\"line\">\t//默认为rectangle</span><br><span class=\"line\">\t&lt;corners //shape = &quot;rectangle&quot; 有用</span><br><span class=\"line\">\t\t// 半径，会被后面的单个半径属性覆盖，默认为1dp</span><br><span class=\"line\">\t\tandroid:radius=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:topLeftRadius=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:topRightRadius=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:bottomLeftRadius=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:bottomRightRadius=&quot;integer&quot;/&gt;</span><br><span class=\"line\">\t&lt;gradient //渐变</span><br><span class=\"line\">\t\tandroid:angle=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:centerX=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:centerY=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:centerColor=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:endColor=&quot;color&quot;</span><br><span class=\"line\">\t\tandroid:gradientRadius=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:startColor=&quot;color&quot;</span><br><span class=\"line\">\t\tandroid:type=[&quot;linear&quot;| &quot;radius&quot; | &quot;sweep&quot;]</span><br><span class=\"line\">\t\tandroid:useLevel=[&quot;true&quot; | &quot;false&quot;]/&gt;</span><br><span class=\"line\">\t&lt;padding</span><br><span class=\"line\">\t\tandroid:left=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:top=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:right=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:bottom=&quot;integer&quot;/&gt;</span><br><span class=\"line\">\t&lt;size // 指定大小，一般用在imageview配合scaletype属性使用</span><br><span class=\"line\">\t\tandroid:width=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:height=&quot;integer&quot;/&gt;</span><br><span class=\"line\">\t&lt;solid // 填充颜色</span><br><span class=\"line\">\t\tandroid:color=&quot;color&quot;/&gt;</span><br><span class=\"line\">\t&lt;stroke //指定边框</span><br><span class=\"line\">\t\tandroid:width=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:color=&quot;color&quot;</span><br><span class=\"line\">\t\tandroid:dashWidth=&quot;integer&quot; //虚线宽度</span><br><span class=\"line\">\t\tandroid:dashGap=&quot;integer&quot; // 虚线间隔宽度</span><br><span class=\"line\">\t\t/&gt;</span><br><span class=\"line\">&lt;/shape&gt;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Layer</li>\n</ol>\n<p>layer中可以使用层级来进行叠加，主要是用item，item可以使用drawable，也可使用shape</p>\n<ol>\n<li>Selector</li>\n</ol>\n<p>Selector用于帮开发者实现静态绘图中的事件反馈，通过不同的事件设置不同的图像。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class=\"line\">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class=\"line\">\t//默认时的背景图片</span><br><span class=\"line\">\t&lt;item android:drawable=&quot;@drawable/x1&quot;/&gt;</span><br><span class=\"line\">\t//没有焦点时的图片</span><br><span class=\"line\">\t&lt;item android:state_window_focused=&quot;false&quot; android:drawable=&quot;@drawable/x2&quot;/&gt;</span><br><span class=\"line\">\t//非触摸模式下获得焦点并单击时的背景图片</span><br><span class=\"line\">\t&lt;item android:state_focuse=&quot;true&quot; android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/x3&quot;/&gt;</span><br><span class=\"line\">\t//触摸模式下单击时的背景图片</span><br><span class=\"line\">\t&lt;item android:state_focuse=&quot;false&quot; android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/x4&quot;/&gt;</span><br><span class=\"line\">\t//选中时的背景图片</span><br><span class=\"line\">\t&lt;item android:state_selected=&quot;true&quot; android:drawable=&quot;@drawable/x5&quot;/&gt;</span><br><span class=\"line\">\t//获得焦点时的背景图片</span><br><span class=\"line\">\t&lt;item android:state_focused=&quot;true&quot; android:drawable=&quot;@drawable/x6&quot;/&gt;</span><br><span class=\"line\">&lt;/selector&gt;</span><br></pre></td></tr></table></figure>\n<p>以上可以用于制作view的触摸反馈。</p>\n<h1 id=\"android-绘图技巧\"><a href=\"#android-绘图技巧\" class=\"headerlink\" title=\"android 绘图技巧\"></a>android 绘图技巧</h1><p>之上的是基本绘图技巧，之下的是常用绘图技巧</p>\n<ol>\n<li>Canvas</li>\n</ol>\n<p>Canvas.save(): 将之前的所有绘制图像保存起来，之后的操作就好像在一个新的图层上面操作一样。</p>\n<p>Canvas.restore(): 用于合并图层，可以用于将save之后绘制的所有图像与save之前的图像合并</p>\n<p>Canvas.translate():调用translate(x, y)操作可以将原点(0, 0)移动到(x, y)之后的所有操作都将以(x, y)为原点执行</p>\n<p>Canvas.rotate():调用rotate(degree)之后可以将canvas调转一定的角度。</p>\n<ol>\n<li>Layer图层</li>\n</ol>\n<p>Android通过调用saveLayer()方法，saveLayerAlpha()方法将一个图层入栈，使用restore()方法,restoreToCount()方法将一个图层出栈。出栈的时候，会把图像绘制到上层Canvas上。</p>\n<h1 id=\"画笔特效处理\"><a href=\"#画笔特效处理\" class=\"headerlink\" title=\"画笔特效处理\"></a>画笔特效处理</h1><ol>\n<li>PorterDuffXferMode</li>\n</ol>\n<p>该模式控制的是两个图像间的混合显示模式。dst是先画的图形，src是后画的图形。</p>\n<ol>\n<li>Shader</li>\n</ol>\n<p>shader被称为着色器，渲染器。可以用来实现一系列的渐变、渲染效果。</p>\n<p>其中shader包括：<br>BitmapShader   —  位图shader<br>LinearGradient —  线性shader<br>RadialGradient —  光束shader<br>SweepGradient  —  梯度shader<br>ComposeShader  —  混合shader</p>\n<p>shader的作用就是通过paint对画布进行指定的bitmap的填充，填充时有三种模式</p>\n<p>CLAMP  — 拉伸的是图片最后的那一个像素，不断重复<br>REPEAT — 横向纵向不断重复<br>MIRROR — 横向不断翻转重复，纵向不断翻转重复</p>\n<ol>\n<li>PathEffect</li>\n</ol>\n<p>patheffect是指用各种笔触效果来绘制一个路径。</p>\n<p>CornerPathEffect:   将拐角处变的圆滑<br>DiscretePathEffect:    使用这个之后线段上会出现很多杂点<br>DashPathEffect:        使用这个可以绘制虚线，用一个数组来设置各个点之间的间隔，此后绘制虚线时就重复这样的间隔进行绘制，另一个参数phase可以用来绘制时数组的一个偏移量，可以通过设置值来实现路径的动态效果。<br>PathDashPathEffect: 与dashpatheffect类似，不过功能更强大，可以设置点的图形，例如方形点的虚线，圆形点的虚线<br>ComposePathEffect   可以通过composepatheffect来组合patheffect，这个方法的功能就是将任意的两种路径特性组合起来形成一个新的效果。</p>\n<h1 id=\"SurfaceView\"><a href=\"#SurfaceView\" class=\"headerlink\" title=\"SurfaceView\"></a>SurfaceView</h1><ol>\n<li>surfaceview 和view的区别</li>\n</ol>\n<p>对view来说，android系统通过发出VSYNC信号来进行屏幕的重绘，刷新的间隔为16ms，如果在16ms内view完成了所需要执行的所有操作，那么用户在视觉上就不会产生卡顿的感觉。但是执行的操作逻辑太多，在需要频繁刷新的界面上，就会阻塞主线程，因此android提供了surfaceview。</p>\n<p>view主要适用于主动更新的情况下，而surfaceview主要适用于被动更新，例如频繁刷新<br>view在主线程中对画面进行刷新，surfaceview则通常会通过一个子线程来进行页面的刷新<br>view在绘图时没有使用双缓冲机制，而surfaceview在底层实现机制中就已经实现了双缓冲机制</p>\n<ol>\n<li>surfaceview的使用</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>本章用于做群英传第六章《Android绘图机制与处理技巧》的学习笔记。主要是整理自己不熟悉的知识点。</p>\n<h1 id=\"屏幕的尺寸信息\"><a href=\"#屏幕的尺寸信息\" class=\"headerlink\" title=\"屏幕的尺寸信息\"></a>屏幕的尺寸信息</h1><ol>\n<li>屏幕大小</li>\n</ol>\n<p>屏幕大小指对角线的长度，一般使用寸来度量，寸指英寸，一英寸为2.54cm</p>\n<ol>\n<li>分辨率</li>\n</ol>\n<p>分辨率指手机屏幕的像素点个数。1920*1080指宽有1920个像素点，高有1080个像素点</p>\n<ol>\n<li>ppi</li>\n</ol>\n<p>pixel per inch，每英寸像素，又称为dpi，为对角线的像素点除以屏幕大小得到。</p>\n<h1 id=\"系统屏幕密度\"><a href=\"#系统屏幕密度\" class=\"headerlink\" title=\"系统屏幕密度\"></a>系统屏幕密度</h1><p>根据dpi大小来进行设置，系统定义了几个标准的dpi值。</p>\n<p>120: ldpi<br>160: mdpi<br>240: hdpi<br>320: xhdpi<br>480: xxhdpi</p>\n<h1 id=\"独立像素密度-dp\"><a href=\"#独立像素密度-dp\" class=\"headerlink\" title=\"独立像素密度 dp\"></a>独立像素密度 dp</h1><p>在mdpi，即dpi为160时， 1dp = 1px。之后顺推即可，xxhdpi为160的3倍，即1dp = 3px</p>\n<p>dp涉及到像素工具类的使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DisplayUtil&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int px2dp(Context context, float px)&#123;</span><br><span class=\"line\">\t\tfinal float scale = context.getResource().getDisplayMetrics().density;</span><br><span class=\"line\">\t\treturn (int)(px/scale + 0.5f);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int dp2px(Context context, float dp)&#123;</span><br><span class=\"line\">\t\tfinal float scale = context.getResource().getDisplayMetrics().density;</span><br><span class=\"line\">\t\treturn (int)(dp*scale + 0.5f);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int px2sp(Context context, float px)&#123;</span><br><span class=\"line\">\t\tfinal float fontScale = context.getResource().getDisplayMetrics().scaledDensity;</span><br><span class=\"line\">\t\treturn (int)(px/fontScale + 0.5f);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int sp2dp(Context context, float sp)&#123;</span><br><span class=\"line\">\t\tfinal float fontScale = context.getResource().getDisplayMetrics().scaledDensity;</span><br><span class=\"line\">\t\treturn (int)(sp*fontScale + 0.5f);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//以上为使用公式进行换算的</span><br><span class=\"line\">\t//还可以使用TypedValue进行换算</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int dp2px(int dp)&#123;</span><br><span class=\"line\">\t\treturn (int)TypedValue.applyDimension(</span><br><span class=\"line\">\t\t\tTypedValue.COMPLEX_UNIT_DIP,</span><br><span class=\"line\">\t\t\tdp,</span><br><span class=\"line\">\t\t\tgetResources().getDisplayMetrics());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int sp2px(int sp)&#123;</span><br><span class=\"line\">\t\treturn (int)TypeValue.applyDimension(</span><br><span class=\"line\">\t\t\tTypedValue.COMPLEX_UNIT_SP,</span><br><span class=\"line\">\t\t\tsp,</span><br><span class=\"line\">\t\t\tgetResources().getDisplayMetrics());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2D绘图基础\"><a href=\"#2D绘图基础\" class=\"headerlink\" title=\"2D绘图基础\"></a>2D绘图基础</h1><p>2d绘图即使用系统提供的Canvas对象来提供绘图方法，该章主要是复习一些常用的api。</p>\n<ol>\n<li>paint</li>\n</ol>\n<p>setAntiAlias():设置抗锯齿效果<br>setColor():设置画笔的颜色<br>setARGB():设置画笔的啊a,r,g,b值<br>setAlpha():设置画笔透明度<br>setTextSize():设置字体的尺寸<br>setStyle():设置画笔的风格（空心或者实心）<br>setStrokeWidth():设置空心边框的宽度</p>\n<ol>\n<li>canvas</li>\n</ol>\n<p>canvas.drawPoint(x, y, paint): 绘制点</p>\n<p>canvas.drawLine(startX, startY, endX, endY, paint): 绘制直线</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float[] pts = &#123;</span><br><span class=\"line\">\tstartX1, startY1, endX1, endY1,</span><br><span class=\"line\">\t... ...</span><br><span class=\"line\">\tstartXn, startYn, endXn, endYn</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">canvas.drawLines(pts, paint);</span><br><span class=\"line\">//画多条直线</span><br></pre></td></tr></table></figure>\n<p>canvas.drawRect(left, top, right, bottom, paint): 绘制矩形</p>\n<p>canvas.drawRoundRect(left, top, right, bottom, radiusX, radiuxY, paint):绘制圆角矩形</p>\n<p>canvas.drawCircle(circleX, circleY, radius, paint):绘制圆</p>\n<p>canvas.drawArc(left, top, right, bottom, startAngle, sweepAngle, useCenter, paint):绘制弧形，扇形，区别在于useCenter</p>\n<p>canvas.drawOval(left, top, right, bottom, paint):画椭圆</p>\n<p>canvas.drawText(text, startX, startY, paint):绘制文本</p>\n<p>canvas.drawPosText(text, new float[]{X1, Y1, X2, Y2… … Xn, Yn}, paint):在制定位置绘制文本</p>\n<p>canvas.drawPath(path, paint):绘制路径</p>\n<h1 id=\"Android-xml绘图\"><a href=\"#Android-xml绘图\" class=\"headerlink\" title=\"Android xml绘图\"></a>Android xml绘图</h1><ol>\n<li>Bitmap</li>\n</ol>\n<p>在xml中使用bitmap<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">\tandroid:src=&quot;@drawable/ic_launcher&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>Shape</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;shape xmlns:android:&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">\tandroid:shape=[&quot;rectangle&quot; | &quot;oval&quot; | &quot;line&quot; | &quot;ring&quot;]&gt;</span><br><span class=\"line\">\t//默认为rectangle</span><br><span class=\"line\">\t&lt;corners //shape = &quot;rectangle&quot; 有用</span><br><span class=\"line\">\t\t// 半径，会被后面的单个半径属性覆盖，默认为1dp</span><br><span class=\"line\">\t\tandroid:radius=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:topLeftRadius=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:topRightRadius=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:bottomLeftRadius=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:bottomRightRadius=&quot;integer&quot;/&gt;</span><br><span class=\"line\">\t&lt;gradient //渐变</span><br><span class=\"line\">\t\tandroid:angle=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:centerX=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:centerY=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:centerColor=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:endColor=&quot;color&quot;</span><br><span class=\"line\">\t\tandroid:gradientRadius=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:startColor=&quot;color&quot;</span><br><span class=\"line\">\t\tandroid:type=[&quot;linear&quot;| &quot;radius&quot; | &quot;sweep&quot;]</span><br><span class=\"line\">\t\tandroid:useLevel=[&quot;true&quot; | &quot;false&quot;]/&gt;</span><br><span class=\"line\">\t&lt;padding</span><br><span class=\"line\">\t\tandroid:left=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:top=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:right=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:bottom=&quot;integer&quot;/&gt;</span><br><span class=\"line\">\t&lt;size // 指定大小，一般用在imageview配合scaletype属性使用</span><br><span class=\"line\">\t\tandroid:width=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:height=&quot;integer&quot;/&gt;</span><br><span class=\"line\">\t&lt;solid // 填充颜色</span><br><span class=\"line\">\t\tandroid:color=&quot;color&quot;/&gt;</span><br><span class=\"line\">\t&lt;stroke //指定边框</span><br><span class=\"line\">\t\tandroid:width=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:color=&quot;color&quot;</span><br><span class=\"line\">\t\tandroid:dashWidth=&quot;integer&quot; //虚线宽度</span><br><span class=\"line\">\t\tandroid:dashGap=&quot;integer&quot; // 虚线间隔宽度</span><br><span class=\"line\">\t\t/&gt;</span><br><span class=\"line\">&lt;/shape&gt;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Layer</li>\n</ol>\n<p>layer中可以使用层级来进行叠加，主要是用item，item可以使用drawable，也可使用shape</p>\n<ol>\n<li>Selector</li>\n</ol>\n<p>Selector用于帮开发者实现静态绘图中的事件反馈，通过不同的事件设置不同的图像。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class=\"line\">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class=\"line\">\t//默认时的背景图片</span><br><span class=\"line\">\t&lt;item android:drawable=&quot;@drawable/x1&quot;/&gt;</span><br><span class=\"line\">\t//没有焦点时的图片</span><br><span class=\"line\">\t&lt;item android:state_window_focused=&quot;false&quot; android:drawable=&quot;@drawable/x2&quot;/&gt;</span><br><span class=\"line\">\t//非触摸模式下获得焦点并单击时的背景图片</span><br><span class=\"line\">\t&lt;item android:state_focuse=&quot;true&quot; android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/x3&quot;/&gt;</span><br><span class=\"line\">\t//触摸模式下单击时的背景图片</span><br><span class=\"line\">\t&lt;item android:state_focuse=&quot;false&quot; android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/x4&quot;/&gt;</span><br><span class=\"line\">\t//选中时的背景图片</span><br><span class=\"line\">\t&lt;item android:state_selected=&quot;true&quot; android:drawable=&quot;@drawable/x5&quot;/&gt;</span><br><span class=\"line\">\t//获得焦点时的背景图片</span><br><span class=\"line\">\t&lt;item android:state_focused=&quot;true&quot; android:drawable=&quot;@drawable/x6&quot;/&gt;</span><br><span class=\"line\">&lt;/selector&gt;</span><br></pre></td></tr></table></figure>\n<p>以上可以用于制作view的触摸反馈。</p>\n<h1 id=\"android-绘图技巧\"><a href=\"#android-绘图技巧\" class=\"headerlink\" title=\"android 绘图技巧\"></a>android 绘图技巧</h1><p>之上的是基本绘图技巧，之下的是常用绘图技巧</p>\n<ol>\n<li>Canvas</li>\n</ol>\n<p>Canvas.save(): 将之前的所有绘制图像保存起来，之后的操作就好像在一个新的图层上面操作一样。</p>\n<p>Canvas.restore(): 用于合并图层，可以用于将save之后绘制的所有图像与save之前的图像合并</p>\n<p>Canvas.translate():调用translate(x, y)操作可以将原点(0, 0)移动到(x, y)之后的所有操作都将以(x, y)为原点执行</p>\n<p>Canvas.rotate():调用rotate(degree)之后可以将canvas调转一定的角度。</p>\n<ol>\n<li>Layer图层</li>\n</ol>\n<p>Android通过调用saveLayer()方法，saveLayerAlpha()方法将一个图层入栈，使用restore()方法,restoreToCount()方法将一个图层出栈。出栈的时候，会把图像绘制到上层Canvas上。</p>\n<h1 id=\"画笔特效处理\"><a href=\"#画笔特效处理\" class=\"headerlink\" title=\"画笔特效处理\"></a>画笔特效处理</h1><ol>\n<li>PorterDuffXferMode</li>\n</ol>\n<p>该模式控制的是两个图像间的混合显示模式。dst是先画的图形，src是后画的图形。</p>\n<ol>\n<li>Shader</li>\n</ol>\n<p>shader被称为着色器，渲染器。可以用来实现一系列的渐变、渲染效果。</p>\n<p>其中shader包括：<br>BitmapShader   —  位图shader<br>LinearGradient —  线性shader<br>RadialGradient —  光束shader<br>SweepGradient  —  梯度shader<br>ComposeShader  —  混合shader</p>\n<p>shader的作用就是通过paint对画布进行指定的bitmap的填充，填充时有三种模式</p>\n<p>CLAMP  — 拉伸的是图片最后的那一个像素，不断重复<br>REPEAT — 横向纵向不断重复<br>MIRROR — 横向不断翻转重复，纵向不断翻转重复</p>\n<ol>\n<li>PathEffect</li>\n</ol>\n<p>patheffect是指用各种笔触效果来绘制一个路径。</p>\n<p>CornerPathEffect:   将拐角处变的圆滑<br>DiscretePathEffect:    使用这个之后线段上会出现很多杂点<br>DashPathEffect:        使用这个可以绘制虚线，用一个数组来设置各个点之间的间隔，此后绘制虚线时就重复这样的间隔进行绘制，另一个参数phase可以用来绘制时数组的一个偏移量，可以通过设置值来实现路径的动态效果。<br>PathDashPathEffect: 与dashpatheffect类似，不过功能更强大，可以设置点的图形，例如方形点的虚线，圆形点的虚线<br>ComposePathEffect   可以通过composepatheffect来组合patheffect，这个方法的功能就是将任意的两种路径特性组合起来形成一个新的效果。</p>\n<h1 id=\"SurfaceView\"><a href=\"#SurfaceView\" class=\"headerlink\" title=\"SurfaceView\"></a>SurfaceView</h1><ol>\n<li>surfaceview 和view的区别</li>\n</ol>\n<p>对view来说，android系统通过发出VSYNC信号来进行屏幕的重绘，刷新的间隔为16ms，如果在16ms内view完成了所需要执行的所有操作，那么用户在视觉上就不会产生卡顿的感觉。但是执行的操作逻辑太多，在需要频繁刷新的界面上，就会阻塞主线程，因此android提供了surfaceview。</p>\n<p>view主要适用于主动更新的情况下，而surfaceview主要适用于被动更新，例如频繁刷新<br>view在主线程中对画面进行刷新，surfaceview则通常会通过一个子线程来进行页面的刷新<br>view在绘图时没有使用双缓冲机制，而surfaceview在底层实现机制中就已经实现了双缓冲机制</p>\n<ol>\n<li>surfaceview的使用</li>\n</ol>\n"},{"title":"viewgroup测量","date":"2018-01-02T15:07:40.000Z","_content":"ViewGroup会去管理子view，当ViewGroup的大小为wrap_content时，ViewGroup就需要对子View进行遍历，以便获得所有的子View的大小，从而决定自己的大小。在其他模式下则会通过具体的制定值来设置自身的大小。\nViewGroup在测量时通过遍历所有的子view，从而调用子view的measure方法来获得每个子view的测量结果。\n当子view测量结束时，就会将子view放到合适的位置，这个过程就是子view的layout过程。viewgroup在执行layout过程时，也同样是使用遍历的方法来调用子view的layout方法，并指定其具体显示的位置，从而来决定其布局位置。\n在自定义viewgroup中，通常会重写layout方法来控制子view显示位置的逻辑。同样如果是wrap_content，也必须重写onmeasure方法，这点与view是相同的。\n\n# viewgroup的绘制\n\nviewgroup通常不需要绘制，因为本身没有什么值得绘制的东西，如果不是需要指定viewgroup的颜色，甚至连ondraw方法都不会调用。但是viewgroup会使用dispatchDraw()方法来绘制子view","source":"_posts/viewgroup测量.md","raw":"---\ntitle: viewgroup测量\ndate: 2018-01-02 23:07:40\ntags: android\n---\nViewGroup会去管理子view，当ViewGroup的大小为wrap_content时，ViewGroup就需要对子View进行遍历，以便获得所有的子View的大小，从而决定自己的大小。在其他模式下则会通过具体的制定值来设置自身的大小。\nViewGroup在测量时通过遍历所有的子view，从而调用子view的measure方法来获得每个子view的测量结果。\n当子view测量结束时，就会将子view放到合适的位置，这个过程就是子view的layout过程。viewgroup在执行layout过程时，也同样是使用遍历的方法来调用子view的layout方法，并指定其具体显示的位置，从而来决定其布局位置。\n在自定义viewgroup中，通常会重写layout方法来控制子view显示位置的逻辑。同样如果是wrap_content，也必须重写onmeasure方法，这点与view是相同的。\n\n# viewgroup的绘制\n\nviewgroup通常不需要绘制，因为本身没有什么值得绘制的东西，如果不是需要指定viewgroup的颜色，甚至连ondraw方法都不会调用。但是viewgroup会使用dispatchDraw()方法来绘制子view","slug":"viewgroup测量","published":1,"updated":"2018-01-09T03:00:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7fag000nd41if35qb6sk","content":"<p>ViewGroup会去管理子view，当ViewGroup的大小为wrap_content时，ViewGroup就需要对子View进行遍历，以便获得所有的子View的大小，从而决定自己的大小。在其他模式下则会通过具体的制定值来设置自身的大小。<br>ViewGroup在测量时通过遍历所有的子view，从而调用子view的measure方法来获得每个子view的测量结果。<br>当子view测量结束时，就会将子view放到合适的位置，这个过程就是子view的layout过程。viewgroup在执行layout过程时，也同样是使用遍历的方法来调用子view的layout方法，并指定其具体显示的位置，从而来决定其布局位置。<br>在自定义viewgroup中，通常会重写layout方法来控制子view显示位置的逻辑。同样如果是wrap_content，也必须重写onmeasure方法，这点与view是相同的。</p>\n<h1 id=\"viewgroup的绘制\"><a href=\"#viewgroup的绘制\" class=\"headerlink\" title=\"viewgroup的绘制\"></a>viewgroup的绘制</h1><p>viewgroup通常不需要绘制，因为本身没有什么值得绘制的东西，如果不是需要指定viewgroup的颜色，甚至连ondraw方法都不会调用。但是viewgroup会使用dispatchDraw()方法来绘制子view</p>\n","site":{"data":{}},"excerpt":"","more":"<p>ViewGroup会去管理子view，当ViewGroup的大小为wrap_content时，ViewGroup就需要对子View进行遍历，以便获得所有的子View的大小，从而决定自己的大小。在其他模式下则会通过具体的制定值来设置自身的大小。<br>ViewGroup在测量时通过遍历所有的子view，从而调用子view的measure方法来获得每个子view的测量结果。<br>当子view测量结束时，就会将子view放到合适的位置，这个过程就是子view的layout过程。viewgroup在执行layout过程时，也同样是使用遍历的方法来调用子view的layout方法，并指定其具体显示的位置，从而来决定其布局位置。<br>在自定义viewgroup中，通常会重写layout方法来控制子view显示位置的逻辑。同样如果是wrap_content，也必须重写onmeasure方法，这点与view是相同的。</p>\n<h1 id=\"viewgroup的绘制\"><a href=\"#viewgroup的绘制\" class=\"headerlink\" title=\"viewgroup的绘制\"></a>viewgroup的绘制</h1><p>viewgroup通常不需要绘制，因为本身没有什么值得绘制的东西，如果不是需要指定viewgroup的颜色，甚至连ondraw方法都不会调用。但是viewgroup会使用dispatchDraw()方法来绘制子view</p>\n"},{"title":"view的测量和绘制","date":"2018-01-02T04:38:03.000Z","_content":"系统绘制一个view，如同蒙着眼睛的小孩拿着笔在画板上画出一个指定的图案。因此需要一个人在旁边指导他如何去画。\nAndroid就是那个蒙着眼睛画画的人，开发者需要告诉它如何去画。\n\n# View的测量\n\n去画一个图形，就必须知道它的大小和位置。\nAndroid系统在绘制view之前，也必须对view进行测量，告诉系统该画一个多大的view。这个过程在onMeasure()中进行。\n\n## MeasureSpec\n\nmeasurespec是一个协助测量view的类。它是一个32位的int值，其中高2位为测量的模式，低30位为测量的大小。使用位运算是为了提高并优化效率。\n测量的模式分为以下三种：\n\n1. EXACTLY\n精确模式，当我们将控件的layout_width属性或者layout_height属性指定为具体数值时，比如android:layout_height=\"100dp\",或者指定为match_parent属性时，系统使用的是EXACTLY模式。\n\n2. AT_MOST\n最大值模式，当控件的layout_width属性或者layout_height属性指定为wrap_content时，控件的大小一般随着子控件或内容的变化而变化，此时控件的尺寸只要不超过父控件的最大尺寸即可。\n\n3. UNSPECIFIED\n不指定大小测量模式。view想多大就多大，通常在绘制自定义view时才使用。\n\nView类默认的onMeasure()方法只能支持EXACTLY模式。如果要让自定义view支持wrap_content属性，必须重写onMeasure方法来指定wrap_content时的大小。\n\n## 测量的步骤\n\n1. 从MeasureSpec对象中提取具体的测量模式和大小\n\n```\n\tint specMode = MeasureSpec.getMode(measureSpec);\n\tint specSize = MeasureSpec.getSize(measureSpec);\n\n```\n\n2. 通过判断测量的模式，给出不同的判断值。当specMode为EXACTLY时，直接使用指定的specSize即可；当specMode为其他两种模式时，需要给它一个默认的大小。特别的，如果指定wrap_content属性，即AT_MOST模式，需要取出我们制定的大小与specSize中最小的一个来作为最后的测量值。\n\n```\nprivate int measureWidth(int measureSpec){\n\tint result = 0;\n\tint specMode = MeasureSpec.getMode(measureSpec);\n\tint specSize = MeasureSpec.getSize(measureSpec);\n\n\tif(specMode == MeasureSpec.EXACTLY){\n\t\tresult = specSize;\n\t}else{\n\t\tresult = 200;\n\t\tif(specMpde == MeasureSpec.AT_MOST){\n\t\t\tresult = Math.min(result, specSize);\n\t\t}\n\t}\n\treturn result;\n}\n```\n\n","source":"_posts/view的测量和绘制.md","raw":"---\ntitle: view的测量和绘制\ndate: 2018-01-02 12:38:03\ntags: android\n---\n系统绘制一个view，如同蒙着眼睛的小孩拿着笔在画板上画出一个指定的图案。因此需要一个人在旁边指导他如何去画。\nAndroid就是那个蒙着眼睛画画的人，开发者需要告诉它如何去画。\n\n# View的测量\n\n去画一个图形，就必须知道它的大小和位置。\nAndroid系统在绘制view之前，也必须对view进行测量，告诉系统该画一个多大的view。这个过程在onMeasure()中进行。\n\n## MeasureSpec\n\nmeasurespec是一个协助测量view的类。它是一个32位的int值，其中高2位为测量的模式，低30位为测量的大小。使用位运算是为了提高并优化效率。\n测量的模式分为以下三种：\n\n1. EXACTLY\n精确模式，当我们将控件的layout_width属性或者layout_height属性指定为具体数值时，比如android:layout_height=\"100dp\",或者指定为match_parent属性时，系统使用的是EXACTLY模式。\n\n2. AT_MOST\n最大值模式，当控件的layout_width属性或者layout_height属性指定为wrap_content时，控件的大小一般随着子控件或内容的变化而变化，此时控件的尺寸只要不超过父控件的最大尺寸即可。\n\n3. UNSPECIFIED\n不指定大小测量模式。view想多大就多大，通常在绘制自定义view时才使用。\n\nView类默认的onMeasure()方法只能支持EXACTLY模式。如果要让自定义view支持wrap_content属性，必须重写onMeasure方法来指定wrap_content时的大小。\n\n## 测量的步骤\n\n1. 从MeasureSpec对象中提取具体的测量模式和大小\n\n```\n\tint specMode = MeasureSpec.getMode(measureSpec);\n\tint specSize = MeasureSpec.getSize(measureSpec);\n\n```\n\n2. 通过判断测量的模式，给出不同的判断值。当specMode为EXACTLY时，直接使用指定的specSize即可；当specMode为其他两种模式时，需要给它一个默认的大小。特别的，如果指定wrap_content属性，即AT_MOST模式，需要取出我们制定的大小与specSize中最小的一个来作为最后的测量值。\n\n```\nprivate int measureWidth(int measureSpec){\n\tint result = 0;\n\tint specMode = MeasureSpec.getMode(measureSpec);\n\tint specSize = MeasureSpec.getSize(measureSpec);\n\n\tif(specMode == MeasureSpec.EXACTLY){\n\t\tresult = specSize;\n\t}else{\n\t\tresult = 200;\n\t\tif(specMpde == MeasureSpec.AT_MOST){\n\t\t\tresult = Math.min(result, specSize);\n\t\t}\n\t}\n\treturn result;\n}\n```\n\n","slug":"view的测量和绘制","published":1,"updated":"2018-01-09T03:00:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7fah000qd41ief8s222l","content":"<p>系统绘制一个view，如同蒙着眼睛的小孩拿着笔在画板上画出一个指定的图案。因此需要一个人在旁边指导他如何去画。<br>Android就是那个蒙着眼睛画画的人，开发者需要告诉它如何去画。</p>\n<h1 id=\"View的测量\"><a href=\"#View的测量\" class=\"headerlink\" title=\"View的测量\"></a>View的测量</h1><p>去画一个图形，就必须知道它的大小和位置。<br>Android系统在绘制view之前，也必须对view进行测量，告诉系统该画一个多大的view。这个过程在onMeasure()中进行。</p>\n<h2 id=\"MeasureSpec\"><a href=\"#MeasureSpec\" class=\"headerlink\" title=\"MeasureSpec\"></a>MeasureSpec</h2><p>measurespec是一个协助测量view的类。它是一个32位的int值，其中高2位为测量的模式，低30位为测量的大小。使用位运算是为了提高并优化效率。<br>测量的模式分为以下三种：</p>\n<ol>\n<li><p>EXACTLY<br>精确模式，当我们将控件的layout_width属性或者layout_height属性指定为具体数值时，比如android:layout_height=”100dp”,或者指定为match_parent属性时，系统使用的是EXACTLY模式。</p>\n</li>\n<li><p>AT_MOST<br>最大值模式，当控件的layout_width属性或者layout_height属性指定为wrap_content时，控件的大小一般随着子控件或内容的变化而变化，此时控件的尺寸只要不超过父控件的最大尺寸即可。</p>\n</li>\n<li><p>UNSPECIFIED<br>不指定大小测量模式。view想多大就多大，通常在绘制自定义view时才使用。</p>\n</li>\n</ol>\n<p>View类默认的onMeasure()方法只能支持EXACTLY模式。如果要让自定义view支持wrap_content属性，必须重写onMeasure方法来指定wrap_content时的大小。</p>\n<h2 id=\"测量的步骤\"><a href=\"#测量的步骤\" class=\"headerlink\" title=\"测量的步骤\"></a>测量的步骤</h2><ol>\n<li>从MeasureSpec对象中提取具体的测量模式和大小</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int specMode = MeasureSpec.getMode(measureSpec);</span><br><span class=\"line\">int specSize = MeasureSpec.getSize(measureSpec);</span><br></pre></td></tr></table></figure>\n<ol>\n<li>通过判断测量的模式，给出不同的判断值。当specMode为EXACTLY时，直接使用指定的specSize即可；当specMode为其他两种模式时，需要给它一个默认的大小。特别的，如果指定wrap_content属性，即AT_MOST模式，需要取出我们制定的大小与specSize中最小的一个来作为最后的测量值。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int measureWidth(int measureSpec)&#123;</span><br><span class=\"line\">\tint result = 0;</span><br><span class=\"line\">\tint specMode = MeasureSpec.getMode(measureSpec);</span><br><span class=\"line\">\tint specSize = MeasureSpec.getSize(measureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">\tif(specMode == MeasureSpec.EXACTLY)&#123;</span><br><span class=\"line\">\t\tresult = specSize;</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">\t\tresult = 200;</span><br><span class=\"line\">\t\tif(specMpde == MeasureSpec.AT_MOST)&#123;</span><br><span class=\"line\">\t\t\tresult = Math.min(result, specSize);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>系统绘制一个view，如同蒙着眼睛的小孩拿着笔在画板上画出一个指定的图案。因此需要一个人在旁边指导他如何去画。<br>Android就是那个蒙着眼睛画画的人，开发者需要告诉它如何去画。</p>\n<h1 id=\"View的测量\"><a href=\"#View的测量\" class=\"headerlink\" title=\"View的测量\"></a>View的测量</h1><p>去画一个图形，就必须知道它的大小和位置。<br>Android系统在绘制view之前，也必须对view进行测量，告诉系统该画一个多大的view。这个过程在onMeasure()中进行。</p>\n<h2 id=\"MeasureSpec\"><a href=\"#MeasureSpec\" class=\"headerlink\" title=\"MeasureSpec\"></a>MeasureSpec</h2><p>measurespec是一个协助测量view的类。它是一个32位的int值，其中高2位为测量的模式，低30位为测量的大小。使用位运算是为了提高并优化效率。<br>测量的模式分为以下三种：</p>\n<ol>\n<li><p>EXACTLY<br>精确模式，当我们将控件的layout_width属性或者layout_height属性指定为具体数值时，比如android:layout_height=”100dp”,或者指定为match_parent属性时，系统使用的是EXACTLY模式。</p>\n</li>\n<li><p>AT_MOST<br>最大值模式，当控件的layout_width属性或者layout_height属性指定为wrap_content时，控件的大小一般随着子控件或内容的变化而变化，此时控件的尺寸只要不超过父控件的最大尺寸即可。</p>\n</li>\n<li><p>UNSPECIFIED<br>不指定大小测量模式。view想多大就多大，通常在绘制自定义view时才使用。</p>\n</li>\n</ol>\n<p>View类默认的onMeasure()方法只能支持EXACTLY模式。如果要让自定义view支持wrap_content属性，必须重写onMeasure方法来指定wrap_content时的大小。</p>\n<h2 id=\"测量的步骤\"><a href=\"#测量的步骤\" class=\"headerlink\" title=\"测量的步骤\"></a>测量的步骤</h2><ol>\n<li>从MeasureSpec对象中提取具体的测量模式和大小</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int specMode = MeasureSpec.getMode(measureSpec);</span><br><span class=\"line\">int specSize = MeasureSpec.getSize(measureSpec);</span><br></pre></td></tr></table></figure>\n<ol>\n<li>通过判断测量的模式，给出不同的判断值。当specMode为EXACTLY时，直接使用指定的specSize即可；当specMode为其他两种模式时，需要给它一个默认的大小。特别的，如果指定wrap_content属性，即AT_MOST模式，需要取出我们制定的大小与specSize中最小的一个来作为最后的测量值。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int measureWidth(int measureSpec)&#123;</span><br><span class=\"line\">\tint result = 0;</span><br><span class=\"line\">\tint specMode = MeasureSpec.getMode(measureSpec);</span><br><span class=\"line\">\tint specSize = MeasureSpec.getSize(measureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">\tif(specMode == MeasureSpec.EXACTLY)&#123;</span><br><span class=\"line\">\t\tresult = specSize;</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">\t\tresult = 200;</span><br><span class=\"line\">\t\tif(specMpde == MeasureSpec.AT_MOST)&#123;</span><br><span class=\"line\">\t\t\tresult = Math.min(result, specSize);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"“rxjava2.0”","date":"2017-12-21T08:24:02.000Z","_content":"#[Rxjava2.0](http://blog.csdn.net/flybasker/article/details/78703295)\n\n## 基础概念\n\nObservable：在观察者模式中称为“被观察者”；\nObserver：观察者模式中的“观察者”，可接收Observable发送的数据；\nsubscribe：订阅，观察者与被观察者，通过Observable的subscribe()方法进行订阅；\nSubscriber：也是一种观察者，在2.0中 它与Observer没什么实质的区别，不同的是 Subscriber要与Flowable(也是一种被观察者)联合使用，该部分 内容是2.0新增的，后续文章再介绍。Obsesrver用于订阅Observable，而Subscriber用于订阅Flowable.\n\n## Rxjava中定义的事件方法\n\nonNext(),普通事件,按照队列依次进行处理.\nonComplete(),事件队列完结时调用该方法\nonError(),事件处理过程中出现异常时，onError()触发，同时队列终止,不再有事件发出.\nonSubscribe(),RxJava 2.0 中新增的，传递参数为Disposable,可用于切断接收事件让Observable (被观察者)开启子线程执行耗操作，完成耗时操作后，触发回调，通知Observer (观察者)进行主线程UI更新\n\n## observable的几种创建方式\n1. just()方式\n使用just( )，将创建一个Observable并自动调用onNext( )发射数据。\n也就是通过just( )方式 直接触发onNext()，just中传递的参数将直接在Observer的onNext()方法中接收到。\n\n2. fromIterable()方式\n使用fromIterable()，遍历集合，发送每个item.多次自动调用onNext()方法，每次传入一个item.\n注意：Collection接口是Iterable接口的子接口，所以所有Collection接口的实现类都可以作为Iterable对象直接传入fromIterable()    方法。\n\n3. defer()方式\n当观察者订阅时,才创建Observable，并且针对每个观察者创建都是一个新的Observable.\n通过Callable中的回调方法call(),决定使用以何种方式来创建这个Observable对象,当订阅后，发送事件.\n\n4. interval( )方式\n创建一个按固定时间间隔发射整数序列的Observable，可用作定时器。按照固定时间间隔来调用onNext()方法。\n\n5. timer( )方式\n通过此种创建一个Observable,它在一个给定的延迟后发射一个特殊的值，即表示延迟指定时间后，调用onNext()方法。\n\n6. range( )方式,range(x,y)\n创建一个发射特定整数序列的Observable，第一个参数x为起始值，第二个y为发送的个数，如果y为0则不发送，y为负数则抛异常。\nrange(1,5)\n上述表示发射1到5的数。即调用5次Next()方法，依次传入1-5数字。\n\n7. repeat( )方式\n创建一个Observable，该Observable的事件可以重复调用。\n\n## ObservableEmitter\nEmitter是发射器的意思,就是用来发出事件的，它可以发出三种类型的事件 \n通过调用onNext(T value),发出next事件 \n通过调用onComplete(),发出complete事件 \n通过调用onError(Throwable error),发出error事件 \n注意事项: \nonComplete和onError唯一并且互斥 \n发送多个onComplete, 第一个onComplete接收到,就不再接收了. \n发送多个onError, 则收到第二个onError事件会导致程序会崩溃. \n不可以随意乱七八糟发射事件，需要满足一定的规则： \n上游可以发送无限个onNext, 下游也可以接收无限个onNext. \n当上游发送了一个onComplete后, 上游onComplete之后的事件将会继续发送, 而下游收到onComplete事件之后将不再继续接收事件. \n上游发送了一个onError后, 上游onError之后的事件将继续发送, 而下游收到onError事件之后将不再继续接收事件. \n上游可以不发送onComplete或onError. \n最为关键的是onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError \n\n## Disposable\n一次性,它理解成两根管道之间的一个机关, 当调用它的dispose()方法时, 它就会将两根管道切断, 从而导致下游收不到事件. \n在RxJava中,用它来切断Observer(观察者)与Observable(被观察者)之间的连接，当调用它的dispose()方法时, 它就会将Observer(观察者)与Observable(被观察者)之间的连接切断, 从而导致Observer(观察者)收不到事件。 \n注意: 调用dispose()并不会导致上游不再继续发送事件, 上游会继续发送剩余的事件 \n\n## 线程调度\n1. Schedulers.immediate(): \n直接在当前线程运行，相当于不指定线程。这是默认的Scheduler。\n\n2. Schedulers.newThread(): \n总是启用新线程，并在新线程执行操作。\n\n3. Schedulers.io(): I/O \n操作（读写文件、读写数据库、网络信息交互等）所使用的Scheduler。行为模式和newThread()差不多，区别在于io()的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下io()比newThread()更有效率。不要把计算工作放在io()中，可以避免创建不必要的线程。\n\n4. Schedulers.computation(): \n计算所使用的Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个Scheduler使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在computation()中，否则 I/O 操作的等待时间会浪费 CPU。\n\n5. AndroidSchedulers.mainThread()，\nAndroid专用线程，指定操作在主线程运行。\n\n如何切换线程呢？RxJava中提供了两个方法：\n    subscribeOn() 和 observeOn() ，\n两者的不同点在于：\n\nsubscribeOn(): 指定subscribe()订阅所发生的线程，或者叫做事件产生的线程。\n\nobserveOn(): 指定Observer所运行在的线程，即onNext()执行的线程。或者叫做事件消费的线程。\n\n## 操作符\n操作符就是用于在Observable和最终的Observer之间，通过转换Observable为其他观察者对象的过程，修改发出的事件,最终将最简洁的数据传递给Observer对象. \n\n1. map()操作符，就是把原来的Observable对象转换成另一个Observable对象，同时将传输的数据进行一些灵活的操作，方便Observer获得想要的数据形式。\n举例:\n```\nObservable<Integer> observable = Observable\n        .just(\"hello\")\n        .map(new Function<String, Integer>() {\n            @Override\n            public Integer apply(String s) throws Exception {\n                return s.length();\n            }\n        });\n```\n\n2. flatMap()操作符 \nflatMap()对于数据的转换比map()更加彻底，如果发送的数据是集合，flatmap()重新生成一个Observable对象，并把数据转换成Observer想 要的数据形式。它可以返回任何它想返回的Observable对象。 \n举例:\n```\nObservable.just(list)\n       .flatMap(new Function<List<String>, ObservableSource<?>>() {\n            @Override\n            public ObservableSource<?> apply(List<String> strings) throws Exception {\n                return Observable.fromIterable(strings);\n            }\n        });\n```\n\n3. filter()操作符 \nfilter()操作符根据它的test()方法中，根据自己想过滤的数据加入相应的逻辑判断，返回true则表示数据满足条件，返回false则表示数据需要被过滤。最后过滤出的数据将加入到新的Observable对象中，方便传递给Observer想要的数据形式。 \n举例:\n```\nObservable\n        .just(list)\n        .flatMap(new Function<List<String>, ObservableSource<?>>() {\n            @Override\n            public ObservableSource<?> apply(List<String> strings) throws Exception {\n                return Observable.fromIterable(strings);\n            }\n        }).filter(new Predicate<Object>() {\n            @Override\n            public boolean test(Object s) throws Exception {\n                String newStr = (String) s;\n                if (newStr.charAt(5) - '0' > 5) {\n                    return true;\n                }\n                return false;\n            }\n        }).subscribe(new Consumer<Object>() {\n            @Override\n            public void accept(Object o) throws Exception {\n                System.out.println((String)o);\n            }\n        });\n```\n\n4. take()操作符\n输出最多指定数量的结果.(接收指定数量的结果) \n举例:\n```\nObservable.just(new ArrayList<String>(){\n            {\n                for (int i = 0; i < 8; i++) {\n                    add(\"data\"+i);\n                }\n            }\n        }).flatMap(new Function<List<String>, ObservableSource<?>>() {\n            @Override\n            public ObservableSource<?> apply(List<String> strings) throws Exception {\n                return Observable.fromIterable(strings);\n            }\n        }).take(5).subscribe(new Consumer<Object>() {\n            @Override\n            public void accept(Object s) throws Exception {\n                DemonstrateUtil.showLogResult(s.toString());\n            }\n        });\n```\n\n5. doOnNext()操作符\n允许我们在每次输出一个元素之前做一些额外的事情 \n举例:\n```\nObservable.just(new ArrayList<String>(){\n            {\n                for (int i = 0; i < 6; i++) {\n                    add(\"data\"+i);\n                }\n            }\n        }).flatMap(new Function<List<String>, ObservableSource<?>>() {\n            @Override\n            public ObservableSource<?> apply(List<String> strings) throws Exception {\n                return Observable.fromIterable(strings);\n            }\n        }).take(5).doOnNext(new Consumer<Object>() {\n            @Override\n            public void accept(Object o) throws Exception {\n                DemonstrateUtil.showLogResult(\"额外的准备工作!\");\n            }\n        }).subscribe(new Consumer<Object>() {\n            @Override\n            public void accept(Object s) throws Exception {\n                DemonstrateUtil.showLogResult(s.toString());\n            }\n        });\n```\n\n## Flowable的理解 \nFlowable是一个被观察者，与Subscriber(观察者)配合使用，解决Backpressure问题 \nBackpressure(背压)。所谓背压，即生产者的速度大于消费者的速度带来的问题。\n\n> 什么情况下才会产生Backpressure问题？\n1.如果生产者和消费者在一个线程的情况下，无论生产者的生产速度有多快，每生产一个事件都会通知消费者，等待消费者消费完毕，再生产下一个事件。\n所以在这种情况下，根本不存在Backpressure问题。即同步情况下，Backpressure问题不存在。\n2.如果生产者和消费者不在同一线程的情况下，如果生产者的速度大于消费者的速度，就会产生Backpressure问题。\n即异步情况下，Backpressure问题才会存在。\n\n现象演示说明:\n被观察者是事件的生产者,观察者是事件的消费者.假如生产者无限生成事件,而消费者以很缓慢的节奏来消费事件,会造成事件无限堆积,形成背压,最后造成OOM!\nFlowable悠然而生，专门用来处理这类问题。\nFlowable是为了应对Backpressure而产生的。Flowable是一个被观察者，\n与Subscriber(观察者)配合使用，解决Backpressure问题。\n注意：处理Backpressure的策略仅仅是处理Subscriber接收事件的方式，并不影响Flowable发送事件的方法。\n即使采用了处理Backpressure的策略，Flowable原来以什么样的速度产生事件，现在还是什么样的速度不会变化，主要处理的是Subscriber接收事件的方式。\n\n处理Backpressure问题的策略,或者来解决Backpressure问题\n\n    BackpressureStrategy.ERROR\n    如果缓存池溢出,就会立刻抛出MissingBackpressureException异常\n    request()用来向生产者申请可以消费的事件数量,这样我们便可以根据本身的消费能力进行消费事件.\n    虽然并不限制向request()方法中传入任意数字，但是如果消费者并没有这么多的消费能力，依旧会造成资源浪费，最后产生OOM\n    at java.lang.OutOfMemoryError.<init>(OutOfMemoryError.java:33)\n    在异步调用时，RxJava中有个缓存池，用来缓存消费者处理不了暂时缓存下来的数据，缓存池的默认大小为128，即只能缓存128个事件。\n    无论request()中传入的数字比128大或小，缓存池中在刚开始都会存入128个事件。\n    当然如果本身并没有这么多事件需要发送，则不会存128个事件。\n    应用举例:\n\n\n    BackpressureStrategy.BUFFER\n    是把RxJava中默认的只能存128个事件的缓存池换成一个大的缓存池,支持存更多的数据.\n    消费者通过request()即使传入一个很大的数字，生产者也会生产事件,并将处理不了的事件缓存.\n    注意:\n    这种方式任然比较消耗内存，除非是我们比较了解消费者的消费能力，能够把握具体情况，不会产生OOM。\n    BUFFER要慎用\n\n    BackpressureStrategy.DROP\n    顾名思义,当消费者处理不了事件，就丢弃!\n    例如,当数据源创建了200个事件,先不进行消费临时进行缓存实际缓存128个,我们第一次申请消费了100个,再次申请消费100个,\n    那么实际只消费了128个,而其余的72个被丢弃了!\n\n    BackpressureStrategy.LATEST\n    LATEST与DROP功能基本一致,当消费者处理不了事件，就丢弃!\n    唯一的区别就是LATEST总能使消费者能够接收到生产者产生的最后一个事件。\n    例如,当数据源创建了200个事件,先不进行消费临时进行缓存,我们第一次申请消费了100个,再次申请消费100个,\n    那么实际只消费了129个,而其余的71个被丢弃了,但是第200个(最后一个)会被消费.\n\n\n    BackpressureStrategy.MISSING\n    生产的事件没有进行缓存和丢弃,下游接收到的事件必须进行消费或者处理!\n\n\n\n在RxJava中会经常遇到一种情况就是被观察者发送消息十分迅速以至于观察者不能及时的响应这些消息\n举例:\nObservable.create(new ObservableOnSubscribe<Integer>() {\n        @Override\n        public void subscribe(ObservableEmitter<Integer> e) throws Exception {\n            while (true){\n                e.onNext(1);\n            }\n        }\n    })\n            .subscribeOn(Schedulers.io())\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(new Consumer<Integer>() {\n        @Override\n        public void accept(Integer integer) throws Exception {\n            Thread.sleep(2000);\n            System.out.println(integer);\n        }\n    });\n    被观察者是事件的生产者，观察者是事件的消费者。上述例子中可以看出生产者无限生成事件，而消费者每2秒才能消费一个事件，这会造成事件无限堆积，最后造成OOM。\nFlowable就是由此产生，专门用来处理这类问题","source":"_posts/“rxjava2-0”.md","raw":"---\ntitle: “rxjava2.0”\ndate: 2017-12-21 16:24:02\ntags: android\n---\n#[Rxjava2.0](http://blog.csdn.net/flybasker/article/details/78703295)\n\n## 基础概念\n\nObservable：在观察者模式中称为“被观察者”；\nObserver：观察者模式中的“观察者”，可接收Observable发送的数据；\nsubscribe：订阅，观察者与被观察者，通过Observable的subscribe()方法进行订阅；\nSubscriber：也是一种观察者，在2.0中 它与Observer没什么实质的区别，不同的是 Subscriber要与Flowable(也是一种被观察者)联合使用，该部分 内容是2.0新增的，后续文章再介绍。Obsesrver用于订阅Observable，而Subscriber用于订阅Flowable.\n\n## Rxjava中定义的事件方法\n\nonNext(),普通事件,按照队列依次进行处理.\nonComplete(),事件队列完结时调用该方法\nonError(),事件处理过程中出现异常时，onError()触发，同时队列终止,不再有事件发出.\nonSubscribe(),RxJava 2.0 中新增的，传递参数为Disposable,可用于切断接收事件让Observable (被观察者)开启子线程执行耗操作，完成耗时操作后，触发回调，通知Observer (观察者)进行主线程UI更新\n\n## observable的几种创建方式\n1. just()方式\n使用just( )，将创建一个Observable并自动调用onNext( )发射数据。\n也就是通过just( )方式 直接触发onNext()，just中传递的参数将直接在Observer的onNext()方法中接收到。\n\n2. fromIterable()方式\n使用fromIterable()，遍历集合，发送每个item.多次自动调用onNext()方法，每次传入一个item.\n注意：Collection接口是Iterable接口的子接口，所以所有Collection接口的实现类都可以作为Iterable对象直接传入fromIterable()    方法。\n\n3. defer()方式\n当观察者订阅时,才创建Observable，并且针对每个观察者创建都是一个新的Observable.\n通过Callable中的回调方法call(),决定使用以何种方式来创建这个Observable对象,当订阅后，发送事件.\n\n4. interval( )方式\n创建一个按固定时间间隔发射整数序列的Observable，可用作定时器。按照固定时间间隔来调用onNext()方法。\n\n5. timer( )方式\n通过此种创建一个Observable,它在一个给定的延迟后发射一个特殊的值，即表示延迟指定时间后，调用onNext()方法。\n\n6. range( )方式,range(x,y)\n创建一个发射特定整数序列的Observable，第一个参数x为起始值，第二个y为发送的个数，如果y为0则不发送，y为负数则抛异常。\nrange(1,5)\n上述表示发射1到5的数。即调用5次Next()方法，依次传入1-5数字。\n\n7. repeat( )方式\n创建一个Observable，该Observable的事件可以重复调用。\n\n## ObservableEmitter\nEmitter是发射器的意思,就是用来发出事件的，它可以发出三种类型的事件 \n通过调用onNext(T value),发出next事件 \n通过调用onComplete(),发出complete事件 \n通过调用onError(Throwable error),发出error事件 \n注意事项: \nonComplete和onError唯一并且互斥 \n发送多个onComplete, 第一个onComplete接收到,就不再接收了. \n发送多个onError, 则收到第二个onError事件会导致程序会崩溃. \n不可以随意乱七八糟发射事件，需要满足一定的规则： \n上游可以发送无限个onNext, 下游也可以接收无限个onNext. \n当上游发送了一个onComplete后, 上游onComplete之后的事件将会继续发送, 而下游收到onComplete事件之后将不再继续接收事件. \n上游发送了一个onError后, 上游onError之后的事件将继续发送, 而下游收到onError事件之后将不再继续接收事件. \n上游可以不发送onComplete或onError. \n最为关键的是onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError \n\n## Disposable\n一次性,它理解成两根管道之间的一个机关, 当调用它的dispose()方法时, 它就会将两根管道切断, 从而导致下游收不到事件. \n在RxJava中,用它来切断Observer(观察者)与Observable(被观察者)之间的连接，当调用它的dispose()方法时, 它就会将Observer(观察者)与Observable(被观察者)之间的连接切断, 从而导致Observer(观察者)收不到事件。 \n注意: 调用dispose()并不会导致上游不再继续发送事件, 上游会继续发送剩余的事件 \n\n## 线程调度\n1. Schedulers.immediate(): \n直接在当前线程运行，相当于不指定线程。这是默认的Scheduler。\n\n2. Schedulers.newThread(): \n总是启用新线程，并在新线程执行操作。\n\n3. Schedulers.io(): I/O \n操作（读写文件、读写数据库、网络信息交互等）所使用的Scheduler。行为模式和newThread()差不多，区别在于io()的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下io()比newThread()更有效率。不要把计算工作放在io()中，可以避免创建不必要的线程。\n\n4. Schedulers.computation(): \n计算所使用的Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个Scheduler使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在computation()中，否则 I/O 操作的等待时间会浪费 CPU。\n\n5. AndroidSchedulers.mainThread()，\nAndroid专用线程，指定操作在主线程运行。\n\n如何切换线程呢？RxJava中提供了两个方法：\n    subscribeOn() 和 observeOn() ，\n两者的不同点在于：\n\nsubscribeOn(): 指定subscribe()订阅所发生的线程，或者叫做事件产生的线程。\n\nobserveOn(): 指定Observer所运行在的线程，即onNext()执行的线程。或者叫做事件消费的线程。\n\n## 操作符\n操作符就是用于在Observable和最终的Observer之间，通过转换Observable为其他观察者对象的过程，修改发出的事件,最终将最简洁的数据传递给Observer对象. \n\n1. map()操作符，就是把原来的Observable对象转换成另一个Observable对象，同时将传输的数据进行一些灵活的操作，方便Observer获得想要的数据形式。\n举例:\n```\nObservable<Integer> observable = Observable\n        .just(\"hello\")\n        .map(new Function<String, Integer>() {\n            @Override\n            public Integer apply(String s) throws Exception {\n                return s.length();\n            }\n        });\n```\n\n2. flatMap()操作符 \nflatMap()对于数据的转换比map()更加彻底，如果发送的数据是集合，flatmap()重新生成一个Observable对象，并把数据转换成Observer想 要的数据形式。它可以返回任何它想返回的Observable对象。 \n举例:\n```\nObservable.just(list)\n       .flatMap(new Function<List<String>, ObservableSource<?>>() {\n            @Override\n            public ObservableSource<?> apply(List<String> strings) throws Exception {\n                return Observable.fromIterable(strings);\n            }\n        });\n```\n\n3. filter()操作符 \nfilter()操作符根据它的test()方法中，根据自己想过滤的数据加入相应的逻辑判断，返回true则表示数据满足条件，返回false则表示数据需要被过滤。最后过滤出的数据将加入到新的Observable对象中，方便传递给Observer想要的数据形式。 \n举例:\n```\nObservable\n        .just(list)\n        .flatMap(new Function<List<String>, ObservableSource<?>>() {\n            @Override\n            public ObservableSource<?> apply(List<String> strings) throws Exception {\n                return Observable.fromIterable(strings);\n            }\n        }).filter(new Predicate<Object>() {\n            @Override\n            public boolean test(Object s) throws Exception {\n                String newStr = (String) s;\n                if (newStr.charAt(5) - '0' > 5) {\n                    return true;\n                }\n                return false;\n            }\n        }).subscribe(new Consumer<Object>() {\n            @Override\n            public void accept(Object o) throws Exception {\n                System.out.println((String)o);\n            }\n        });\n```\n\n4. take()操作符\n输出最多指定数量的结果.(接收指定数量的结果) \n举例:\n```\nObservable.just(new ArrayList<String>(){\n            {\n                for (int i = 0; i < 8; i++) {\n                    add(\"data\"+i);\n                }\n            }\n        }).flatMap(new Function<List<String>, ObservableSource<?>>() {\n            @Override\n            public ObservableSource<?> apply(List<String> strings) throws Exception {\n                return Observable.fromIterable(strings);\n            }\n        }).take(5).subscribe(new Consumer<Object>() {\n            @Override\n            public void accept(Object s) throws Exception {\n                DemonstrateUtil.showLogResult(s.toString());\n            }\n        });\n```\n\n5. doOnNext()操作符\n允许我们在每次输出一个元素之前做一些额外的事情 \n举例:\n```\nObservable.just(new ArrayList<String>(){\n            {\n                for (int i = 0; i < 6; i++) {\n                    add(\"data\"+i);\n                }\n            }\n        }).flatMap(new Function<List<String>, ObservableSource<?>>() {\n            @Override\n            public ObservableSource<?> apply(List<String> strings) throws Exception {\n                return Observable.fromIterable(strings);\n            }\n        }).take(5).doOnNext(new Consumer<Object>() {\n            @Override\n            public void accept(Object o) throws Exception {\n                DemonstrateUtil.showLogResult(\"额外的准备工作!\");\n            }\n        }).subscribe(new Consumer<Object>() {\n            @Override\n            public void accept(Object s) throws Exception {\n                DemonstrateUtil.showLogResult(s.toString());\n            }\n        });\n```\n\n## Flowable的理解 \nFlowable是一个被观察者，与Subscriber(观察者)配合使用，解决Backpressure问题 \nBackpressure(背压)。所谓背压，即生产者的速度大于消费者的速度带来的问题。\n\n> 什么情况下才会产生Backpressure问题？\n1.如果生产者和消费者在一个线程的情况下，无论生产者的生产速度有多快，每生产一个事件都会通知消费者，等待消费者消费完毕，再生产下一个事件。\n所以在这种情况下，根本不存在Backpressure问题。即同步情况下，Backpressure问题不存在。\n2.如果生产者和消费者不在同一线程的情况下，如果生产者的速度大于消费者的速度，就会产生Backpressure问题。\n即异步情况下，Backpressure问题才会存在。\n\n现象演示说明:\n被观察者是事件的生产者,观察者是事件的消费者.假如生产者无限生成事件,而消费者以很缓慢的节奏来消费事件,会造成事件无限堆积,形成背压,最后造成OOM!\nFlowable悠然而生，专门用来处理这类问题。\nFlowable是为了应对Backpressure而产生的。Flowable是一个被观察者，\n与Subscriber(观察者)配合使用，解决Backpressure问题。\n注意：处理Backpressure的策略仅仅是处理Subscriber接收事件的方式，并不影响Flowable发送事件的方法。\n即使采用了处理Backpressure的策略，Flowable原来以什么样的速度产生事件，现在还是什么样的速度不会变化，主要处理的是Subscriber接收事件的方式。\n\n处理Backpressure问题的策略,或者来解决Backpressure问题\n\n    BackpressureStrategy.ERROR\n    如果缓存池溢出,就会立刻抛出MissingBackpressureException异常\n    request()用来向生产者申请可以消费的事件数量,这样我们便可以根据本身的消费能力进行消费事件.\n    虽然并不限制向request()方法中传入任意数字，但是如果消费者并没有这么多的消费能力，依旧会造成资源浪费，最后产生OOM\n    at java.lang.OutOfMemoryError.<init>(OutOfMemoryError.java:33)\n    在异步调用时，RxJava中有个缓存池，用来缓存消费者处理不了暂时缓存下来的数据，缓存池的默认大小为128，即只能缓存128个事件。\n    无论request()中传入的数字比128大或小，缓存池中在刚开始都会存入128个事件。\n    当然如果本身并没有这么多事件需要发送，则不会存128个事件。\n    应用举例:\n\n\n    BackpressureStrategy.BUFFER\n    是把RxJava中默认的只能存128个事件的缓存池换成一个大的缓存池,支持存更多的数据.\n    消费者通过request()即使传入一个很大的数字，生产者也会生产事件,并将处理不了的事件缓存.\n    注意:\n    这种方式任然比较消耗内存，除非是我们比较了解消费者的消费能力，能够把握具体情况，不会产生OOM。\n    BUFFER要慎用\n\n    BackpressureStrategy.DROP\n    顾名思义,当消费者处理不了事件，就丢弃!\n    例如,当数据源创建了200个事件,先不进行消费临时进行缓存实际缓存128个,我们第一次申请消费了100个,再次申请消费100个,\n    那么实际只消费了128个,而其余的72个被丢弃了!\n\n    BackpressureStrategy.LATEST\n    LATEST与DROP功能基本一致,当消费者处理不了事件，就丢弃!\n    唯一的区别就是LATEST总能使消费者能够接收到生产者产生的最后一个事件。\n    例如,当数据源创建了200个事件,先不进行消费临时进行缓存,我们第一次申请消费了100个,再次申请消费100个,\n    那么实际只消费了129个,而其余的71个被丢弃了,但是第200个(最后一个)会被消费.\n\n\n    BackpressureStrategy.MISSING\n    生产的事件没有进行缓存和丢弃,下游接收到的事件必须进行消费或者处理!\n\n\n\n在RxJava中会经常遇到一种情况就是被观察者发送消息十分迅速以至于观察者不能及时的响应这些消息\n举例:\nObservable.create(new ObservableOnSubscribe<Integer>() {\n        @Override\n        public void subscribe(ObservableEmitter<Integer> e) throws Exception {\n            while (true){\n                e.onNext(1);\n            }\n        }\n    })\n            .subscribeOn(Schedulers.io())\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(new Consumer<Integer>() {\n        @Override\n        public void accept(Integer integer) throws Exception {\n            Thread.sleep(2000);\n            System.out.println(integer);\n        }\n    });\n    被观察者是事件的生产者，观察者是事件的消费者。上述例子中可以看出生产者无限生成事件，而消费者每2秒才能消费一个事件，这会造成事件无限堆积，最后造成OOM。\nFlowable就是由此产生，专门用来处理这类问题","slug":"“rxjava2-0”","published":1,"updated":"2018-01-09T03:00:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7fai000sd41itlglx8rh","content":"<p>#<a href=\"http://blog.csdn.net/flybasker/article/details/78703295\" target=\"_blank\" rel=\"noopener\">Rxjava2.0</a></p>\n<h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><p>Observable：在观察者模式中称为“被观察者”；<br>Observer：观察者模式中的“观察者”，可接收Observable发送的数据；<br>subscribe：订阅，观察者与被观察者，通过Observable的subscribe()方法进行订阅；<br>Subscriber：也是一种观察者，在2.0中 它与Observer没什么实质的区别，不同的是 Subscriber要与Flowable(也是一种被观察者)联合使用，该部分 内容是2.0新增的，后续文章再介绍。Obsesrver用于订阅Observable，而Subscriber用于订阅Flowable.</p>\n<h2 id=\"Rxjava中定义的事件方法\"><a href=\"#Rxjava中定义的事件方法\" class=\"headerlink\" title=\"Rxjava中定义的事件方法\"></a>Rxjava中定义的事件方法</h2><p>onNext(),普通事件,按照队列依次进行处理.<br>onComplete(),事件队列完结时调用该方法<br>onError(),事件处理过程中出现异常时，onError()触发，同时队列终止,不再有事件发出.<br>onSubscribe(),RxJava 2.0 中新增的，传递参数为Disposable,可用于切断接收事件让Observable (被观察者)开启子线程执行耗操作，完成耗时操作后，触发回调，通知Observer (观察者)进行主线程UI更新</p>\n<h2 id=\"observable的几种创建方式\"><a href=\"#observable的几种创建方式\" class=\"headerlink\" title=\"observable的几种创建方式\"></a>observable的几种创建方式</h2><ol>\n<li><p>just()方式<br>使用just( )，将创建一个Observable并自动调用onNext( )发射数据。<br>也就是通过just( )方式 直接触发onNext()，just中传递的参数将直接在Observer的onNext()方法中接收到。</p>\n</li>\n<li><p>fromIterable()方式<br>使用fromIterable()，遍历集合，发送每个item.多次自动调用onNext()方法，每次传入一个item.<br>注意：Collection接口是Iterable接口的子接口，所以所有Collection接口的实现类都可以作为Iterable对象直接传入fromIterable()    方法。</p>\n</li>\n<li><p>defer()方式<br>当观察者订阅时,才创建Observable，并且针对每个观察者创建都是一个新的Observable.<br>通过Callable中的回调方法call(),决定使用以何种方式来创建这个Observable对象,当订阅后，发送事件.</p>\n</li>\n<li><p>interval( )方式<br>创建一个按固定时间间隔发射整数序列的Observable，可用作定时器。按照固定时间间隔来调用onNext()方法。</p>\n</li>\n<li><p>timer( )方式<br>通过此种创建一个Observable,它在一个给定的延迟后发射一个特殊的值，即表示延迟指定时间后，调用onNext()方法。</p>\n</li>\n<li><p>range( )方式,range(x,y)<br>创建一个发射特定整数序列的Observable，第一个参数x为起始值，第二个y为发送的个数，如果y为0则不发送，y为负数则抛异常。<br>range(1,5)<br>上述表示发射1到5的数。即调用5次Next()方法，依次传入1-5数字。</p>\n</li>\n<li><p>repeat( )方式<br>创建一个Observable，该Observable的事件可以重复调用。</p>\n</li>\n</ol>\n<h2 id=\"ObservableEmitter\"><a href=\"#ObservableEmitter\" class=\"headerlink\" title=\"ObservableEmitter\"></a>ObservableEmitter</h2><p>Emitter是发射器的意思,就是用来发出事件的，它可以发出三种类型的事件<br>通过调用onNext(T value),发出next事件<br>通过调用onComplete(),发出complete事件<br>通过调用onError(Throwable error),发出error事件<br>注意事项:<br>onComplete和onError唯一并且互斥<br>发送多个onComplete, 第一个onComplete接收到,就不再接收了.<br>发送多个onError, 则收到第二个onError事件会导致程序会崩溃.<br>不可以随意乱七八糟发射事件，需要满足一定的规则：<br>上游可以发送无限个onNext, 下游也可以接收无限个onNext.<br>当上游发送了一个onComplete后, 上游onComplete之后的事件将会继续发送, 而下游收到onComplete事件之后将不再继续接收事件.<br>上游发送了一个onError后, 上游onError之后的事件将继续发送, 而下游收到onError事件之后将不再继续接收事件.<br>上游可以不发送onComplete或onError.<br>最为关键的是onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError </p>\n<h2 id=\"Disposable\"><a href=\"#Disposable\" class=\"headerlink\" title=\"Disposable\"></a>Disposable</h2><p>一次性,它理解成两根管道之间的一个机关, 当调用它的dispose()方法时, 它就会将两根管道切断, 从而导致下游收不到事件.<br>在RxJava中,用它来切断Observer(观察者)与Observable(被观察者)之间的连接，当调用它的dispose()方法时, 它就会将Observer(观察者)与Observable(被观察者)之间的连接切断, 从而导致Observer(观察者)收不到事件。<br>注意: 调用dispose()并不会导致上游不再继续发送事件, 上游会继续发送剩余的事件 </p>\n<h2 id=\"线程调度\"><a href=\"#线程调度\" class=\"headerlink\" title=\"线程调度\"></a>线程调度</h2><ol>\n<li><p>Schedulers.immediate():<br>直接在当前线程运行，相当于不指定线程。这是默认的Scheduler。</p>\n</li>\n<li><p>Schedulers.newThread():<br>总是启用新线程，并在新线程执行操作。</p>\n</li>\n<li><p>Schedulers.io(): I/O<br>操作（读写文件、读写数据库、网络信息交互等）所使用的Scheduler。行为模式和newThread()差不多，区别在于io()的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下io()比newThread()更有效率。不要把计算工作放在io()中，可以避免创建不必要的线程。</p>\n</li>\n<li><p>Schedulers.computation():<br>计算所使用的Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个Scheduler使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在computation()中，否则 I/O 操作的等待时间会浪费 CPU。</p>\n</li>\n<li><p>AndroidSchedulers.mainThread()，<br>Android专用线程，指定操作在主线程运行。</p>\n</li>\n</ol>\n<p>如何切换线程呢？RxJava中提供了两个方法：<br>    subscribeOn() 和 observeOn() ，<br>两者的不同点在于：</p>\n<p>subscribeOn(): 指定subscribe()订阅所发生的线程，或者叫做事件产生的线程。</p>\n<p>observeOn(): 指定Observer所运行在的线程，即onNext()执行的线程。或者叫做事件消费的线程。</p>\n<h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h2><p>操作符就是用于在Observable和最终的Observer之间，通过转换Observable为其他观察者对象的过程，修改发出的事件,最终将最简洁的数据传递给Observer对象. </p>\n<ol>\n<li><p>map()操作符，就是把原来的Observable对象转换成另一个Observable对象，同时将传输的数据进行一些灵活的操作，方便Observer获得想要的数据形式。<br>举例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable&lt;Integer&gt; observable = Observable</span><br><span class=\"line\">        .just(&quot;hello&quot;)</span><br><span class=\"line\">        .map(new Function&lt;String, Integer&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public Integer apply(String s) throws Exception &#123;</span><br><span class=\"line\">                return s.length();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>flatMap()操作符<br>flatMap()对于数据的转换比map()更加彻底，如果发送的数据是集合，flatmap()重新生成一个Observable对象，并把数据转换成Observer想 要的数据形式。它可以返回任何它想返回的Observable对象。<br>举例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.just(list)</span><br><span class=\"line\">       .flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class=\"line\">                return Observable.fromIterable(strings);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>filter()操作符<br>filter()操作符根据它的test()方法中，根据自己想过滤的数据加入相应的逻辑判断，返回true则表示数据满足条件，返回false则表示数据需要被过滤。最后过滤出的数据将加入到新的Observable对象中，方便传递给Observer想要的数据形式。<br>举例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable</span><br><span class=\"line\">        .just(list)</span><br><span class=\"line\">        .flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class=\"line\">                return Observable.fromIterable(strings);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).filter(new Predicate&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public boolean test(Object s) throws Exception &#123;</span><br><span class=\"line\">                String newStr = (String) s;</span><br><span class=\"line\">                if (newStr.charAt(5) - &apos;0&apos; &gt; 5) &#123;</span><br><span class=\"line\">                    return true;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).subscribe(new Consumer&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(Object o) throws Exception &#123;</span><br><span class=\"line\">                System.out.println((String)o);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>take()操作符<br>输出最多指定数量的结果.(接收指定数量的结果)<br>举例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.just(new ArrayList&lt;String&gt;()&#123;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class=\"line\">                    add(&quot;data&quot;+i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class=\"line\">                return Observable.fromIterable(strings);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).take(5).subscribe(new Consumer&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(Object s) throws Exception &#123;</span><br><span class=\"line\">                DemonstrateUtil.showLogResult(s.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>doOnNext()操作符<br>允许我们在每次输出一个元素之前做一些额外的事情<br>举例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.just(new ArrayList&lt;String&gt;()&#123;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class=\"line\">                    add(&quot;data&quot;+i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class=\"line\">                return Observable.fromIterable(strings);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).take(5).doOnNext(new Consumer&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(Object o) throws Exception &#123;</span><br><span class=\"line\">                DemonstrateUtil.showLogResult(&quot;额外的准备工作!&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).subscribe(new Consumer&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(Object s) throws Exception &#123;</span><br><span class=\"line\">                DemonstrateUtil.showLogResult(s.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"Flowable的理解\"><a href=\"#Flowable的理解\" class=\"headerlink\" title=\"Flowable的理解\"></a>Flowable的理解</h2><p>Flowable是一个被观察者，与Subscriber(观察者)配合使用，解决Backpressure问题<br>Backpressure(背压)。所谓背压，即生产者的速度大于消费者的速度带来的问题。</p>\n<blockquote>\n<p>什么情况下才会产生Backpressure问题？<br>1.如果生产者和消费者在一个线程的情况下，无论生产者的生产速度有多快，每生产一个事件都会通知消费者，等待消费者消费完毕，再生产下一个事件。<br>所以在这种情况下，根本不存在Backpressure问题。即同步情况下，Backpressure问题不存在。<br>2.如果生产者和消费者不在同一线程的情况下，如果生产者的速度大于消费者的速度，就会产生Backpressure问题。<br>即异步情况下，Backpressure问题才会存在。</p>\n</blockquote>\n<p>现象演示说明:<br>被观察者是事件的生产者,观察者是事件的消费者.假如生产者无限生成事件,而消费者以很缓慢的节奏来消费事件,会造成事件无限堆积,形成背压,最后造成OOM!<br>Flowable悠然而生，专门用来处理这类问题。<br>Flowable是为了应对Backpressure而产生的。Flowable是一个被观察者，<br>与Subscriber(观察者)配合使用，解决Backpressure问题。<br>注意：处理Backpressure的策略仅仅是处理Subscriber接收事件的方式，并不影响Flowable发送事件的方法。<br>即使采用了处理Backpressure的策略，Flowable原来以什么样的速度产生事件，现在还是什么样的速度不会变化，主要处理的是Subscriber接收事件的方式。</p>\n<p>处理Backpressure问题的策略,或者来解决Backpressure问题</p>\n<pre><code>BackpressureStrategy.ERROR\n如果缓存池溢出,就会立刻抛出MissingBackpressureException异常\nrequest()用来向生产者申请可以消费的事件数量,这样我们便可以根据本身的消费能力进行消费事件.\n虽然并不限制向request()方法中传入任意数字，但是如果消费者并没有这么多的消费能力，依旧会造成资源浪费，最后产生OOM\nat java.lang.OutOfMemoryError.&lt;init&gt;(OutOfMemoryError.java:33)\n在异步调用时，RxJava中有个缓存池，用来缓存消费者处理不了暂时缓存下来的数据，缓存池的默认大小为128，即只能缓存128个事件。\n无论request()中传入的数字比128大或小，缓存池中在刚开始都会存入128个事件。\n当然如果本身并没有这么多事件需要发送，则不会存128个事件。\n应用举例:\n\n\nBackpressureStrategy.BUFFER\n是把RxJava中默认的只能存128个事件的缓存池换成一个大的缓存池,支持存更多的数据.\n消费者通过request()即使传入一个很大的数字，生产者也会生产事件,并将处理不了的事件缓存.\n注意:\n这种方式任然比较消耗内存，除非是我们比较了解消费者的消费能力，能够把握具体情况，不会产生OOM。\nBUFFER要慎用\n\nBackpressureStrategy.DROP\n顾名思义,当消费者处理不了事件，就丢弃!\n例如,当数据源创建了200个事件,先不进行消费临时进行缓存实际缓存128个,我们第一次申请消费了100个,再次申请消费100个,\n那么实际只消费了128个,而其余的72个被丢弃了!\n\nBackpressureStrategy.LATEST\nLATEST与DROP功能基本一致,当消费者处理不了事件，就丢弃!\n唯一的区别就是LATEST总能使消费者能够接收到生产者产生的最后一个事件。\n例如,当数据源创建了200个事件,先不进行消费临时进行缓存,我们第一次申请消费了100个,再次申请消费100个,\n那么实际只消费了129个,而其余的71个被丢弃了,但是第200个(最后一个)会被消费.\n\n\nBackpressureStrategy.MISSING\n生产的事件没有进行缓存和丢弃,下游接收到的事件必须进行消费或者处理!\n</code></pre><p>在RxJava中会经常遇到一种情况就是被观察者发送消息十分迅速以至于观察者不能及时的响应这些消息<br>举例:<br>Observable.create(new ObservableOnSubscribe<integer>() {<br>        @Override<br>        public void subscribe(ObservableEmitter<integer> e) throws Exception {<br>            while (true){<br>                e.onNext(1);<br>            }<br>        }<br>    })<br>            .subscribeOn(Schedulers.io())<br>            .observeOn(AndroidSchedulers.mainThread())<br>            .subscribe(new Consumer<integer>() {<br>        @Override<br>        public void accept(Integer integer) throws Exception {<br>            Thread.sleep(2000);<br>            System.out.println(integer);<br>        }<br>    });<br>    被观察者是事件的生产者，观察者是事件的消费者。上述例子中可以看出生产者无限生成事件，而消费者每2秒才能消费一个事件，这会造成事件无限堆积，最后造成OOM。<br>Flowable就是由此产生，专门用来处理这类问题</integer></integer></integer></p>\n","site":{"data":{}},"excerpt":"","more":"<p>#<a href=\"http://blog.csdn.net/flybasker/article/details/78703295\" target=\"_blank\" rel=\"noopener\">Rxjava2.0</a></p>\n<h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><p>Observable：在观察者模式中称为“被观察者”；<br>Observer：观察者模式中的“观察者”，可接收Observable发送的数据；<br>subscribe：订阅，观察者与被观察者，通过Observable的subscribe()方法进行订阅；<br>Subscriber：也是一种观察者，在2.0中 它与Observer没什么实质的区别，不同的是 Subscriber要与Flowable(也是一种被观察者)联合使用，该部分 内容是2.0新增的，后续文章再介绍。Obsesrver用于订阅Observable，而Subscriber用于订阅Flowable.</p>\n<h2 id=\"Rxjava中定义的事件方法\"><a href=\"#Rxjava中定义的事件方法\" class=\"headerlink\" title=\"Rxjava中定义的事件方法\"></a>Rxjava中定义的事件方法</h2><p>onNext(),普通事件,按照队列依次进行处理.<br>onComplete(),事件队列完结时调用该方法<br>onError(),事件处理过程中出现异常时，onError()触发，同时队列终止,不再有事件发出.<br>onSubscribe(),RxJava 2.0 中新增的，传递参数为Disposable,可用于切断接收事件让Observable (被观察者)开启子线程执行耗操作，完成耗时操作后，触发回调，通知Observer (观察者)进行主线程UI更新</p>\n<h2 id=\"observable的几种创建方式\"><a href=\"#observable的几种创建方式\" class=\"headerlink\" title=\"observable的几种创建方式\"></a>observable的几种创建方式</h2><ol>\n<li><p>just()方式<br>使用just( )，将创建一个Observable并自动调用onNext( )发射数据。<br>也就是通过just( )方式 直接触发onNext()，just中传递的参数将直接在Observer的onNext()方法中接收到。</p>\n</li>\n<li><p>fromIterable()方式<br>使用fromIterable()，遍历集合，发送每个item.多次自动调用onNext()方法，每次传入一个item.<br>注意：Collection接口是Iterable接口的子接口，所以所有Collection接口的实现类都可以作为Iterable对象直接传入fromIterable()    方法。</p>\n</li>\n<li><p>defer()方式<br>当观察者订阅时,才创建Observable，并且针对每个观察者创建都是一个新的Observable.<br>通过Callable中的回调方法call(),决定使用以何种方式来创建这个Observable对象,当订阅后，发送事件.</p>\n</li>\n<li><p>interval( )方式<br>创建一个按固定时间间隔发射整数序列的Observable，可用作定时器。按照固定时间间隔来调用onNext()方法。</p>\n</li>\n<li><p>timer( )方式<br>通过此种创建一个Observable,它在一个给定的延迟后发射一个特殊的值，即表示延迟指定时间后，调用onNext()方法。</p>\n</li>\n<li><p>range( )方式,range(x,y)<br>创建一个发射特定整数序列的Observable，第一个参数x为起始值，第二个y为发送的个数，如果y为0则不发送，y为负数则抛异常。<br>range(1,5)<br>上述表示发射1到5的数。即调用5次Next()方法，依次传入1-5数字。</p>\n</li>\n<li><p>repeat( )方式<br>创建一个Observable，该Observable的事件可以重复调用。</p>\n</li>\n</ol>\n<h2 id=\"ObservableEmitter\"><a href=\"#ObservableEmitter\" class=\"headerlink\" title=\"ObservableEmitter\"></a>ObservableEmitter</h2><p>Emitter是发射器的意思,就是用来发出事件的，它可以发出三种类型的事件<br>通过调用onNext(T value),发出next事件<br>通过调用onComplete(),发出complete事件<br>通过调用onError(Throwable error),发出error事件<br>注意事项:<br>onComplete和onError唯一并且互斥<br>发送多个onComplete, 第一个onComplete接收到,就不再接收了.<br>发送多个onError, 则收到第二个onError事件会导致程序会崩溃.<br>不可以随意乱七八糟发射事件，需要满足一定的规则：<br>上游可以发送无限个onNext, 下游也可以接收无限个onNext.<br>当上游发送了一个onComplete后, 上游onComplete之后的事件将会继续发送, 而下游收到onComplete事件之后将不再继续接收事件.<br>上游发送了一个onError后, 上游onError之后的事件将继续发送, 而下游收到onError事件之后将不再继续接收事件.<br>上游可以不发送onComplete或onError.<br>最为关键的是onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError </p>\n<h2 id=\"Disposable\"><a href=\"#Disposable\" class=\"headerlink\" title=\"Disposable\"></a>Disposable</h2><p>一次性,它理解成两根管道之间的一个机关, 当调用它的dispose()方法时, 它就会将两根管道切断, 从而导致下游收不到事件.<br>在RxJava中,用它来切断Observer(观察者)与Observable(被观察者)之间的连接，当调用它的dispose()方法时, 它就会将Observer(观察者)与Observable(被观察者)之间的连接切断, 从而导致Observer(观察者)收不到事件。<br>注意: 调用dispose()并不会导致上游不再继续发送事件, 上游会继续发送剩余的事件 </p>\n<h2 id=\"线程调度\"><a href=\"#线程调度\" class=\"headerlink\" title=\"线程调度\"></a>线程调度</h2><ol>\n<li><p>Schedulers.immediate():<br>直接在当前线程运行，相当于不指定线程。这是默认的Scheduler。</p>\n</li>\n<li><p>Schedulers.newThread():<br>总是启用新线程，并在新线程执行操作。</p>\n</li>\n<li><p>Schedulers.io(): I/O<br>操作（读写文件、读写数据库、网络信息交互等）所使用的Scheduler。行为模式和newThread()差不多，区别在于io()的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下io()比newThread()更有效率。不要把计算工作放在io()中，可以避免创建不必要的线程。</p>\n</li>\n<li><p>Schedulers.computation():<br>计算所使用的Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个Scheduler使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在computation()中，否则 I/O 操作的等待时间会浪费 CPU。</p>\n</li>\n<li><p>AndroidSchedulers.mainThread()，<br>Android专用线程，指定操作在主线程运行。</p>\n</li>\n</ol>\n<p>如何切换线程呢？RxJava中提供了两个方法：<br>    subscribeOn() 和 observeOn() ，<br>两者的不同点在于：</p>\n<p>subscribeOn(): 指定subscribe()订阅所发生的线程，或者叫做事件产生的线程。</p>\n<p>observeOn(): 指定Observer所运行在的线程，即onNext()执行的线程。或者叫做事件消费的线程。</p>\n<h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h2><p>操作符就是用于在Observable和最终的Observer之间，通过转换Observable为其他观察者对象的过程，修改发出的事件,最终将最简洁的数据传递给Observer对象. </p>\n<ol>\n<li><p>map()操作符，就是把原来的Observable对象转换成另一个Observable对象，同时将传输的数据进行一些灵活的操作，方便Observer获得想要的数据形式。<br>举例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable&lt;Integer&gt; observable = Observable</span><br><span class=\"line\">        .just(&quot;hello&quot;)</span><br><span class=\"line\">        .map(new Function&lt;String, Integer&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public Integer apply(String s) throws Exception &#123;</span><br><span class=\"line\">                return s.length();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>flatMap()操作符<br>flatMap()对于数据的转换比map()更加彻底，如果发送的数据是集合，flatmap()重新生成一个Observable对象，并把数据转换成Observer想 要的数据形式。它可以返回任何它想返回的Observable对象。<br>举例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.just(list)</span><br><span class=\"line\">       .flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class=\"line\">                return Observable.fromIterable(strings);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>filter()操作符<br>filter()操作符根据它的test()方法中，根据自己想过滤的数据加入相应的逻辑判断，返回true则表示数据满足条件，返回false则表示数据需要被过滤。最后过滤出的数据将加入到新的Observable对象中，方便传递给Observer想要的数据形式。<br>举例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable</span><br><span class=\"line\">        .just(list)</span><br><span class=\"line\">        .flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class=\"line\">                return Observable.fromIterable(strings);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).filter(new Predicate&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public boolean test(Object s) throws Exception &#123;</span><br><span class=\"line\">                String newStr = (String) s;</span><br><span class=\"line\">                if (newStr.charAt(5) - &apos;0&apos; &gt; 5) &#123;</span><br><span class=\"line\">                    return true;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).subscribe(new Consumer&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(Object o) throws Exception &#123;</span><br><span class=\"line\">                System.out.println((String)o);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>take()操作符<br>输出最多指定数量的结果.(接收指定数量的结果)<br>举例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.just(new ArrayList&lt;String&gt;()&#123;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class=\"line\">                    add(&quot;data&quot;+i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class=\"line\">                return Observable.fromIterable(strings);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).take(5).subscribe(new Consumer&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(Object s) throws Exception &#123;</span><br><span class=\"line\">                DemonstrateUtil.showLogResult(s.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>doOnNext()操作符<br>允许我们在每次输出一个元素之前做一些额外的事情<br>举例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.just(new ArrayList&lt;String&gt;()&#123;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class=\"line\">                    add(&quot;data&quot;+i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class=\"line\">                return Observable.fromIterable(strings);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).take(5).doOnNext(new Consumer&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(Object o) throws Exception &#123;</span><br><span class=\"line\">                DemonstrateUtil.showLogResult(&quot;额外的准备工作!&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).subscribe(new Consumer&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(Object s) throws Exception &#123;</span><br><span class=\"line\">                DemonstrateUtil.showLogResult(s.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"Flowable的理解\"><a href=\"#Flowable的理解\" class=\"headerlink\" title=\"Flowable的理解\"></a>Flowable的理解</h2><p>Flowable是一个被观察者，与Subscriber(观察者)配合使用，解决Backpressure问题<br>Backpressure(背压)。所谓背压，即生产者的速度大于消费者的速度带来的问题。</p>\n<blockquote>\n<p>什么情况下才会产生Backpressure问题？<br>1.如果生产者和消费者在一个线程的情况下，无论生产者的生产速度有多快，每生产一个事件都会通知消费者，等待消费者消费完毕，再生产下一个事件。<br>所以在这种情况下，根本不存在Backpressure问题。即同步情况下，Backpressure问题不存在。<br>2.如果生产者和消费者不在同一线程的情况下，如果生产者的速度大于消费者的速度，就会产生Backpressure问题。<br>即异步情况下，Backpressure问题才会存在。</p>\n</blockquote>\n<p>现象演示说明:<br>被观察者是事件的生产者,观察者是事件的消费者.假如生产者无限生成事件,而消费者以很缓慢的节奏来消费事件,会造成事件无限堆积,形成背压,最后造成OOM!<br>Flowable悠然而生，专门用来处理这类问题。<br>Flowable是为了应对Backpressure而产生的。Flowable是一个被观察者，<br>与Subscriber(观察者)配合使用，解决Backpressure问题。<br>注意：处理Backpressure的策略仅仅是处理Subscriber接收事件的方式，并不影响Flowable发送事件的方法。<br>即使采用了处理Backpressure的策略，Flowable原来以什么样的速度产生事件，现在还是什么样的速度不会变化，主要处理的是Subscriber接收事件的方式。</p>\n<p>处理Backpressure问题的策略,或者来解决Backpressure问题</p>\n<pre><code>BackpressureStrategy.ERROR\n如果缓存池溢出,就会立刻抛出MissingBackpressureException异常\nrequest()用来向生产者申请可以消费的事件数量,这样我们便可以根据本身的消费能力进行消费事件.\n虽然并不限制向request()方法中传入任意数字，但是如果消费者并没有这么多的消费能力，依旧会造成资源浪费，最后产生OOM\nat java.lang.OutOfMemoryError.&lt;init&gt;(OutOfMemoryError.java:33)\n在异步调用时，RxJava中有个缓存池，用来缓存消费者处理不了暂时缓存下来的数据，缓存池的默认大小为128，即只能缓存128个事件。\n无论request()中传入的数字比128大或小，缓存池中在刚开始都会存入128个事件。\n当然如果本身并没有这么多事件需要发送，则不会存128个事件。\n应用举例:\n\n\nBackpressureStrategy.BUFFER\n是把RxJava中默认的只能存128个事件的缓存池换成一个大的缓存池,支持存更多的数据.\n消费者通过request()即使传入一个很大的数字，生产者也会生产事件,并将处理不了的事件缓存.\n注意:\n这种方式任然比较消耗内存，除非是我们比较了解消费者的消费能力，能够把握具体情况，不会产生OOM。\nBUFFER要慎用\n\nBackpressureStrategy.DROP\n顾名思义,当消费者处理不了事件，就丢弃!\n例如,当数据源创建了200个事件,先不进行消费临时进行缓存实际缓存128个,我们第一次申请消费了100个,再次申请消费100个,\n那么实际只消费了128个,而其余的72个被丢弃了!\n\nBackpressureStrategy.LATEST\nLATEST与DROP功能基本一致,当消费者处理不了事件，就丢弃!\n唯一的区别就是LATEST总能使消费者能够接收到生产者产生的最后一个事件。\n例如,当数据源创建了200个事件,先不进行消费临时进行缓存,我们第一次申请消费了100个,再次申请消费100个,\n那么实际只消费了129个,而其余的71个被丢弃了,但是第200个(最后一个)会被消费.\n\n\nBackpressureStrategy.MISSING\n生产的事件没有进行缓存和丢弃,下游接收到的事件必须进行消费或者处理!\n</code></pre><p>在RxJava中会经常遇到一种情况就是被观察者发送消息十分迅速以至于观察者不能及时的响应这些消息<br>举例:<br>Observable.create(new ObservableOnSubscribe<integer>() {<br>        @Override<br>        public void subscribe(ObservableEmitter<integer> e) throws Exception {<br>            while (true){<br>                e.onNext(1);<br>            }<br>        }<br>    })<br>            .subscribeOn(Schedulers.io())<br>            .observeOn(AndroidSchedulers.mainThread())<br>            .subscribe(new Consumer<integer>() {<br>        @Override<br>        public void accept(Integer integer) throws Exception {<br>            Thread.sleep(2000);<br>            System.out.println(integer);<br>        }<br>    });<br>    被观察者是事件的生产者，观察者是事件的消费者。上述例子中可以看出生产者无限生成事件，而消费者每2秒才能消费一个事件，这会造成事件无限堆积，最后造成OOM。<br>Flowable就是由此产生，专门用来处理这类问题</integer></integer></integer></p>\n"},{"title":"使用appveyor.xml 进行双端部署hexo","date":"2017-12-21T03:12:17.000Z","_content":"\n\n# 注册并登录AppVeyor\n\n> 访问 [AppVeyor](https://ci.appveyor.com/login),使用github登录即可。\n\n# 添加project\n\n> 在 [project页面](https://ci.appveyor.com/projects/new),添加相应的source repo\n\n# 添加appveyor.yml到source repo\n\n> appveyor如[appveyor样例](https://github.com/formulahendry/formulahendry.github.io.source/blob/master/appveyor.yml),只需要更改 [Your Github Access Token]即可。\n\n# 在repo/settings/Environment中添加四个变量\n\n> GIT_USER_EMAIL: github email\n> GIT_USER_NAME: github username\n> STATIC_SITE_REPO: blog repo site\n> TARGET_BRANCH: blog repo main branch (default is master)\n\n# 完成\n\n> 背后的过程如下\n> Git push to Source Repo -> AppVeyor CI -> Update GitHub Pages Content Repo -> Generate your Hexo blog site\n\n# [出处](https://formulahendry.github.io/2016/12/04/hexo-ci/)\n","source":"_posts/使用appveyor-xml-进行双端部署hexo.md","raw":"---\ntitle: 使用appveyor.xml 进行双端部署hexo\ndate: 2017-12-21 11:12:17\ntags: hexo\n---\n\n\n# 注册并登录AppVeyor\n\n> 访问 [AppVeyor](https://ci.appveyor.com/login),使用github登录即可。\n\n# 添加project\n\n> 在 [project页面](https://ci.appveyor.com/projects/new),添加相应的source repo\n\n# 添加appveyor.yml到source repo\n\n> appveyor如[appveyor样例](https://github.com/formulahendry/formulahendry.github.io.source/blob/master/appveyor.yml),只需要更改 [Your Github Access Token]即可。\n\n# 在repo/settings/Environment中添加四个变量\n\n> GIT_USER_EMAIL: github email\n> GIT_USER_NAME: github username\n> STATIC_SITE_REPO: blog repo site\n> TARGET_BRANCH: blog repo main branch (default is master)\n\n# 完成\n\n> 背后的过程如下\n> Git push to Source Repo -> AppVeyor CI -> Update GitHub Pages Content Repo -> Generate your Hexo blog site\n\n# [出处](https://formulahendry.github.io/2016/12/04/hexo-ci/)\n","slug":"使用appveyor-xml-进行双端部署hexo","published":1,"updated":"2018-01-09T03:00:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7faj000vd41iw3ugducm","content":"<h1 id=\"注册并登录AppVeyor\"><a href=\"#注册并登录AppVeyor\" class=\"headerlink\" title=\"注册并登录AppVeyor\"></a>注册并登录AppVeyor</h1><blockquote>\n<p>访问 <a href=\"https://ci.appveyor.com/login\" target=\"_blank\" rel=\"noopener\">AppVeyor</a>,使用github登录即可。</p>\n</blockquote>\n<h1 id=\"添加project\"><a href=\"#添加project\" class=\"headerlink\" title=\"添加project\"></a>添加project</h1><blockquote>\n<p>在 <a href=\"https://ci.appveyor.com/projects/new\" target=\"_blank\" rel=\"noopener\">project页面</a>,添加相应的source repo</p>\n</blockquote>\n<h1 id=\"添加appveyor-yml到source-repo\"><a href=\"#添加appveyor-yml到source-repo\" class=\"headerlink\" title=\"添加appveyor.yml到source repo\"></a>添加appveyor.yml到source repo</h1><blockquote>\n<p>appveyor如<a href=\"https://github.com/formulahendry/formulahendry.github.io.source/blob/master/appveyor.yml\" target=\"_blank\" rel=\"noopener\">appveyor样例</a>,只需要更改 [Your Github Access Token]即可。</p>\n</blockquote>\n<h1 id=\"在repo-settings-Environment中添加四个变量\"><a href=\"#在repo-settings-Environment中添加四个变量\" class=\"headerlink\" title=\"在repo/settings/Environment中添加四个变量\"></a>在repo/settings/Environment中添加四个变量</h1><blockquote>\n<p>GIT_USER_EMAIL: github email<br>GIT_USER_NAME: github username<br>STATIC_SITE_REPO: blog repo site<br>TARGET_BRANCH: blog repo main branch (default is master)</p>\n</blockquote>\n<h1 id=\"完成\"><a href=\"#完成\" class=\"headerlink\" title=\"完成\"></a>完成</h1><blockquote>\n<p>背后的过程如下<br>Git push to Source Repo -&gt; AppVeyor CI -&gt; Update GitHub Pages Content Repo -&gt; Generate your Hexo blog site</p>\n</blockquote>\n<h1 id=\"出处\"><a href=\"#出处\" class=\"headerlink\" title=\"出处\"></a><a href=\"https://formulahendry.github.io/2016/12/04/hexo-ci/\" target=\"_blank\" rel=\"noopener\">出处</a></h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"注册并登录AppVeyor\"><a href=\"#注册并登录AppVeyor\" class=\"headerlink\" title=\"注册并登录AppVeyor\"></a>注册并登录AppVeyor</h1><blockquote>\n<p>访问 <a href=\"https://ci.appveyor.com/login\" target=\"_blank\" rel=\"noopener\">AppVeyor</a>,使用github登录即可。</p>\n</blockquote>\n<h1 id=\"添加project\"><a href=\"#添加project\" class=\"headerlink\" title=\"添加project\"></a>添加project</h1><blockquote>\n<p>在 <a href=\"https://ci.appveyor.com/projects/new\" target=\"_blank\" rel=\"noopener\">project页面</a>,添加相应的source repo</p>\n</blockquote>\n<h1 id=\"添加appveyor-yml到source-repo\"><a href=\"#添加appveyor-yml到source-repo\" class=\"headerlink\" title=\"添加appveyor.yml到source repo\"></a>添加appveyor.yml到source repo</h1><blockquote>\n<p>appveyor如<a href=\"https://github.com/formulahendry/formulahendry.github.io.source/blob/master/appveyor.yml\" target=\"_blank\" rel=\"noopener\">appveyor样例</a>,只需要更改 [Your Github Access Token]即可。</p>\n</blockquote>\n<h1 id=\"在repo-settings-Environment中添加四个变量\"><a href=\"#在repo-settings-Environment中添加四个变量\" class=\"headerlink\" title=\"在repo/settings/Environment中添加四个变量\"></a>在repo/settings/Environment中添加四个变量</h1><blockquote>\n<p>GIT_USER_EMAIL: github email<br>GIT_USER_NAME: github username<br>STATIC_SITE_REPO: blog repo site<br>TARGET_BRANCH: blog repo main branch (default is master)</p>\n</blockquote>\n<h1 id=\"完成\"><a href=\"#完成\" class=\"headerlink\" title=\"完成\"></a>完成</h1><blockquote>\n<p>背后的过程如下<br>Git push to Source Repo -&gt; AppVeyor CI -&gt; Update GitHub Pages Content Repo -&gt; Generate your Hexo blog site</p>\n</blockquote>\n<h1 id=\"出处\"><a href=\"#出处\" class=\"headerlink\" title=\"出处\"></a><a href=\"https://formulahendry.github.io/2016/12/04/hexo-ci/\" target=\"_blank\" rel=\"noopener\">出处</a></h1>"},{"title":"使用浏览器唤起app","date":"2018-01-06T10:38:38.000Z","_content":"浏览器唤起app，其实很简单，是使用manifest中注册scheme的方式来设置。\n\nmanifest中注册如下\n\n```\n<intent-filter>\n    <action android:name=\"android.intent.action.VIEW\"/>\n    <category android:name=\"android.intent.category.DEFAULT\" />\n    <category android:name=\"android.intent.category.BROWSABLE\" />\n    <data android:scheme=\"myapp\" android:host=\"jp.app\" android:pathPrefix=\"/openwith\"/>\n</intent-filter>\n```\n\n这段代表了唤起方式可以由浏览器唤起，data方面重要的是写scheme，之后的host和pathprefix都是无关紧要的。\n\nassets文件夹里面放静态html页面，使用webview来load。\n\n```\n<a href=\"myapp://jp.app/openwith?name=zhangsan&age=26\">启动应用程序</a>\n```\n\n启动的activity里面接受intent\n```\nif(Intent.ACTION_VIEW.equals(action)){\n    Uri uri = i_getvalue.getData();\n    if(uri != null){\n        String name = uri.getQueryParameter(\"name\");\n        String age= uri.getQueryParameter(\"age\");\n        Log.d(getClass().getName(),name+age);\n\t}\n}\n```\n\n可以接收到intent里面包含的信息。\n\n针对昨天的问题，如何从html中get一个接口的数据，然后返回吊起activity，可以直接使用script来fetch（url），针对内容对唤起的activity后缀加内容。\n\n目前关于这个问题还是涉及到跨域的情况，张凯说使用301转发，周宇说跨域需要接口支持。我也不知道该怎么办了。周一去公司的时候查一下接口能不能跨域再说。","source":"_posts/使用浏览器唤起app.md","raw":"---\ntitle: 使用浏览器唤起app\ndate: 2018-01-06 18:38:38\ntags: android\n---\n浏览器唤起app，其实很简单，是使用manifest中注册scheme的方式来设置。\n\nmanifest中注册如下\n\n```\n<intent-filter>\n    <action android:name=\"android.intent.action.VIEW\"/>\n    <category android:name=\"android.intent.category.DEFAULT\" />\n    <category android:name=\"android.intent.category.BROWSABLE\" />\n    <data android:scheme=\"myapp\" android:host=\"jp.app\" android:pathPrefix=\"/openwith\"/>\n</intent-filter>\n```\n\n这段代表了唤起方式可以由浏览器唤起，data方面重要的是写scheme，之后的host和pathprefix都是无关紧要的。\n\nassets文件夹里面放静态html页面，使用webview来load。\n\n```\n<a href=\"myapp://jp.app/openwith?name=zhangsan&age=26\">启动应用程序</a>\n```\n\n启动的activity里面接受intent\n```\nif(Intent.ACTION_VIEW.equals(action)){\n    Uri uri = i_getvalue.getData();\n    if(uri != null){\n        String name = uri.getQueryParameter(\"name\");\n        String age= uri.getQueryParameter(\"age\");\n        Log.d(getClass().getName(),name+age);\n\t}\n}\n```\n\n可以接收到intent里面包含的信息。\n\n针对昨天的问题，如何从html中get一个接口的数据，然后返回吊起activity，可以直接使用script来fetch（url），针对内容对唤起的activity后缀加内容。\n\n目前关于这个问题还是涉及到跨域的情况，张凯说使用301转发，周宇说跨域需要接口支持。我也不知道该怎么办了。周一去公司的时候查一下接口能不能跨域再说。","slug":"使用浏览器唤起app","published":1,"updated":"2018-01-09T03:00:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7faj000xd41ig6505kwd","content":"<p>浏览器唤起app，其实很简单，是使用manifest中注册scheme的方式来设置。</p>\n<p>manifest中注册如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;intent-filter&gt;</span><br><span class=\"line\">    &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;</span><br><span class=\"line\">    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class=\"line\">    &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;</span><br><span class=\"line\">    &lt;data android:scheme=&quot;myapp&quot; android:host=&quot;jp.app&quot; android:pathPrefix=&quot;/openwith&quot;/&gt;</span><br><span class=\"line\">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>\n<p>这段代表了唤起方式可以由浏览器唤起，data方面重要的是写scheme，之后的host和pathprefix都是无关紧要的。</p>\n<p>assets文件夹里面放静态html页面，使用webview来load。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;myapp://jp.app/openwith?name=zhangsan&amp;age=26&quot;&gt;启动应用程序&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<p>启动的activity里面接受intent<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(Intent.ACTION_VIEW.equals(action))&#123;</span><br><span class=\"line\">    Uri uri = i_getvalue.getData();</span><br><span class=\"line\">    if(uri != null)&#123;</span><br><span class=\"line\">        String name = uri.getQueryParameter(&quot;name&quot;);</span><br><span class=\"line\">        String age= uri.getQueryParameter(&quot;age&quot;);</span><br><span class=\"line\">        Log.d(getClass().getName(),name+age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以接收到intent里面包含的信息。</p>\n<p>针对昨天的问题，如何从html中get一个接口的数据，然后返回吊起activity，可以直接使用script来fetch（url），针对内容对唤起的activity后缀加内容。</p>\n<p>目前关于这个问题还是涉及到跨域的情况，张凯说使用301转发，周宇说跨域需要接口支持。我也不知道该怎么办了。周一去公司的时候查一下接口能不能跨域再说。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>浏览器唤起app，其实很简单，是使用manifest中注册scheme的方式来设置。</p>\n<p>manifest中注册如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;intent-filter&gt;</span><br><span class=\"line\">    &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;</span><br><span class=\"line\">    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class=\"line\">    &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;</span><br><span class=\"line\">    &lt;data android:scheme=&quot;myapp&quot; android:host=&quot;jp.app&quot; android:pathPrefix=&quot;/openwith&quot;/&gt;</span><br><span class=\"line\">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>\n<p>这段代表了唤起方式可以由浏览器唤起，data方面重要的是写scheme，之后的host和pathprefix都是无关紧要的。</p>\n<p>assets文件夹里面放静态html页面，使用webview来load。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;myapp://jp.app/openwith?name=zhangsan&amp;age=26&quot;&gt;启动应用程序&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<p>启动的activity里面接受intent<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(Intent.ACTION_VIEW.equals(action))&#123;</span><br><span class=\"line\">    Uri uri = i_getvalue.getData();</span><br><span class=\"line\">    if(uri != null)&#123;</span><br><span class=\"line\">        String name = uri.getQueryParameter(&quot;name&quot;);</span><br><span class=\"line\">        String age= uri.getQueryParameter(&quot;age&quot;);</span><br><span class=\"line\">        Log.d(getClass().getName(),name+age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以接收到intent里面包含的信息。</p>\n<p>针对昨天的问题，如何从html中get一个接口的数据，然后返回吊起activity，可以直接使用script来fetch（url），针对内容对唤起的activity后缀加内容。</p>\n<p>目前关于这个问题还是涉及到跨域的情况，张凯说使用301转发，周宇说跨域需要接口支持。我也不知道该怎么办了。周一去公司的时候查一下接口能不能跨域再说。</p>\n"},{"title":"冒泡排序","date":"2018-01-11T13:52:24.000Z","_content":"\n冒泡排序是内部排序中交换排序的一种。\n\n# 算法思想\n\n对当前还未排序好的范围内的全部数，自上而下对相邻的两个数进行比较和调整，大的下沉，小的上浮。\n\n# 空间复杂度\n\n只是互换，为O(1)\n\n# 时间复杂度\n\n两次循环，故为O(n^2)\n\n# 算法实现思想\n\n每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。\n\n# java实现\n\n```\npublic int[] bubbleSort(int[] array){\n\tint[] arr = array;\n\tfor(int i = 0; i < array.length - 1; i ++){\n\t\tfor(int j = 0; j < array.length - i - 1; j ++){\n\t\t\tif(arr[j] > arr[j+1]){\n\t\t\t\tint temp = arr[j];\n\t\t\t\tarr[j] = arr[j+1];\n\t\t\t\tarr[j+1] = temp;\n\t\t\t}\n\t\t}\n\t}\n\treturn arr;\n}\n\n```\n\n# c实现\n\n# python实现","source":"_posts/冒泡排序.md","raw":"---\ntitle: 冒泡排序\ndate: 2018-01-11 21:52:24\ntags:\n---\n\n冒泡排序是内部排序中交换排序的一种。\n\n# 算法思想\n\n对当前还未排序好的范围内的全部数，自上而下对相邻的两个数进行比较和调整，大的下沉，小的上浮。\n\n# 空间复杂度\n\n只是互换，为O(1)\n\n# 时间复杂度\n\n两次循环，故为O(n^2)\n\n# 算法实现思想\n\n每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。\n\n# java实现\n\n```\npublic int[] bubbleSort(int[] array){\n\tint[] arr = array;\n\tfor(int i = 0; i < array.length - 1; i ++){\n\t\tfor(int j = 0; j < array.length - i - 1; j ++){\n\t\t\tif(arr[j] > arr[j+1]){\n\t\t\t\tint temp = arr[j];\n\t\t\t\tarr[j] = arr[j+1];\n\t\t\t\tarr[j+1] = temp;\n\t\t\t}\n\t\t}\n\t}\n\treturn arr;\n}\n\n```\n\n# c实现\n\n# python实现","slug":"冒泡排序","published":1,"updated":"2018-01-16T08:58:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7fak0010d41inph5ao6h","content":"<p>冒泡排序是内部排序中交换排序的一种。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>对当前还未排序好的范围内的全部数，自上而下对相邻的两个数进行比较和调整，大的下沉，小的上浮。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>只是互换，为O(1)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>两次循环，故为O(n^2)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p>\n<h1 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int[] bubbleSort(int[] array)&#123;</span><br><span class=\"line\">\tint[] arr = array;</span><br><span class=\"line\">\tfor(int i = 0; i &lt; array.length - 1; i ++)&#123;</span><br><span class=\"line\">\t\tfor(int j = 0; j &lt; array.length - i - 1; j ++)&#123;</span><br><span class=\"line\">\t\t\tif(arr[j] &gt; arr[j+1])&#123;</span><br><span class=\"line\">\t\t\t\tint temp = arr[j];</span><br><span class=\"line\">\t\t\t\tarr[j] = arr[j+1];</span><br><span class=\"line\">\t\t\t\tarr[j+1] = temp;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h1><h1 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h1>","site":{"data":{}},"excerpt":"","more":"<p>冒泡排序是内部排序中交换排序的一种。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>对当前还未排序好的范围内的全部数，自上而下对相邻的两个数进行比较和调整，大的下沉，小的上浮。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>只是互换，为O(1)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>两次循环，故为O(n^2)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p>\n<h1 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int[] bubbleSort(int[] array)&#123;</span><br><span class=\"line\">\tint[] arr = array;</span><br><span class=\"line\">\tfor(int i = 0; i &lt; array.length - 1; i ++)&#123;</span><br><span class=\"line\">\t\tfor(int j = 0; j &lt; array.length - i - 1; j ++)&#123;</span><br><span class=\"line\">\t\t\tif(arr[j] &gt; arr[j+1])&#123;</span><br><span class=\"line\">\t\t\t\tint temp = arr[j];</span><br><span class=\"line\">\t\t\t\tarr[j] = arr[j+1];</span><br><span class=\"line\">\t\t\t\tarr[j+1] = temp;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h1><h1 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h1>"},{"title":"希尔排序","date":"2018-01-08T15:43:42.000Z","_content":"希尔排序又叫缩小增量排序，是排序中的内部排序的插入排序的一种\n\n# 算法思想\n\n先将整个待排序的记录数组分割为若干个子数组，对各个子数组进行直接插入排序，待整个数组中的元素“基本有序”时，在对全体数组进行依次直接插入排序。\n所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，例如｛2,1,3,6,4,7,5,8,9,｝就可以称为基本有序了。但像｛1,5,9,3,7,8,2,4,6｝这样，9在第三位，2在倒数第三位就谈不上基本有序。\n\n# 空间复杂度\n\n每次只比较一个单元，所以空间复杂度为O(1)\n\n# 时间复杂度\n\n希尔排序是不稳定排序，时间复杂度最好和平均都是O(nlogn),最坏复杂度是O(n^2)\n\n# 算法实现思想\n\n以数组{26, 53, 67, 48, 57, 13, 48, 32, 60, 50 }为例，步长序列为{5,3,1} \n初始化关键字： [26, 53, 67, 48, 57, 13, 48, 32, 60, 50 ]\n\n![排序过程](/images/算法/希尔排序.png)\n\n最后的排序结果： \n13 26 32 48 48 50 53 57 60 67\n\n## java实现\n\n```\npublic static int[] shellSort(int[] array){\n\tint i = 0;\n\tint temp = 0;\n\tint[] arr = array;\n\tfor (int increment = arr.length; increment > 0; increment /= 2){\n\t\tfor (i = increment; i < arr.length; i++){\n\t\t\ttemp = arr[i];\n\t\t\tfor (j = i - increment; j >= 0; j -= increment){\n\t\t\t\tif (temp < data[j]){\n\t\t\t\t\tdata[j + increment] = data[j];\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn arr;\n}\n```\n\n## c实现\n\n```\nvoid shell_sort(int array[], int length){  \n    int i;  \n    int j;  \n    int k;  \n    int gap;    //gap是分组的步长  \n    int temp;   //希尔排序是在直接插入排序的基础上实现的,所以仍然需要哨兵  \n    for(gap=length/2; gap>0; gap=gap/2){  \n        for(i=0; i<gap; i++){  \n            for(j=i+gap; j<length; j=j+gap){ //单独一次的插入排序  \n                if(array[j] < array[j - gap]){  \n                    temp = array[j];    //哨兵  \n                    k = j - gap;  \n                    while(k>=0 && array[k]>temp){  \n                        array[k + gap] = array[k];  \n                        k = k - gap;  \n                    }  \n                    array[k + gap] = temp;  \n                }  \n            }  \n        }  \n    }  \n} \n```\n\n## python实现\n\n```\ndef shell_sort(A):\n    N = len(A)\n    increment = N//2\n    while increment > 0:\n        i = increment\n        while i < N:\n            j = i - increment\n            tmp = A[i]\n            while j >= 0 and A[j] > tmp:\n                A[j + increment] = A[j]\n                j -= increment\n            A[j + increment] = tmp\n            i += 1\n        increment //= 2\n    return None\n```\n","source":"_posts/希尔排序.md","raw":"---\ntitle: 希尔排序\ndate: 2018-01-08 23:43:42\ntags: 算法\n---\n希尔排序又叫缩小增量排序，是排序中的内部排序的插入排序的一种\n\n# 算法思想\n\n先将整个待排序的记录数组分割为若干个子数组，对各个子数组进行直接插入排序，待整个数组中的元素“基本有序”时，在对全体数组进行依次直接插入排序。\n所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，例如｛2,1,3,6,4,7,5,8,9,｝就可以称为基本有序了。但像｛1,5,9,3,7,8,2,4,6｝这样，9在第三位，2在倒数第三位就谈不上基本有序。\n\n# 空间复杂度\n\n每次只比较一个单元，所以空间复杂度为O(1)\n\n# 时间复杂度\n\n希尔排序是不稳定排序，时间复杂度最好和平均都是O(nlogn),最坏复杂度是O(n^2)\n\n# 算法实现思想\n\n以数组{26, 53, 67, 48, 57, 13, 48, 32, 60, 50 }为例，步长序列为{5,3,1} \n初始化关键字： [26, 53, 67, 48, 57, 13, 48, 32, 60, 50 ]\n\n![排序过程](/images/算法/希尔排序.png)\n\n最后的排序结果： \n13 26 32 48 48 50 53 57 60 67\n\n## java实现\n\n```\npublic static int[] shellSort(int[] array){\n\tint i = 0;\n\tint temp = 0;\n\tint[] arr = array;\n\tfor (int increment = arr.length; increment > 0; increment /= 2){\n\t\tfor (i = increment; i < arr.length; i++){\n\t\t\ttemp = arr[i];\n\t\t\tfor (j = i - increment; j >= 0; j -= increment){\n\t\t\t\tif (temp < data[j]){\n\t\t\t\t\tdata[j + increment] = data[j];\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn arr;\n}\n```\n\n## c实现\n\n```\nvoid shell_sort(int array[], int length){  \n    int i;  \n    int j;  \n    int k;  \n    int gap;    //gap是分组的步长  \n    int temp;   //希尔排序是在直接插入排序的基础上实现的,所以仍然需要哨兵  \n    for(gap=length/2; gap>0; gap=gap/2){  \n        for(i=0; i<gap; i++){  \n            for(j=i+gap; j<length; j=j+gap){ //单独一次的插入排序  \n                if(array[j] < array[j - gap]){  \n                    temp = array[j];    //哨兵  \n                    k = j - gap;  \n                    while(k>=0 && array[k]>temp){  \n                        array[k + gap] = array[k];  \n                        k = k - gap;  \n                    }  \n                    array[k + gap] = temp;  \n                }  \n            }  \n        }  \n    }  \n} \n```\n\n## python实现\n\n```\ndef shell_sort(A):\n    N = len(A)\n    increment = N//2\n    while increment > 0:\n        i = increment\n        while i < N:\n            j = i - increment\n            tmp = A[i]\n            while j >= 0 and A[j] > tmp:\n                A[j + increment] = A[j]\n                j -= increment\n            A[j + increment] = tmp\n            i += 1\n        increment //= 2\n    return None\n```\n","slug":"希尔排序","published":1,"updated":"2018-01-09T03:00:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7fal0012d41idji40ycp","content":"<p>希尔排序又叫缩小增量排序，是排序中的内部排序的插入排序的一种</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>先将整个待排序的记录数组分割为若干个子数组，对各个子数组进行直接插入排序，待整个数组中的元素“基本有序”时，在对全体数组进行依次直接插入排序。<br>所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，例如｛2,1,3,6,4,7,5,8,9,｝就可以称为基本有序了。但像｛1,5,9,3,7,8,2,4,6｝这样，9在第三位，2在倒数第三位就谈不上基本有序。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>每次只比较一个单元，所以空间复杂度为O(1)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>希尔排序是不稳定排序，时间复杂度最好和平均都是O(nlogn),最坏复杂度是O(n^2)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>以数组{26, 53, 67, 48, 57, 13, 48, 32, 60, 50 }为例，步长序列为{5,3,1}<br>初始化关键字： [26, 53, 67, 48, 57, 13, 48, 32, 60, 50 ]</p>\n<p><img src=\"/images/算法/希尔排序.png\" alt=\"排序过程\"></p>\n<p>最后的排序结果：<br>13 26 32 48 48 50 53 57 60 67</p>\n<h2 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int[] shellSort(int[] array)&#123;</span><br><span class=\"line\">\tint i = 0;</span><br><span class=\"line\">\tint temp = 0;</span><br><span class=\"line\">\tint[] arr = array;</span><br><span class=\"line\">\tfor (int increment = arr.length; increment &gt; 0; increment /= 2)&#123;</span><br><span class=\"line\">\t\tfor (i = increment; i &lt; arr.length; i++)&#123;</span><br><span class=\"line\">\t\t\ttemp = arr[i];</span><br><span class=\"line\">\t\t\tfor (j = i - increment; j &gt;= 0; j -= increment)&#123;</span><br><span class=\"line\">\t\t\t\tif (temp &lt; data[j])&#123;</span><br><span class=\"line\">\t\t\t\t\tdata[j + increment] = data[j];</span><br><span class=\"line\">\t\t\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void shell_sort(int array[], int length)&#123;  </span><br><span class=\"line\">    int i;  </span><br><span class=\"line\">    int j;  </span><br><span class=\"line\">    int k;  </span><br><span class=\"line\">    int gap;    //gap是分组的步长  </span><br><span class=\"line\">    int temp;   //希尔排序是在直接插入排序的基础上实现的,所以仍然需要哨兵  </span><br><span class=\"line\">    for(gap=length/2; gap&gt;0; gap=gap/2)&#123;  </span><br><span class=\"line\">        for(i=0; i&lt;gap; i++)&#123;  </span><br><span class=\"line\">            for(j=i+gap; j&lt;length; j=j+gap)&#123; //单独一次的插入排序  </span><br><span class=\"line\">                if(array[j] &lt; array[j - gap])&#123;  </span><br><span class=\"line\">                    temp = array[j];    //哨兵  </span><br><span class=\"line\">                    k = j - gap;  </span><br><span class=\"line\">                    while(k&gt;=0 &amp;&amp; array[k]&gt;temp)&#123;  </span><br><span class=\"line\">                        array[k + gap] = array[k];  </span><br><span class=\"line\">                        k = k - gap;  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    array[k + gap] = temp;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def shell_sort(A):</span><br><span class=\"line\">    N = len(A)</span><br><span class=\"line\">    increment = N//2</span><br><span class=\"line\">    while increment &gt; 0:</span><br><span class=\"line\">        i = increment</span><br><span class=\"line\">        while i &lt; N:</span><br><span class=\"line\">            j = i - increment</span><br><span class=\"line\">            tmp = A[i]</span><br><span class=\"line\">            while j &gt;= 0 and A[j] &gt; tmp:</span><br><span class=\"line\">                A[j + increment] = A[j]</span><br><span class=\"line\">                j -= increment</span><br><span class=\"line\">            A[j + increment] = tmp</span><br><span class=\"line\">            i += 1</span><br><span class=\"line\">        increment //= 2</span><br><span class=\"line\">    return None</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>希尔排序又叫缩小增量排序，是排序中的内部排序的插入排序的一种</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>先将整个待排序的记录数组分割为若干个子数组，对各个子数组进行直接插入排序，待整个数组中的元素“基本有序”时，在对全体数组进行依次直接插入排序。<br>所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，例如｛2,1,3,6,4,7,5,8,9,｝就可以称为基本有序了。但像｛1,5,9,3,7,8,2,4,6｝这样，9在第三位，2在倒数第三位就谈不上基本有序。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>每次只比较一个单元，所以空间复杂度为O(1)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>希尔排序是不稳定排序，时间复杂度最好和平均都是O(nlogn),最坏复杂度是O(n^2)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>以数组{26, 53, 67, 48, 57, 13, 48, 32, 60, 50 }为例，步长序列为{5,3,1}<br>初始化关键字： [26, 53, 67, 48, 57, 13, 48, 32, 60, 50 ]</p>\n<p><img src=\"/images/算法/希尔排序.png\" alt=\"排序过程\"></p>\n<p>最后的排序结果：<br>13 26 32 48 48 50 53 57 60 67</p>\n<h2 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int[] shellSort(int[] array)&#123;</span><br><span class=\"line\">\tint i = 0;</span><br><span class=\"line\">\tint temp = 0;</span><br><span class=\"line\">\tint[] arr = array;</span><br><span class=\"line\">\tfor (int increment = arr.length; increment &gt; 0; increment /= 2)&#123;</span><br><span class=\"line\">\t\tfor (i = increment; i &lt; arr.length; i++)&#123;</span><br><span class=\"line\">\t\t\ttemp = arr[i];</span><br><span class=\"line\">\t\t\tfor (j = i - increment; j &gt;= 0; j -= increment)&#123;</span><br><span class=\"line\">\t\t\t\tif (temp &lt; data[j])&#123;</span><br><span class=\"line\">\t\t\t\t\tdata[j + increment] = data[j];</span><br><span class=\"line\">\t\t\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void shell_sort(int array[], int length)&#123;  </span><br><span class=\"line\">    int i;  </span><br><span class=\"line\">    int j;  </span><br><span class=\"line\">    int k;  </span><br><span class=\"line\">    int gap;    //gap是分组的步长  </span><br><span class=\"line\">    int temp;   //希尔排序是在直接插入排序的基础上实现的,所以仍然需要哨兵  </span><br><span class=\"line\">    for(gap=length/2; gap&gt;0; gap=gap/2)&#123;  </span><br><span class=\"line\">        for(i=0; i&lt;gap; i++)&#123;  </span><br><span class=\"line\">            for(j=i+gap; j&lt;length; j=j+gap)&#123; //单独一次的插入排序  </span><br><span class=\"line\">                if(array[j] &lt; array[j - gap])&#123;  </span><br><span class=\"line\">                    temp = array[j];    //哨兵  </span><br><span class=\"line\">                    k = j - gap;  </span><br><span class=\"line\">                    while(k&gt;=0 &amp;&amp; array[k]&gt;temp)&#123;  </span><br><span class=\"line\">                        array[k + gap] = array[k];  </span><br><span class=\"line\">                        k = k - gap;  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    array[k + gap] = temp;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def shell_sort(A):</span><br><span class=\"line\">    N = len(A)</span><br><span class=\"line\">    increment = N//2</span><br><span class=\"line\">    while increment &gt; 0:</span><br><span class=\"line\">        i = increment</span><br><span class=\"line\">        while i &lt; N:</span><br><span class=\"line\">            j = i - increment</span><br><span class=\"line\">            tmp = A[i]</span><br><span class=\"line\">            while j &gt;= 0 and A[j] &gt; tmp:</span><br><span class=\"line\">                A[j + increment] = A[j]</span><br><span class=\"line\">                j -= increment</span><br><span class=\"line\">            A[j + increment] = tmp</span><br><span class=\"line\">            i += 1</span><br><span class=\"line\">        increment //= 2</span><br><span class=\"line\">    return None</span><br></pre></td></tr></table></figure>\n"},{"title":"堆排序","date":"2018-01-09T15:27:02.000Z","_content":"堆排序是内部排序中选择排序的一种。堆排序是一种树形选择排序，是对选择排序的有效改进。\n\n堆是一种具有n个元素的序列，当且仅当满足 ki<=k2i, ki<= k2i+1，或者反过来。\n若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。\n\n初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。\n然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大的元素。\n依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。\n\n1. 调整小堆顶的方法\n\n1）设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。\n\n2）将根结点与左、右子树中较小元素的进行交换。\n\n3）若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）.\n\n4）若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）.\n\n5）继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。\n\n2. 建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。\n\n1）n 个结点的完全二叉树，则最后一个结点是第个结点的子树。\n\n2）筛选从第个结点为根的子树开始，该子树成为堆。\n\n3）之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。\n\n\n# 算法思想\n\n初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。\n然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大的元素。\n依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。\n\n\n# 空间复杂度\n\n因为堆排序是就地排序，空间复杂度为常数：O(1)\n\n# 时间复杂度\n\n堆排序的时间复杂度，主要在初始化堆过程和每次选取最大数后重新建堆的过程；\n\n初始化建堆过程时间：O(n)\n\n推算过程：\n\n首先要理解怎么计算这个堆化过程所消耗的时间，可以直接画图去理解；\n\n假设高度为k，则从倒数第二层右边的节点开始，这一层的节点都要执行子节点比较然后交换（如果顺序是对的就不用交换）；倒数第三层呢，则会选择其子节点进行比较和交换，如果没交换就可以不用再执行下去了。如果交换了，那么又要选择一支子树进行比较和交换；\n\n那么总的时间计算为：s = 2^( i - 1 )  *  ( k - i )；其中 i 表示第几层，2^( i - 1) 表示该层上有多少个元素，( k - i) 表示子树上要比较的次数，如果在最差的条件下，就是比较次数后还要交换；因为这个是常数，所以提出来后可以忽略；\n\nS = 2^(k-2) * 1 + 2^(k-3)*2.....+2*(k-2)+2^(0)*(k-1)  ===> 因为叶子层不用交换，所以i从 k-1 开始到 1；\n这个等式求解，我想高中已经会了：等式左右乘上2，然后和原来的等式相减，就变成了：\nS = 2^(k - 1) + 2^(k - 2) + 2^(k - 3) ..... + 2 - (k-1)\n除最后一项外，就是一个等比数列了，直接用求和公式：S = {  a1[ 1-  (q^n) ] }  / (1-q)；\nS = 2^k -k -1；又因为k为完全二叉树的深度，所以 (2^k) <=  n < (2^k  -1 )，总之可以认为：k = logn （实际计算得到应该是 log(n+1) < k <= logn ）;\n综上所述得到：S = n - longn -1，所以时间复杂度为：O(n)\n更改堆元素后重建堆时间：O(nlogn)\n推算过程：\n1、循环  n -1 次，每次都是从根节点往下循环查找，所以每一次时间是 logn，总时间：logn(n-1) = nlogn  - logn ；\n综上所述：堆排序的时间复杂度为：O(nlogn)\n\n# 算法实现思想\n\n堆排序的大概步骤如下:\n\n1. 构建最大堆。\n2. 选择顶，并与第0位置元素交换\n3. 由于步骤2的的交换可能破环了最大堆的性质，第0不再是最大元素，需要调用maxHeap调整堆(沉降法)，如果需要重复步骤2\n\n# java实现\n\n```\npublic static void heapSort(int[] array) {  \n    if (array == null || array.length <= 1) {  \n        return;  \n    }  \n  \n    buildMaxHeap(array);  \n  \n    for (int i = array.length - 1; i >= 1; i--) {  \n    \tArrayUtils.exchangeElements(array, 0, i);  \n\n    \tmaxHeap(array, i, 0);  \n    }  \n}  \n  \nprivate static void buildMaxHeap(int[] array) {  \n\tif (array == null || array.length <= 1) {  \n\t\treturn;  \n\t}  \n\n\tint half = array.length / 2;  \n\tfor (int i = half; i >= 0; i--) {  \n\t\tmaxHeap(array, array.length, i);  \n\t}  \n}\nprivate static void maxHeap(int[] array, int heapSize, int index) {  \n\tint left = index * 2 + 1;  \n\tint right = index * 2 + 2;  \n\n\tint largest = index;  \n\tif (left < heapSize && array[left] > array[index]) {  \n\t\tlargest = left;  \n\t}  \n\n\tif (right < heapSize && array[right] > array[largest]) {  \n\t\tlargest = right;  \n\t}  \n\n\tif (index != largest) {  \n\t\tArrayUtils.exchangeElements(array, index, largest);  \n\n\t\tmaxHeap(array, heapSize, largest);  \n\t}  \n}  \npublic static void exchangeElements(int[] array, int index1, int index2) {  \n\tint temp = array[index1];  \n\tarray[index1] = array[index2];  \n\tarray[index2] = temp;  \n}  \n```\n\n# c实现\n\n# python实现","source":"_posts/堆排序.md","raw":"---\ntitle: 堆排序\ndate: 2018-01-09 23:27:02\ntags: 算法\n---\n堆排序是内部排序中选择排序的一种。堆排序是一种树形选择排序，是对选择排序的有效改进。\n\n堆是一种具有n个元素的序列，当且仅当满足 ki<=k2i, ki<= k2i+1，或者反过来。\n若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。\n\n初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。\n然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大的元素。\n依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。\n\n1. 调整小堆顶的方法\n\n1）设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。\n\n2）将根结点与左、右子树中较小元素的进行交换。\n\n3）若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）.\n\n4）若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）.\n\n5）继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。\n\n2. 建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。\n\n1）n 个结点的完全二叉树，则最后一个结点是第个结点的子树。\n\n2）筛选从第个结点为根的子树开始，该子树成为堆。\n\n3）之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。\n\n\n# 算法思想\n\n初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。\n然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大的元素。\n依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。\n\n\n# 空间复杂度\n\n因为堆排序是就地排序，空间复杂度为常数：O(1)\n\n# 时间复杂度\n\n堆排序的时间复杂度，主要在初始化堆过程和每次选取最大数后重新建堆的过程；\n\n初始化建堆过程时间：O(n)\n\n推算过程：\n\n首先要理解怎么计算这个堆化过程所消耗的时间，可以直接画图去理解；\n\n假设高度为k，则从倒数第二层右边的节点开始，这一层的节点都要执行子节点比较然后交换（如果顺序是对的就不用交换）；倒数第三层呢，则会选择其子节点进行比较和交换，如果没交换就可以不用再执行下去了。如果交换了，那么又要选择一支子树进行比较和交换；\n\n那么总的时间计算为：s = 2^( i - 1 )  *  ( k - i )；其中 i 表示第几层，2^( i - 1) 表示该层上有多少个元素，( k - i) 表示子树上要比较的次数，如果在最差的条件下，就是比较次数后还要交换；因为这个是常数，所以提出来后可以忽略；\n\nS = 2^(k-2) * 1 + 2^(k-3)*2.....+2*(k-2)+2^(0)*(k-1)  ===> 因为叶子层不用交换，所以i从 k-1 开始到 1；\n这个等式求解，我想高中已经会了：等式左右乘上2，然后和原来的等式相减，就变成了：\nS = 2^(k - 1) + 2^(k - 2) + 2^(k - 3) ..... + 2 - (k-1)\n除最后一项外，就是一个等比数列了，直接用求和公式：S = {  a1[ 1-  (q^n) ] }  / (1-q)；\nS = 2^k -k -1；又因为k为完全二叉树的深度，所以 (2^k) <=  n < (2^k  -1 )，总之可以认为：k = logn （实际计算得到应该是 log(n+1) < k <= logn ）;\n综上所述得到：S = n - longn -1，所以时间复杂度为：O(n)\n更改堆元素后重建堆时间：O(nlogn)\n推算过程：\n1、循环  n -1 次，每次都是从根节点往下循环查找，所以每一次时间是 logn，总时间：logn(n-1) = nlogn  - logn ；\n综上所述：堆排序的时间复杂度为：O(nlogn)\n\n# 算法实现思想\n\n堆排序的大概步骤如下:\n\n1. 构建最大堆。\n2. 选择顶，并与第0位置元素交换\n3. 由于步骤2的的交换可能破环了最大堆的性质，第0不再是最大元素，需要调用maxHeap调整堆(沉降法)，如果需要重复步骤2\n\n# java实现\n\n```\npublic static void heapSort(int[] array) {  \n    if (array == null || array.length <= 1) {  \n        return;  \n    }  \n  \n    buildMaxHeap(array);  \n  \n    for (int i = array.length - 1; i >= 1; i--) {  \n    \tArrayUtils.exchangeElements(array, 0, i);  \n\n    \tmaxHeap(array, i, 0);  \n    }  \n}  \n  \nprivate static void buildMaxHeap(int[] array) {  \n\tif (array == null || array.length <= 1) {  \n\t\treturn;  \n\t}  \n\n\tint half = array.length / 2;  \n\tfor (int i = half; i >= 0; i--) {  \n\t\tmaxHeap(array, array.length, i);  \n\t}  \n}\nprivate static void maxHeap(int[] array, int heapSize, int index) {  \n\tint left = index * 2 + 1;  \n\tint right = index * 2 + 2;  \n\n\tint largest = index;  \n\tif (left < heapSize && array[left] > array[index]) {  \n\t\tlargest = left;  \n\t}  \n\n\tif (right < heapSize && array[right] > array[largest]) {  \n\t\tlargest = right;  \n\t}  \n\n\tif (index != largest) {  \n\t\tArrayUtils.exchangeElements(array, index, largest);  \n\n\t\tmaxHeap(array, heapSize, largest);  \n\t}  \n}  \npublic static void exchangeElements(int[] array, int index1, int index2) {  \n\tint temp = array[index1];  \n\tarray[index1] = array[index2];  \n\tarray[index2] = temp;  \n}  \n```\n\n# c实现\n\n# python实现","slug":"堆排序","published":1,"updated":"2018-01-16T08:58:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7fan0014d41inueyo4zq","content":"<p>堆排序是内部排序中选择排序的一种。堆排序是一种树形选择排序，是对选择排序的有效改进。</p>\n<p>堆是一种具有n个元素的序列，当且仅当满足 ki&lt;=k2i, ki&lt;= k2i+1，或者反过来。<br>若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。</p>\n<p>初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。<br>然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大的元素。<br>依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。</p>\n<ol>\n<li>调整小堆顶的方法</li>\n</ol>\n<p>1）设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。</p>\n<p>2）将根结点与左、右子树中较小元素的进行交换。</p>\n<p>3）若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）.</p>\n<p>4）若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）.</p>\n<p>5）继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。</p>\n<ol>\n<li>建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。</li>\n</ol>\n<p>1）n 个结点的完全二叉树，则最后一个结点是第个结点的子树。</p>\n<p>2）筛选从第个结点为根的子树开始，该子树成为堆。</p>\n<p>3）之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。<br>然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大的元素。<br>依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>因为堆排序是就地排序，空间复杂度为常数：O(1)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>堆排序的时间复杂度，主要在初始化堆过程和每次选取最大数后重新建堆的过程；</p>\n<p>初始化建堆过程时间：O(n)</p>\n<p>推算过程：</p>\n<p>首先要理解怎么计算这个堆化过程所消耗的时间，可以直接画图去理解；</p>\n<p>假设高度为k，则从倒数第二层右边的节点开始，这一层的节点都要执行子节点比较然后交换（如果顺序是对的就不用交换）；倒数第三层呢，则会选择其子节点进行比较和交换，如果没交换就可以不用再执行下去了。如果交换了，那么又要选择一支子树进行比较和交换；</p>\n<p>那么总的时间计算为：s = 2^( i - 1 )  *  ( k - i )；其中 i 表示第几层，2^( i - 1) 表示该层上有多少个元素，( k - i) 表示子树上要比较的次数，如果在最差的条件下，就是比较次数后还要交换；因为这个是常数，所以提出来后可以忽略；</p>\n<p>S = 2^(k-2) <em> 1 + 2^(k-3)</em>2…..+2<em>(k-2)+2^(0)</em>(k-1)  ===&gt; 因为叶子层不用交换，所以i从 k-1 开始到 1；<br>这个等式求解，我想高中已经会了：等式左右乘上2，然后和原来的等式相减，就变成了：<br>S = 2^(k - 1) + 2^(k - 2) + 2^(k - 3) ….. + 2 - (k-1)<br>除最后一项外，就是一个等比数列了，直接用求和公式：S = {  a1[ 1-  (q^n) ] }  / (1-q)；<br>S = 2^k -k -1；又因为k为完全二叉树的深度，所以 (2^k) &lt;=  n &lt; (2^k  -1 )，总之可以认为：k = logn （实际计算得到应该是 log(n+1) &lt; k &lt;= logn ）;<br>综上所述得到：S = n - longn -1，所以时间复杂度为：O(n)<br>更改堆元素后重建堆时间：O(nlogn)<br>推算过程：<br>1、循环  n -1 次，每次都是从根节点往下循环查找，所以每一次时间是 logn，总时间：logn(n-1) = nlogn  - logn ；<br>综上所述：堆排序的时间复杂度为：O(nlogn)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>堆排序的大概步骤如下:</p>\n<ol>\n<li>构建最大堆。</li>\n<li>选择顶，并与第0位置元素交换</li>\n<li>由于步骤2的的交换可能破环了最大堆的性质，第0不再是最大元素，需要调用maxHeap调整堆(沉降法)，如果需要重复步骤2</li>\n</ol>\n<h1 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void heapSort(int[] array) &#123;  </span><br><span class=\"line\">    if (array == null || array.length &lt;= 1) &#123;  </span><br><span class=\"line\">        return;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    buildMaxHeap(array);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    for (int i = array.length - 1; i &gt;= 1; i--) &#123;  </span><br><span class=\"line\">    \tArrayUtils.exchangeElements(array, 0, i);  </span><br><span class=\"line\"></span><br><span class=\"line\">    \tmaxHeap(array, i, 0);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">private static void buildMaxHeap(int[] array) &#123;  </span><br><span class=\"line\">\tif (array == null || array.length &lt;= 1) &#123;  </span><br><span class=\"line\">\t\treturn;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">\tint half = array.length / 2;  </span><br><span class=\"line\">\tfor (int i = half; i &gt;= 0; i--) &#123;  </span><br><span class=\"line\">\t\tmaxHeap(array, array.length, i);  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private static void maxHeap(int[] array, int heapSize, int index) &#123;  </span><br><span class=\"line\">\tint left = index * 2 + 1;  </span><br><span class=\"line\">\tint right = index * 2 + 2;  </span><br><span class=\"line\"></span><br><span class=\"line\">\tint largest = index;  </span><br><span class=\"line\">\tif (left &lt; heapSize &amp;&amp; array[left] &gt; array[index]) &#123;  </span><br><span class=\"line\">\t\tlargest = left;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">\tif (right &lt; heapSize &amp;&amp; array[right] &gt; array[largest]) &#123;  </span><br><span class=\"line\">\t\tlargest = right;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">\tif (index != largest) &#123;  </span><br><span class=\"line\">\t\tArrayUtils.exchangeElements(array, index, largest);  </span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmaxHeap(array, heapSize, largest);  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">public static void exchangeElements(int[] array, int index1, int index2) &#123;  </span><br><span class=\"line\">\tint temp = array[index1];  </span><br><span class=\"line\">\tarray[index1] = array[index2];  </span><br><span class=\"line\">\tarray[index2] = temp;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h1><h1 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h1>","site":{"data":{}},"excerpt":"","more":"<p>堆排序是内部排序中选择排序的一种。堆排序是一种树形选择排序，是对选择排序的有效改进。</p>\n<p>堆是一种具有n个元素的序列，当且仅当满足 ki&lt;=k2i, ki&lt;= k2i+1，或者反过来。<br>若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。</p>\n<p>初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。<br>然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大的元素。<br>依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。</p>\n<ol>\n<li>调整小堆顶的方法</li>\n</ol>\n<p>1）设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。</p>\n<p>2）将根结点与左、右子树中较小元素的进行交换。</p>\n<p>3）若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）.</p>\n<p>4）若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）.</p>\n<p>5）继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。</p>\n<ol>\n<li>建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。</li>\n</ol>\n<p>1）n 个结点的完全二叉树，则最后一个结点是第个结点的子树。</p>\n<p>2）筛选从第个结点为根的子树开始，该子树成为堆。</p>\n<p>3）之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。<br>然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大的元素。<br>依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>因为堆排序是就地排序，空间复杂度为常数：O(1)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>堆排序的时间复杂度，主要在初始化堆过程和每次选取最大数后重新建堆的过程；</p>\n<p>初始化建堆过程时间：O(n)</p>\n<p>推算过程：</p>\n<p>首先要理解怎么计算这个堆化过程所消耗的时间，可以直接画图去理解；</p>\n<p>假设高度为k，则从倒数第二层右边的节点开始，这一层的节点都要执行子节点比较然后交换（如果顺序是对的就不用交换）；倒数第三层呢，则会选择其子节点进行比较和交换，如果没交换就可以不用再执行下去了。如果交换了，那么又要选择一支子树进行比较和交换；</p>\n<p>那么总的时间计算为：s = 2^( i - 1 )  *  ( k - i )；其中 i 表示第几层，2^( i - 1) 表示该层上有多少个元素，( k - i) 表示子树上要比较的次数，如果在最差的条件下，就是比较次数后还要交换；因为这个是常数，所以提出来后可以忽略；</p>\n<p>S = 2^(k-2) <em> 1 + 2^(k-3)</em>2…..+2<em>(k-2)+2^(0)</em>(k-1)  ===&gt; 因为叶子层不用交换，所以i从 k-1 开始到 1；<br>这个等式求解，我想高中已经会了：等式左右乘上2，然后和原来的等式相减，就变成了：<br>S = 2^(k - 1) + 2^(k - 2) + 2^(k - 3) ….. + 2 - (k-1)<br>除最后一项外，就是一个等比数列了，直接用求和公式：S = {  a1[ 1-  (q^n) ] }  / (1-q)；<br>S = 2^k -k -1；又因为k为完全二叉树的深度，所以 (2^k) &lt;=  n &lt; (2^k  -1 )，总之可以认为：k = logn （实际计算得到应该是 log(n+1) &lt; k &lt;= logn ）;<br>综上所述得到：S = n - longn -1，所以时间复杂度为：O(n)<br>更改堆元素后重建堆时间：O(nlogn)<br>推算过程：<br>1、循环  n -1 次，每次都是从根节点往下循环查找，所以每一次时间是 logn，总时间：logn(n-1) = nlogn  - logn ；<br>综上所述：堆排序的时间复杂度为：O(nlogn)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>堆排序的大概步骤如下:</p>\n<ol>\n<li>构建最大堆。</li>\n<li>选择顶，并与第0位置元素交换</li>\n<li>由于步骤2的的交换可能破环了最大堆的性质，第0不再是最大元素，需要调用maxHeap调整堆(沉降法)，如果需要重复步骤2</li>\n</ol>\n<h1 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void heapSort(int[] array) &#123;  </span><br><span class=\"line\">    if (array == null || array.length &lt;= 1) &#123;  </span><br><span class=\"line\">        return;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    buildMaxHeap(array);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    for (int i = array.length - 1; i &gt;= 1; i--) &#123;  </span><br><span class=\"line\">    \tArrayUtils.exchangeElements(array, 0, i);  </span><br><span class=\"line\"></span><br><span class=\"line\">    \tmaxHeap(array, i, 0);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">private static void buildMaxHeap(int[] array) &#123;  </span><br><span class=\"line\">\tif (array == null || array.length &lt;= 1) &#123;  </span><br><span class=\"line\">\t\treturn;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">\tint half = array.length / 2;  </span><br><span class=\"line\">\tfor (int i = half; i &gt;= 0; i--) &#123;  </span><br><span class=\"line\">\t\tmaxHeap(array, array.length, i);  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private static void maxHeap(int[] array, int heapSize, int index) &#123;  </span><br><span class=\"line\">\tint left = index * 2 + 1;  </span><br><span class=\"line\">\tint right = index * 2 + 2;  </span><br><span class=\"line\"></span><br><span class=\"line\">\tint largest = index;  </span><br><span class=\"line\">\tif (left &lt; heapSize &amp;&amp; array[left] &gt; array[index]) &#123;  </span><br><span class=\"line\">\t\tlargest = left;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">\tif (right &lt; heapSize &amp;&amp; array[right] &gt; array[largest]) &#123;  </span><br><span class=\"line\">\t\tlargest = right;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">\tif (index != largest) &#123;  </span><br><span class=\"line\">\t\tArrayUtils.exchangeElements(array, index, largest);  </span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmaxHeap(array, heapSize, largest);  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">public static void exchangeElements(int[] array, int index1, int index2) &#123;  </span><br><span class=\"line\">\tint temp = array[index1];  </span><br><span class=\"line\">\tarray[index1] = array[index2];  </span><br><span class=\"line\">\tarray[index2] = temp;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h1><h1 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h1>"},{"title":"快速排序","date":"2018-01-11T14:32:16.000Z","_content":"快速排序是内部排序中交换排序的一种。\n\n# 算法思想\n\n1）选择一个基准元素,通常选择第一个元素或者最后一个元素,\n\n2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。\n\n3）此时基准元素在其排好序后的正确位置\n\n4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。\n\n# 空间复杂度\n\nO(1)\n\n# 时间复杂度\n\n最理想 O(nlogn) 最差时间O(n^2)\n\n# 算法实现思想\n\n# java实现\n\n```\npublic void sort(int[] a){\n\tint start = 0;\n\tint end = a.length-1;\n\tint key = a[low];\n\t\n\t\n\twhile(end>start){\n\t\t//从后往前比较\n\t\twhile(end>start&&a[end]>=key)  //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较\n\t\tend--;\n\t\tif(a[end]<=key){\n\t\t\tint temp = a[end];\n\t\t\ta[end] = a[start];\n\t\t\ta[start] = temp;\n\t\t}\n\t\t//从前往后比较\n\t\twhile(end>start&&a[start]<=key)//如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置\n\t\tstart++;\n\t\tif(a[start]>=key){\n\t\t\tint temp = a[start];\n\t\t\ta[start] = a[end];\n\t\t\ta[end] = temp;\n\t\t}\n\t\t//此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用\n\t}\n\t//递归\n\tif(start>low) sort(a,low,start-1);//左边序列。第一个索引位置到关键值索引-1\n\tif(end<high) sort(a,end+1,high);//右边序列。从关键值索引+1到最后一个\n}\n```\n\n# c实现\n\n# python实现","source":"_posts/快速排序.md","raw":"---\ntitle: 快速排序\ndate: 2018-01-11 22:32:16\ntags:\n---\n快速排序是内部排序中交换排序的一种。\n\n# 算法思想\n\n1）选择一个基准元素,通常选择第一个元素或者最后一个元素,\n\n2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。\n\n3）此时基准元素在其排好序后的正确位置\n\n4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。\n\n# 空间复杂度\n\nO(1)\n\n# 时间复杂度\n\n最理想 O(nlogn) 最差时间O(n^2)\n\n# 算法实现思想\n\n# java实现\n\n```\npublic void sort(int[] a){\n\tint start = 0;\n\tint end = a.length-1;\n\tint key = a[low];\n\t\n\t\n\twhile(end>start){\n\t\t//从后往前比较\n\t\twhile(end>start&&a[end]>=key)  //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较\n\t\tend--;\n\t\tif(a[end]<=key){\n\t\t\tint temp = a[end];\n\t\t\ta[end] = a[start];\n\t\t\ta[start] = temp;\n\t\t}\n\t\t//从前往后比较\n\t\twhile(end>start&&a[start]<=key)//如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置\n\t\tstart++;\n\t\tif(a[start]>=key){\n\t\t\tint temp = a[start];\n\t\t\ta[start] = a[end];\n\t\t\ta[end] = temp;\n\t\t}\n\t\t//此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用\n\t}\n\t//递归\n\tif(start>low) sort(a,low,start-1);//左边序列。第一个索引位置到关键值索引-1\n\tif(end<high) sort(a,end+1,high);//右边序列。从关键值索引+1到最后一个\n}\n```\n\n# c实现\n\n# python实现","slug":"快速排序","published":1,"updated":"2018-01-16T08:58:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7fao0017d41i9xvw8g9b","content":"<p>快速排序是内部排序中交换排序的一种。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>1）选择一个基准元素,通常选择第一个元素或者最后一个元素,</p>\n<p>2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。</p>\n<p>3）此时基准元素在其排好序后的正确位置</p>\n<p>4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>O(1)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>最理想 O(nlogn) 最差时间O(n^2)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><h1 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void sort(int[] a)&#123;</span><br><span class=\"line\">\tint start = 0;</span><br><span class=\"line\">\tint end = a.length-1;</span><br><span class=\"line\">\tint key = a[low];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\twhile(end&gt;start)&#123;</span><br><span class=\"line\">\t\t//从后往前比较</span><br><span class=\"line\">\t\twhile(end&gt;start&amp;&amp;a[end]&gt;=key)  //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较</span><br><span class=\"line\">\t\tend--;</span><br><span class=\"line\">\t\tif(a[end]&lt;=key)&#123;</span><br><span class=\"line\">\t\t\tint temp = a[end];</span><br><span class=\"line\">\t\t\ta[end] = a[start];</span><br><span class=\"line\">\t\t\ta[start] = temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t//从前往后比较</span><br><span class=\"line\">\t\twhile(end&gt;start&amp;&amp;a[start]&lt;=key)//如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置</span><br><span class=\"line\">\t\tstart++;</span><br><span class=\"line\">\t\tif(a[start]&gt;=key)&#123;</span><br><span class=\"line\">\t\t\tint temp = a[start];</span><br><span class=\"line\">\t\t\ta[start] = a[end];</span><br><span class=\"line\">\t\t\ta[end] = temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t//此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t//递归</span><br><span class=\"line\">\tif(start&gt;low) sort(a,low,start-1);//左边序列。第一个索引位置到关键值索引-1</span><br><span class=\"line\">\tif(end&lt;high) sort(a,end+1,high);//右边序列。从关键值索引+1到最后一个</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h1><h1 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h1>","site":{"data":{}},"excerpt":"","more":"<p>快速排序是内部排序中交换排序的一种。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>1）选择一个基准元素,通常选择第一个元素或者最后一个元素,</p>\n<p>2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。</p>\n<p>3）此时基准元素在其排好序后的正确位置</p>\n<p>4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>O(1)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>最理想 O(nlogn) 最差时间O(n^2)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><h1 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void sort(int[] a)&#123;</span><br><span class=\"line\">\tint start = 0;</span><br><span class=\"line\">\tint end = a.length-1;</span><br><span class=\"line\">\tint key = a[low];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\twhile(end&gt;start)&#123;</span><br><span class=\"line\">\t\t//从后往前比较</span><br><span class=\"line\">\t\twhile(end&gt;start&amp;&amp;a[end]&gt;=key)  //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较</span><br><span class=\"line\">\t\tend--;</span><br><span class=\"line\">\t\tif(a[end]&lt;=key)&#123;</span><br><span class=\"line\">\t\t\tint temp = a[end];</span><br><span class=\"line\">\t\t\ta[end] = a[start];</span><br><span class=\"line\">\t\t\ta[start] = temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t//从前往后比较</span><br><span class=\"line\">\t\twhile(end&gt;start&amp;&amp;a[start]&lt;=key)//如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置</span><br><span class=\"line\">\t\tstart++;</span><br><span class=\"line\">\t\tif(a[start]&gt;=key)&#123;</span><br><span class=\"line\">\t\t\tint temp = a[start];</span><br><span class=\"line\">\t\t\ta[start] = a[end];</span><br><span class=\"line\">\t\t\ta[end] = temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t//此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t//递归</span><br><span class=\"line\">\tif(start&gt;low) sort(a,low,start-1);//左边序列。第一个索引位置到关键值索引-1</span><br><span class=\"line\">\tif(end&lt;high) sort(a,end+1,high);//右边序列。从关键值索引+1到最后一个</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h1><h1 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h1>"},{"title":"某金融公司面试小记","date":"2018-01-12T12:38:32.000Z","_content":"\n前几天在boss直聘上面接到了一个面试邀请，hr蛮真诚的，今天下午请了半天年假去试试。\n\n# 笔试\n\n首先是笔试，笔试第一题是Math.round(11.5)和Math.round(-11.5)的值,我居然没用过，当时猜的12和-11，还猜对了。\n\n挑有印象的写。\n\n之后是问intent能传送哪些内容，serizable，parcel，bundle，charsquence,当时忘了，就写了个parcel和bundle，回来一看其实都能..\n\n之后的一些字符串处理的\nStringBuffer str = new StringBuffer(\"hello\");\nstr.append(\"world\");\n当然输出hello world了\n\nList<Integer> listA = new ArrayList<>();\nlistA.add(1);\nlistA.add(2);\nList<Integer> listB = new ArrayList<>(listA);\nCollections.copy(listA, listB);\n这时候listb还是1，2\n\nfragment在activity中使用和fragment中使用的差别：\n记得就是fragmentmanager的差别，context的差别。\n\n解释一下DVM中的线程和linux中线程的区别：\nDVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。 \n这题不会。\n\n笔试大概就这么多了。\n\n# 一面\n\n一面是个android的leader，刚开始还不是很打开话夹子，问我为啥走，问我做了哪些工作。居然还把我app开发说成只有6个月，丫的。\n这个leader感觉没问啥高深的问题，我居然都想不起来了。但我的确有几个没回答的上来..汗怎么忘了。\n\n感觉好像对大学学java的比较歧视，以为我没有多深的java功底。\n\n后来问我kotlin的一些相关的，高阶编程，我以为是函数式编程，拿python的高阶函数去说，还居然蒙对了。\n还问我h5会不会，我说只会一丁点，node会不会，只会搭博客，python会不会，这个有。没问c我有点诧异。\n\n问了我一个问题，关于activity的启动模式的，四种我都熟了，后来问我假如这四种同时添加，栈内什么情况，我说正确的，后来问我怎么从a回退到c，我真不知道这个，只能从activitymanager获取stack这个角度来说，这样获取了实例可以直接启动。\n\n\n# 二面\n\n二面是项目经理，这是大神，上来就是一系列由浅入深的题目，让我用mvp设计一个架构，保证耦合度低和热插拔，这部分是接口分离的原则来设计，这部分真不了解。\n之后问我一些别的内容，数据结构方面的，set vector的区别，我居然说vector是线程安全的，但是好像不止这些，其内部指责都不同。\n还问了我一些内容，可是好多我都忘了- -汗。\n\n# 三面\n\n三面是个证券经理，既然是证券经理，为啥揪着我简历上面的技术栈问..蛋疼\n\n# 四面\n\n四面是个妹子，和我讲了一些公司的发展，薪酬方面的，大概扣多少钱五险之类的。\n\n# 五面\n\n五面是联系我去公司的hr，他和我讲了好久公司发展的内容，其实我写的预期薪资并不高啊，最后成功的从税前13扯到了税后11-12，其实还不错。不过明显的他有点慌，他的意思是希望我接到offer能早点去，不要太拖，不要被别的公司高不到5k的offer挖走。汗，加5k是他妈18k了，我哪里值这么多钱。\n\n# 心得\n\n安卓开发自己还是投入了不少心血的，虽然一年半的从业经验，还是收获了不少东西，这次面试也证明了自己的能力。不再是当年在传音的时候任人宰割的那个我了。\n\n# 期望\n\n希望能拿到offer吧，税后12我就去，11以内我就放弃。","source":"_posts/某金融公司面试小记.md","raw":"---\ntitle: 某金融公司面试小记\ndate: 2018-01-12 20:38:32\ntags: 生活\n---\n\n前几天在boss直聘上面接到了一个面试邀请，hr蛮真诚的，今天下午请了半天年假去试试。\n\n# 笔试\n\n首先是笔试，笔试第一题是Math.round(11.5)和Math.round(-11.5)的值,我居然没用过，当时猜的12和-11，还猜对了。\n\n挑有印象的写。\n\n之后是问intent能传送哪些内容，serizable，parcel，bundle，charsquence,当时忘了，就写了个parcel和bundle，回来一看其实都能..\n\n之后的一些字符串处理的\nStringBuffer str = new StringBuffer(\"hello\");\nstr.append(\"world\");\n当然输出hello world了\n\nList<Integer> listA = new ArrayList<>();\nlistA.add(1);\nlistA.add(2);\nList<Integer> listB = new ArrayList<>(listA);\nCollections.copy(listA, listB);\n这时候listb还是1，2\n\nfragment在activity中使用和fragment中使用的差别：\n记得就是fragmentmanager的差别，context的差别。\n\n解释一下DVM中的线程和linux中线程的区别：\nDVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。 \n这题不会。\n\n笔试大概就这么多了。\n\n# 一面\n\n一面是个android的leader，刚开始还不是很打开话夹子，问我为啥走，问我做了哪些工作。居然还把我app开发说成只有6个月，丫的。\n这个leader感觉没问啥高深的问题，我居然都想不起来了。但我的确有几个没回答的上来..汗怎么忘了。\n\n感觉好像对大学学java的比较歧视，以为我没有多深的java功底。\n\n后来问我kotlin的一些相关的，高阶编程，我以为是函数式编程，拿python的高阶函数去说，还居然蒙对了。\n还问我h5会不会，我说只会一丁点，node会不会，只会搭博客，python会不会，这个有。没问c我有点诧异。\n\n问了我一个问题，关于activity的启动模式的，四种我都熟了，后来问我假如这四种同时添加，栈内什么情况，我说正确的，后来问我怎么从a回退到c，我真不知道这个，只能从activitymanager获取stack这个角度来说，这样获取了实例可以直接启动。\n\n\n# 二面\n\n二面是项目经理，这是大神，上来就是一系列由浅入深的题目，让我用mvp设计一个架构，保证耦合度低和热插拔，这部分是接口分离的原则来设计，这部分真不了解。\n之后问我一些别的内容，数据结构方面的，set vector的区别，我居然说vector是线程安全的，但是好像不止这些，其内部指责都不同。\n还问了我一些内容，可是好多我都忘了- -汗。\n\n# 三面\n\n三面是个证券经理，既然是证券经理，为啥揪着我简历上面的技术栈问..蛋疼\n\n# 四面\n\n四面是个妹子，和我讲了一些公司的发展，薪酬方面的，大概扣多少钱五险之类的。\n\n# 五面\n\n五面是联系我去公司的hr，他和我讲了好久公司发展的内容，其实我写的预期薪资并不高啊，最后成功的从税前13扯到了税后11-12，其实还不错。不过明显的他有点慌，他的意思是希望我接到offer能早点去，不要太拖，不要被别的公司高不到5k的offer挖走。汗，加5k是他妈18k了，我哪里值这么多钱。\n\n# 心得\n\n安卓开发自己还是投入了不少心血的，虽然一年半的从业经验，还是收获了不少东西，这次面试也证明了自己的能力。不再是当年在传音的时候任人宰割的那个我了。\n\n# 期望\n\n希望能拿到offer吧，税后12我就去，11以内我就放弃。","slug":"某金融公司面试小记","published":1,"updated":"2018-01-16T08:58:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7fap0019d41iva3ige7c","content":"<p>前几天在boss直聘上面接到了一个面试邀请，hr蛮真诚的，今天下午请了半天年假去试试。</p>\n<h1 id=\"笔试\"><a href=\"#笔试\" class=\"headerlink\" title=\"笔试\"></a>笔试</h1><p>首先是笔试，笔试第一题是Math.round(11.5)和Math.round(-11.5)的值,我居然没用过，当时猜的12和-11，还猜对了。</p>\n<p>挑有印象的写。</p>\n<p>之后是问intent能传送哪些内容，serizable，parcel，bundle，charsquence,当时忘了，就写了个parcel和bundle，回来一看其实都能..</p>\n<p>之后的一些字符串处理的<br>StringBuffer str = new StringBuffer(“hello”);<br>str.append(“world”);<br>当然输出hello world了</p>\n<p>List<integer> listA = new ArrayList&lt;&gt;();<br>listA.add(1);<br>listA.add(2);<br>List<integer> listB = new ArrayList&lt;&gt;(listA);<br>Collections.copy(listA, listB);<br>这时候listb还是1，2</integer></integer></p>\n<p>fragment在activity中使用和fragment中使用的差别：<br>记得就是fragmentmanager的差别，context的差别。</p>\n<p>解释一下DVM中的线程和linux中线程的区别：<br>DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。<br>这题不会。</p>\n<p>笔试大概就这么多了。</p>\n<h1 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h1><p>一面是个android的leader，刚开始还不是很打开话夹子，问我为啥走，问我做了哪些工作。居然还把我app开发说成只有6个月，丫的。<br>这个leader感觉没问啥高深的问题，我居然都想不起来了。但我的确有几个没回答的上来..汗怎么忘了。</p>\n<p>感觉好像对大学学java的比较歧视，以为我没有多深的java功底。</p>\n<p>后来问我kotlin的一些相关的，高阶编程，我以为是函数式编程，拿python的高阶函数去说，还居然蒙对了。<br>还问我h5会不会，我说只会一丁点，node会不会，只会搭博客，python会不会，这个有。没问c我有点诧异。</p>\n<p>问了我一个问题，关于activity的启动模式的，四种我都熟了，后来问我假如这四种同时添加，栈内什么情况，我说正确的，后来问我怎么从a回退到c，我真不知道这个，只能从activitymanager获取stack这个角度来说，这样获取了实例可以直接启动。</p>\n<h1 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h1><p>二面是项目经理，这是大神，上来就是一系列由浅入深的题目，让我用mvp设计一个架构，保证耦合度低和热插拔，这部分是接口分离的原则来设计，这部分真不了解。<br>之后问我一些别的内容，数据结构方面的，set vector的区别，我居然说vector是线程安全的，但是好像不止这些，其内部指责都不同。<br>还问了我一些内容，可是好多我都忘了- -汗。</p>\n<h1 id=\"三面\"><a href=\"#三面\" class=\"headerlink\" title=\"三面\"></a>三面</h1><p>三面是个证券经理，既然是证券经理，为啥揪着我简历上面的技术栈问..蛋疼</p>\n<h1 id=\"四面\"><a href=\"#四面\" class=\"headerlink\" title=\"四面\"></a>四面</h1><p>四面是个妹子，和我讲了一些公司的发展，薪酬方面的，大概扣多少钱五险之类的。</p>\n<h1 id=\"五面\"><a href=\"#五面\" class=\"headerlink\" title=\"五面\"></a>五面</h1><p>五面是联系我去公司的hr，他和我讲了好久公司发展的内容，其实我写的预期薪资并不高啊，最后成功的从税前13扯到了税后11-12，其实还不错。不过明显的他有点慌，他的意思是希望我接到offer能早点去，不要太拖，不要被别的公司高不到5k的offer挖走。汗，加5k是他妈18k了，我哪里值这么多钱。</p>\n<h1 id=\"心得\"><a href=\"#心得\" class=\"headerlink\" title=\"心得\"></a>心得</h1><p>安卓开发自己还是投入了不少心血的，虽然一年半的从业经验，还是收获了不少东西，这次面试也证明了自己的能力。不再是当年在传音的时候任人宰割的那个我了。</p>\n<h1 id=\"期望\"><a href=\"#期望\" class=\"headerlink\" title=\"期望\"></a>期望</h1><p>希望能拿到offer吧，税后12我就去，11以内我就放弃。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>前几天在boss直聘上面接到了一个面试邀请，hr蛮真诚的，今天下午请了半天年假去试试。</p>\n<h1 id=\"笔试\"><a href=\"#笔试\" class=\"headerlink\" title=\"笔试\"></a>笔试</h1><p>首先是笔试，笔试第一题是Math.round(11.5)和Math.round(-11.5)的值,我居然没用过，当时猜的12和-11，还猜对了。</p>\n<p>挑有印象的写。</p>\n<p>之后是问intent能传送哪些内容，serizable，parcel，bundle，charsquence,当时忘了，就写了个parcel和bundle，回来一看其实都能..</p>\n<p>之后的一些字符串处理的<br>StringBuffer str = new StringBuffer(“hello”);<br>str.append(“world”);<br>当然输出hello world了</p>\n<p>List<integer> listA = new ArrayList&lt;&gt;();<br>listA.add(1);<br>listA.add(2);<br>List<integer> listB = new ArrayList&lt;&gt;(listA);<br>Collections.copy(listA, listB);<br>这时候listb还是1，2</integer></integer></p>\n<p>fragment在activity中使用和fragment中使用的差别：<br>记得就是fragmentmanager的差别，context的差别。</p>\n<p>解释一下DVM中的线程和linux中线程的区别：<br>DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。<br>这题不会。</p>\n<p>笔试大概就这么多了。</p>\n<h1 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h1><p>一面是个android的leader，刚开始还不是很打开话夹子，问我为啥走，问我做了哪些工作。居然还把我app开发说成只有6个月，丫的。<br>这个leader感觉没问啥高深的问题，我居然都想不起来了。但我的确有几个没回答的上来..汗怎么忘了。</p>\n<p>感觉好像对大学学java的比较歧视，以为我没有多深的java功底。</p>\n<p>后来问我kotlin的一些相关的，高阶编程，我以为是函数式编程，拿python的高阶函数去说，还居然蒙对了。<br>还问我h5会不会，我说只会一丁点，node会不会，只会搭博客，python会不会，这个有。没问c我有点诧异。</p>\n<p>问了我一个问题，关于activity的启动模式的，四种我都熟了，后来问我假如这四种同时添加，栈内什么情况，我说正确的，后来问我怎么从a回退到c，我真不知道这个，只能从activitymanager获取stack这个角度来说，这样获取了实例可以直接启动。</p>\n<h1 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h1><p>二面是项目经理，这是大神，上来就是一系列由浅入深的题目，让我用mvp设计一个架构，保证耦合度低和热插拔，这部分是接口分离的原则来设计，这部分真不了解。<br>之后问我一些别的内容，数据结构方面的，set vector的区别，我居然说vector是线程安全的，但是好像不止这些，其内部指责都不同。<br>还问了我一些内容，可是好多我都忘了- -汗。</p>\n<h1 id=\"三面\"><a href=\"#三面\" class=\"headerlink\" title=\"三面\"></a>三面</h1><p>三面是个证券经理，既然是证券经理，为啥揪着我简历上面的技术栈问..蛋疼</p>\n<h1 id=\"四面\"><a href=\"#四面\" class=\"headerlink\" title=\"四面\"></a>四面</h1><p>四面是个妹子，和我讲了一些公司的发展，薪酬方面的，大概扣多少钱五险之类的。</p>\n<h1 id=\"五面\"><a href=\"#五面\" class=\"headerlink\" title=\"五面\"></a>五面</h1><p>五面是联系我去公司的hr，他和我讲了好久公司发展的内容，其实我写的预期薪资并不高啊，最后成功的从税前13扯到了税后11-12，其实还不错。不过明显的他有点慌，他的意思是希望我接到offer能早点去，不要太拖，不要被别的公司高不到5k的offer挖走。汗，加5k是他妈18k了，我哪里值这么多钱。</p>\n<h1 id=\"心得\"><a href=\"#心得\" class=\"headerlink\" title=\"心得\"></a>心得</h1><p>安卓开发自己还是投入了不少心血的，虽然一年半的从业经验，还是收获了不少东西，这次面试也证明了自己的能力。不再是当年在传音的时候任人宰割的那个我了。</p>\n<h1 id=\"期望\"><a href=\"#期望\" class=\"headerlink\" title=\"期望\"></a>期望</h1><p>希望能拿到offer吧，税后12我就去，11以内我就放弃。</p>\n"},{"title":"爬虫相关","date":"2017-12-23T09:21:18.000Z","_content":"\n# 概念相关：\n\n## 所有网站皆可爬\n\n互联网的内容都是人写出来的，而且都是偷懒写出来的（不会第一页是a，下一页是8），所以肯定有规律，这就给人有了爬取的可能，可以说，天下没有不能爬的网站\n\n## 框架不变\n\n网站不同，但是原理都类似，大部分爬虫都是从 发送请求——获得页面——解析页面——下载内容——储存内容 这样的流程来进行，只是用的工具不同\n\n# 基础相关\n\n## python 基础\n\nlist，dict：用来序列化你爬的东西\n切片：用来对爬取的内容进行分割，生成\n条件判断（if等）：用来解决爬虫过程中哪些要哪些不要的问题\n循环和迭代（for while ）：用来循环，重复爬虫动作\n文件读写操作：用来读取参数、保存爬下来的内容等\n\n## 网页基本知识\n\n基本的HTML语言知识（知道href等大学计算机一级内容即可）\n理解网站的发包和收包的概念（POST GET）\n稍微一点点的js知识，用于理解动态网页（当然如果本身就懂当然更好啦）\n\n## 分析语言相关\n\n### 正则表达式：扛把子技术，总得会最基础的\n\n![正则表达式](/images/爬虫相关/正则.jpg)\n\n### [xpath](http://www.w3school.com.cn/xpath/)：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则\n\n### [BeautifulSoup](http://beautifulsoup.readthedocs.io/zh_CN/latest/)：美丽汤模块解析网页神器,一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本\n\n## 辅助工具相关\n\n### F12开发者工具\n\n1. 看源代码：快速定位元素\n2. 分析xpath：1、此处建议谷歌系浏览器,可以在源码界面直接右键看\n\n### 抓包工具\n\n推荐httpfox，火狐浏览器下的插件,比谷歌火狐系自带的F12工具都要好，可以方便查看网站收包发包的信息\n\n### XPATH CHECKER (火狐插件）\n\n非常不错的xpath测试工具，但是有几个坑，都是个人踩过的，，在此告诫大家：     1、xpath checker生成的是绝对路径，遇到一些动态生成的图标（常见的有列表翻页按钮等），飘忽不定的绝对路径很有可能造成错误，所以这里建议在真正分析的时候，只是作为参考     2、记得把如下图xpath框里的“x:”去掉，貌似这个是早期版本xpath的语法，目前已经和一些模块不兼容（比如scrapy），还是删去避免报错\n\n### 正则表达式测试工具\n\n[在线正则表达式测试](http://tool.oschina.net/regex/)\n拿来多练练手，也辅助分析！里面有很多现成的正则表达式可以用，也可以进行参考！\n\n## 爬虫模块相关\n\nurllib urllib2 requests \n\n### 现成模块 scrapy\n\n### 动态页面解决 selenium phantomJS\n\n### 反爬虫策略验证码 \n\nPIL opencv pybrain 打码平台\n\n## 数据库相关\n\nmysql， mongodb， sqlite\n\n## 数据处理\n\nnumpy 数据分析，类似matlab的模块\npandas（基于numpy的数据分析模块，相信我，如果你不是专门搞TB级数据的，这个就够了）\n\n## 技术进阶\n\n多线程、分布式\n\n\n","source":"_posts/爬虫相关.md","raw":"---\ntitle: 爬虫相关\ndate: 2017-12-23 17:21:18\ntags: python\n---\n\n# 概念相关：\n\n## 所有网站皆可爬\n\n互联网的内容都是人写出来的，而且都是偷懒写出来的（不会第一页是a，下一页是8），所以肯定有规律，这就给人有了爬取的可能，可以说，天下没有不能爬的网站\n\n## 框架不变\n\n网站不同，但是原理都类似，大部分爬虫都是从 发送请求——获得页面——解析页面——下载内容——储存内容 这样的流程来进行，只是用的工具不同\n\n# 基础相关\n\n## python 基础\n\nlist，dict：用来序列化你爬的东西\n切片：用来对爬取的内容进行分割，生成\n条件判断（if等）：用来解决爬虫过程中哪些要哪些不要的问题\n循环和迭代（for while ）：用来循环，重复爬虫动作\n文件读写操作：用来读取参数、保存爬下来的内容等\n\n## 网页基本知识\n\n基本的HTML语言知识（知道href等大学计算机一级内容即可）\n理解网站的发包和收包的概念（POST GET）\n稍微一点点的js知识，用于理解动态网页（当然如果本身就懂当然更好啦）\n\n## 分析语言相关\n\n### 正则表达式：扛把子技术，总得会最基础的\n\n![正则表达式](/images/爬虫相关/正则.jpg)\n\n### [xpath](http://www.w3school.com.cn/xpath/)：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则\n\n### [BeautifulSoup](http://beautifulsoup.readthedocs.io/zh_CN/latest/)：美丽汤模块解析网页神器,一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本\n\n## 辅助工具相关\n\n### F12开发者工具\n\n1. 看源代码：快速定位元素\n2. 分析xpath：1、此处建议谷歌系浏览器,可以在源码界面直接右键看\n\n### 抓包工具\n\n推荐httpfox，火狐浏览器下的插件,比谷歌火狐系自带的F12工具都要好，可以方便查看网站收包发包的信息\n\n### XPATH CHECKER (火狐插件）\n\n非常不错的xpath测试工具，但是有几个坑，都是个人踩过的，，在此告诫大家：     1、xpath checker生成的是绝对路径，遇到一些动态生成的图标（常见的有列表翻页按钮等），飘忽不定的绝对路径很有可能造成错误，所以这里建议在真正分析的时候，只是作为参考     2、记得把如下图xpath框里的“x:”去掉，貌似这个是早期版本xpath的语法，目前已经和一些模块不兼容（比如scrapy），还是删去避免报错\n\n### 正则表达式测试工具\n\n[在线正则表达式测试](http://tool.oschina.net/regex/)\n拿来多练练手，也辅助分析！里面有很多现成的正则表达式可以用，也可以进行参考！\n\n## 爬虫模块相关\n\nurllib urllib2 requests \n\n### 现成模块 scrapy\n\n### 动态页面解决 selenium phantomJS\n\n### 反爬虫策略验证码 \n\nPIL opencv pybrain 打码平台\n\n## 数据库相关\n\nmysql， mongodb， sqlite\n\n## 数据处理\n\nnumpy 数据分析，类似matlab的模块\npandas（基于numpy的数据分析模块，相信我，如果你不是专门搞TB级数据的，这个就够了）\n\n## 技术进阶\n\n多线程、分布式\n\n\n","slug":"爬虫相关","published":1,"updated":"2018-01-09T03:00:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7faq001cd41iz22qrifv","content":"<h1 id=\"概念相关：\"><a href=\"#概念相关：\" class=\"headerlink\" title=\"概念相关：\"></a>概念相关：</h1><h2 id=\"所有网站皆可爬\"><a href=\"#所有网站皆可爬\" class=\"headerlink\" title=\"所有网站皆可爬\"></a>所有网站皆可爬</h2><p>互联网的内容都是人写出来的，而且都是偷懒写出来的（不会第一页是a，下一页是8），所以肯定有规律，这就给人有了爬取的可能，可以说，天下没有不能爬的网站</p>\n<h2 id=\"框架不变\"><a href=\"#框架不变\" class=\"headerlink\" title=\"框架不变\"></a>框架不变</h2><p>网站不同，但是原理都类似，大部分爬虫都是从 发送请求——获得页面——解析页面——下载内容——储存内容 这样的流程来进行，只是用的工具不同</p>\n<h1 id=\"基础相关\"><a href=\"#基础相关\" class=\"headerlink\" title=\"基础相关\"></a>基础相关</h1><h2 id=\"python-基础\"><a href=\"#python-基础\" class=\"headerlink\" title=\"python 基础\"></a>python 基础</h2><p>list，dict：用来序列化你爬的东西<br>切片：用来对爬取的内容进行分割，生成<br>条件判断（if等）：用来解决爬虫过程中哪些要哪些不要的问题<br>循环和迭代（for while ）：用来循环，重复爬虫动作<br>文件读写操作：用来读取参数、保存爬下来的内容等</p>\n<h2 id=\"网页基本知识\"><a href=\"#网页基本知识\" class=\"headerlink\" title=\"网页基本知识\"></a>网页基本知识</h2><p>基本的HTML语言知识（知道href等大学计算机一级内容即可）<br>理解网站的发包和收包的概念（POST GET）<br>稍微一点点的js知识，用于理解动态网页（当然如果本身就懂当然更好啦）</p>\n<h2 id=\"分析语言相关\"><a href=\"#分析语言相关\" class=\"headerlink\" title=\"分析语言相关\"></a>分析语言相关</h2><h3 id=\"正则表达式：扛把子技术，总得会最基础的\"><a href=\"#正则表达式：扛把子技术，总得会最基础的\" class=\"headerlink\" title=\"正则表达式：扛把子技术，总得会最基础的\"></a>正则表达式：扛把子技术，总得会最基础的</h3><p><img src=\"/images/爬虫相关/正则.jpg\" alt=\"正则表达式\"></p>\n<h3 id=\"xpath：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则\"><a href=\"#xpath：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则\" class=\"headerlink\" title=\"xpath：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则\"></a><a href=\"http://www.w3school.com.cn/xpath/\" target=\"_blank\" rel=\"noopener\">xpath</a>：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则</h3><h3 id=\"BeautifulSoup：美丽汤模块解析网页神器-一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本\"><a href=\"#BeautifulSoup：美丽汤模块解析网页神器-一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本\" class=\"headerlink\" title=\"BeautifulSoup：美丽汤模块解析网页神器,一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本\"></a><a href=\"http://beautifulsoup.readthedocs.io/zh_CN/latest/\" target=\"_blank\" rel=\"noopener\">BeautifulSoup</a>：美丽汤模块解析网页神器,一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本</h3><h2 id=\"辅助工具相关\"><a href=\"#辅助工具相关\" class=\"headerlink\" title=\"辅助工具相关\"></a>辅助工具相关</h2><h3 id=\"F12开发者工具\"><a href=\"#F12开发者工具\" class=\"headerlink\" title=\"F12开发者工具\"></a>F12开发者工具</h3><ol>\n<li>看源代码：快速定位元素</li>\n<li>分析xpath：1、此处建议谷歌系浏览器,可以在源码界面直接右键看</li>\n</ol>\n<h3 id=\"抓包工具\"><a href=\"#抓包工具\" class=\"headerlink\" title=\"抓包工具\"></a>抓包工具</h3><p>推荐httpfox，火狐浏览器下的插件,比谷歌火狐系自带的F12工具都要好，可以方便查看网站收包发包的信息</p>\n<h3 id=\"XPATH-CHECKER-火狐插件）\"><a href=\"#XPATH-CHECKER-火狐插件）\" class=\"headerlink\" title=\"XPATH CHECKER (火狐插件）\"></a>XPATH CHECKER (火狐插件）</h3><p>非常不错的xpath测试工具，但是有几个坑，都是个人踩过的，，在此告诫大家：     1、xpath checker生成的是绝对路径，遇到一些动态生成的图标（常见的有列表翻页按钮等），飘忽不定的绝对路径很有可能造成错误，所以这里建议在真正分析的时候，只是作为参考     2、记得把如下图xpath框里的“x:”去掉，貌似这个是早期版本xpath的语法，目前已经和一些模块不兼容（比如scrapy），还是删去避免报错</p>\n<h3 id=\"正则表达式测试工具\"><a href=\"#正则表达式测试工具\" class=\"headerlink\" title=\"正则表达式测试工具\"></a>正则表达式测试工具</h3><p><a href=\"http://tool.oschina.net/regex/\" target=\"_blank\" rel=\"noopener\">在线正则表达式测试</a><br>拿来多练练手，也辅助分析！里面有很多现成的正则表达式可以用，也可以进行参考！</p>\n<h2 id=\"爬虫模块相关\"><a href=\"#爬虫模块相关\" class=\"headerlink\" title=\"爬虫模块相关\"></a>爬虫模块相关</h2><p>urllib urllib2 requests </p>\n<h3 id=\"现成模块-scrapy\"><a href=\"#现成模块-scrapy\" class=\"headerlink\" title=\"现成模块 scrapy\"></a>现成模块 scrapy</h3><h3 id=\"动态页面解决-selenium-phantomJS\"><a href=\"#动态页面解决-selenium-phantomJS\" class=\"headerlink\" title=\"动态页面解决 selenium phantomJS\"></a>动态页面解决 selenium phantomJS</h3><h3 id=\"反爬虫策略验证码\"><a href=\"#反爬虫策略验证码\" class=\"headerlink\" title=\"反爬虫策略验证码\"></a>反爬虫策略验证码</h3><p>PIL opencv pybrain 打码平台</p>\n<h2 id=\"数据库相关\"><a href=\"#数据库相关\" class=\"headerlink\" title=\"数据库相关\"></a>数据库相关</h2><p>mysql， mongodb， sqlite</p>\n<h2 id=\"数据处理\"><a href=\"#数据处理\" class=\"headerlink\" title=\"数据处理\"></a>数据处理</h2><p>numpy 数据分析，类似matlab的模块<br>pandas（基于numpy的数据分析模块，相信我，如果你不是专门搞TB级数据的，这个就够了）</p>\n<h2 id=\"技术进阶\"><a href=\"#技术进阶\" class=\"headerlink\" title=\"技术进阶\"></a>技术进阶</h2><p>多线程、分布式</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"概念相关：\"><a href=\"#概念相关：\" class=\"headerlink\" title=\"概念相关：\"></a>概念相关：</h1><h2 id=\"所有网站皆可爬\"><a href=\"#所有网站皆可爬\" class=\"headerlink\" title=\"所有网站皆可爬\"></a>所有网站皆可爬</h2><p>互联网的内容都是人写出来的，而且都是偷懒写出来的（不会第一页是a，下一页是8），所以肯定有规律，这就给人有了爬取的可能，可以说，天下没有不能爬的网站</p>\n<h2 id=\"框架不变\"><a href=\"#框架不变\" class=\"headerlink\" title=\"框架不变\"></a>框架不变</h2><p>网站不同，但是原理都类似，大部分爬虫都是从 发送请求——获得页面——解析页面——下载内容——储存内容 这样的流程来进行，只是用的工具不同</p>\n<h1 id=\"基础相关\"><a href=\"#基础相关\" class=\"headerlink\" title=\"基础相关\"></a>基础相关</h1><h2 id=\"python-基础\"><a href=\"#python-基础\" class=\"headerlink\" title=\"python 基础\"></a>python 基础</h2><p>list，dict：用来序列化你爬的东西<br>切片：用来对爬取的内容进行分割，生成<br>条件判断（if等）：用来解决爬虫过程中哪些要哪些不要的问题<br>循环和迭代（for while ）：用来循环，重复爬虫动作<br>文件读写操作：用来读取参数、保存爬下来的内容等</p>\n<h2 id=\"网页基本知识\"><a href=\"#网页基本知识\" class=\"headerlink\" title=\"网页基本知识\"></a>网页基本知识</h2><p>基本的HTML语言知识（知道href等大学计算机一级内容即可）<br>理解网站的发包和收包的概念（POST GET）<br>稍微一点点的js知识，用于理解动态网页（当然如果本身就懂当然更好啦）</p>\n<h2 id=\"分析语言相关\"><a href=\"#分析语言相关\" class=\"headerlink\" title=\"分析语言相关\"></a>分析语言相关</h2><h3 id=\"正则表达式：扛把子技术，总得会最基础的\"><a href=\"#正则表达式：扛把子技术，总得会最基础的\" class=\"headerlink\" title=\"正则表达式：扛把子技术，总得会最基础的\"></a>正则表达式：扛把子技术，总得会最基础的</h3><p><img src=\"/images/爬虫相关/正则.jpg\" alt=\"正则表达式\"></p>\n<h3 id=\"xpath：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则\"><a href=\"#xpath：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则\" class=\"headerlink\" title=\"xpath：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则\"></a><a href=\"http://www.w3school.com.cn/xpath/\" target=\"_blank\" rel=\"noopener\">xpath</a>：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则</h3><h3 id=\"BeautifulSoup：美丽汤模块解析网页神器-一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本\"><a href=\"#BeautifulSoup：美丽汤模块解析网页神器-一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本\" class=\"headerlink\" title=\"BeautifulSoup：美丽汤模块解析网页神器,一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本\"></a><a href=\"http://beautifulsoup.readthedocs.io/zh_CN/latest/\" target=\"_blank\" rel=\"noopener\">BeautifulSoup</a>：美丽汤模块解析网页神器,一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本</h3><h2 id=\"辅助工具相关\"><a href=\"#辅助工具相关\" class=\"headerlink\" title=\"辅助工具相关\"></a>辅助工具相关</h2><h3 id=\"F12开发者工具\"><a href=\"#F12开发者工具\" class=\"headerlink\" title=\"F12开发者工具\"></a>F12开发者工具</h3><ol>\n<li>看源代码：快速定位元素</li>\n<li>分析xpath：1、此处建议谷歌系浏览器,可以在源码界面直接右键看</li>\n</ol>\n<h3 id=\"抓包工具\"><a href=\"#抓包工具\" class=\"headerlink\" title=\"抓包工具\"></a>抓包工具</h3><p>推荐httpfox，火狐浏览器下的插件,比谷歌火狐系自带的F12工具都要好，可以方便查看网站收包发包的信息</p>\n<h3 id=\"XPATH-CHECKER-火狐插件）\"><a href=\"#XPATH-CHECKER-火狐插件）\" class=\"headerlink\" title=\"XPATH CHECKER (火狐插件）\"></a>XPATH CHECKER (火狐插件）</h3><p>非常不错的xpath测试工具，但是有几个坑，都是个人踩过的，，在此告诫大家：     1、xpath checker生成的是绝对路径，遇到一些动态生成的图标（常见的有列表翻页按钮等），飘忽不定的绝对路径很有可能造成错误，所以这里建议在真正分析的时候，只是作为参考     2、记得把如下图xpath框里的“x:”去掉，貌似这个是早期版本xpath的语法，目前已经和一些模块不兼容（比如scrapy），还是删去避免报错</p>\n<h3 id=\"正则表达式测试工具\"><a href=\"#正则表达式测试工具\" class=\"headerlink\" title=\"正则表达式测试工具\"></a>正则表达式测试工具</h3><p><a href=\"http://tool.oschina.net/regex/\" target=\"_blank\" rel=\"noopener\">在线正则表达式测试</a><br>拿来多练练手，也辅助分析！里面有很多现成的正则表达式可以用，也可以进行参考！</p>\n<h2 id=\"爬虫模块相关\"><a href=\"#爬虫模块相关\" class=\"headerlink\" title=\"爬虫模块相关\"></a>爬虫模块相关</h2><p>urllib urllib2 requests </p>\n<h3 id=\"现成模块-scrapy\"><a href=\"#现成模块-scrapy\" class=\"headerlink\" title=\"现成模块 scrapy\"></a>现成模块 scrapy</h3><h3 id=\"动态页面解决-selenium-phantomJS\"><a href=\"#动态页面解决-selenium-phantomJS\" class=\"headerlink\" title=\"动态页面解决 selenium phantomJS\"></a>动态页面解决 selenium phantomJS</h3><h3 id=\"反爬虫策略验证码\"><a href=\"#反爬虫策略验证码\" class=\"headerlink\" title=\"反爬虫策略验证码\"></a>反爬虫策略验证码</h3><p>PIL opencv pybrain 打码平台</p>\n<h2 id=\"数据库相关\"><a href=\"#数据库相关\" class=\"headerlink\" title=\"数据库相关\"></a>数据库相关</h2><p>mysql， mongodb， sqlite</p>\n<h2 id=\"数据处理\"><a href=\"#数据处理\" class=\"headerlink\" title=\"数据处理\"></a>数据处理</h2><p>numpy 数据分析，类似matlab的模块<br>pandas（基于numpy的数据分析模块，相信我，如果你不是专门搞TB级数据的，这个就够了）</p>\n<h2 id=\"技术进阶\"><a href=\"#技术进阶\" class=\"headerlink\" title=\"技术进阶\"></a>技术进阶</h2><p>多线程、分布式</p>\n"},{"title":"简单选择排序","date":"2018-01-09T15:02:00.000Z","_content":"简单选择排序属于内部排序中的选择排序的一种。\n\n# 算法思想\n\n在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。\n\n# 空间复杂度\n\n最优的情况下（已正序）复杂度为O(0)，最差情况下（全部元素都需要排序），空间复杂度为O(n)\n\n# 时间复杂度\n\n最优，最差和平均都是O(n^2)\n\n# 算法实现思想\n\n从牌堆里找出最大的的一张牌，插在左手边。\n\n## java实现\n\n```\npublic int[] selectSort(int[] array){\n\tif (array.length <= 1){\n\t\treturn array;\n\t}\n\tfor(int i = 0; i < array.length - 1; i++){\n\t\tint temp = 0;\n\t\tint index = i;\n\t\tfor (int j = i + 1; j < array.length; j++){\n\t\t\tif (array[index] > array[j]){\n\t\t\t\tindex = j;\n\t\t\t}\n\t\t}\n\t\ttemp = array[index];\n\t\tarray[index] = array[i];\n\t\tarray[i] = temp;\n\t}\n\treturn array;\n}\n```\n\n## c实现\n\n```\nvoid selectSort(int array[], int length){\n\tint i, j, temp;\n\tif(1 >= length)\n\t\treturn;\n\tfor(i = 0; i < length; i ++){\n\t\ttemp = i;\n\t\tfor(j = i; j < length; j++){\n\t\t\tif(array[temp] < array[j])\n\t\t\t\ttemp = j;\n\t\t}\n\t\tif(i != temp){\n\t\t\tj = array[temp];\n\t\t\tarray[temp] = array[i];\n\t\t\tarray[i] = j;\n\t\t}\n\t}\n}\n```\n\n## python实现\n\n```\ndef selectSort(self, A):\n        for i in range(len(A) - 1):\n            min_ind = i\n            for j in range(i + 1,len(A)):\n                if A[min_ind] > A[j]:\n                    min_ind = j\n            if min_ind != i:\n                self.swap(A, min_ind, i)\n```\n","source":"_posts/简单选择排序.md","raw":"---\ntitle: 简单选择排序\ndate: 2018-01-09 23:02:00\ntags: 算法\n---\n简单选择排序属于内部排序中的选择排序的一种。\n\n# 算法思想\n\n在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。\n\n# 空间复杂度\n\n最优的情况下（已正序）复杂度为O(0)，最差情况下（全部元素都需要排序），空间复杂度为O(n)\n\n# 时间复杂度\n\n最优，最差和平均都是O(n^2)\n\n# 算法实现思想\n\n从牌堆里找出最大的的一张牌，插在左手边。\n\n## java实现\n\n```\npublic int[] selectSort(int[] array){\n\tif (array.length <= 1){\n\t\treturn array;\n\t}\n\tfor(int i = 0; i < array.length - 1; i++){\n\t\tint temp = 0;\n\t\tint index = i;\n\t\tfor (int j = i + 1; j < array.length; j++){\n\t\t\tif (array[index] > array[j]){\n\t\t\t\tindex = j;\n\t\t\t}\n\t\t}\n\t\ttemp = array[index];\n\t\tarray[index] = array[i];\n\t\tarray[i] = temp;\n\t}\n\treturn array;\n}\n```\n\n## c实现\n\n```\nvoid selectSort(int array[], int length){\n\tint i, j, temp;\n\tif(1 >= length)\n\t\treturn;\n\tfor(i = 0; i < length; i ++){\n\t\ttemp = i;\n\t\tfor(j = i; j < length; j++){\n\t\t\tif(array[temp] < array[j])\n\t\t\t\ttemp = j;\n\t\t}\n\t\tif(i != temp){\n\t\t\tj = array[temp];\n\t\t\tarray[temp] = array[i];\n\t\t\tarray[i] = j;\n\t\t}\n\t}\n}\n```\n\n## python实现\n\n```\ndef selectSort(self, A):\n        for i in range(len(A) - 1):\n            min_ind = i\n            for j in range(i + 1,len(A)):\n                if A[min_ind] > A[j]:\n                    min_ind = j\n            if min_ind != i:\n                self.swap(A, min_ind, i)\n```\n","slug":"简单选择排序","published":1,"updated":"2018-01-16T08:58:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7faq001ed41iq7gnpiw0","content":"<p>简单选择排序属于内部排序中的选择排序的一种。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>最优的情况下（已正序）复杂度为O(0)，最差情况下（全部元素都需要排序），空间复杂度为O(n)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>最优，最差和平均都是O(n^2)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>从牌堆里找出最大的的一张牌，插在左手边。</p>\n<h2 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int[] selectSort(int[] array)&#123;</span><br><span class=\"line\">\tif (array.length &lt;= 1)&#123;</span><br><span class=\"line\">\t\treturn array;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor(int i = 0; i &lt; array.length - 1; i++)&#123;</span><br><span class=\"line\">\t\tint temp = 0;</span><br><span class=\"line\">\t\tint index = i;</span><br><span class=\"line\">\t\tfor (int j = i + 1; j &lt; array.length; j++)&#123;</span><br><span class=\"line\">\t\t\tif (array[index] &gt; array[j])&#123;</span><br><span class=\"line\">\t\t\t\tindex = j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttemp = array[index];</span><br><span class=\"line\">\t\tarray[index] = array[i];</span><br><span class=\"line\">\t\tarray[i] = temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void selectSort(int array[], int length)&#123;</span><br><span class=\"line\">\tint i, j, temp;</span><br><span class=\"line\">\tif(1 &gt;= length)</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\tfor(i = 0; i &lt; length; i ++)&#123;</span><br><span class=\"line\">\t\ttemp = i;</span><br><span class=\"line\">\t\tfor(j = i; j &lt; length; j++)&#123;</span><br><span class=\"line\">\t\t\tif(array[temp] &lt; array[j])</span><br><span class=\"line\">\t\t\t\ttemp = j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(i != temp)&#123;</span><br><span class=\"line\">\t\t\tj = array[temp];</span><br><span class=\"line\">\t\t\tarray[temp] = array[i];</span><br><span class=\"line\">\t\t\tarray[i] = j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def selectSort(self, A):</span><br><span class=\"line\">        for i in range(len(A) - 1):</span><br><span class=\"line\">            min_ind = i</span><br><span class=\"line\">            for j in range(i + 1,len(A)):</span><br><span class=\"line\">                if A[min_ind] &gt; A[j]:</span><br><span class=\"line\">                    min_ind = j</span><br><span class=\"line\">            if min_ind != i:</span><br><span class=\"line\">                self.swap(A, min_ind, i)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>简单选择排序属于内部排序中的选择排序的一种。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>最优的情况下（已正序）复杂度为O(0)，最差情况下（全部元素都需要排序），空间复杂度为O(n)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>最优，最差和平均都是O(n^2)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>从牌堆里找出最大的的一张牌，插在左手边。</p>\n<h2 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int[] selectSort(int[] array)&#123;</span><br><span class=\"line\">\tif (array.length &lt;= 1)&#123;</span><br><span class=\"line\">\t\treturn array;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor(int i = 0; i &lt; array.length - 1; i++)&#123;</span><br><span class=\"line\">\t\tint temp = 0;</span><br><span class=\"line\">\t\tint index = i;</span><br><span class=\"line\">\t\tfor (int j = i + 1; j &lt; array.length; j++)&#123;</span><br><span class=\"line\">\t\t\tif (array[index] &gt; array[j])&#123;</span><br><span class=\"line\">\t\t\t\tindex = j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttemp = array[index];</span><br><span class=\"line\">\t\tarray[index] = array[i];</span><br><span class=\"line\">\t\tarray[i] = temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void selectSort(int array[], int length)&#123;</span><br><span class=\"line\">\tint i, j, temp;</span><br><span class=\"line\">\tif(1 &gt;= length)</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\tfor(i = 0; i &lt; length; i ++)&#123;</span><br><span class=\"line\">\t\ttemp = i;</span><br><span class=\"line\">\t\tfor(j = i; j &lt; length; j++)&#123;</span><br><span class=\"line\">\t\t\tif(array[temp] &lt; array[j])</span><br><span class=\"line\">\t\t\t\ttemp = j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(i != temp)&#123;</span><br><span class=\"line\">\t\t\tj = array[temp];</span><br><span class=\"line\">\t\t\tarray[temp] = array[i];</span><br><span class=\"line\">\t\t\tarray[i] = j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def selectSort(self, A):</span><br><span class=\"line\">        for i in range(len(A) - 1):</span><br><span class=\"line\">            min_ind = i</span><br><span class=\"line\">            for j in range(i + 1,len(A)):</span><br><span class=\"line\">                if A[min_ind] &gt; A[j]:</span><br><span class=\"line\">                    min_ind = j</span><br><span class=\"line\">            if min_ind != i:</span><br><span class=\"line\">                self.swap(A, min_ind, i)</span><br></pre></td></tr></table></figure>\n"},{"title":"直接插入排序","date":"2018-01-08T14:29:59.000Z","_content":"直接插入排序属于排序中的内部排序的插入排序的一种。\n\n# 算法思想\n\n直接将一个记录插入到已排序好的有序列表中，从而得到一个新的，记录数增1的有序表。\n\n# 空间复杂度\n\n只需要一个待记录的空间，空间复杂度为O(1)\n\n# 时间复杂度\n\n最好情况下，已有列表有序且正序，只需要插入一次，比较n-1次，移动0次\n最坏情况下，已有列表有序但是倒序，需要全部更改，比较n-1次，移动n-1次，复杂度为O(n^2)\n\n# 算法实现思想\n\n把它当作一个牌堆，现在从第一张开始抽。（开启一个循环，循环长度为数组的长度）\n\n假如抽的这一张比右手第一张小，代表需要插到前面。（a[j] < a[j-1]）\n\n从右手第二张开始往左看，如果找到有比抽到的这张小的，插到这张的后面。\n这个过程需要将每个比抽到的这大的往后挪一位，\n\n小技巧，将手中最右边这张先拿出去，然后将抽到的这张加到最右边，然后从最右边开始排序，排序完毕之后将拿出去的这张重新加到最右边。\n\n## java实现\n\n```\npublic static int[] insertSort(int[] array){\n\tint[] arr = array;\n\tint temp;\n\tfor(int i = 1; i < arr.length; i++){\n\t\tfor(int j = i; j >= 1 && arr[j - 1] > arr[j]; j-- ){\n\t\t\ttemp = arr[j];\n\t\t\tarr[j] = arr[j - 1];\n\t\t\tarr[j - 1] = temp;\n\t\t}\n\t}\n\treturn arr;\n}\n```\n\n## c实现\n\n```\nint inser_sort(int s[], int length){\n\tint i, j, t;\n\tfor (i = 1; i < length; i++){\n\t\tfor (j = i - 1; j > -1 && s[j] > t; j--){\n\t\t\tt = s[i];\n\t\t\ts[j + 1] = s[j];\n\t\t\ts[j] = t;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n## python实现\n\n```\ndef insertSort(a):\n\tlength = len(targetList)\n\tfor i in range(1, length:\n\t\tj = i - 1\n\t\tif (target[i] < targetList[j]){\n\t\t\ttemp = targetList[i]\n\t\t\ttarget[i] = targetList[j]\n\t\t\tj = j - 1\n\t\t\twhile j > 0 and targetList[j] > temp:\n\t\t\t\ttargetList[j + 1] = targetList[j]\n\t\t\t\tj = j - 1\n\t\t\ttargetList[j + 1] = temp\n\t\t}\n```\n","source":"_posts/直接插入排序.md","raw":"---\ntitle: 直接插入排序\ndate: 2018-01-08 22:29:59\ntags: 算法\n---\n直接插入排序属于排序中的内部排序的插入排序的一种。\n\n# 算法思想\n\n直接将一个记录插入到已排序好的有序列表中，从而得到一个新的，记录数增1的有序表。\n\n# 空间复杂度\n\n只需要一个待记录的空间，空间复杂度为O(1)\n\n# 时间复杂度\n\n最好情况下，已有列表有序且正序，只需要插入一次，比较n-1次，移动0次\n最坏情况下，已有列表有序但是倒序，需要全部更改，比较n-1次，移动n-1次，复杂度为O(n^2)\n\n# 算法实现思想\n\n把它当作一个牌堆，现在从第一张开始抽。（开启一个循环，循环长度为数组的长度）\n\n假如抽的这一张比右手第一张小，代表需要插到前面。（a[j] < a[j-1]）\n\n从右手第二张开始往左看，如果找到有比抽到的这张小的，插到这张的后面。\n这个过程需要将每个比抽到的这大的往后挪一位，\n\n小技巧，将手中最右边这张先拿出去，然后将抽到的这张加到最右边，然后从最右边开始排序，排序完毕之后将拿出去的这张重新加到最右边。\n\n## java实现\n\n```\npublic static int[] insertSort(int[] array){\n\tint[] arr = array;\n\tint temp;\n\tfor(int i = 1; i < arr.length; i++){\n\t\tfor(int j = i; j >= 1 && arr[j - 1] > arr[j]; j-- ){\n\t\t\ttemp = arr[j];\n\t\t\tarr[j] = arr[j - 1];\n\t\t\tarr[j - 1] = temp;\n\t\t}\n\t}\n\treturn arr;\n}\n```\n\n## c实现\n\n```\nint inser_sort(int s[], int length){\n\tint i, j, t;\n\tfor (i = 1; i < length; i++){\n\t\tfor (j = i - 1; j > -1 && s[j] > t; j--){\n\t\t\tt = s[i];\n\t\t\ts[j + 1] = s[j];\n\t\t\ts[j] = t;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n## python实现\n\n```\ndef insertSort(a):\n\tlength = len(targetList)\n\tfor i in range(1, length:\n\t\tj = i - 1\n\t\tif (target[i] < targetList[j]){\n\t\t\ttemp = targetList[i]\n\t\t\ttarget[i] = targetList[j]\n\t\t\tj = j - 1\n\t\t\twhile j > 0 and targetList[j] > temp:\n\t\t\t\ttargetList[j + 1] = targetList[j]\n\t\t\t\tj = j - 1\n\t\t\ttargetList[j + 1] = temp\n\t\t}\n```\n","slug":"直接插入排序","published":1,"updated":"2018-01-09T03:00:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjckf7fas001gd41if05751jn","content":"<p>直接插入排序属于排序中的内部排序的插入排序的一种。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>直接将一个记录插入到已排序好的有序列表中，从而得到一个新的，记录数增1的有序表。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>只需要一个待记录的空间，空间复杂度为O(1)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>最好情况下，已有列表有序且正序，只需要插入一次，比较n-1次，移动0次<br>最坏情况下，已有列表有序但是倒序，需要全部更改，比较n-1次，移动n-1次，复杂度为O(n^2)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>把它当作一个牌堆，现在从第一张开始抽。（开启一个循环，循环长度为数组的长度）</p>\n<p>假如抽的这一张比右手第一张小，代表需要插到前面。（a[j] &lt; a[j-1]）</p>\n<p>从右手第二张开始往左看，如果找到有比抽到的这张小的，插到这张的后面。<br>这个过程需要将每个比抽到的这大的往后挪一位，</p>\n<p>小技巧，将手中最右边这张先拿出去，然后将抽到的这张加到最右边，然后从最右边开始排序，排序完毕之后将拿出去的这张重新加到最右边。</p>\n<h2 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int[] insertSort(int[] array)&#123;</span><br><span class=\"line\">\tint[] arr = array;</span><br><span class=\"line\">\tint temp;</span><br><span class=\"line\">\tfor(int i = 1; i &lt; arr.length; i++)&#123;</span><br><span class=\"line\">\t\tfor(int j = i; j &gt;= 1 &amp;&amp; arr[j - 1] &gt; arr[j]; j-- )&#123;</span><br><span class=\"line\">\t\t\ttemp = arr[j];</span><br><span class=\"line\">\t\t\tarr[j] = arr[j - 1];</span><br><span class=\"line\">\t\t\tarr[j - 1] = temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int inser_sort(int s[], int length)&#123;</span><br><span class=\"line\">\tint i, j, t;</span><br><span class=\"line\">\tfor (i = 1; i &lt; length; i++)&#123;</span><br><span class=\"line\">\t\tfor (j = i - 1; j &gt; -1 &amp;&amp; s[j] &gt; t; j--)&#123;</span><br><span class=\"line\">\t\t\tt = s[i];</span><br><span class=\"line\">\t\t\ts[j + 1] = s[j];</span><br><span class=\"line\">\t\t\ts[j] = t;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def insertSort(a):</span><br><span class=\"line\">\tlength = len(targetList)</span><br><span class=\"line\">\tfor i in range(1, length:</span><br><span class=\"line\">\t\tj = i - 1</span><br><span class=\"line\">\t\tif (target[i] &lt; targetList[j])&#123;</span><br><span class=\"line\">\t\t\ttemp = targetList[i]</span><br><span class=\"line\">\t\t\ttarget[i] = targetList[j]</span><br><span class=\"line\">\t\t\tj = j - 1</span><br><span class=\"line\">\t\t\twhile j &gt; 0 and targetList[j] &gt; temp:</span><br><span class=\"line\">\t\t\t\ttargetList[j + 1] = targetList[j]</span><br><span class=\"line\">\t\t\t\tj = j - 1</span><br><span class=\"line\">\t\t\ttargetList[j + 1] = temp</span><br><span class=\"line\">\t\t&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>直接插入排序属于排序中的内部排序的插入排序的一种。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>直接将一个记录插入到已排序好的有序列表中，从而得到一个新的，记录数增1的有序表。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>只需要一个待记录的空间，空间复杂度为O(1)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>最好情况下，已有列表有序且正序，只需要插入一次，比较n-1次，移动0次<br>最坏情况下，已有列表有序但是倒序，需要全部更改，比较n-1次，移动n-1次，复杂度为O(n^2)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>把它当作一个牌堆，现在从第一张开始抽。（开启一个循环，循环长度为数组的长度）</p>\n<p>假如抽的这一张比右手第一张小，代表需要插到前面。（a[j] &lt; a[j-1]）</p>\n<p>从右手第二张开始往左看，如果找到有比抽到的这张小的，插到这张的后面。<br>这个过程需要将每个比抽到的这大的往后挪一位，</p>\n<p>小技巧，将手中最右边这张先拿出去，然后将抽到的这张加到最右边，然后从最右边开始排序，排序完毕之后将拿出去的这张重新加到最右边。</p>\n<h2 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int[] insertSort(int[] array)&#123;</span><br><span class=\"line\">\tint[] arr = array;</span><br><span class=\"line\">\tint temp;</span><br><span class=\"line\">\tfor(int i = 1; i &lt; arr.length; i++)&#123;</span><br><span class=\"line\">\t\tfor(int j = i; j &gt;= 1 &amp;&amp; arr[j - 1] &gt; arr[j]; j-- )&#123;</span><br><span class=\"line\">\t\t\ttemp = arr[j];</span><br><span class=\"line\">\t\t\tarr[j] = arr[j - 1];</span><br><span class=\"line\">\t\t\tarr[j - 1] = temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int inser_sort(int s[], int length)&#123;</span><br><span class=\"line\">\tint i, j, t;</span><br><span class=\"line\">\tfor (i = 1; i &lt; length; i++)&#123;</span><br><span class=\"line\">\t\tfor (j = i - 1; j &gt; -1 &amp;&amp; s[j] &gt; t; j--)&#123;</span><br><span class=\"line\">\t\t\tt = s[i];</span><br><span class=\"line\">\t\t\ts[j + 1] = s[j];</span><br><span class=\"line\">\t\t\ts[j] = t;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def insertSort(a):</span><br><span class=\"line\">\tlength = len(targetList)</span><br><span class=\"line\">\tfor i in range(1, length:</span><br><span class=\"line\">\t\tj = i - 1</span><br><span class=\"line\">\t\tif (target[i] &lt; targetList[j])&#123;</span><br><span class=\"line\">\t\t\ttemp = targetList[i]</span><br><span class=\"line\">\t\t\ttarget[i] = targetList[j]</span><br><span class=\"line\">\t\t\tj = j - 1</span><br><span class=\"line\">\t\t\twhile j &gt; 0 and targetList[j] &gt; temp:</span><br><span class=\"line\">\t\t\t\ttargetList[j + 1] = targetList[j]</span><br><span class=\"line\">\t\t\t\tj = j - 1</span><br><span class=\"line\">\t\t\ttargetList[j + 1] = temp</span><br><span class=\"line\">\t\t&#125;</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjckf7f9q0000d41ig7hj9479","tag_id":"cjckf7f9w0002d41ivd83vd44","_id":"cjckf7fa20007d41i0pk1wl0l"},{"post_id":"cjckf7f9u0001d41inq9znmda","tag_id":"cjckf7fa10006d41itenwjt5z","_id":"cjckf7fa6000cd41il3ygy11a"},{"post_id":"cjckf7fa40009d41ibbncaeys","tag_id":"cjckf7fa10006d41itenwjt5z","_id":"cjckf7fa8000ed41iygzxc3fn"},{"post_id":"cjckf7f9y0003d41i1hiehmdq","tag_id":"cjckf7fa5000ad41i46emc423","_id":"cjckf7fad000hd41idm6lyvsr"},{"post_id":"cjckf7fa6000dd41iwkfpa0sa","tag_id":"cjckf7fa5000ad41i46emc423","_id":"cjckf7fae000jd41ivtjmxw45"},{"post_id":"cjckf7f9z0004d41il2tcg1vx","tag_id":"cjckf7fa5000ad41i46emc423","_id":"cjckf7faf000md41ihy201l93"},{"post_id":"cjckf7fad000id41i96moste7","tag_id":"cjckf7fa5000ad41i46emc423","_id":"cjckf7fag000od41id2iriey0"},{"post_id":"cjckf7faf000ld41iw86mbcem","tag_id":"cjckf7fa5000ad41i46emc423","_id":"cjckf7fah000rd41im4q0hq7e"},{"post_id":"cjckf7fa10005d41ixannta37","tag_id":"cjckf7fa5000ad41i46emc423","_id":"cjckf7fai000td41i0hg1y1x7"},{"post_id":"cjckf7fag000nd41if35qb6sk","tag_id":"cjckf7fa5000ad41i46emc423","_id":"cjckf7faj000wd41imuk0ogsp"},{"post_id":"cjckf7fah000qd41ief8s222l","tag_id":"cjckf7fa5000ad41i46emc423","_id":"cjckf7fak000yd41i12sbqc6t"},{"post_id":"cjckf7fa20008d41imv8wkd46","tag_id":"cjckf7fa5000ad41i46emc423","_id":"cjckf7fal0011d41ife870mtr"},{"post_id":"cjckf7fai000sd41itlglx8rh","tag_id":"cjckf7fa5000ad41i46emc423","_id":"cjckf7fam0013d41ifvfnwjha"},{"post_id":"cjckf7fa5000bd41i8soks306","tag_id":"cjckf7fai000ud41ia58drgpd","_id":"cjckf7fan0016d41i5da7urw2"},{"post_id":"cjckf7faj000xd41ig6505kwd","tag_id":"cjckf7fa5000ad41i46emc423","_id":"cjckf7fao0018d41id2vrn2qd"},{"post_id":"cjckf7fac000gd41ihzdtkb3l","tag_id":"cjckf7fak000zd41iavpeglea","_id":"cjckf7fap001bd41ikir8gz84"},{"post_id":"cjckf7faj000vd41iw3ugducm","tag_id":"cjckf7fak000zd41iavpeglea","_id":"cjckf7faq001dd41irpcwwd28"},{"post_id":"cjckf7fal0012d41idji40ycp","tag_id":"cjckf7fap001ad41iyrw19ps9","_id":"cjckf7fat001hd41iykg7skcy"},{"post_id":"cjckf7faq001ed41iq7gnpiw0","tag_id":"cjckf7fap001ad41iyrw19ps9","_id":"cjckf7fat001id41ihsbgtwtb"},{"post_id":"cjckf7fas001gd41if05751jn","tag_id":"cjckf7fap001ad41iyrw19ps9","_id":"cjckf7fav001kd41iq5u6zyn6"},{"post_id":"cjckf7fan0014d41inueyo4zq","tag_id":"cjckf7fap001ad41iyrw19ps9","_id":"cjckf7fav001ld41itokfsne6"},{"post_id":"cjckf7fap0019d41iva3ige7c","tag_id":"cjckf7fau001jd41iyhwhg7e4","_id":"cjckf7fav001nd41ih8mrf1ak"},{"post_id":"cjckf7faq001cd41iz22qrifv","tag_id":"cjckf7fav001md41i61iuhk58","_id":"cjckf7fav001od41i6txom994"}],"Tag":[{"name":"计划","_id":"cjckf7f9w0002d41ivd83vd44"},{"name":"工作小结","_id":"cjckf7fa10006d41itenwjt5z"},{"name":"android","_id":"cjckf7fa5000ad41i46emc423"},{"name":"ios","_id":"cjckf7fai000ud41ia58drgpd"},{"name":"hexo","_id":"cjckf7fak000zd41iavpeglea"},{"name":"算法","_id":"cjckf7fap001ad41iyrw19ps9"},{"name":"生活","_id":"cjckf7fau001jd41iyhwhg7e4"},{"name":"python","_id":"cjckf7fav001md41i61iuhk58"}]}}