<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="记录者">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="记录者">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="记录者">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>记录者</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">记录者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/03/针对activity栈启动模式进行fragment栈的引申/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/03/针对activity栈启动模式进行fragment栈的引申/" itemprop="url">针对activity栈启动模式进行fragment栈的引申</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-03T23:30:29+08:00">
                2018-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>“one activity for the whole app, you can use fragments, just don’t use the backstack with fragments”</p>
<p>— jake·warton</p>
<p>安卓开发有其独特的魅力，相对于每个页面不断的切换，事实上前端开发从安卓的角度来看可以有不同的作为。</p>
<p>比如说jake·warton所说的只使用一个activity窗口，外加很多个碎片，来组成一个app。这句话很好理解，可是后面的这半句话是什么意思呢？主要是fragment的后台管理栈比较不容易操控。</p>
<p>所以我们需要了解一下如何操控这个栈。这次就从activity的启动模式来分析。</p>
<ul>
<li>standard</li>
</ul>
<p>默认的启动模式，对fragment来讲，在basefragment中抽取activity的stackedfragments，每次新建一个fragment时，创建一个新的加入到栈顶即可。</p>
<ul>
<li>singleTop</li>
</ul>
<p>在栈顶的话，启动还是会转到自己，而不在栈顶的话就会新建。这个属性对fragment来讲不怎么实用，没怎么遇到过这种情形，如果要用的话，就判断之前的栈顶是否和新传入的相同，相同的话，就仍然返回的自身，不同就创建一个。</p>
<ul>
<li>singleTask</li>
</ul>
<p>在栈内的话，启动一个实例，就会启动栈内的。这个属性比较好用，对fragment来讲，可以用这个来做很多事情，包括回去的时候直接pop起到了cleartop的效果。</p>
<p>开发中还遇到相似的，一次传入三到四个fragment，如果有其中的fragment在栈上方，立即返回他，中断其余判断。这种操作其实就是遍历栈而已，不过能够在fragment多复用的情况下，找到当前回归路径，省了很多其他的事情。</p>
<ul>
<li>singleinstance</li>
</ul>
<p>每次开辟一个新的栈，这个在fragment中没用，因为只有唯一的一个栈在activity中。</p>
<ul>
<li>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</li>
</ul>
<p>对activity来讲，新的Activity不会在最近启动的Activity的列表中保存。对fragment来讲，就是新启动的不入栈，可以考虑设计一个固定大小的栈的时候，只有固定的几个fragment可以用于入栈，其余的都不入。不过这个设计要考虑一下，返回哪些栈。</p>
<p>实际效果可能就是切了很多个页面，最后一个回退，回退到了很久之前的一个页面。使用情景比较局限。</p>
<ul>
<li>FLAG_ACTIVITY_FORWARD_RESULT</li>
</ul>
<p>这个是startactivityforresult的标志位，同样的也可以设计一个startfragmentforresult。事实上也就是在进入这个fragment的时候，basefragment记录一下resultcode的值，然后回退的时候，将这个result值传入到栈顶即可。</p>
<ul>
<li>FLAG_ACTIVITY_NO_HISTORY</li>
</ul>
<p>单纯的不入栈的操作。</p>
<ul>
<li>FLAG_ACTIVITY_REORDER_TO_FRONT</li>
</ul>
<p>该标志位是用于启动时挪动activity栈的，对fragment同样可以设计，不过较为复杂，可以从栈内取出，重新排序之后插入。比较不好的是可能会遗漏状态。</p>
<ul>
<li>FLAG_ACTIVITY_NEW_TASK</li>
</ul>
<p>同 singinstance</p>
<ul>
<li>FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET</li>
</ul>
<p>对activity来讲，是当新进入的activity携带这个标志时，就会清理栈。fragment同样可以设计，若有个携带该标记的进入，也可以清空。虽然我目前仍然是使用老的回到最起初的fragment，不过效果可能没这个设计的好。</p>
<p>大致就这些。针对fragment设计一个单独的有特征的栈，我个人觉得是使用fragment代替activity的第一步。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/01/2018第十七周工作小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/01/2018第十七周工作小结/" itemprop="url">2018第十七周工作小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-01T23:45:39+08:00">
                2018-05-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近实在是太忙了，忙到github都忘了更新博客了。每天都在忙着需求，改bug，然后项目追着上线。累的半死不活的。</p>
<p>好消息是项目终于给整上线了，坏消息是项目上线之后可能会更忙。</p>
<p>来公司2个月还没到，一下子回到了刚毕业的时候在传音那种加班加点很累的生活方式。不过好的是，起码现在自己是在做自己的事情。</p>
<p>上周来了个大牛，技术比我厉害，也跟着他学习到了不少东西。需要整理一下。主要是http/https，okhttp工作原理，还有序列化原理等等。这些是学到的东西。</p>
<p>工作上面的总结感觉没啥好说的，有两个要写一下，一个是activity栈的工作原理，一个是fragment栈的工作原理。目前了解一些，但是不够深入。</p>
<p>明天开始仍然是进入学习的阶段。就先这样吧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/2018第十六周工作小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/2018第十六周工作小结/" itemprop="url">2018第十六周工作小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-22T17:01:05+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这周简直是崩溃的一周。</p>
<p>首先是上一周没有休息，加上上周由于假期多上了一天，导致连着9点到晚上10点多（甚至凌晨）13天，身体在周三的时候报警，整个人精神状态十分不佳，加上深陷在我写的bug中无法自拔，整个人基本上是废了的状态。</p>
<p>昨天整整睡了一天，今天精神才缓过来。</p>
<p>这一周的工作情况也不容乐观，一边开发加需求，一边修改bug，压力是在是太大，所有的东西都要我来改，十分十分的蛋疼。产品那边催，技术总监那边也在催，就是周五上线周五上线。</p>
<p>可是我能怎么办呢？我除了硬着头皮上还能做什么呢？</p>
<p>算了，额外的话不说了，说一下这周做了什么吧。</p>
<p>这周重写了购物车的缓存，针对目前的需求针对化的重写了一些方法。但是bug太多，购物车和订单2个互联的东西，写起来说实话坑还蛮多的。目前还有关于购物车的删除事件的处理行为，这个很麻烦，不知道用什么来删除，目前使用的是遍历，效率十分的低。</p>
<p>这周说实话就做了这么一些东西，下周就是埋点和功能的设计，今天还要解一些bug。难受</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/16/2018第十五周工作小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/16/2018第十五周工作小结/" itemprop="url">2018第十五周工作小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-16T14:08:02+08:00">
                2018-04-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>14周的工作小结没写，也就不写了。总结一下上一周，也就是十五周吧。</p>
<p>15周周二的时候，完成了手头的开发任务，进入到了debug状态，面对的头上很多很多的bug，亚历山大。</p>
<p>具体的bug，其实已经忘了差不多了，印象深刻的就2个，一个是当时butterknife的snapshot版本的bug，巨蛋疼，昨天能用的代码今天不能用了，还没办法搞，当时折腾了好久好久，连事件传递过程都全部debug一边，还是没查出问题。最后是涛哥反编译之后对比，才忽然发现bindviews导致的bug。</p>
<p>由于这个bug，让我的开发周期硬生生拖慢了一天，然后无休无止的折腾后续的bug，后续的bug大多数都是流程的问题，流程相关导致的bug。总体上分为两种，一种是activity切换fragment，一种是activity切activity然后切fragment，目前用的是eventbus和arouter，加上startactivity和startfragment，总结下来发现关于activity管理的fragment栈我还是不是很懂。后续需要加强。</p>
<p>其余的没啥好说的了。这一周很累，不过和在传音的时候那种没事做还被逼着加班的累却不同。</p>
<p>在其位必谋其政，有所失也必然有所得。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/12/记一次“代码过期”错误/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/记一次“代码过期”错误/" itemprop="url">记一次“代码过期”错误</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-12T23:42:00+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近太忙了，每天加班到十一点，都来不及写博客了。</p>
<p>昨天晚上9点，我完成了一个feature，结果编译结束发现apk的hosttab点击事件无效了。</p>
<p>懵逼，因为4点还是好的。</p>
<p>于是回退代码，回退到4点，发现编译好了还是这个问题。懵逼。</p>
<p>然后继续回退，回退到上次释放正确版本的地方，发现还是有这个问题，继续懵逼。</p>
<p>继续回退，回退到上个人离职的时候，发现还是有这个问题。超级懵逼。</p>
<p>也就是原本有用的代码，突然没用了。</p>
<p>排查，发现tabhost的点击事件没传下去，继续排查，发现tabhost各个子tab的点击事件没接收到，然后写父类的ontouch事件，发现父类并没有拦截，而是返回给在上面的父类了。而各个父类都没有拦截。</p>
<p>什么情况？</p>
<p>然后不知道怎么回事了，彻底懵逼了。</p>
<p>然后技术总监和我讲这种情况就应该对比二进制文件。</p>
<p>于是反编译上个版本释放的apk，对比相同代码生成的apk，发现真有问题，butterknife生成代码的时候覆盖了之前的按钮。蛋疼</p>
<p>原因是因为butterknife版本是snapshot，而有个人提交了一个错误的代码到butterknife中，导致我错误了。难受。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/05/2018第十三周工作小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/05/2018第十三周工作小结/" itemprop="url">2018第十三周工作小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-05T21:59:54+08:00">
                2018-04-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上周实在是太忙了，周六加班，周日睡了一天，结果工作小结都没有来的及写。</p>
<p>不过还是写一下吧。</p>
<p>上周主要任务是适配接口，当时想了一套wrapper来封装接口的做法。但是现在想想，那也只是一种取巧而已。其实数据结构的使用并没有那么复杂，而且在调整数据结构的时候也可以更大程度的理解流程。</p>
<p>上周整周都在调试接口中度过，刚开始还差点没来得及，后来王洋回来调，才来的及的。</p>
<p>这周他走了，在20号之前，整个项目是我一个人负责了。难受。想哭。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/04/java克隆、浅克隆、深克隆/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/04/java克隆、浅克隆、深克隆/" itemprop="url">java克隆、浅克隆、深克隆</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-04T14:29:51+08:00">
                2018-04-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h1><p>当我们需要有一个当前对象的克隆体，和当前对象完全相同的属性、功能，但又不想去仅仅创建一个对象的引用时，我们就需要对对象进行克隆。</p>
<p>克隆clone，是创建了一个一摸一样的对象。该方法是object的方法，平时用不到是因为这个方法是protect属性的。</p>
<p>需要用到clone方法的时候，直接覆盖父类的方法，定义成public，然后写super.clone()。或者直接自己写一个clone方法也可以。同时不要忘了记成clonable接口。</p>
<h1 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h1><p>被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。</p>
<p>继承自object的clone方法，就是浅克隆，除非对引用也使用clone的方法。</p>
<p>没啥大用。</p>
<h1 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h1><p>被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。</p>
<p>深克隆可以使用序列化的方法。</p>
<p>精髓主要是将对象写入流中，然后在从流中都取出来。这样就实现了一个对象的深克隆。</p>
<p>前提是对象都是序列化的，不论成员还是引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Object deepClone() throws IOException,OptionalDataException,ClassNotFoundException&#123;//将对象写到流里</span><br><span class="line">ByteArrayOutoutStream bo=new ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream oo=new ObjectOutputStream(bo);</span><br><span class="line">oo.writeObject(this);//从流里读出来</span><br><span class="line">ByteArrayInputStream bi=new ByteArrayInputStream(bo.toByteArray());</span><br><span class="line">ObjectInputStream oi=new ObjectInputStream(bi);</span><br><span class="line">return(oi.readObject());</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/01/LruCache缓存源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/01/LruCache缓存源码解析/" itemprop="url">LruCache缓存源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-01T12:26:43+08:00">
                2018-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以前曾经在volley中使用networkimageview的时候使用过lrucache，当时以为这只是一个第三方的开源框架。昨天在网上找安卓的缓存框架的时候看到了lrucache，居然是android.util包下面的。所以这次就着源码看看是个怎么缓存的原理。</p>
<h1 id="类解释"><a href="#类解释" class="headerlink" title="类解释"></a>类解释</h1><p>首先看一下这个类官方的解释。</p>
<ul>
<li>A cache that holds strong references to a limited number of values. Each time</li>
<li>a value is accessed, it is moved to the head of a queue. When a value is</li>
<li>added to a full cache, the value at the end of that queue is evicted and may</li>
<li>become eligible for garbage collection.</li>
</ul>
<p>这个类是一个用于对有限的值持有强引用的缓存类。</p>
<p>每次一个值被获取了，它将被挪到队列的头部。</p>
<p>每当一个值被加入完全缓存（full-cache,完全缓存模式，讲一个对象完全的加载到内存中，而非只加载其映射关系。对应的还有Partial Cache，部分缓存模式，部分缓存模式多数用于加载对象的部分，用于判断对象是否曾经加载过，或者是否需要再次加载），缓存队列末尾的值将会被驱逐，丢失了强引用的关系，就会变得可以被gc清除。</p>
<ul>
<li><p>If your cached values hold resources that need to be explicitly released,</p></li>
<li>override {@link #entryRemoved}.</li>
</ul>
<p>如果希望避免部分资源被lrucache缓存，可以继承entryremoved</p>
<ul>
<li><p>If a cache miss should be computed on demand for the corresponding keys,</p></li>
<li>override {@link #create}. This simplifies the calling code, allowing it to</li>
<li>assume a value will always be returned, even when there’s a cache miss.</li>
</ul>
<p>如果需要对一个响应返回一个完整的缓存，但是这个缓存目前是缺失状态，可以继承create方法，这样可以使得针对这个响应总是可以有回应，即时目前是缓存缺失的状态，也可以构造一个回应。</p>
<ul>
<li><p>By default, the cache size is measured in the number of entries. Override</p></li>
<li>{@link #sizeOf} to size the cache in different units. For example, this cache</li>
<li>is limited to 4MiB of bitmaps:</li>
<li><pre>   {@code</pre></li>
<li>int cacheSize = 4 <em> 1024 </em> 1024; // 4MiB</li>
<li>LruCache&lt;String, Bitmap&gt; bitmapCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {</li>
<li>protected int sizeOf(String key, Bitmap value) {</li>
<li>return value.getByteCount();</li>
<li>}</li>
<li>}}</li>
</ul>
<p>缓存的数量是通过对象的数量来确定的。继承sizeOf方法可以使用不同的单位来计算缓存。（该方法提供的例子是用于限制缓存，那缓存不够怎么办？一张bitmap一般有8m啊？事实上它并不会精确计算占用的内存，只能说你说a有3m，总共给30m的缓存的话，他就会放最多10个a，事实上a并不一定只有3m，当然这也没必要关心，在不同的地方自己精确赋一下就好了）</p>
<ul>
<li><p>This class is thread-safe. Perform multiple cache operations atomically by</p></li>
<li>synchronizing on the cache: <pre>   {@code</pre></li>
<li>synchronized (cache) {</li>
<li>if (cache.get(key) == null) {</li>
<li>cache.put(key, value);</li>
<li>}</li>
<li>}}</li>
</ul>
<p>该类是线程安全的，主要是对缓存操作的部分都加了锁。</p>
<ul>
<li><p>This class does not allow null to be used as a key or value. A return</p></li>
<li>value of null from {@link #get}, {@link #put} or {@link #remove} is</li>
<li>unambiguous: the key was not in the cache.</li>
</ul>
<p>该类不允许空指针被使用作为key或者value。</p>
<ul>
<li><p>This class appeared in Android 3.1 (Honeycomb MR1); it’s available as part</p></li>
<li>of <a href="http://developer.android.com/sdk/compatibility-library.html" target="_blank" rel="noopener">Android’s</a></li>
<li>Support Package for earlier releases.</li>
</ul>
<p>该类在android3.1出现。</p>
<h1 id="源码探究"><a href="#源码探究" class="headerlink" title="源码探究"></a>源码探究</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final LinkedHashMap&lt;K, V&gt; map;</span><br></pre></td></tr></table></figure>
<p> 使用了linkedHashMap的方法来存储数据。有向图就是强引用方式，key在，value在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/** Size of this cache in units. Not necessarily the number of elements. */</span><br><span class="line">private int size;</span><br><span class="line">   private int maxSize;</span><br><span class="line"></span><br><span class="line">   private int putCount;</span><br><span class="line">   private int createCount;</span><br><span class="line">   private int evictionCount;</span><br><span class="line">   private int hitCount;</span><br><span class="line">   private int missCount;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param maxSize for caches that do not override &#123;@link #sizeOf&#125;, this is</span><br><span class="line"> *     the maximum number of entries in the cache. For all other caches,</span><br><span class="line"> *     this is the maximum sum of the sizes of the entries in this cache.</span><br><span class="line"> */</span><br><span class="line">public LruCache(int maxSize) &#123;</span><br><span class="line">    if (maxSize &lt;= 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.maxSize = maxSize;</span><br><span class="line">    this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方面需要给一个maxSize，该参数是用于在为定义sizeof的对象计算容量大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Sets the size of the cache.</span><br><span class="line"> *</span><br><span class="line"> * @param maxSize The new maximum size.</span><br><span class="line"> */</span><br><span class="line">public void resize(int maxSize) &#123;</span><br><span class="line">    if (maxSize &lt;= 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    trimToSize(maxSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新设计maxsize</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns the value for &#123;@code key&#125; if it exists in the cache or can be</span><br><span class="line"> * created by &#123;@code #create&#125;. If a value was returned, it is moved to the</span><br><span class="line"> * head of the queue. This returns null if a value is not cached and cannot</span><br><span class="line"> * be created.</span><br><span class="line"> */</span><br><span class="line">public final V get(K key) &#123;</span><br><span class="line">    if (key == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;key == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V mapValue;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        mapValue = map.get(key);</span><br><span class="line">        if (mapValue != null) &#123;</span><br><span class="line">            hitCount++;</span><br><span class="line">            return mapValue;</span><br><span class="line">        &#125;</span><br><span class="line">        missCount++;</span><br><span class="line">    &#125;</span><br><span class="line">     /*</span><br><span class="line">     * Attempt to create a value. This may take a long time, and the map</span><br><span class="line">     * may be different when create() returns. If a conflicting value was</span><br><span class="line">     * added to the map while create() was working, we leave that value in</span><br><span class="line">     * the map and release the created value.</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    V createdValue = create(key);</span><br><span class="line">    if (createdValue == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        createCount++;</span><br><span class="line">        mapValue = map.put(key, createdValue);</span><br><span class="line"></span><br><span class="line">        if (mapValue != null) &#123;</span><br><span class="line">            // There was a conflict so undo that last put</span><br><span class="line">            map.put(key, mapValue);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            size += safeSizeOf(key, createdValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mapValue != null) &#123;</span><br><span class="line">        entryRemoved(false, key, createdValue, mapValue);</span><br><span class="line">        return mapValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        trimToSize(maxSize);</span><br><span class="line">        return createdValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get的时候加锁，每次有返回的话，hitcount自增。没有返回代表是缺失缓存，misscount自增。</p>
<p>若找不到值，会调用createvalue来创建，创建成功，createcount自增，失败就代表没有该缓存内容，直接终端。创建成功同时加入到map里面，map的size会增加。</p>
<p>创建出来的mapvalue会执行entryremoved的检查，对有设置过不加入的参数进行操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Called for entries that have been evicted or removed. This method is</span><br><span class="line"> * invoked when a value is evicted to make space, removed by a call to</span><br><span class="line"> * &#123;@link #remove&#125;, or replaced by a call to &#123;@link #put&#125;. The default</span><br><span class="line"> * implementation does nothing.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;The method is called without synchronization: other threads may</span><br><span class="line"> * access the cache while this method is executing.</span><br><span class="line"> *</span><br><span class="line"> * @param evicted true if the entry is being removed to make space, false</span><br><span class="line"> *     if the removal was caused by a &#123;@link #put&#125; or &#123;@link #remove&#125;.</span><br><span class="line"> * @param newValue the new value for &#123;@code key&#125;, if it exists. If non-null,</span><br><span class="line"> *     this removal was caused by a &#123;@link #put&#125;. Otherwise it was caused by</span><br><span class="line"> *     an eviction or a &#123;@link #remove&#125;.</span><br><span class="line"> */</span><br><span class="line">protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>entryRemoved的方法准确的说法是用于吊起被驱逐和移除的对象。确保key对应的value可以是正确的，newvalue为空的话就代表是移除老的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Remove the eldest entries until the total of remaining entries is at or</span><br><span class="line"> * below the requested size.</span><br><span class="line"> *</span><br><span class="line"> * @param maxSize the maximum size of the cache before returning. May be -1</span><br><span class="line"> *            to evict even 0-sized elements.</span><br><span class="line"> */</span><br><span class="line">public void trimToSize(int maxSize) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123;</span><br><span class="line">                throw new IllegalStateException(getClass().getName()</span><br><span class="line">                        + &quot;.sizeOf() is reporting inconsistent results!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (size &lt;= maxSize) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Map.Entry&lt;K, V&gt; toEvict = map.eldest();</span><br><span class="line">            if (toEvict == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            key = toEvict.getKey();</span><br><span class="line">            value = toEvict.getValue();</span><br><span class="line">            map.remove(key);</span><br><span class="line">            size -= safeSizeOf(key, value);</span><br><span class="line">            evictionCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        entryRemoved(true, key, value, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>trimToSize方法是针对目前队列中的对象，移除最老的。移除的操作就是移除了key，去掉强引用的部分。移除完之后要减去移除的大小，之后移除数自增，确保安全之后将之前的key，映射关系改为一个null，这个移除的数量并不是固定的，这是一个死循环，会移除到size小于maxsize，或者最老的是空。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Removes the entry for &#123;@code key&#125; if it exists.</span><br><span class="line"> *</span><br><span class="line"> * @return the previous value mapped by &#123;@code key&#125;.</span><br><span class="line"> */</span><br><span class="line">public final V remove(K key) &#123;</span><br><span class="line">    if (key == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;key == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V previous;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        previous = map.remove(key);</span><br><span class="line">        if (previous != null) &#123;</span><br><span class="line">            size -= safeSizeOf(key, previous);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (previous != null) &#123;</span><br><span class="line">        entryRemoved(false, key, previous, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>remove操作和之前的那个操作几乎一样，移除，如果曾经存在就在此赋空。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Clear the cache, calling &#123;@link #entryRemoved&#125; on each removed entry.</span><br><span class="line"> */</span><br><span class="line">public final void evictAll() &#123;</span><br><span class="line">    trimToSize(-1); // -1 will evict 0-sized elements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是移除所有的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override public synchronized final String toString() &#123;</span><br><span class="line">    int accesses = hitCount + missCount;</span><br><span class="line">    int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;</span><br><span class="line">    return String.format(&quot;LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]&quot;,</span><br><span class="line">            maxSize, hitCount, missCount, hitPercent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>toString方法可以看到状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns a copy of the current contents of the cache, ordered from least</span><br><span class="line"> * recently accessed to most recently accessed.</span><br><span class="line"> */</span><br><span class="line">public synchronized final Map&lt;K, V&gt; snapshot() &#123;</span><br><span class="line">    return new LinkedHashMap&lt;K, V&gt;(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>snapshot直接一个以自己map构造的对象。（这种避免返回自身的操作值得学习）</p>
<h1 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h1><p>整个LruCache的作用，说到底就是针对gc的树状搜索删除算法的一种方案。<br>但是我们平时使用的时候，需要针对几个地方进行定制，一是sizeof,二是removeentry。</p>
<p>整个缓存还是在内存中的，所以lrucache是一种内存缓存框架。</p>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>value最好放软应用对象，确保释放之后的第一次gc就可以回收。<br>设置maxsize，可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().maxMemory()</span><br></pre></td></tr></table></figure></p>
<p>也可针对不同情况进行设置。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/31/关于面向对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/31/关于面向对象/" itemprop="url">关于面向对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-31T23:22:59+08:00">
                2018-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>写java也这么多年了，从一开始就知道面向对象的三大特征：封装多态和继承。然而在工作这么久之后，突然回头看看，才一下子意识到这三大特征的重要性。</p>
<p>知其然容易，知其所以然则太难了。如今希望能在突然一瞬间的理解出现时，将其记录下来。</p>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>封装是将对象使用一系列方法包裹起来，仅仅对外提供一系列功能接口，而屏蔽内在的属性。</p>
<p>为什么这么做呢？</p>
<p>首先，我们将对象定义为一系列的属性，这一系列的属性决定了这个对象能够表达出什么样的信息。但是其实我们并不关心他真正的属性，并不关心他某个值的含义，关心的仅仅是他能够做什么。</p>
<p>所以我们需要将他的功能列出来，这些功能并不是说他们只能这样，而是我们处于项目的需求，只需要这些功能。</p>
<p>因此在我们眼前，对象不是一系列的数据组合的，而是一系列功能组合的。</p>
<p>这样其实就已经从普通的物理层面抽象出来了对象的本质，换言之，我们仅仅需要功能，而不再是属性。</p>
<p>从代码层面，这样有一个好处，就是我们将一个对象可以做的事情，限制在他的类中，直观的操作，而不再是通过在不同条件下拼装其属性来展现功能。</p>
<p>对象可以是变的，可能是后端接口导致的映射改变，也可能是某个属性不在起作用，但是我们仅仅需要关心的功能是否能够再次实现。</p>
<p>对内，对象是一个系统。对外，对象却只是一个小模块。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态是对一个方法的展开。</p>
<p>我们将一个个的对象封装起来的意义，就是为了只观功能。</p>
<p>而多态恰巧给功能的健壮性提供了面对多场合的稳定。</p>
<p>没有了多态，我们需要实现一个相同功能，却命名为一个不同的名字。在不同的场景下会产生很多的误解。</p>
<p>封装是为了将对象进行功能的抽象，而多态，是对功能的抽象进行一个整合，让这个抽象不需要太离谱。</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承，或者说实现，就是一个完全的面向功能的操作。</p>
<p>继承是子类对父类的角色实现一种扩展，每个子类都需要有父类的特征，但同时也可以拥有自己的特征。</p>
<p>接口在我眼里也是一种继承，不过接口在高度上高于直接继承，接口是完完全全为了功能实现的。</p>
<p>有了接口，我们可以直接在功能的角度上面来设计代码，之后只需要对这些功能来实现即可。这是自上而下，而之前的封装，则是自下而上，实际操作没有这么隔离，但是大致意义这样。</p>
<h1 id="对架构的关系"><a href="#对架构的关系" class="headerlink" title="对架构的关系"></a>对架构的关系</h1><p>总是从低到高的实现，就如同从底层开始构筑，很容易出现越垒越歪，越垒越庞大。而由于基于底层，所以一旦对底层有一些更改，很容易出现大规模的重构。十分不利于代码的健壮性。</p>
<p>而从高到低的实现，很大程度避免了这个问题的发生。</p>
<p>将一个项目拆分成几个子模块，然后将子模块的功能定下来，之后无论下层如何实现，如何更改，从高层来看，仍然是原来的模样。</p>
<p>架构的魅力很大，单纯写代码会让人觉得疲惫，庸于在代码中翻找。而架构，让人一瞬间高屋建瓴，一眼看透了需要做什么。之后连工期都很容易预估。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/30/关于后台改接口之后前端应该做的事情/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/30/关于后台改接口之后前端应该做的事情/" itemprop="url">关于后台改接口之后前端应该做的事情</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-30T21:45:26+08:00">
                2018-03-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>新到公司，一切都是新鲜的，然而很快问题就来了。</p>
<p>公司后台重构了后台的接口，将原先多层级的接口，改成了扁平化的接口。</p>
<p>这对我是完全没有接触过的挑战。</p>
<p>刚开始我觉得，既然后台改了接口，我就应该把接口部分删了重构，然后将得到的数据结构也重构。但是后来发现，基于原来数据结构上的接口衍生的代码十分庞大，层级比较深，这样重构数据结构基本上等于重构项目了，时间上面不可行。</p>
<p>因此我后来想到一个办法，将原来的数据结构设为set和get，然后将现在获取的数据结构扭成之前的数据结构，需要原先参数的地方，我改成get的方式，将现有的数据结构组合来返回，这样衍生的代码就可以基于之前的数据结构上来运行，可以保证数据结构之上的代码不需要改变。</p>
<p>但是又遇到一个问题，就是项目中很多地方是直接使用数据结构里面的值来进行操作的，而不是set和get，这样我改成set和get，就需要更改使用到该值的地方。当时采取了这种方式，的确代码可运行，而且较为稳定了。</p>
<p>后来在和别人的交流中，得知可以使用一层封装，封装现有的数据结构，变成原来的数据结构，这样也可以。</p>
<p>例如我使用retrofit获取的数据，在rxjava中对observable的执行过程中，直接将原先的数据进行转换，写一个wrapper，然后onnext中返回这个wrapper，这样使用这个接口的部分仍然可以直接使用原来的数据，甚至都不需要使用get和set。</p>
<p>所以当以后遇到这种情况，可以直接使用上述方法，将数据扭合成原先的结构，来进行更改。这样每次更改接口，仅仅需要更改这个wrapper即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sample</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">87</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sample</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
