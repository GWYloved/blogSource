{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/android/instantRunApkMarker.webp","path":"images/android/instantRunApkMarker.webp","modified":0,"renderable":0},{"_id":"source/images/android/instantRunOpenApkMarker.webp","path":"images/android/instantRunOpenApkMarker.webp","modified":0,"renderable":0},{"_id":"source/images/android/instantRunSwapImage.webp","path":"images/android/instantRunSwapImage.webp","modified":0,"renderable":0},{"_id":"source/images/android/instantRun热插拔.webp","path":"images/android/instantRun热插拔.webp","modified":0,"renderable":0},{"_id":"source/images/android/jvm内存模型.jpg","path":"images/android/jvm内存模型.jpg","modified":0,"renderable":0},{"_id":"source/images/android/recyclerview缓存模型.jpg","path":"images/android/recyclerview缓存模型.jpg","modified":0,"renderable":0},{"_id":"source/images/数据结构/tree图1.png","path":"images/数据结构/tree图1.png","modified":0,"renderable":0},{"_id":"source/images/算法/希尔排序.png","path":"images/算法/希尔排序.png","modified":0,"renderable":0},{"_id":"source/images/网络协议/TCP头部图.png","path":"images/网络协议/TCP头部图.png","modified":0,"renderable":0},{"_id":"source/images/android/androidpackageimage.png","path":"images/android/androidpackageimage.png","modified":0,"renderable":0},{"_id":"source/images/java/java锁图.png","path":"images/java/java锁图.png","modified":0,"renderable":0},{"_id":"source/images/架构/clean架构图.jpg","path":"images/架构/clean架构图.jpg","modified":0,"renderable":0},{"_id":"source/images/爬虫相关/正则.jpg","path":"images/爬虫相关/正则.jpg","modified":0,"renderable":0},{"_id":"source/images/数据结构/Java集合框架.jpg","path":"images/数据结构/Java集合框架.jpg","modified":0,"renderable":0},{"_id":"source/images/android/Retrofit个人理解图.png","path":"images/android/Retrofit个人理解图.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"01579ea88d131b8e8c548644d7ec5b771a8be4ea","modified":1552382793131},{"_id":"source/images/.DS_Store","hash":"67880b359310accf7aed3614b487b33aabc2f7ec","modified":1552382793173},{"_id":"source/tags/index.md","hash":"194383e990c52c0cae7b1ad0dbb6e5fa87e4c61d","modified":1552382793193},{"_id":"source/_posts/.DS_Store","hash":"13dac3dab0b40b14533bb5c2630847a2ed4d63b3","modified":1552382793133},{"_id":"source/_posts/2018-2-3-4月工作计划安排.md","hash":"895767fa4fab8654bbc2225b0c31b843b54f62f4","modified":1552382793133},{"_id":"source/_posts/2018-3-2018-12记产品死亡总结.md","hash":"fcad67d5afabd553f5b06032e357b47a22fa7b28","modified":1552382793133},{"_id":"source/_posts/2018八月-第三十一周到三十五周-工作小结.md","hash":"9e5ac2d3680af8dbac1491e0afbb11aa0921fa5f","modified":1552382793135},{"_id":"source/_posts/2018年第44周工作小结.md","hash":"92abf3cb2942ceb78f2a20972edb16cf4706a457","modified":1552382793135},{"_id":"source/_posts/2018年第四十七周工作小结.md","hash":"3dfc04f154da642231d863289c0480cc7e28fce1","modified":1552382793135},{"_id":"source/_posts/2018年第四十六周工作小结.md","hash":"caf46187898fbd6687a0325a6463f09356b9aee9","modified":1552382793136},{"_id":"source/_posts/2018开年愿景.md","hash":"c1bb8335aace0208cf0f992486341cba2bf02cc4","modified":1552382793138},{"_id":"source/_posts/2018第一周工作小结.md","hash":"5600b026710f78fffaff100e28833785d0bdcc82","modified":1552382793138},{"_id":"source/_posts/2018第七周工作小结.md","hash":"559c6737854c03eced2408d7a5af7ccc50522735","modified":1552382793138},{"_id":"source/_posts/2018第三十七周工作小结.md","hash":"e50ad9035b5c576d7cef257614146b500b345054","modified":1552382793138},{"_id":"source/_posts/2018第三十六周工作小结.md","hash":"40fc86ea4db815a38fd54a7acc38538d7734acba","modified":1552382793139},{"_id":"source/_posts/2018第三十周工作小结.md","hash":"d21545cbd617806b3fe195bbc64b83bc456bedab","modified":1552382793139},{"_id":"source/_posts/2018第三周工作小结.md","hash":"6ca63232492016b4eb8f86e5b25a6b25b3d8d0e4","modified":1552382793139},{"_id":"source/_posts/2018第三季度复盘（第40周）.md","hash":"ad1bc33e9b93db65768c755517706d7e7249f8b8","modified":1552382793139},{"_id":"source/_posts/2018第九周工作小结.md","hash":"4596a50ffa3fb8e57149e0d3c5c764212ec3c5cb","modified":1552382793139},{"_id":"source/_posts/2018第二十一周工作小结.md","hash":"e81b92ce38c651f95ebead31ab8240856a353377","modified":1552382793140},{"_id":"source/_posts/2018第二十二周工作小结.md","hash":"171095efa12886d1a8f13eb9dcdcee5a729ad763","modified":1552382793141},{"_id":"source/_posts/2018第二十七周工作小结.md","hash":"3731672a973cf7d7666448a8f529d69b1bd1c860","modified":1552382793140},{"_id":"source/_posts/2018第二十五周工作小结.md","hash":"f9841f7b7207632e1f105c658be19087ac07a797","modified":1552382793141},{"_id":"source/_posts/2018第二十八周工作小结.md","hash":"06be59e1933042a91e199dba69a6c5c7c96f87cb","modified":1552382793141},{"_id":"source/_posts/2018第二十周工作小结.md","hash":"318dfd46de333f0cde4621fe00cb73bb9d89795d","modified":1552382793141},{"_id":"source/_posts/2018第二周工作小结.md","hash":"70890750d2ea1d10cde0a31eecf354b39cb63f75","modified":1552382793141},{"_id":"source/_posts/2018第五周工作小结.md","hash":"1c45799b8e6d1b98363f8d2d8c8e015cd610c330","modified":1552382793141},{"_id":"source/_posts/2018第八周工作小结.md","hash":"752497bdb82f17411d7a59b0059c89fa69561af3","modified":1552382793142},{"_id":"source/_posts/2018第六周工作小结.md","hash":"94240d02c3fadc514beb957fa3701b064673aaa8","modified":1552382793142},{"_id":"source/_posts/2018第十一周工作小结.md","hash":"a98800d9d4285734e9798ec2b7c40b9918b2546e","modified":1552382793142},{"_id":"source/_posts/2018第十七周工作小结.md","hash":"9e22608a8ff7367a4d551ff7f4358dd1a8541c32","modified":1552382793143},{"_id":"source/_posts/2018第十三周工作小结.md","hash":"5c509d3a4d5c7ac070dbafae16fc20045b93ca03","modified":1552382793143},{"_id":"source/_posts/2018第十九周工作小结.md","hash":"8a8c643fbb144606d1beba6f22c3525c583c0e73","modified":1552382793143},{"_id":"source/_posts/2018第十二周工作小结.md","hash":"f7c1c367e9591746569cd8f53d6a1c6ad63beb60","modified":1552382793143},{"_id":"source/_posts/2018第十五周工作小结.md","hash":"a3d6cba2c990f20a27b32a3ccce213971a891da6","modified":1552382793144},{"_id":"source/_posts/2018第十八周工作小结.md","hash":"24bf885d191a24d3bdaa4dcf6ac48f79d12d8f57","modified":1552382793144},{"_id":"source/_posts/2018第十六周工作小结.md","hash":"3b1e3bdcbb7f70a7ecdb954994766f6a6ba5001b","modified":1552382793145},{"_id":"source/_posts/2018第十周工作小结.md","hash":"d5af75c43e9004d159ebc773346a20d6a9bfe7c2","modified":1552382793145},{"_id":"source/_posts/2018第四周工作小结.md","hash":"5d3f1b369a9110935133ec34a365b1c600c5bfa8","modified":1552382793145},{"_id":"source/_posts/ARouter组件化框架学习笔记.md","hash":"ad0db991a91ba0be1d608d403c55789470c9f7eb","modified":1552382793146},{"_id":"source/_posts/Android基础知识点.md","hash":"2680dddb716bafe312623eac2c9371ba79fcf252","modified":1552382793146},{"_id":"source/_posts/Android性能优化.md","hash":"16277a133689f98a72de0fe287ca2a65526ac55e","modified":1552382793148},{"_id":"source/_posts/Android系统信息和安全机制.md","hash":"8043f70f7a6f90b8d2f2bfd0c6a522fff069427f","modified":1552382793148},{"_id":"source/_posts/Android绘图机制与处理技巧.md","hash":"d7266692011dcfcd70d28bad62ba7cc755a92e03","modified":1552382793150},{"_id":"source/_posts/Butterknife源码学习.md","hash":"ab310343e47b9f0e18d4fc17609dd790dfa38597","modified":1552382793150},{"_id":"source/_posts/Collection.md","hash":"ba3ed4b8e20330f4b68373f25257893e81935982","modified":1552382793150},{"_id":"source/_posts/LruCache缓存源码解析.md","hash":"20f3045a3a17c92b7554843529502c40ddd44ad3","modified":1552382793151},{"_id":"source/_posts/OSS服务器接入上传下载学习.md","hash":"0caec9d3bc8fc715d4b2d3c8f2ad35ffab9862ec","modified":1552382793151},{"_id":"source/_posts/android1-0-7-0各版本feature.md","hash":"25eef825cf63bdc71b59c16f32c6158cba9684aa","modified":1552382793152},{"_id":"source/_posts/android8-0-feature一览.md","hash":"0fca2bee9e03ae72b39099d9c40789b09c78171c","modified":1552382793152},{"_id":"source/_posts/androidMVP架构学习.md","hash":"8551a45d772dac99ae11cd4e3a2ee4352c61a3f9","modified":1552382793152},{"_id":"source/_posts/androidscroll分析笔记.md","hash":"2d561c2ff23296fdff0a102abbe3722639c8e30c","modified":1552382793152},{"_id":"source/_posts/android事件拦截机制分析.md","hash":"5cd8fe2060043449d78336dd0eabcda8a2033398","modified":1552382793153},{"_id":"source/_posts/android事件分发机制.md","hash":"0c22de1de2c578f596fb56d57b70c4a01d75f7f7","modified":1552382793152},{"_id":"source/_posts/android持久化存储.md","hash":"747a6a5e5786073761c3aebc462dc6b684f0990c","modified":1552382793153},{"_id":"source/_posts/android横竖屏切换总结.md","hash":"8d07df594e94e9b2d3cd3eec9cabf30ca118f04c","modified":1552382793153},{"_id":"source/_posts/android消息推送.md","hash":"ac1610479ed9f45c21e2b24a2033584fae392cb5","modified":1552382793153},{"_id":"source/_posts/android渠道包打包取舍以及打包流程分析.md","hash":"723d69f048d7f44cd1378fa99920f7c63d0fb37b","modified":1552382793154},{"_id":"source/_posts/android自动化打包脚本搭建.md","hash":"0e5cfa6ab08a73b2e0c171b0994ea0ddc2fa812d","modified":1552382793154},{"_id":"source/_posts/android自定义注解.md","hash":"31a4b24191f104bd9630fb7a5e9bfb3499888f02","modified":1552382793154},{"_id":"source/_posts/binder机制学习.md","hash":"521775091dff29693829fac131944cc6e14a2509","modified":1552382793154},{"_id":"source/_posts/clean架构学习.md","hash":"f8609dbf1b592cea322833708852d04fdf1fe5a1","modified":1552382793154},{"_id":"source/_posts/gradlew编译报错小结.md","hash":"96e61e43c64eccbd7ae73c268b599ea8ff2aa325","modified":1552382793155},{"_id":"source/_posts/effective-java学习笔记.md","hash":"e0b9261fe09b50fb13ccd936378a8a628a80f92c","modified":1552382793155},{"_id":"source/_posts/http知识杂烩.md","hash":"faf3fd323ff1d369636314f08948ce4a5498da81","modified":1552382793155},{"_id":"source/_posts/ios-stanford-1.md","hash":"4c2fda5290b37e4a0ab455261358461869a8417e","modified":1552382793156},{"_id":"source/_posts/java-uri拼接.md","hash":"03661817d845281e1ff96c04e70812aca9482c22","modified":1552382793156},{"_id":"source/_posts/java二分法查找.md","hash":"d8e0934bab0405f341ff8d1e16e10db9d3024e47","modified":1552382793156},{"_id":"source/_posts/java克隆、浅克隆、深克隆.md","hash":"6ea02c9d86c9cd6aa9af01a7bf2c525add282aca","modified":1552382793156},{"_id":"source/_posts/java动态编程.md","hash":"760e4a692af92622f68bbeadee82e2f8780b7c30","modified":1552382793156},{"_id":"source/_posts/java反射.md","hash":"7754b82248ba53b95bb58ccf32d51b45ba13ed37","modified":1552382793157},{"_id":"source/_posts/java各种锁学习.md","hash":"fb45b2e268fefbb983f1de72faddf215eaa5820f","modified":1552382793157},{"_id":"source/_posts/java基础知识点.md","hash":"e081008742d68d4d5b17c63486ff7b30c51ee164","modified":1552382793158},{"_id":"source/_posts/java对象的三种状态.md","hash":"54b261733ddc8d6ad639fb997f0a8476d73f96ca","modified":1552382793159},{"_id":"source/_posts/java编程思想第一章《对象导论》学习笔记.md","hash":"ca05cb1c278c0174975c396ee453eacc25063aa6","modified":1552382793159},{"_id":"source/_posts/js语法学习.md","hash":"82fdd7b1e1750784bfcfd4d8f9b1773b737b2c82","modified":1552382793159},{"_id":"source/_posts/jvm内存模型.md","hash":"9f4bf2b5c56f5772deba8fad70ccc082d078dc3f","modified":1552382793159},{"_id":"source/_posts/jvm方法调用机制.md","hash":"45b4b22d2da81dc3b6cc26dccd521c47e18b2cd4","modified":1552382793159},{"_id":"source/_posts/looper的message分发方式.md","hash":"7eddfdc97bde9be437d339e1910075e7218b2766","modified":1552382793160},{"_id":"source/_posts/merge标签的作用.md","hash":"770359263a791e322a2a9b05bbac14961819a204","modified":1552382793160},{"_id":"source/_posts/mongodb安装、常用操作记录.md","hash":"a7ce57aa5a4be484f0eac6255956f52de3d3ec33","modified":1552382793160},{"_id":"source/_posts/multidex错误小结.md","hash":"31d559228f0a39f2e4809f2369b2723bfde3c144","modified":1552382793160},{"_id":"source/_posts/mvc在android中的使用.md","hash":"3a276c2c77b2b86517435dfa41ab6c44f99a3ab4","modified":1552382793160},{"_id":"source/_posts/okhttp+retrofit.md","hash":"77c99ab3e89eac31f87094927a08e3ab76a8e740","modified":1552382793161},{"_id":"source/_posts/okio学习.md","hash":"216587c2808986d6003a9048d0af1f31e3ab5c7c","modified":1552382793161},{"_id":"source/_posts/python操作mongodb.md","hash":"b8a3fa98a44c8486bf3a73c2dac7ddbfc16208fa","modified":1552382793161},{"_id":"source/_posts/recyclerview源码学习.md","hash":"c2b14bd519cb56f36d6225bf0ef68de2b7d1342a","modified":1552382793161},{"_id":"source/_posts/retrofit2-post.md","hash":"f50126aea2a1128c5cd31b95149415da79bf0240","modified":1552382793162},{"_id":"source/_posts/rxjava操作符笔记.md","hash":"66255746132c90ef360c291d071a42d74e4d0fea","modified":1552382793162},{"_id":"source/_posts/test-appveyor.md","hash":"572b01d5c8f4153dcff51265b6cb4c238354d1d6","modified":1552382793162},{"_id":"source/_posts/threadlocal学习.md","hash":"2eaebce91af6bf47659745e79ddd53abd3e5bff0","modified":1552382793162},{"_id":"source/_posts/tinker机制学习.md","hash":"b32de74d88f1ba0bcdc8d90fee3ce124898d2325","modified":1552382793163},{"_id":"source/_posts/tree学习.md","hash":"195b3b157654ac2c0374469fa6150c44dac94073","modified":1552382793163},{"_id":"source/_posts/viewgroup测量.md","hash":"57966cead6d1fa33850103f366ee0090d2156940","modified":1552382793163},{"_id":"source/_posts/viewstub的作用.md","hash":"2848183388b423a758cfdfdb56dc814e7f7c1378","modified":1552382793163},{"_id":"source/_posts/view的测量和绘制.md","hash":"282881f7d0c8e81c343bc55756c94dc55bd3e62f","modified":1552382793163},{"_id":"source/_posts/virtual-app学习.md","hash":"0cfed3dec72713ef9ec9c4faa3dcfe85604cacd3","modified":1552382793163},{"_id":"source/_posts/volatile的作用及其原理.md","hash":"25a1d2632a36b785f791f202d50f69ec50909b3d","modified":1552382793164},{"_id":"source/_posts/“rxjava2-0”.md","hash":"409b3a1256c37d3dddc271b9ebb46d2799992d18","modified":1552382793164},{"_id":"source/_posts/为什么在activity触发ondestroy的时候内部类可能产生泄露.md","hash":"84b0f6ac9fef2556c94206da893744c551f2e639","modified":1552382793164},{"_id":"source/_posts/二路归并排序.md","hash":"c4958ab7619779a5aceb5937ce89f167d1114040","modified":1552382793164},{"_id":"source/_posts/使用appveyor-xml-进行双端部署hexo.md","hash":"7669678aea2bcd13ad1747fdefb491d8492d569e","modified":1552382793164},{"_id":"source/_posts/使用python抓取网页内容.md","hash":"8fc185c1fee14a41974e21c6a64b2a669693b113","modified":1552382793165},{"_id":"source/_posts/使用浏览器唤起app.md","hash":"a33d570d556bb7fe633569b58f125d2a78e257f6","modified":1552382793165},{"_id":"source/_posts/关于WebviewJavaScriptBrige的一些学习.md","hash":"f0472199e5c1a321ea1dc655aa2364fcdaecb4a5","modified":1552382793165},{"_id":"source/_posts/关于后台改接口之后前端应该做的事情.md","hash":"b07f7bd0ecc4640aa1e08bdea7abd3b986d3ebc2","modified":1552382793165},{"_id":"source/_posts/关于面向对象.md","hash":"923b03067e5c6a478c2a50c763c34340bab893de","modified":1552382793166},{"_id":"source/_posts/冒泡排序.md","hash":"fbd7e6b9d74eba1d26e6e69df4ad017189c5fca0","modified":1552382793166},{"_id":"source/_posts/动态规划.md","hash":"6940ad05663a26b26fc4eb8c88c761bad9591583","modified":1552382793166},{"_id":"source/_posts/动态代理的好处.md","hash":"a53189f19f94b9be87fb6f5c6ce32d1238b6b41e","modified":1552382793166},{"_id":"source/_posts/堆排序.md","hash":"c9994c1582ae185da01a35ba6dcce8bf386573d0","modified":1552382793167},{"_id":"source/_posts/大话多线程阅读笔记.md","hash":"759e10ef9e44f2a2738580ea8d61f2416dffc11d","modified":1552382793167},{"_id":"source/_posts/希尔排序.md","hash":"39e7d990c9fcc5e91f728f5420839d858c7c3a96","modified":1552382793167},{"_id":"source/_posts/快速排序.md","hash":"08b0b1401422a990241a899dbae98a42e007f40c","modified":1552382793167},{"_id":"source/_posts/某金融公司面试小记.md","hash":"56f31ceba418094c6ba85d9a792d65ab61f30aa9","modified":1552382793168},{"_id":"source/_posts/混淆学习.md","hash":"07392a6d315b4bd8d59c89e24c9157f8431a7f4a","modified":1552382793168},{"_id":"source/_posts/焦虑感的排解方式.md","hash":"f9e3b8953ec947290209c0e178916d5496f91659","modified":1552382793168},{"_id":"source/_posts/爬虫相关.md","hash":"85019633b497c58e7dba3dbf737477e6d55be97e","modified":1552382793168},{"_id":"source/_posts/直接插入排序.md","hash":"ebdc754408c79c661c9de5b22e34a1370d0cc5f0","modified":1552382793168},{"_id":"source/_posts/神策埋点reftype踩坑记.md","hash":"b84ed7bfc2ad75bbdcee714a1648c3461eb3708b","modified":1552382793168},{"_id":"source/_posts/第七章动画机制与使用技巧学习笔记.md","hash":"d036d27955e02d87716de2f8742c254bf1a52548","modified":1552382793169},{"_id":"source/_posts/第八章Activity与Activity调用栈分析笔记.md","hash":"5e185438b01f64b5d7d4eaa25b7372ae4804fdc2","modified":1552382793169},{"_id":"source/_posts/简单选择排序.md","hash":"2870bc3aa80dea92de790f0c0e3c67c2a1923f96","modified":1552382793169},{"_id":"source/_posts/网络协议基础.md","hash":"52d9cb0d3532e422b019a7438dbf1873713df181","modified":1552382793169},{"_id":"source/_posts/记一次“代码过期”错误.md","hash":"1af0e515afb9a48fd7d49ef67f05f111b16cbd0c","modified":1552382793169},{"_id":"source/_posts/设计模式以及Android举例.md","hash":"5c56fe8acbb70358efe4ab1d84997bf5b2ad4cf2","modified":1552382793170},{"_id":"source/_posts/近期问题回顾.md","hash":"b5613c4a63740a5dd5a844b508329ed4032d47c8","modified":1552382793170},{"_id":"source/_posts/针对activity栈启动模式进行fragment栈的引申.md","hash":"95a67918cd79cb3134e013dfb8f097d8ce7963b9","modified":1552382793171},{"_id":"source/_posts/项目卡顿问题优化专题.md","hash":"54c49d40de505b771d70e05ab4d5616dcfaae489","modified":1552382793171},{"_id":"source/_posts/项目架构总结.md","hash":"79a71b99b3a5244e9731b72ab1a3d5778cb15ac4","modified":1552382793171},{"_id":"source/images/android/instantRunApkMarker.webp","hash":"802d356f3ed23ee8118d8c2acf8e5527a9442652","modified":1552382793179},{"_id":"source/images/android/instantRunOpenApkMarker.webp","hash":"802d356f3ed23ee8118d8c2acf8e5527a9442652","modified":1552382793179},{"_id":"source/images/android/instantRunSwapImage.webp","hash":"b01afe937db76343bf55b284610e8f19c2d85f85","modified":1552382793180},{"_id":"source/images/android/instantRun热插拔.webp","hash":"7822057b60eaa29fb56c1796cd51c9f9a65e8361","modified":1552382793180},{"_id":"source/images/android/jvm内存模型.jpg","hash":"863ea04e441356616906435801b88ba298f749f7","modified":1552382793181},{"_id":"source/images/android/recyclerview缓存模型.jpg","hash":"3c5ea60671c6318e8fb62a0cda2534709593bb68","modified":1552382793181},{"_id":"source/images/数据结构/tree图1.png","hash":"ba674f7d9faea61b1348b84b6a7cd85ed139444c","modified":1552382793185},{"_id":"source/images/算法/.DS_Store","hash":"9552d5178a745483796d140c5090aaa456768a5f","modified":1552382793189},{"_id":"source/images/算法/希尔排序.png","hash":"42b8dff82d3e13b1c771640fd73ca18426294a97","modified":1552382793190},{"_id":"source/images/网络协议/TCP头部图.png","hash":"06af539047c93bd53c571cba6fb357287b986914","modified":1552382793192},{"_id":"source/images/android/androidpackageimage.png","hash":"9a2313c4a0c6533f757ce8fcdc10d30d4454cb86","modified":1552382793178},{"_id":"source/images/java/java锁图.png","hash":"11cd62524f1737f9d8cb1a04672ab0d8602548e0","modified":1552382793183},{"_id":"source/images/架构/clean架构图.jpg","hash":"35d11d882fe10293ead30f70989bd831cf1d0044","modified":1552382793187},{"_id":"source/images/爬虫相关/正则.jpg","hash":"41904e45cf2faf0600b802e342d6e6959bf9ff7e","modified":1552382793188},{"_id":"source/images/数据结构/Java集合框架.jpg","hash":"91bd8d323518f261b4046f65b35d22ee584be4b1","modified":1552382793185},{"_id":"source/images/android/Retrofit个人理解图.png","hash":"dd191435275059092b6509c81cc3a97b94089a23","modified":1552382793176},{"_id":"public/tags/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801244},{"_id":"public/2019/02/23/jvm方法调用机制/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801244},{"_id":"public/2019/02/21/virtual-app学习/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801244},{"_id":"public/2019/02/15/设计模式以及Android举例/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801244},{"_id":"public/2019/01/28/tinker机制学习/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801244},{"_id":"public/2019/01/27/recyclerview源码学习/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801244},{"_id":"public/2019/01/16/looper的message分发方式/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2019/01/16/神策埋点reftype踩坑记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2019/01/13/java对象的三种状态/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2019/01/09/volatile的作用及其原理/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2019/01/07/threadlocal学习/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2019/01/05/动态代理的好处/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2019/01/02/jvm内存模型/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2019/01/02/okhttp+retrofit/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/12/30/2018-3-2018-12记产品死亡总结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/12/30/二路归并排序/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/12/27/动态规划/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/12/26/焦虑感的排解方式/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/12/13/java各种锁学习/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/12/11/okio学习/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/12/06/Butterknife源码学习/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/12/06/2018年第四十七周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/11/28/项目卡顿问题优化专题/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/11/25/2018年第四十六周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/11/16/网络协议基础/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/11/16/2018年第44周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/11/14/项目架构总结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/11/12/tree学习/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/11/06/android自动化打包脚本搭建/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/10/22/viewstub的作用/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/10/22/merge标签的作用/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/10/21/为什么在activity触发ondestroy的时候内部类可能产生泄露/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/10/20/android渠道包打包取舍以及打包流程分析/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/10/18/binder机制学习/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/10/10/2018第三季度复盘（第40周）/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801245},{"_id":"public/2018/09/25/2018第三十七周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/09/16/2018第三十六周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/08/29/2018八月-第三十一周到三十五周-工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/08/01/2018第三十周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/07/16/2018第二十八周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/07/08/2018第二十七周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/06/24/2018第二十五周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/06/06/python操作mongodb/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/06/04/2018第二十二周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/05/29/mongodb安装、常用操作记录/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/05/28/2018第二十一周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/05/20/2018第二十周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/05/12/2018第十九周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/05/08/2018第十八周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/05/07/effective-java学习笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/05/07/java编程思想第一章《对象导论》学习笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/05/03/针对activity栈启动模式进行fragment栈的引申/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/05/01/2018第十七周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/04/22/2018第十六周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/04/16/2018第十五周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/04/12/记一次“代码过期”错误/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/04/05/2018第十三周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/04/04/java克隆、浅克隆、深克隆/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/04/01/LruCache缓存源码解析/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/03/31/关于面向对象/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/03/30/关于后台改接口之后前端应该做的事情/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/03/27/http知识杂烩/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/03/26/java-uri拼接/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/03/25/2018第十二周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/03/23/android1-0-7-0各版本feature/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/03/22/android8-0-feature一览/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/03/22/OSS服务器接入上传下载学习/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/03/20/关于WebviewJavaScriptBrige的一些学习/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801246},{"_id":"public/2018/03/19/2018第十一周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/03/19/multidex错误小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/03/14/ARouter组件化框架学习笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/03/14/混淆学习/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/03/12/2018第十周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/03/09/gradlew编译报错小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/03/07/clean架构学习/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/03/02/2018第九周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/02/28/Collection/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/02/27/近期问题回顾/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/02/26/2018第八周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/02/23/大话多线程阅读笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/02/23/android横竖屏切换总结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/02/21/java二分法查找/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/02/20/2018-2-3-4月工作计划安排/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/02/15/rxjava操作符笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/02/13/2018第七周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/02/10/2018第六周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/02/10/android自定义注解/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/02/10/androidMVP架构学习/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/02/10/mvc在android中的使用/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801247},{"_id":"public/2018/02/08/js语法学习/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801248},{"_id":"public/2018/02/06/2018第五周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801248},{"_id":"public/2018/02/06/Android基础知识点/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801248},{"_id":"public/2018/01/31/java基础知识点/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801248},{"_id":"public/2018/01/29/java动态编程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801248},{"_id":"public/2018/01/28/java反射/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801248},{"_id":"public/2018/01/28/2018第四周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801248},{"_id":"public/2018/01/26/使用python抓取网页内容/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801248},{"_id":"public/2018/01/25/Android性能优化/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801248},{"_id":"public/2018/01/25/Android系统信息和安全机制/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801248},{"_id":"public/2018/01/24/第八章Activity与Activity调用栈分析笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/22/第七章动画机制与使用技巧学习笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/21/2018第三周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/16/Android绘图机制与处理技巧/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/14/2018第二周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/13/androidscroll分析笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/12/某金融公司面试小记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/11/快速排序/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/11/冒泡排序/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/09/堆排序/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/09/简单选择排序/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/08/希尔排序/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/08/直接插入排序/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/07/android消息推送/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/06/使用浏览器唤起app/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/05/2018第一周工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/03/android事件分发机制/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/03/android事件拦截机制分析/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/03/android持久化存储/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/02/viewgroup测量/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/02/view的测量和绘制/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2018/01/01/2018开年愿景/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801249},{"_id":"public/2017/12/31/ios-stanford-1/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/2017/12/23/爬虫相关/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/2017/12/21/“rxjava2-0”/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/2017/12/21/retrofit2-post/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/2017/12/21/test-appveyor/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/2017/12/21/使用appveyor-xml-进行双端部署hexo/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/page/5/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/page/6/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/page/7/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/page/8/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/page/9/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/page/10/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/page/11/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/page/12/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/page/13/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/2017/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/2017/12/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/2018/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/2018/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/2018/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/2018/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/2018/page/5/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801250},{"_id":"public/archives/2018/page/6/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/page/7/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/page/8/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/page/9/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/page/10/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/page/11/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/01/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/01/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/01/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/02/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/02/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/03/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/03/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/04/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/05/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/06/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/07/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/08/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/09/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/10/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/11/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2018/12/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2019/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2019/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2019/01/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/archives/2019/02/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/tags/工作小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/tags/工作小结/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/tags/工作小结/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/tags/工作小结/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/tags/工作复盘/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801251},{"_id":"public/tags/android/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801252},{"_id":"public/tags/android/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801252},{"_id":"public/tags/android/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801252},{"_id":"public/tags/android/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801252},{"_id":"public/tags/android/page/5/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801252},{"_id":"public/tags/架构/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801252},{"_id":"public/tags/日常bug/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801252},{"_id":"public/tags/http/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801252},{"_id":"public/tags/ios/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801252},{"_id":"public/tags/java/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801252},{"_id":"public/tags/java/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801252},{"_id":"public/tags/算法/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801252},{"_id":"public/tags/javascript/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801252},{"_id":"public/tags/python/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801252},{"_id":"public/tags/hexo/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801252},{"_id":"public/tags/生活/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801252},{"_id":"public/tags/自我提升/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801255},{"_id":"public/tags/设计模式/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801255},{"_id":"public/tags/计划/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801255},{"_id":"public/tags/数据结构/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801255},{"_id":"public/tags/sql/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801255},{"_id":"public/tags/多线程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801255},{"_id":"public/tags/andrid/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801255},{"_id":"public/tags/网络协议/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801255},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801256},{"_id":"public/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801256},{"_id":"public/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801256},{"_id":"public/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801256},{"_id":"public/page/5/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801256},{"_id":"public/page/6/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801256},{"_id":"public/page/7/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801256},{"_id":"public/page/8/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801256},{"_id":"public/page/9/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801256},{"_id":"public/page/10/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801256},{"_id":"public/page/11/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801256},{"_id":"public/page/12/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801256},{"_id":"public/page/13/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552384801256},{"_id":"public/images/android/instantRunOpenApkMarker.webp","hash":"802d356f3ed23ee8118d8c2acf8e5527a9442652","modified":1552384801266},{"_id":"public/images/android/instantRunSwapImage.webp","hash":"b01afe937db76343bf55b284610e8f19c2d85f85","modified":1552384801266},{"_id":"public/images/android/instantRun热插拔.webp","hash":"7822057b60eaa29fb56c1796cd51c9f9a65e8361","modified":1552384801266},{"_id":"public/images/android/jvm内存模型.jpg","hash":"863ea04e441356616906435801b88ba298f749f7","modified":1552384801266},{"_id":"public/images/数据结构/tree图1.png","hash":"ba674f7d9faea61b1348b84b6a7cd85ed139444c","modified":1552384801266},{"_id":"public/images/算法/希尔排序.png","hash":"42b8dff82d3e13b1c771640fd73ca18426294a97","modified":1552384801266},{"_id":"public/images/网络协议/TCP头部图.png","hash":"06af539047c93bd53c571cba6fb357287b986914","modified":1552384801266},{"_id":"public/images/java/java锁图.png","hash":"11cd62524f1737f9d8cb1a04672ab0d8602548e0","modified":1552384801266},{"_id":"public/images/android/instantRunApkMarker.webp","hash":"802d356f3ed23ee8118d8c2acf8e5527a9442652","modified":1552384801272},{"_id":"public/images/android/recyclerview缓存模型.jpg","hash":"3c5ea60671c6318e8fb62a0cda2534709593bb68","modified":1552384801273},{"_id":"public/images/android/androidpackageimage.png","hash":"9a2313c4a0c6533f757ce8fcdc10d30d4454cb86","modified":1552384801273},{"_id":"public/images/架构/clean架构图.jpg","hash":"35d11d882fe10293ead30f70989bd831cf1d0044","modified":1552384801273},{"_id":"public/images/爬虫相关/正则.jpg","hash":"41904e45cf2faf0600b802e342d6e6959bf9ff7e","modified":1552384801283},{"_id":"public/images/android/Retrofit个人理解图.png","hash":"dd191435275059092b6509c81cc3a97b94089a23","modified":1552384801289},{"_id":"public/images/数据结构/Java集合框架.jpg","hash":"91bd8d323518f261b4046f65b35d22ee584be4b1","modified":1552384801303}],"Category":[],"Data":[],"Page":[{"title":"tags","date":"2018-12-19T09:17:24.000Z","type":"tags","layout":"tags","_content":"\n","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-12-19 17:17:24\ntype: \"tags\"\nlayout: \"tags\"\n---\n\n","updated":"2019-03-12T09:26:33.193Z","path":"tags/index.html","comments":1,"_id":"cjt5lttwb00003a8ktc6ay7pr","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"2-3-4月工作计划安排","date":"2018-02-20T14:44:51.000Z","_content":"\n2-3-4月主要任务是重新找一份工作，目前的安排是优先进行算法+安卓基础的复习。\n\n其次是针对证券从业资格证和基金从业资格证还有司法考试三样进行学习。\n\n天道酬勤\n","source":"_posts/2018-2-3-4月工作计划安排.md","raw":"---\ntitle: 2-3-4月工作计划安排\ndate: 2018-02-20 22:44:51\ntags: 工作小结\n---\n\n2-3-4月主要任务是重新找一份工作，目前的安排是优先进行算法+安卓基础的复习。\n\n其次是针对证券从业资格证和基金从业资格证还有司法考试三样进行学习。\n\n天道酬勤\n","slug":"2018-2-3-4月工作计划安排","published":1,"updated":"2019-03-12T09:26:33.133Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttwc00013a8ktue6u1ta","content":"<p>2-3-4月主要任务是重新找一份工作，目前的安排是优先进行算法+安卓基础的复习。</p>\n<p>其次是针对证券从业资格证和基金从业资格证还有司法考试三样进行学习。</p>\n<p>天道酬勤</p>\n","site":{"data":{}},"excerpt":"","more":"<p>2-3-4月主要任务是重新找一份工作，目前的安排是优先进行算法+安卓基础的复习。</p>\n<p>其次是针对证券从业资格证和基金从业资格证还有司法考试三样进行学习。</p>\n<p>天道酬勤</p>\n"},{"title":"2018年第44周工作小结","date":"2018-11-16T03:21:57.000Z","_content":"\n好几周没有写工作小结了。上个月母亲生病，请假回去，加上十月份国庆节，前前后后只持续工作了一周左右，工作上面的事情大都委托给同组的同事帮忙了。\n\n所以这个月才开始继续写工作小结。\n\n十一月的工作主要是针对商品缺货现象进行优化。产品部门给了两个个需求点，一是增加会员专区，二是进行缺货订阅推送。这两个需求点演化为很多独立或者不独立的需求。\n\n## 增加会员专区\n\n增加会员专区的目的是将部分商品从所有商品中拉出来，保证这些商品能够给VIP选择，这样至少能保证在货源不足的情况下付费用户能够选择。针对该问题我们开发需要做的是加入VIP专区，针对商品是否是vip设置专门的标识，另外在打包的流程中需要额外将成为会员的路径加上。\n\n增加会员标识有些问题，比如说对非会员用户，需要显示成为会员的区域，但是对于已是会员的用户，就需要遮蔽这个区域，这个地方以前的做法是在activity的onresume的时候做检查，检查一遍会员的状态，但是其实商品详情页面如果总这样做的话，onresume里面做的事情过于多了。\n\n我看了一下别的app，像京东这种支持无限订单模式的，返回的状态刷新不是在onresume里面的，而是返回时直接显示出来改变的结果。因此我判断此处使用的应该是广播的方式。因此我觉得在设计app的activity的时候需要将视图同时与广播绑定，在广播发送来的时候，直接针对广播的内容进行相关行为的实施。因此在封装activity的时候，其实需要额外开辟一个针对广播的ui修改区。当然这个广播只需要是应用内广播即可，我使用eventbus来实现了一款。不过鉴于发送广播会造成ui修改，而在activity内的相关行为，一般造成相同ui修改，也会同时发个广播，此时就需要鉴别一下，不要重复刷新。\n\n说道eventbus，在支付宝和微信的回调处理的时候，我也使用的是eventbus，假以时日需要总结一下eventbus原理。\n\n\n## sku订阅推送\n\n订阅推送是上周提出的需求，但是这周才开始实施，期初的想法是一个spu可以订阅一个缺货的sku，这样在sku到货的时候通过推送来唤醒用户。\n\n因此需要在商品详情页面进行订阅功能的添加。但是后来说需要在确认订单页面也同样进行订阅功能的添加，这就将原本的一个spu订阅一个sku的需求变更了，变成了一个spu可以订阅多个sku，相关的逻辑也需要进行改变。\n\n订单流程页面，一直是独立发起，但是并未有比较好的处理措施。由于订单流程本来自身支持很多跳转，而跳转到的页面又支持相应的订单发起，因此其实应该将订单发起页面做成singletask模式，这样可以保证订单发起页面的独立性。但是回来的时候，需要做本地的刷新措施。\n\n回到这个问题，单sku订阅spu涉及到订阅和取消订阅的关系，订阅的时候代表这个spu中的这个sku被订阅，取消订阅也只能说是这个sku被取消订阅。而单品详情页面则拥有取消全部的关系。另外由于订单流程页面并未做单栈模式，所以也有在别的订单流程进行了操作，回到这个未关闭的流程时需要处理订阅的相关消息。\n\n因此此处也使用的广播模式，两种广播，一种是携带了单独sku的广播，这类广播获取之后只需要判断sku的id是否是自己的id，然后做相应的处理即可。另外一种广播是携带了spu信息的广播，这类广播获取之后只需要判断spuid和自己携带的spuid是否相同，如果相同并且为取消订阅的时候，就可以直接取消自己的订阅关系。\n\n## bug修复类\n\nui那边提出了一个修改建议，需要将所有的button通用为一个style，这个比较好做，在别的页面都处理的很好，但是在物流页面发现button点击失效\n\n原来的布局\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:background=\"@color/color_half_alpha_black\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n    <View\n        android:id=\"@+id/view_background\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"@id/text_confirm\"\n        android:background=\"@color/white\"\n        android:layout_marginTop=\"135dp\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"0dp\"/>\n\n    <TextView\n        android:id=\"@+id/text_confirm\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"49dp\"\n        android:text=\"我知道了\"\n        style=\"@style/BlackButtonStyle\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        />\n\n    <TextView\n        android:id=\"@+id/text_express_name\"\n        tools:text=\"顺丰快递\"\n        app:layout_constraintTop_toTopOf=\"@id/view_background\"\n        app:layout_constraintStart_toStartOf=\"@id/view_background\"\n        app:layout_constraintEnd_toEndOf=\"@id/view_background\"\n        android:layout_marginTop=\"20dp\"\n        android:textSize=\"15dp\"\n        android:textColor=\"@color/black\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\" />\n    <TextView\n        android:id=\"@+id/text_express_number\"\n        tools:text=\"（运单编号：3832333043290）\"\n        app:layout_constraintTop_toBottomOf=\"@id/text_express_name\"\n        app:layout_constraintStart_toStartOf=\"@id/view_background\"\n        app:layout_constraintEnd_toEndOf=\"@id/view_background\"\n        android:layout_marginTop=\"10dp\"\n        android:textColor=\"@color/color_666666\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\" />\n    \n    <View\n        android:id=\"@+id/divider_express_number\"\n        android:layout_width=\"0dp\"\n        app:layout_constraintTop_toBottomOf=\"@id/text_express_number\"\n        app:layout_constraintStart_toStartOf=\"@id/view_background\"\n        app:layout_constraintEnd_toEndOf=\"@id/view_background\"\n        android:layout_marginTop=\"20dp\"\n        android:background=\"@color/color_ececec\"\n        android:layout_marginStart=\"20dp\"\n        android:layout_marginEnd=\"20dp\"\n        android:layout_height=\"0.5dp\"/>\n    <ScrollView\n        android:id=\"@+id/scroll_view\"\n        app:layout_constraintTop_toBottomOf=\"@id/divider_express_number\"\n        app:layout_constraintStart_toStartOf=\"@id/view_background\"\n        app:layout_constraintEnd_toEndOf=\"@id/view_background\"\n        app:layout_constraintBottom_toBottomOf=\"@id/view_background\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"0dp\">\n        <LinearLayout\n            android:id=\"@+id/container_logistic\"\n            android:orientation=\"vertical\"\n            android:paddingTop=\"5dp\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\">\n            <include\n                android:visibility=\"gone\"\n                tools:visibility=\"visible\"\n                layout=\"@layout/item_popupwindow_logistic\"/>\n        </LinearLayout>\n    </ScrollView>\n</android.support.constraint.ConstraintLayout>\n```\n\n当时只知道从layoutinspecter中发现布局存在，并且点击事件没有更改。当时做的措施是将id为text_confirm的控件挪到底部，挪到底部保证这个view最后被绘制并且不会被覆盖。但是今天检查了一下发现其实是scrollview的布局的底部写错了，应该以text_confirm的头部为底。当时分析的时候没有注重到这个，而且从布局分析器上面来看其实很难看出这个问题。","source":"_posts/2018年第44周工作小结.md","raw":"title: 2018年第44周工作小结\ndate: 2018-11-16 11:21:57\ntags: 工作小结\n---\n\n好几周没有写工作小结了。上个月母亲生病，请假回去，加上十月份国庆节，前前后后只持续工作了一周左右，工作上面的事情大都委托给同组的同事帮忙了。\n\n所以这个月才开始继续写工作小结。\n\n十一月的工作主要是针对商品缺货现象进行优化。产品部门给了两个个需求点，一是增加会员专区，二是进行缺货订阅推送。这两个需求点演化为很多独立或者不独立的需求。\n\n## 增加会员专区\n\n增加会员专区的目的是将部分商品从所有商品中拉出来，保证这些商品能够给VIP选择，这样至少能保证在货源不足的情况下付费用户能够选择。针对该问题我们开发需要做的是加入VIP专区，针对商品是否是vip设置专门的标识，另外在打包的流程中需要额外将成为会员的路径加上。\n\n增加会员标识有些问题，比如说对非会员用户，需要显示成为会员的区域，但是对于已是会员的用户，就需要遮蔽这个区域，这个地方以前的做法是在activity的onresume的时候做检查，检查一遍会员的状态，但是其实商品详情页面如果总这样做的话，onresume里面做的事情过于多了。\n\n我看了一下别的app，像京东这种支持无限订单模式的，返回的状态刷新不是在onresume里面的，而是返回时直接显示出来改变的结果。因此我判断此处使用的应该是广播的方式。因此我觉得在设计app的activity的时候需要将视图同时与广播绑定，在广播发送来的时候，直接针对广播的内容进行相关行为的实施。因此在封装activity的时候，其实需要额外开辟一个针对广播的ui修改区。当然这个广播只需要是应用内广播即可，我使用eventbus来实现了一款。不过鉴于发送广播会造成ui修改，而在activity内的相关行为，一般造成相同ui修改，也会同时发个广播，此时就需要鉴别一下，不要重复刷新。\n\n说道eventbus，在支付宝和微信的回调处理的时候，我也使用的是eventbus，假以时日需要总结一下eventbus原理。\n\n\n## sku订阅推送\n\n订阅推送是上周提出的需求，但是这周才开始实施，期初的想法是一个spu可以订阅一个缺货的sku，这样在sku到货的时候通过推送来唤醒用户。\n\n因此需要在商品详情页面进行订阅功能的添加。但是后来说需要在确认订单页面也同样进行订阅功能的添加，这就将原本的一个spu订阅一个sku的需求变更了，变成了一个spu可以订阅多个sku，相关的逻辑也需要进行改变。\n\n订单流程页面，一直是独立发起，但是并未有比较好的处理措施。由于订单流程本来自身支持很多跳转，而跳转到的页面又支持相应的订单发起，因此其实应该将订单发起页面做成singletask模式，这样可以保证订单发起页面的独立性。但是回来的时候，需要做本地的刷新措施。\n\n回到这个问题，单sku订阅spu涉及到订阅和取消订阅的关系，订阅的时候代表这个spu中的这个sku被订阅，取消订阅也只能说是这个sku被取消订阅。而单品详情页面则拥有取消全部的关系。另外由于订单流程页面并未做单栈模式，所以也有在别的订单流程进行了操作，回到这个未关闭的流程时需要处理订阅的相关消息。\n\n因此此处也使用的广播模式，两种广播，一种是携带了单独sku的广播，这类广播获取之后只需要判断sku的id是否是自己的id，然后做相应的处理即可。另外一种广播是携带了spu信息的广播，这类广播获取之后只需要判断spuid和自己携带的spuid是否相同，如果相同并且为取消订阅的时候，就可以直接取消自己的订阅关系。\n\n## bug修复类\n\nui那边提出了一个修改建议，需要将所有的button通用为一个style，这个比较好做，在别的页面都处理的很好，但是在物流页面发现button点击失效\n\n原来的布局\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:background=\"@color/color_half_alpha_black\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n    <View\n        android:id=\"@+id/view_background\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"@id/text_confirm\"\n        android:background=\"@color/white\"\n        android:layout_marginTop=\"135dp\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"0dp\"/>\n\n    <TextView\n        android:id=\"@+id/text_confirm\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"49dp\"\n        android:text=\"我知道了\"\n        style=\"@style/BlackButtonStyle\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        />\n\n    <TextView\n        android:id=\"@+id/text_express_name\"\n        tools:text=\"顺丰快递\"\n        app:layout_constraintTop_toTopOf=\"@id/view_background\"\n        app:layout_constraintStart_toStartOf=\"@id/view_background\"\n        app:layout_constraintEnd_toEndOf=\"@id/view_background\"\n        android:layout_marginTop=\"20dp\"\n        android:textSize=\"15dp\"\n        android:textColor=\"@color/black\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\" />\n    <TextView\n        android:id=\"@+id/text_express_number\"\n        tools:text=\"（运单编号：3832333043290）\"\n        app:layout_constraintTop_toBottomOf=\"@id/text_express_name\"\n        app:layout_constraintStart_toStartOf=\"@id/view_background\"\n        app:layout_constraintEnd_toEndOf=\"@id/view_background\"\n        android:layout_marginTop=\"10dp\"\n        android:textColor=\"@color/color_666666\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\" />\n    \n    <View\n        android:id=\"@+id/divider_express_number\"\n        android:layout_width=\"0dp\"\n        app:layout_constraintTop_toBottomOf=\"@id/text_express_number\"\n        app:layout_constraintStart_toStartOf=\"@id/view_background\"\n        app:layout_constraintEnd_toEndOf=\"@id/view_background\"\n        android:layout_marginTop=\"20dp\"\n        android:background=\"@color/color_ececec\"\n        android:layout_marginStart=\"20dp\"\n        android:layout_marginEnd=\"20dp\"\n        android:layout_height=\"0.5dp\"/>\n    <ScrollView\n        android:id=\"@+id/scroll_view\"\n        app:layout_constraintTop_toBottomOf=\"@id/divider_express_number\"\n        app:layout_constraintStart_toStartOf=\"@id/view_background\"\n        app:layout_constraintEnd_toEndOf=\"@id/view_background\"\n        app:layout_constraintBottom_toBottomOf=\"@id/view_background\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"0dp\">\n        <LinearLayout\n            android:id=\"@+id/container_logistic\"\n            android:orientation=\"vertical\"\n            android:paddingTop=\"5dp\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\">\n            <include\n                android:visibility=\"gone\"\n                tools:visibility=\"visible\"\n                layout=\"@layout/item_popupwindow_logistic\"/>\n        </LinearLayout>\n    </ScrollView>\n</android.support.constraint.ConstraintLayout>\n```\n\n当时只知道从layoutinspecter中发现布局存在，并且点击事件没有更改。当时做的措施是将id为text_confirm的控件挪到底部，挪到底部保证这个view最后被绘制并且不会被覆盖。但是今天检查了一下发现其实是scrollview的布局的底部写错了，应该以text_confirm的头部为底。当时分析的时候没有注重到这个，而且从布局分析器上面来看其实很难看出这个问题。","slug":"2018年第44周工作小结","published":1,"updated":"2019-03-12T09:26:33.135Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttwg00023a8kee0yl1e9","content":"<p>好几周没有写工作小结了。上个月母亲生病，请假回去，加上十月份国庆节，前前后后只持续工作了一周左右，工作上面的事情大都委托给同组的同事帮忙了。</p>\n<p>所以这个月才开始继续写工作小结。</p>\n<p>十一月的工作主要是针对商品缺货现象进行优化。产品部门给了两个个需求点，一是增加会员专区，二是进行缺货订阅推送。这两个需求点演化为很多独立或者不独立的需求。</p>\n<h2 id=\"增加会员专区\"><a href=\"#增加会员专区\" class=\"headerlink\" title=\"增加会员专区\"></a>增加会员专区</h2><p>增加会员专区的目的是将部分商品从所有商品中拉出来，保证这些商品能够给VIP选择，这样至少能保证在货源不足的情况下付费用户能够选择。针对该问题我们开发需要做的是加入VIP专区，针对商品是否是vip设置专门的标识，另外在打包的流程中需要额外将成为会员的路径加上。</p>\n<p>增加会员标识有些问题，比如说对非会员用户，需要显示成为会员的区域，但是对于已是会员的用户，就需要遮蔽这个区域，这个地方以前的做法是在activity的onresume的时候做检查，检查一遍会员的状态，但是其实商品详情页面如果总这样做的话，onresume里面做的事情过于多了。</p>\n<p>我看了一下别的app，像京东这种支持无限订单模式的，返回的状态刷新不是在onresume里面的，而是返回时直接显示出来改变的结果。因此我判断此处使用的应该是广播的方式。因此我觉得在设计app的activity的时候需要将视图同时与广播绑定，在广播发送来的时候，直接针对广播的内容进行相关行为的实施。因此在封装activity的时候，其实需要额外开辟一个针对广播的ui修改区。当然这个广播只需要是应用内广播即可，我使用eventbus来实现了一款。不过鉴于发送广播会造成ui修改，而在activity内的相关行为，一般造成相同ui修改，也会同时发个广播，此时就需要鉴别一下，不要重复刷新。</p>\n<p>说道eventbus，在支付宝和微信的回调处理的时候，我也使用的是eventbus，假以时日需要总结一下eventbus原理。</p>\n<h2 id=\"sku订阅推送\"><a href=\"#sku订阅推送\" class=\"headerlink\" title=\"sku订阅推送\"></a>sku订阅推送</h2><p>订阅推送是上周提出的需求，但是这周才开始实施，期初的想法是一个spu可以订阅一个缺货的sku，这样在sku到货的时候通过推送来唤醒用户。</p>\n<p>因此需要在商品详情页面进行订阅功能的添加。但是后来说需要在确认订单页面也同样进行订阅功能的添加，这就将原本的一个spu订阅一个sku的需求变更了，变成了一个spu可以订阅多个sku，相关的逻辑也需要进行改变。</p>\n<p>订单流程页面，一直是独立发起，但是并未有比较好的处理措施。由于订单流程本来自身支持很多跳转，而跳转到的页面又支持相应的订单发起，因此其实应该将订单发起页面做成singletask模式，这样可以保证订单发起页面的独立性。但是回来的时候，需要做本地的刷新措施。</p>\n<p>回到这个问题，单sku订阅spu涉及到订阅和取消订阅的关系，订阅的时候代表这个spu中的这个sku被订阅，取消订阅也只能说是这个sku被取消订阅。而单品详情页面则拥有取消全部的关系。另外由于订单流程页面并未做单栈模式，所以也有在别的订单流程进行了操作，回到这个未关闭的流程时需要处理订阅的相关消息。</p>\n<p>因此此处也使用的广播模式，两种广播，一种是携带了单独sku的广播，这类广播获取之后只需要判断sku的id是否是自己的id，然后做相应的处理即可。另外一种广播是携带了spu信息的广播，这类广播获取之后只需要判断spuid和自己携带的spuid是否相同，如果相同并且为取消订阅的时候，就可以直接取消自己的订阅关系。</p>\n<h2 id=\"bug修复类\"><a href=\"#bug修复类\" class=\"headerlink\" title=\"bug修复类\"></a>bug修复类</h2><p>ui那边提出了一个修改建议，需要将所有的button通用为一个style，这个比较好做，在别的页面都处理的很好，但是在物流页面发现button点击失效</p>\n<p>原来的布局</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class=\"line\">    android:background=&quot;@color/color_half_alpha_black&quot;</span><br><span class=\"line\">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class=\"line\">    &lt;View</span><br><span class=\"line\">        android:id=&quot;@+id/view_background&quot;</span><br><span class=\"line\">        app:layout_constraintTop_toTopOf=&quot;parent&quot;</span><br><span class=\"line\">        app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class=\"line\">        app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class=\"line\">        app:layout_constraintBottom_toBottomOf=&quot;@id/text_confirm&quot;</span><br><span class=\"line\">        android:background=&quot;@color/white&quot;</span><br><span class=\"line\">        android:layout_marginTop=&quot;135dp&quot;</span><br><span class=\"line\">        android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;0dp&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;TextView</span><br><span class=\"line\">        android:id=&quot;@+id/text_confirm&quot;</span><br><span class=\"line\">        android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;49dp&quot;</span><br><span class=\"line\">        android:text=&quot;我知道了&quot;</span><br><span class=\"line\">        style=&quot;@style/BlackButtonStyle&quot;</span><br><span class=\"line\">        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;TextView</span><br><span class=\"line\">        android:id=&quot;@+id/text_express_name&quot;</span><br><span class=\"line\">        tools:text=&quot;顺丰快递&quot;</span><br><span class=\"line\">        app:layout_constraintTop_toTopOf=&quot;@id/view_background&quot;</span><br><span class=\"line\">        app:layout_constraintStart_toStartOf=&quot;@id/view_background&quot;</span><br><span class=\"line\">        app:layout_constraintEnd_toEndOf=&quot;@id/view_background&quot;</span><br><span class=\"line\">        android:layout_marginTop=&quot;20dp&quot;</span><br><span class=\"line\">        android:textSize=&quot;15dp&quot;</span><br><span class=\"line\">        android:textColor=&quot;@color/black&quot;</span><br><span class=\"line\">        android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class=\"line\">    &lt;TextView</span><br><span class=\"line\">        android:id=&quot;@+id/text_express_number&quot;</span><br><span class=\"line\">        tools:text=&quot;（运单编号：3832333043290）&quot;</span><br><span class=\"line\">        app:layout_constraintTop_toBottomOf=&quot;@id/text_express_name&quot;</span><br><span class=\"line\">        app:layout_constraintStart_toStartOf=&quot;@id/view_background&quot;</span><br><span class=\"line\">        app:layout_constraintEnd_toEndOf=&quot;@id/view_background&quot;</span><br><span class=\"line\">        android:layout_marginTop=&quot;10dp&quot;</span><br><span class=\"line\">        android:textColor=&quot;@color/color_666666&quot;</span><br><span class=\"line\">        android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;View</span><br><span class=\"line\">        android:id=&quot;@+id/divider_express_number&quot;</span><br><span class=\"line\">        android:layout_width=&quot;0dp&quot;</span><br><span class=\"line\">        app:layout_constraintTop_toBottomOf=&quot;@id/text_express_number&quot;</span><br><span class=\"line\">        app:layout_constraintStart_toStartOf=&quot;@id/view_background&quot;</span><br><span class=\"line\">        app:layout_constraintEnd_toEndOf=&quot;@id/view_background&quot;</span><br><span class=\"line\">        android:layout_marginTop=&quot;20dp&quot;</span><br><span class=\"line\">        android:background=&quot;@color/color_ececec&quot;</span><br><span class=\"line\">        android:layout_marginStart=&quot;20dp&quot;</span><br><span class=\"line\">        android:layout_marginEnd=&quot;20dp&quot;</span><br><span class=\"line\">        android:layout_height=&quot;0.5dp&quot;/&gt;</span><br><span class=\"line\">    &lt;ScrollView</span><br><span class=\"line\">        android:id=&quot;@+id/scroll_view&quot;</span><br><span class=\"line\">        app:layout_constraintTop_toBottomOf=&quot;@id/divider_express_number&quot;</span><br><span class=\"line\">        app:layout_constraintStart_toStartOf=&quot;@id/view_background&quot;</span><br><span class=\"line\">        app:layout_constraintEnd_toEndOf=&quot;@id/view_background&quot;</span><br><span class=\"line\">        app:layout_constraintBottom_toBottomOf=&quot;@id/view_background&quot;</span><br><span class=\"line\">        android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;0dp&quot;&gt;</span><br><span class=\"line\">        &lt;LinearLayout</span><br><span class=\"line\">            android:id=&quot;@+id/container_logistic&quot;</span><br><span class=\"line\">            android:orientation=&quot;vertical&quot;</span><br><span class=\"line\">            android:paddingTop=&quot;5dp&quot;</span><br><span class=\"line\">            android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">            android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class=\"line\">            &lt;include</span><br><span class=\"line\">                android:visibility=&quot;gone&quot;</span><br><span class=\"line\">                tools:visibility=&quot;visible&quot;</span><br><span class=\"line\">                layout=&quot;@layout/item_popupwindow_logistic&quot;/&gt;</span><br><span class=\"line\">        &lt;/LinearLayout&gt;</span><br><span class=\"line\">    &lt;/ScrollView&gt;</span><br><span class=\"line\">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure>\n<p>当时只知道从layoutinspecter中发现布局存在，并且点击事件没有更改。当时做的措施是将id为text_confirm的控件挪到底部，挪到底部保证这个view最后被绘制并且不会被覆盖。但是今天检查了一下发现其实是scrollview的布局的底部写错了，应该以text_confirm的头部为底。当时分析的时候没有注重到这个，而且从布局分析器上面来看其实很难看出这个问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>好几周没有写工作小结了。上个月母亲生病，请假回去，加上十月份国庆节，前前后后只持续工作了一周左右，工作上面的事情大都委托给同组的同事帮忙了。</p>\n<p>所以这个月才开始继续写工作小结。</p>\n<p>十一月的工作主要是针对商品缺货现象进行优化。产品部门给了两个个需求点，一是增加会员专区，二是进行缺货订阅推送。这两个需求点演化为很多独立或者不独立的需求。</p>\n<h2 id=\"增加会员专区\"><a href=\"#增加会员专区\" class=\"headerlink\" title=\"增加会员专区\"></a>增加会员专区</h2><p>增加会员专区的目的是将部分商品从所有商品中拉出来，保证这些商品能够给VIP选择，这样至少能保证在货源不足的情况下付费用户能够选择。针对该问题我们开发需要做的是加入VIP专区，针对商品是否是vip设置专门的标识，另外在打包的流程中需要额外将成为会员的路径加上。</p>\n<p>增加会员标识有些问题，比如说对非会员用户，需要显示成为会员的区域，但是对于已是会员的用户，就需要遮蔽这个区域，这个地方以前的做法是在activity的onresume的时候做检查，检查一遍会员的状态，但是其实商品详情页面如果总这样做的话，onresume里面做的事情过于多了。</p>\n<p>我看了一下别的app，像京东这种支持无限订单模式的，返回的状态刷新不是在onresume里面的，而是返回时直接显示出来改变的结果。因此我判断此处使用的应该是广播的方式。因此我觉得在设计app的activity的时候需要将视图同时与广播绑定，在广播发送来的时候，直接针对广播的内容进行相关行为的实施。因此在封装activity的时候，其实需要额外开辟一个针对广播的ui修改区。当然这个广播只需要是应用内广播即可，我使用eventbus来实现了一款。不过鉴于发送广播会造成ui修改，而在activity内的相关行为，一般造成相同ui修改，也会同时发个广播，此时就需要鉴别一下，不要重复刷新。</p>\n<p>说道eventbus，在支付宝和微信的回调处理的时候，我也使用的是eventbus，假以时日需要总结一下eventbus原理。</p>\n<h2 id=\"sku订阅推送\"><a href=\"#sku订阅推送\" class=\"headerlink\" title=\"sku订阅推送\"></a>sku订阅推送</h2><p>订阅推送是上周提出的需求，但是这周才开始实施，期初的想法是一个spu可以订阅一个缺货的sku，这样在sku到货的时候通过推送来唤醒用户。</p>\n<p>因此需要在商品详情页面进行订阅功能的添加。但是后来说需要在确认订单页面也同样进行订阅功能的添加，这就将原本的一个spu订阅一个sku的需求变更了，变成了一个spu可以订阅多个sku，相关的逻辑也需要进行改变。</p>\n<p>订单流程页面，一直是独立发起，但是并未有比较好的处理措施。由于订单流程本来自身支持很多跳转，而跳转到的页面又支持相应的订单发起，因此其实应该将订单发起页面做成singletask模式，这样可以保证订单发起页面的独立性。但是回来的时候，需要做本地的刷新措施。</p>\n<p>回到这个问题，单sku订阅spu涉及到订阅和取消订阅的关系，订阅的时候代表这个spu中的这个sku被订阅，取消订阅也只能说是这个sku被取消订阅。而单品详情页面则拥有取消全部的关系。另外由于订单流程页面并未做单栈模式，所以也有在别的订单流程进行了操作，回到这个未关闭的流程时需要处理订阅的相关消息。</p>\n<p>因此此处也使用的广播模式，两种广播，一种是携带了单独sku的广播，这类广播获取之后只需要判断sku的id是否是自己的id，然后做相应的处理即可。另外一种广播是携带了spu信息的广播，这类广播获取之后只需要判断spuid和自己携带的spuid是否相同，如果相同并且为取消订阅的时候，就可以直接取消自己的订阅关系。</p>\n<h2 id=\"bug修复类\"><a href=\"#bug修复类\" class=\"headerlink\" title=\"bug修复类\"></a>bug修复类</h2><p>ui那边提出了一个修改建议，需要将所有的button通用为一个style，这个比较好做，在别的页面都处理的很好，但是在物流页面发现button点击失效</p>\n<p>原来的布局</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class=\"line\">    android:background=&quot;@color/color_half_alpha_black&quot;</span><br><span class=\"line\">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class=\"line\">    &lt;View</span><br><span class=\"line\">        android:id=&quot;@+id/view_background&quot;</span><br><span class=\"line\">        app:layout_constraintTop_toTopOf=&quot;parent&quot;</span><br><span class=\"line\">        app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class=\"line\">        app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class=\"line\">        app:layout_constraintBottom_toBottomOf=&quot;@id/text_confirm&quot;</span><br><span class=\"line\">        android:background=&quot;@color/white&quot;</span><br><span class=\"line\">        android:layout_marginTop=&quot;135dp&quot;</span><br><span class=\"line\">        android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;0dp&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;TextView</span><br><span class=\"line\">        android:id=&quot;@+id/text_confirm&quot;</span><br><span class=\"line\">        android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;49dp&quot;</span><br><span class=\"line\">        android:text=&quot;我知道了&quot;</span><br><span class=\"line\">        style=&quot;@style/BlackButtonStyle&quot;</span><br><span class=\"line\">        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;TextView</span><br><span class=\"line\">        android:id=&quot;@+id/text_express_name&quot;</span><br><span class=\"line\">        tools:text=&quot;顺丰快递&quot;</span><br><span class=\"line\">        app:layout_constraintTop_toTopOf=&quot;@id/view_background&quot;</span><br><span class=\"line\">        app:layout_constraintStart_toStartOf=&quot;@id/view_background&quot;</span><br><span class=\"line\">        app:layout_constraintEnd_toEndOf=&quot;@id/view_background&quot;</span><br><span class=\"line\">        android:layout_marginTop=&quot;20dp&quot;</span><br><span class=\"line\">        android:textSize=&quot;15dp&quot;</span><br><span class=\"line\">        android:textColor=&quot;@color/black&quot;</span><br><span class=\"line\">        android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class=\"line\">    &lt;TextView</span><br><span class=\"line\">        android:id=&quot;@+id/text_express_number&quot;</span><br><span class=\"line\">        tools:text=&quot;（运单编号：3832333043290）&quot;</span><br><span class=\"line\">        app:layout_constraintTop_toBottomOf=&quot;@id/text_express_name&quot;</span><br><span class=\"line\">        app:layout_constraintStart_toStartOf=&quot;@id/view_background&quot;</span><br><span class=\"line\">        app:layout_constraintEnd_toEndOf=&quot;@id/view_background&quot;</span><br><span class=\"line\">        android:layout_marginTop=&quot;10dp&quot;</span><br><span class=\"line\">        android:textColor=&quot;@color/color_666666&quot;</span><br><span class=\"line\">        android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;View</span><br><span class=\"line\">        android:id=&quot;@+id/divider_express_number&quot;</span><br><span class=\"line\">        android:layout_width=&quot;0dp&quot;</span><br><span class=\"line\">        app:layout_constraintTop_toBottomOf=&quot;@id/text_express_number&quot;</span><br><span class=\"line\">        app:layout_constraintStart_toStartOf=&quot;@id/view_background&quot;</span><br><span class=\"line\">        app:layout_constraintEnd_toEndOf=&quot;@id/view_background&quot;</span><br><span class=\"line\">        android:layout_marginTop=&quot;20dp&quot;</span><br><span class=\"line\">        android:background=&quot;@color/color_ececec&quot;</span><br><span class=\"line\">        android:layout_marginStart=&quot;20dp&quot;</span><br><span class=\"line\">        android:layout_marginEnd=&quot;20dp&quot;</span><br><span class=\"line\">        android:layout_height=&quot;0.5dp&quot;/&gt;</span><br><span class=\"line\">    &lt;ScrollView</span><br><span class=\"line\">        android:id=&quot;@+id/scroll_view&quot;</span><br><span class=\"line\">        app:layout_constraintTop_toBottomOf=&quot;@id/divider_express_number&quot;</span><br><span class=\"line\">        app:layout_constraintStart_toStartOf=&quot;@id/view_background&quot;</span><br><span class=\"line\">        app:layout_constraintEnd_toEndOf=&quot;@id/view_background&quot;</span><br><span class=\"line\">        app:layout_constraintBottom_toBottomOf=&quot;@id/view_background&quot;</span><br><span class=\"line\">        android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;0dp&quot;&gt;</span><br><span class=\"line\">        &lt;LinearLayout</span><br><span class=\"line\">            android:id=&quot;@+id/container_logistic&quot;</span><br><span class=\"line\">            android:orientation=&quot;vertical&quot;</span><br><span class=\"line\">            android:paddingTop=&quot;5dp&quot;</span><br><span class=\"line\">            android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">            android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class=\"line\">            &lt;include</span><br><span class=\"line\">                android:visibility=&quot;gone&quot;</span><br><span class=\"line\">                tools:visibility=&quot;visible&quot;</span><br><span class=\"line\">                layout=&quot;@layout/item_popupwindow_logistic&quot;/&gt;</span><br><span class=\"line\">        &lt;/LinearLayout&gt;</span><br><span class=\"line\">    &lt;/ScrollView&gt;</span><br><span class=\"line\">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure>\n<p>当时只知道从layoutinspecter中发现布局存在，并且点击事件没有更改。当时做的措施是将id为text_confirm的控件挪到底部，挪到底部保证这个view最后被绘制并且不会被覆盖。但是今天检查了一下发现其实是scrollview的布局的底部写错了，应该以text_confirm的头部为底。当时分析的时候没有注重到这个，而且从布局分析器上面来看其实很难看出这个问题。</p>\n"},{"title":"2018年第四十七周工作小结","date":"2018-12-06T10:56:13.000Z","_content":"\n上周比较累，一个版本发了两周，而且上周结束还没有完成发版的任务。\n\n多人开发本来就有很多问题，但是最关键的问题还是大锅饭的问题。\n\n三个人每个人都有两个任务，从上上周开始做，由于任务比较重，所以要了两周的工时，我从上上周三接口对接了开始做，直到上周二全部完成正式提测。而他们是怎么做的呢？一个上上周全部宕机，直到上周一才开始做，做到周四结束提测。另一个是每天下午做一点，到点跑路。也是周四提测。\n\n也就是一个组，我周三测试完毕全部通过后，等到周四他们才提测。\n\n结果呢？如果能力足够，确保bug不多的话，多晚提测都没问题，但是出了30多个bug是个什么鬼。\n\n我心里简直日了狗，本来准备周五发版，结果周四晚上出了30多个bug，而且在一个人身上就有25个。没办法，因为我手上没活，被迫帮人收拾摊子。搞到了周六凌晨三点多。各种奇奇怪怪的bug，有逻辑错误的，有移植过程参数丢失的，而且还有接口错误的，神奇，接口对接的时候在玩猴子啊。真是想吐槽一车的。\n\n说回大锅饭，多人开发，多人协助是没错的，但是前期各种拖，各种没事找事，到后期deadline了，开始抢工期，表现的很勤奋，真不知道是给谁看。最后需要做的快的人来帮忙收拾摊子。做的东西难吗？搞了两周，逻辑错误还是外人一眼就能看出来的，这是认真搞了？\n\n神烦是周五晚上，两个人都像是宕机了，看着我在debug，一个在看博客，另一个在盯着我改bug。我心里简直是日了狗，非我的模块，非我的职责，最后变成了我来维护。这也罢了，我帮忙做事，能不能给点面子表现的好点，看着我改是什么鬼？\n\n大锅饭真是让人疲惫的事情，没有必要的激励，出问题大家抗，没问题就当无事发生。这种不健全的制度，怎么可能留得住想好好发展的人。\n\n\n\n","source":"_posts/2018年第四十七周工作小结.md","raw":"---\ntitle: 2018年第四十七周工作小结\ndate: 2018-12-06 18:56:13\ntags: 工作小结\n---\n\n上周比较累，一个版本发了两周，而且上周结束还没有完成发版的任务。\n\n多人开发本来就有很多问题，但是最关键的问题还是大锅饭的问题。\n\n三个人每个人都有两个任务，从上上周开始做，由于任务比较重，所以要了两周的工时，我从上上周三接口对接了开始做，直到上周二全部完成正式提测。而他们是怎么做的呢？一个上上周全部宕机，直到上周一才开始做，做到周四结束提测。另一个是每天下午做一点，到点跑路。也是周四提测。\n\n也就是一个组，我周三测试完毕全部通过后，等到周四他们才提测。\n\n结果呢？如果能力足够，确保bug不多的话，多晚提测都没问题，但是出了30多个bug是个什么鬼。\n\n我心里简直日了狗，本来准备周五发版，结果周四晚上出了30多个bug，而且在一个人身上就有25个。没办法，因为我手上没活，被迫帮人收拾摊子。搞到了周六凌晨三点多。各种奇奇怪怪的bug，有逻辑错误的，有移植过程参数丢失的，而且还有接口错误的，神奇，接口对接的时候在玩猴子啊。真是想吐槽一车的。\n\n说回大锅饭，多人开发，多人协助是没错的，但是前期各种拖，各种没事找事，到后期deadline了，开始抢工期，表现的很勤奋，真不知道是给谁看。最后需要做的快的人来帮忙收拾摊子。做的东西难吗？搞了两周，逻辑错误还是外人一眼就能看出来的，这是认真搞了？\n\n神烦是周五晚上，两个人都像是宕机了，看着我在debug，一个在看博客，另一个在盯着我改bug。我心里简直是日了狗，非我的模块，非我的职责，最后变成了我来维护。这也罢了，我帮忙做事，能不能给点面子表现的好点，看着我改是什么鬼？\n\n大锅饭真是让人疲惫的事情，没有必要的激励，出问题大家抗，没问题就当无事发生。这种不健全的制度，怎么可能留得住想好好发展的人。\n\n\n\n","slug":"2018年第四十七周工作小结","published":1,"updated":"2019-03-12T09:26:33.135Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttwj00043a8kz2oxy5lr","content":"<p>上周比较累，一个版本发了两周，而且上周结束还没有完成发版的任务。</p>\n<p>多人开发本来就有很多问题，但是最关键的问题还是大锅饭的问题。</p>\n<p>三个人每个人都有两个任务，从上上周开始做，由于任务比较重，所以要了两周的工时，我从上上周三接口对接了开始做，直到上周二全部完成正式提测。而他们是怎么做的呢？一个上上周全部宕机，直到上周一才开始做，做到周四结束提测。另一个是每天下午做一点，到点跑路。也是周四提测。</p>\n<p>也就是一个组，我周三测试完毕全部通过后，等到周四他们才提测。</p>\n<p>结果呢？如果能力足够，确保bug不多的话，多晚提测都没问题，但是出了30多个bug是个什么鬼。</p>\n<p>我心里简直日了狗，本来准备周五发版，结果周四晚上出了30多个bug，而且在一个人身上就有25个。没办法，因为我手上没活，被迫帮人收拾摊子。搞到了周六凌晨三点多。各种奇奇怪怪的bug，有逻辑错误的，有移植过程参数丢失的，而且还有接口错误的，神奇，接口对接的时候在玩猴子啊。真是想吐槽一车的。</p>\n<p>说回大锅饭，多人开发，多人协助是没错的，但是前期各种拖，各种没事找事，到后期deadline了，开始抢工期，表现的很勤奋，真不知道是给谁看。最后需要做的快的人来帮忙收拾摊子。做的东西难吗？搞了两周，逻辑错误还是外人一眼就能看出来的，这是认真搞了？</p>\n<p>神烦是周五晚上，两个人都像是宕机了，看着我在debug，一个在看博客，另一个在盯着我改bug。我心里简直是日了狗，非我的模块，非我的职责，最后变成了我来维护。这也罢了，我帮忙做事，能不能给点面子表现的好点，看着我改是什么鬼？</p>\n<p>大锅饭真是让人疲惫的事情，没有必要的激励，出问题大家抗，没问题就当无事发生。这种不健全的制度，怎么可能留得住想好好发展的人。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>上周比较累，一个版本发了两周，而且上周结束还没有完成发版的任务。</p>\n<p>多人开发本来就有很多问题，但是最关键的问题还是大锅饭的问题。</p>\n<p>三个人每个人都有两个任务，从上上周开始做，由于任务比较重，所以要了两周的工时，我从上上周三接口对接了开始做，直到上周二全部完成正式提测。而他们是怎么做的呢？一个上上周全部宕机，直到上周一才开始做，做到周四结束提测。另一个是每天下午做一点，到点跑路。也是周四提测。</p>\n<p>也就是一个组，我周三测试完毕全部通过后，等到周四他们才提测。</p>\n<p>结果呢？如果能力足够，确保bug不多的话，多晚提测都没问题，但是出了30多个bug是个什么鬼。</p>\n<p>我心里简直日了狗，本来准备周五发版，结果周四晚上出了30多个bug，而且在一个人身上就有25个。没办法，因为我手上没活，被迫帮人收拾摊子。搞到了周六凌晨三点多。各种奇奇怪怪的bug，有逻辑错误的，有移植过程参数丢失的，而且还有接口错误的，神奇，接口对接的时候在玩猴子啊。真是想吐槽一车的。</p>\n<p>说回大锅饭，多人开发，多人协助是没错的，但是前期各种拖，各种没事找事，到后期deadline了，开始抢工期，表现的很勤奋，真不知道是给谁看。最后需要做的快的人来帮忙收拾摊子。做的东西难吗？搞了两周，逻辑错误还是外人一眼就能看出来的，这是认真搞了？</p>\n<p>神烦是周五晚上，两个人都像是宕机了，看着我在debug，一个在看博客，另一个在盯着我改bug。我心里简直是日了狗，非我的模块，非我的职责，最后变成了我来维护。这也罢了，我帮忙做事，能不能给点面子表现的好点，看着我改是什么鬼？</p>\n<p>大锅饭真是让人疲惫的事情，没有必要的激励，出问题大家抗，没问题就当无事发生。这种不健全的制度，怎么可能留得住想好好发展的人。</p>\n"},{"title":"2018年第四十六周工作小结","date":"2018-11-25T14:55:08.000Z","_content":"\n本周的主要工作是完成了medel放大，手势滑动，以及分享到app等功能。\n\nmedel放大主要使用的是photoview的改写版本，因为产品要求不支持反转，因此读了一下代码去掉了反转的操作，放大的弹性指数用的是正常的2.5倍。medel放大，手势等等业务逻辑写的都比较简单。\n\n这次medel的放大页面，需要使用viewpager进行滑动更改，因此这就需要了进行medel的bitmap缓存，按照以往的写法，这个地方应该写一个lrucache，配套SoftReference<Bitmap>来使用，但是调试过程中发现了一些问题。\n\nsoftreference是当内存不足的时候会被强制回收，lrucache里面携带的是linkedlist，直接使用key指向该软引用，lrucache里面会记录目前保留下来的数量，然后作对比。但是比较神奇的是，发现了lrucache里面记录的数量大于0，但是linkedlist里面size却为0了。做了两个对比，当不使用软引用，直接使用携带bitmap，发现并不会出现这种情况。关于这个问题查了一下，其实jvm并不希望我们使用软引用，因为无法确定何时回收比较好，因此此处回收的机制并不是当内存不足的时候才回收，由于给了1/8最大可用内存，因此此处应该是触发了一个最大内存限制，导致直接被强制回收了所有软引用的地方，导致发生了这个问题。另外实验了一下，在recyclerview中，当view被回收复用的时候，此时使用软引用就不会触发这个问题，因为当view被回收复用的时候，此时就会释放该部分指向，当这部分到了内存限制的时候回被自然的回收，但是viewpager中view不会被回收，而且我没有设置最大页面的offset，导致这个问题发生。\n\n因此以后使用到软引用的时候，不能光认为是内存不足就会被回收，要做好直接被回收的准备，否则就不应该使用软引用。\n\n另外这次关于medel的设计，是在spu详情页面，spu详情页面跳出medel预览，然后medel预览还可以跳转详情，这涉及一个无限跳转的问题，测试发现一个详情页面占用起码300M内存，但是如果是相同的大概只会增加100M，但是如果无限跳转肯定会导致内存不足的问题，从淘宝测试了一下，淘宝最多只允许三个页面跳转，因此我们也需要考虑到这个问题。\n\n下个版本需要设计一下页面多级跳转的问题。目前思想是在activty栈里面做一些设置，在相同activity过多的时候，采取旧页面强制销毁的方式，然后启动新的页面，这样应该可以解决这个问题\n","source":"_posts/2018年第四十六周工作小结.md","raw":"---\ntitle: 2018年第四十六周工作小结\ndate: 2018-11-25 22:55:08\ntags: 工作小结\n---\n\n本周的主要工作是完成了medel放大，手势滑动，以及分享到app等功能。\n\nmedel放大主要使用的是photoview的改写版本，因为产品要求不支持反转，因此读了一下代码去掉了反转的操作，放大的弹性指数用的是正常的2.5倍。medel放大，手势等等业务逻辑写的都比较简单。\n\n这次medel的放大页面，需要使用viewpager进行滑动更改，因此这就需要了进行medel的bitmap缓存，按照以往的写法，这个地方应该写一个lrucache，配套SoftReference<Bitmap>来使用，但是调试过程中发现了一些问题。\n\nsoftreference是当内存不足的时候会被强制回收，lrucache里面携带的是linkedlist，直接使用key指向该软引用，lrucache里面会记录目前保留下来的数量，然后作对比。但是比较神奇的是，发现了lrucache里面记录的数量大于0，但是linkedlist里面size却为0了。做了两个对比，当不使用软引用，直接使用携带bitmap，发现并不会出现这种情况。关于这个问题查了一下，其实jvm并不希望我们使用软引用，因为无法确定何时回收比较好，因此此处回收的机制并不是当内存不足的时候才回收，由于给了1/8最大可用内存，因此此处应该是触发了一个最大内存限制，导致直接被强制回收了所有软引用的地方，导致发生了这个问题。另外实验了一下，在recyclerview中，当view被回收复用的时候，此时使用软引用就不会触发这个问题，因为当view被回收复用的时候，此时就会释放该部分指向，当这部分到了内存限制的时候回被自然的回收，但是viewpager中view不会被回收，而且我没有设置最大页面的offset，导致这个问题发生。\n\n因此以后使用到软引用的时候，不能光认为是内存不足就会被回收，要做好直接被回收的准备，否则就不应该使用软引用。\n\n另外这次关于medel的设计，是在spu详情页面，spu详情页面跳出medel预览，然后medel预览还可以跳转详情，这涉及一个无限跳转的问题，测试发现一个详情页面占用起码300M内存，但是如果是相同的大概只会增加100M，但是如果无限跳转肯定会导致内存不足的问题，从淘宝测试了一下，淘宝最多只允许三个页面跳转，因此我们也需要考虑到这个问题。\n\n下个版本需要设计一下页面多级跳转的问题。目前思想是在activty栈里面做一些设置，在相同activity过多的时候，采取旧页面强制销毁的方式，然后启动新的页面，这样应该可以解决这个问题\n","slug":"2018年第四十六周工作小结","published":1,"updated":"2019-03-12T09:26:33.136Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttwk00053a8kdpdryq0n","content":"<p>本周的主要工作是完成了medel放大，手势滑动，以及分享到app等功能。</p>\n<p>medel放大主要使用的是photoview的改写版本，因为产品要求不支持反转，因此读了一下代码去掉了反转的操作，放大的弹性指数用的是正常的2.5倍。medel放大，手势等等业务逻辑写的都比较简单。</p>\n<p>这次medel的放大页面，需要使用viewpager进行滑动更改，因此这就需要了进行medel的bitmap缓存，按照以往的写法，这个地方应该写一个lrucache，配套SoftReference<bitmap>来使用，但是调试过程中发现了一些问题。</bitmap></p>\n<p>softreference是当内存不足的时候会被强制回收，lrucache里面携带的是linkedlist，直接使用key指向该软引用，lrucache里面会记录目前保留下来的数量，然后作对比。但是比较神奇的是，发现了lrucache里面记录的数量大于0，但是linkedlist里面size却为0了。做了两个对比，当不使用软引用，直接使用携带bitmap，发现并不会出现这种情况。关于这个问题查了一下，其实jvm并不希望我们使用软引用，因为无法确定何时回收比较好，因此此处回收的机制并不是当内存不足的时候才回收，由于给了1/8最大可用内存，因此此处应该是触发了一个最大内存限制，导致直接被强制回收了所有软引用的地方，导致发生了这个问题。另外实验了一下，在recyclerview中，当view被回收复用的时候，此时使用软引用就不会触发这个问题，因为当view被回收复用的时候，此时就会释放该部分指向，当这部分到了内存限制的时候回被自然的回收，但是viewpager中view不会被回收，而且我没有设置最大页面的offset，导致这个问题发生。</p>\n<p>因此以后使用到软引用的时候，不能光认为是内存不足就会被回收，要做好直接被回收的准备，否则就不应该使用软引用。</p>\n<p>另外这次关于medel的设计，是在spu详情页面，spu详情页面跳出medel预览，然后medel预览还可以跳转详情，这涉及一个无限跳转的问题，测试发现一个详情页面占用起码300M内存，但是如果是相同的大概只会增加100M，但是如果无限跳转肯定会导致内存不足的问题，从淘宝测试了一下，淘宝最多只允许三个页面跳转，因此我们也需要考虑到这个问题。</p>\n<p>下个版本需要设计一下页面多级跳转的问题。目前思想是在activty栈里面做一些设置，在相同activity过多的时候，采取旧页面强制销毁的方式，然后启动新的页面，这样应该可以解决这个问题</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本周的主要工作是完成了medel放大，手势滑动，以及分享到app等功能。</p>\n<p>medel放大主要使用的是photoview的改写版本，因为产品要求不支持反转，因此读了一下代码去掉了反转的操作，放大的弹性指数用的是正常的2.5倍。medel放大，手势等等业务逻辑写的都比较简单。</p>\n<p>这次medel的放大页面，需要使用viewpager进行滑动更改，因此这就需要了进行medel的bitmap缓存，按照以往的写法，这个地方应该写一个lrucache，配套SoftReference<bitmap>来使用，但是调试过程中发现了一些问题。</bitmap></p>\n<p>softreference是当内存不足的时候会被强制回收，lrucache里面携带的是linkedlist，直接使用key指向该软引用，lrucache里面会记录目前保留下来的数量，然后作对比。但是比较神奇的是，发现了lrucache里面记录的数量大于0，但是linkedlist里面size却为0了。做了两个对比，当不使用软引用，直接使用携带bitmap，发现并不会出现这种情况。关于这个问题查了一下，其实jvm并不希望我们使用软引用，因为无法确定何时回收比较好，因此此处回收的机制并不是当内存不足的时候才回收，由于给了1/8最大可用内存，因此此处应该是触发了一个最大内存限制，导致直接被强制回收了所有软引用的地方，导致发生了这个问题。另外实验了一下，在recyclerview中，当view被回收复用的时候，此时使用软引用就不会触发这个问题，因为当view被回收复用的时候，此时就会释放该部分指向，当这部分到了内存限制的时候回被自然的回收，但是viewpager中view不会被回收，而且我没有设置最大页面的offset，导致这个问题发生。</p>\n<p>因此以后使用到软引用的时候，不能光认为是内存不足就会被回收，要做好直接被回收的准备，否则就不应该使用软引用。</p>\n<p>另外这次关于medel的设计，是在spu详情页面，spu详情页面跳出medel预览，然后medel预览还可以跳转详情，这涉及一个无限跳转的问题，测试发现一个详情页面占用起码300M内存，但是如果是相同的大概只会增加100M，但是如果无限跳转肯定会导致内存不足的问题，从淘宝测试了一下，淘宝最多只允许三个页面跳转，因此我们也需要考虑到这个问题。</p>\n<p>下个版本需要设计一下页面多级跳转的问题。目前思想是在activty栈里面做一些设置，在相同activity过多的时候，采取旧页面强制销毁的方式，然后启动新的页面，这样应该可以解决这个问题</p>\n"},{"title":"2018第一周工作小结","date":"2018-01-05T14:18:49.000Z","_content":"这一周由于元旦的关系，只上了四天班。2017上半年的时候在传音工作，那时候每天都要写日报，然后周五要写周报，当时写的实在是痛苦，结果来崇杏之后，一天日报都没有写过。\n\n刚开始的确很爽，可是年底总结的时候发现写不出什么来了，对于半年多的工作只有一个浅薄的印象，大致知道做了哪些项目，可是项目相关都有些模糊了。因此重拾写周报的习惯，希望今年能够有一些改变。\n\n这周由于spirtMonitor项目需要重新制作ui，前几天陈哥还没有做完效果，因此先将之前做的肺科医院订餐管理后台先进行微信登陆的集成。\n\n微信的集成刚开始准备我这边获取相关的token，然后直接与服务器对接。但是当我获取了openid之后，后端说微信开放平台的openid与公众平台的openid不同，只可以使用unionid来对接。同时还有个问题，就是我这边无法直接使用获取的unionid来进行对接，不可以把appid和secretid放在app里面，防止别人抓包。\n\n因此需要重新设置一个模式，使用appid加微信登陆获取的一次性code，将code传回服务器，在服务器里面进行处理，之后返回一个处理完毕的token，我在app这边做一个持久化，这个token有效期三天，我根据token是否过期进行重新获取code，重复之上的行为即可。因此等待张凯把后端处理完我才可以进行之后的行动。\n\n关于token，我和张凯交流的时候有个设想，我这边将code，使用query的方式添加到url的末尾，然后使用浏览器传出去，之后浏览器走之前微信公众号的那个端口，走完之后浏览器返回值，然后浏览器吊起我的程序。这个方法感觉是可行的，但是当时考虑到跨域的问题没有实现。\n\n晚上关于这个问题搜索了一下，主要针对是如何使用webview来吊起activity。\n\n结果显示，的确如果直接发intent吊起webview会出现跨域的问题，但是可以本地写一个html页面来解决跨域的问题。\n\n[使用webview吊起activity](http://www.cnblogs.com/yejiurui/p/3413796.html)\n\n这样给我一个想法。由于安卓跨域保护的问题，很多和浏览器协作的方面，比如说之前做的，hybirdapp调用本地视频的功能，可以截取webview的url，然后吊起本地的html来加载视频。不过这个方式对于那种内嵌的视频可能不好用，内嵌的视频还是需要使用webserver来进行视频的提供。但是也是一种思路。\n\n明天做一下相关的demo。\n\n微信集成搞了2天，之后陈总那边的ui好了，因此需要重新更改ui。\n\n之前使用animation的方式，对textview进行动画的设置，这样会在更新的时候触发动画，但是动画的效果不是很好看，之后恰好看到了一个app，使用的是每次更新的时候数字从小到大的方式。刚好找到了一个库，单纯的一个自定义view，直接继承了textview，使用的一个valueAmatior动画，这个动画里面添加了一个animationListener，在这个监听器里面进行了textview的设值。值的范围从设置的开端到末端。这个设置的动画和我之前设置的对比就完全不同了，感觉十分好。\n\n周四周五大概就做了这几件事。晚上回来的路上，在想关于借口查询的问题，我之前使用的是定时去查询接口的方式，但是之前了解了一个关于http长连接的方式，实时聊天软件就是使用的长连接的效果，这方面也需要了解一下。\n\n因此本周的收获如下：\n1. 了解了如何使用valueAmator来进行动画的更新。\n2. 了解了如何集成微信\n\n遗留未解决的问题如下：\n1. 使用本地静态html来进行get操作，对返回值过滤来吊起app并且获取返回值\n2. 学习使用长链接的方式来进行接口的查询\n\n周末的任务：\n1. 解决遗留问题\n2. 处理一下williamchart的ui更改\n3. 研究一下安卓的渐变色，圆心渐变和直线渐变\n\n有时间的话：\n1. 学习一下常用的排序算法\n2. 继续学习安卓群英传","source":"_posts/2018第一周工作小结.md","raw":"---\ntitle: 2018第一周工作小结\ndate: 2018-01-05 22:18:49\ntags: 工作小结\n---\n这一周由于元旦的关系，只上了四天班。2017上半年的时候在传音工作，那时候每天都要写日报，然后周五要写周报，当时写的实在是痛苦，结果来崇杏之后，一天日报都没有写过。\n\n刚开始的确很爽，可是年底总结的时候发现写不出什么来了，对于半年多的工作只有一个浅薄的印象，大致知道做了哪些项目，可是项目相关都有些模糊了。因此重拾写周报的习惯，希望今年能够有一些改变。\n\n这周由于spirtMonitor项目需要重新制作ui，前几天陈哥还没有做完效果，因此先将之前做的肺科医院订餐管理后台先进行微信登陆的集成。\n\n微信的集成刚开始准备我这边获取相关的token，然后直接与服务器对接。但是当我获取了openid之后，后端说微信开放平台的openid与公众平台的openid不同，只可以使用unionid来对接。同时还有个问题，就是我这边无法直接使用获取的unionid来进行对接，不可以把appid和secretid放在app里面，防止别人抓包。\n\n因此需要重新设置一个模式，使用appid加微信登陆获取的一次性code，将code传回服务器，在服务器里面进行处理，之后返回一个处理完毕的token，我在app这边做一个持久化，这个token有效期三天，我根据token是否过期进行重新获取code，重复之上的行为即可。因此等待张凯把后端处理完我才可以进行之后的行动。\n\n关于token，我和张凯交流的时候有个设想，我这边将code，使用query的方式添加到url的末尾，然后使用浏览器传出去，之后浏览器走之前微信公众号的那个端口，走完之后浏览器返回值，然后浏览器吊起我的程序。这个方法感觉是可行的，但是当时考虑到跨域的问题没有实现。\n\n晚上关于这个问题搜索了一下，主要针对是如何使用webview来吊起activity。\n\n结果显示，的确如果直接发intent吊起webview会出现跨域的问题，但是可以本地写一个html页面来解决跨域的问题。\n\n[使用webview吊起activity](http://www.cnblogs.com/yejiurui/p/3413796.html)\n\n这样给我一个想法。由于安卓跨域保护的问题，很多和浏览器协作的方面，比如说之前做的，hybirdapp调用本地视频的功能，可以截取webview的url，然后吊起本地的html来加载视频。不过这个方式对于那种内嵌的视频可能不好用，内嵌的视频还是需要使用webserver来进行视频的提供。但是也是一种思路。\n\n明天做一下相关的demo。\n\n微信集成搞了2天，之后陈总那边的ui好了，因此需要重新更改ui。\n\n之前使用animation的方式，对textview进行动画的设置，这样会在更新的时候触发动画，但是动画的效果不是很好看，之后恰好看到了一个app，使用的是每次更新的时候数字从小到大的方式。刚好找到了一个库，单纯的一个自定义view，直接继承了textview，使用的一个valueAmatior动画，这个动画里面添加了一个animationListener，在这个监听器里面进行了textview的设值。值的范围从设置的开端到末端。这个设置的动画和我之前设置的对比就完全不同了，感觉十分好。\n\n周四周五大概就做了这几件事。晚上回来的路上，在想关于借口查询的问题，我之前使用的是定时去查询接口的方式，但是之前了解了一个关于http长连接的方式，实时聊天软件就是使用的长连接的效果，这方面也需要了解一下。\n\n因此本周的收获如下：\n1. 了解了如何使用valueAmator来进行动画的更新。\n2. 了解了如何集成微信\n\n遗留未解决的问题如下：\n1. 使用本地静态html来进行get操作，对返回值过滤来吊起app并且获取返回值\n2. 学习使用长链接的方式来进行接口的查询\n\n周末的任务：\n1. 解决遗留问题\n2. 处理一下williamchart的ui更改\n3. 研究一下安卓的渐变色，圆心渐变和直线渐变\n\n有时间的话：\n1. 学习一下常用的排序算法\n2. 继续学习安卓群英传","slug":"2018第一周工作小结","published":1,"updated":"2019-03-12T09:26:33.138Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttwl00063a8ksss0i4cu","content":"<p>这一周由于元旦的关系，只上了四天班。2017上半年的时候在传音工作，那时候每天都要写日报，然后周五要写周报，当时写的实在是痛苦，结果来崇杏之后，一天日报都没有写过。</p>\n<p>刚开始的确很爽，可是年底总结的时候发现写不出什么来了，对于半年多的工作只有一个浅薄的印象，大致知道做了哪些项目，可是项目相关都有些模糊了。因此重拾写周报的习惯，希望今年能够有一些改变。</p>\n<p>这周由于spirtMonitor项目需要重新制作ui，前几天陈哥还没有做完效果，因此先将之前做的肺科医院订餐管理后台先进行微信登陆的集成。</p>\n<p>微信的集成刚开始准备我这边获取相关的token，然后直接与服务器对接。但是当我获取了openid之后，后端说微信开放平台的openid与公众平台的openid不同，只可以使用unionid来对接。同时还有个问题，就是我这边无法直接使用获取的unionid来进行对接，不可以把appid和secretid放在app里面，防止别人抓包。</p>\n<p>因此需要重新设置一个模式，使用appid加微信登陆获取的一次性code，将code传回服务器，在服务器里面进行处理，之后返回一个处理完毕的token，我在app这边做一个持久化，这个token有效期三天，我根据token是否过期进行重新获取code，重复之上的行为即可。因此等待张凯把后端处理完我才可以进行之后的行动。</p>\n<p>关于token，我和张凯交流的时候有个设想，我这边将code，使用query的方式添加到url的末尾，然后使用浏览器传出去，之后浏览器走之前微信公众号的那个端口，走完之后浏览器返回值，然后浏览器吊起我的程序。这个方法感觉是可行的，但是当时考虑到跨域的问题没有实现。</p>\n<p>晚上关于这个问题搜索了一下，主要针对是如何使用webview来吊起activity。</p>\n<p>结果显示，的确如果直接发intent吊起webview会出现跨域的问题，但是可以本地写一个html页面来解决跨域的问题。</p>\n<p><a href=\"http://www.cnblogs.com/yejiurui/p/3413796.html\" target=\"_blank\" rel=\"noopener\">使用webview吊起activity</a></p>\n<p>这样给我一个想法。由于安卓跨域保护的问题，很多和浏览器协作的方面，比如说之前做的，hybirdapp调用本地视频的功能，可以截取webview的url，然后吊起本地的html来加载视频。不过这个方式对于那种内嵌的视频可能不好用，内嵌的视频还是需要使用webserver来进行视频的提供。但是也是一种思路。</p>\n<p>明天做一下相关的demo。</p>\n<p>微信集成搞了2天，之后陈总那边的ui好了，因此需要重新更改ui。</p>\n<p>之前使用animation的方式，对textview进行动画的设置，这样会在更新的时候触发动画，但是动画的效果不是很好看，之后恰好看到了一个app，使用的是每次更新的时候数字从小到大的方式。刚好找到了一个库，单纯的一个自定义view，直接继承了textview，使用的一个valueAmatior动画，这个动画里面添加了一个animationListener，在这个监听器里面进行了textview的设值。值的范围从设置的开端到末端。这个设置的动画和我之前设置的对比就完全不同了，感觉十分好。</p>\n<p>周四周五大概就做了这几件事。晚上回来的路上，在想关于借口查询的问题，我之前使用的是定时去查询接口的方式，但是之前了解了一个关于http长连接的方式，实时聊天软件就是使用的长连接的效果，这方面也需要了解一下。</p>\n<p>因此本周的收获如下：</p>\n<ol>\n<li>了解了如何使用valueAmator来进行动画的更新。</li>\n<li>了解了如何集成微信</li>\n</ol>\n<p>遗留未解决的问题如下：</p>\n<ol>\n<li>使用本地静态html来进行get操作，对返回值过滤来吊起app并且获取返回值</li>\n<li>学习使用长链接的方式来进行接口的查询</li>\n</ol>\n<p>周末的任务：</p>\n<ol>\n<li>解决遗留问题</li>\n<li>处理一下williamchart的ui更改</li>\n<li>研究一下安卓的渐变色，圆心渐变和直线渐变</li>\n</ol>\n<p>有时间的话：</p>\n<ol>\n<li>学习一下常用的排序算法</li>\n<li>继续学习安卓群英传</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>这一周由于元旦的关系，只上了四天班。2017上半年的时候在传音工作，那时候每天都要写日报，然后周五要写周报，当时写的实在是痛苦，结果来崇杏之后，一天日报都没有写过。</p>\n<p>刚开始的确很爽，可是年底总结的时候发现写不出什么来了，对于半年多的工作只有一个浅薄的印象，大致知道做了哪些项目，可是项目相关都有些模糊了。因此重拾写周报的习惯，希望今年能够有一些改变。</p>\n<p>这周由于spirtMonitor项目需要重新制作ui，前几天陈哥还没有做完效果，因此先将之前做的肺科医院订餐管理后台先进行微信登陆的集成。</p>\n<p>微信的集成刚开始准备我这边获取相关的token，然后直接与服务器对接。但是当我获取了openid之后，后端说微信开放平台的openid与公众平台的openid不同，只可以使用unionid来对接。同时还有个问题，就是我这边无法直接使用获取的unionid来进行对接，不可以把appid和secretid放在app里面，防止别人抓包。</p>\n<p>因此需要重新设置一个模式，使用appid加微信登陆获取的一次性code，将code传回服务器，在服务器里面进行处理，之后返回一个处理完毕的token，我在app这边做一个持久化，这个token有效期三天，我根据token是否过期进行重新获取code，重复之上的行为即可。因此等待张凯把后端处理完我才可以进行之后的行动。</p>\n<p>关于token，我和张凯交流的时候有个设想，我这边将code，使用query的方式添加到url的末尾，然后使用浏览器传出去，之后浏览器走之前微信公众号的那个端口，走完之后浏览器返回值，然后浏览器吊起我的程序。这个方法感觉是可行的，但是当时考虑到跨域的问题没有实现。</p>\n<p>晚上关于这个问题搜索了一下，主要针对是如何使用webview来吊起activity。</p>\n<p>结果显示，的确如果直接发intent吊起webview会出现跨域的问题，但是可以本地写一个html页面来解决跨域的问题。</p>\n<p><a href=\"http://www.cnblogs.com/yejiurui/p/3413796.html\" target=\"_blank\" rel=\"noopener\">使用webview吊起activity</a></p>\n<p>这样给我一个想法。由于安卓跨域保护的问题，很多和浏览器协作的方面，比如说之前做的，hybirdapp调用本地视频的功能，可以截取webview的url，然后吊起本地的html来加载视频。不过这个方式对于那种内嵌的视频可能不好用，内嵌的视频还是需要使用webserver来进行视频的提供。但是也是一种思路。</p>\n<p>明天做一下相关的demo。</p>\n<p>微信集成搞了2天，之后陈总那边的ui好了，因此需要重新更改ui。</p>\n<p>之前使用animation的方式，对textview进行动画的设置，这样会在更新的时候触发动画，但是动画的效果不是很好看，之后恰好看到了一个app，使用的是每次更新的时候数字从小到大的方式。刚好找到了一个库，单纯的一个自定义view，直接继承了textview，使用的一个valueAmatior动画，这个动画里面添加了一个animationListener，在这个监听器里面进行了textview的设值。值的范围从设置的开端到末端。这个设置的动画和我之前设置的对比就完全不同了，感觉十分好。</p>\n<p>周四周五大概就做了这几件事。晚上回来的路上，在想关于借口查询的问题，我之前使用的是定时去查询接口的方式，但是之前了解了一个关于http长连接的方式，实时聊天软件就是使用的长连接的效果，这方面也需要了解一下。</p>\n<p>因此本周的收获如下：</p>\n<ol>\n<li>了解了如何使用valueAmator来进行动画的更新。</li>\n<li>了解了如何集成微信</li>\n</ol>\n<p>遗留未解决的问题如下：</p>\n<ol>\n<li>使用本地静态html来进行get操作，对返回值过滤来吊起app并且获取返回值</li>\n<li>学习使用长链接的方式来进行接口的查询</li>\n</ol>\n<p>周末的任务：</p>\n<ol>\n<li>解决遗留问题</li>\n<li>处理一下williamchart的ui更改</li>\n<li>研究一下安卓的渐变色，圆心渐变和直线渐变</li>\n</ol>\n<p>有时间的话：</p>\n<ol>\n<li>学习一下常用的排序算法</li>\n<li>继续学习安卓群英传</li>\n</ol>\n"},{"title":"2018第七周工作小结","date":"2018-02-13T15:16:05.000Z","_content":"\n这周除了学习还是学习，学习了测试规范和测试用例，美中不足的是用了很久但是没有什么效果。\n\n明天就放假了，需要安排一下新年的计划安排。\n简要地说就是为了开年做的准备。\n1. 完善简历知识点，对薄弱的地方进行强化。\n2. 写一个视频监控出来。\n\n大致就这两个，其实难度还蛮大的。时间安排明天车上的时候想。\n","source":"_posts/2018第七周工作小结.md","raw":"---\ntitle: 2018第七周工作小结\ndate: 2018-02-13 23:16:05\ntags: 工作小结\n---\n\n这周除了学习还是学习，学习了测试规范和测试用例，美中不足的是用了很久但是没有什么效果。\n\n明天就放假了，需要安排一下新年的计划安排。\n简要地说就是为了开年做的准备。\n1. 完善简历知识点，对薄弱的地方进行强化。\n2. 写一个视频监控出来。\n\n大致就这两个，其实难度还蛮大的。时间安排明天车上的时候想。\n","slug":"2018第七周工作小结","published":1,"updated":"2019-03-12T09:26:33.138Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttwn00093a8kat5f8ywe","content":"<p>这周除了学习还是学习，学习了测试规范和测试用例，美中不足的是用了很久但是没有什么效果。</p>\n<p>明天就放假了，需要安排一下新年的计划安排。<br>简要地说就是为了开年做的准备。</p>\n<ol>\n<li>完善简历知识点，对薄弱的地方进行强化。</li>\n<li>写一个视频监控出来。</li>\n</ol>\n<p>大致就这两个，其实难度还蛮大的。时间安排明天车上的时候想。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这周除了学习还是学习，学习了测试规范和测试用例，美中不足的是用了很久但是没有什么效果。</p>\n<p>明天就放假了，需要安排一下新年的计划安排。<br>简要地说就是为了开年做的准备。</p>\n<ol>\n<li>完善简历知识点，对薄弱的地方进行强化。</li>\n<li>写一个视频监控出来。</li>\n</ol>\n<p>大致就这两个，其实难度还蛮大的。时间安排明天车上的时候想。</p>\n"},{"title":"2018第三十七周工作小结","date":"2018-09-25T01:49:14.000Z","_content":"\n上周大概做了几件小事，一是完善了app的相关细节，二是修了很多medel的bug，三是发了个版。很惭愧。\n\n现在想来上周有两件事做的不好，一是读书，effective-java大概看了三次，但是一章都没看完。二是娱乐，赶上了中秋，却躺了三天。\n\n上周从网上打印了本csapp，这周开读吧。","source":"_posts/2018第三十七周工作小结.md","raw":"---\ntitle: 2018第三十七周工作小结\ndate: 2018-09-25 09:49:14\ntags: 工作小结\n---\n\n上周大概做了几件小事，一是完善了app的相关细节，二是修了很多medel的bug，三是发了个版。很惭愧。\n\n现在想来上周有两件事做的不好，一是读书，effective-java大概看了三次，但是一章都没看完。二是娱乐，赶上了中秋，却躺了三天。\n\n上周从网上打印了本csapp，这周开读吧。","slug":"2018第三十七周工作小结","published":1,"updated":"2019-03-12T09:26:33.138Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttwo000b3a8kd50sdsww","content":"<p>上周大概做了几件小事，一是完善了app的相关细节，二是修了很多medel的bug，三是发了个版。很惭愧。</p>\n<p>现在想来上周有两件事做的不好，一是读书，effective-java大概看了三次，但是一章都没看完。二是娱乐，赶上了中秋，却躺了三天。</p>\n<p>上周从网上打印了本csapp，这周开读吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>上周大概做了几件小事，一是完善了app的相关细节，二是修了很多medel的bug，三是发了个版。很惭愧。</p>\n<p>现在想来上周有两件事做的不好，一是读书，effective-java大概看了三次，但是一章都没看完。二是娱乐，赶上了中秋，却躺了三天。</p>\n<p>上周从网上打印了本csapp，这周开读吧。</p>\n"},{"title":"2018第三十六周工作小结","date":"2018-09-16T14:51:04.000Z","_content":"\n本周主要任务是2.2.1的迭代计划，自从2.2.0发版以后，小程序端，ios端的进度都大大落后于android。我们也进入了喜闻乐见的等进度阶段。\n\n本周个人主要负责商品详情页面的优化。这次主要是借鉴淘宝的布局，做了较大量的优化。\n\n优化方面一是接口部分的抽离，将逻辑部分放在p层，视图放在v层，隔离开来，逻辑因此较为清晰，对比前人的过程式编程，感觉光编译器编译都快了很多。\n\n优化第二方面是布局的优化，还是老样子，一层constaintlayout解决问题。从爆红的过度绘制一下子变成了淡绿，打开页面的速度也快了很多。\n\n优化第三方面是父类的精简，经过仔细排查，最终抽丝剥茧下来了一个比较简单的activitybase，上层是rxactivity，在上层就是appcompatactivity。对比之前的fragmeng->appbasefragment->basefragment->rxbasefragment,以及对应的activity，光这一方面就精简了8层。打开速度快也不是没有原因的。\n\n优化第四方面是接口的生命周期绑定，之前只是在ondestroy中集中处理了接口，但是大部分的跳转，切换，接口并未做处理，这样在接口请求时切换了，就造成了泄漏。这次直接统一compose到了rxlifecycle中，连destroy中都不需要处理。\n\n不过这次让做一个属性动画，加入购物车的时候进行弹跳的一个动画布局，我搞了2天，原本准备搞个抛物线结束，结果三点计算抛物线公式忘了，自己推了2个小时，还推了个错的，debug了半天才发现。之后和ios商量，他们说应该用贝塞尔曲线，我又去翻以前的贝塞尔曲线的笔记，结果公式是以前就总结好的，但是好像是错的，怎么画都不对头。网上找了一圈还是没找到相关的对的例子。明天上班的时候去和ios的讨论讨论。\n\n以上为本周的工作内容。\n\n最近沉迷dnf无法自拔，结果今天给封号了一天，日。","source":"_posts/2018第三十六周工作小结.md","raw":"---\ntitle: 2018第三十六周工作小结\ndate: 2018-09-16 22:51:04\ntags: 工作小结\n---\n\n本周主要任务是2.2.1的迭代计划，自从2.2.0发版以后，小程序端，ios端的进度都大大落后于android。我们也进入了喜闻乐见的等进度阶段。\n\n本周个人主要负责商品详情页面的优化。这次主要是借鉴淘宝的布局，做了较大量的优化。\n\n优化方面一是接口部分的抽离，将逻辑部分放在p层，视图放在v层，隔离开来，逻辑因此较为清晰，对比前人的过程式编程，感觉光编译器编译都快了很多。\n\n优化第二方面是布局的优化，还是老样子，一层constaintlayout解决问题。从爆红的过度绘制一下子变成了淡绿，打开页面的速度也快了很多。\n\n优化第三方面是父类的精简，经过仔细排查，最终抽丝剥茧下来了一个比较简单的activitybase，上层是rxactivity，在上层就是appcompatactivity。对比之前的fragmeng->appbasefragment->basefragment->rxbasefragment,以及对应的activity，光这一方面就精简了8层。打开速度快也不是没有原因的。\n\n优化第四方面是接口的生命周期绑定，之前只是在ondestroy中集中处理了接口，但是大部分的跳转，切换，接口并未做处理，这样在接口请求时切换了，就造成了泄漏。这次直接统一compose到了rxlifecycle中，连destroy中都不需要处理。\n\n不过这次让做一个属性动画，加入购物车的时候进行弹跳的一个动画布局，我搞了2天，原本准备搞个抛物线结束，结果三点计算抛物线公式忘了，自己推了2个小时，还推了个错的，debug了半天才发现。之后和ios商量，他们说应该用贝塞尔曲线，我又去翻以前的贝塞尔曲线的笔记，结果公式是以前就总结好的，但是好像是错的，怎么画都不对头。网上找了一圈还是没找到相关的对的例子。明天上班的时候去和ios的讨论讨论。\n\n以上为本周的工作内容。\n\n最近沉迷dnf无法自拔，结果今天给封号了一天，日。","slug":"2018第三十六周工作小结","published":1,"updated":"2019-03-12T09:26:33.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttwq000e3a8k9krefnrp","content":"<p>本周主要任务是2.2.1的迭代计划，自从2.2.0发版以后，小程序端，ios端的进度都大大落后于android。我们也进入了喜闻乐见的等进度阶段。</p>\n<p>本周个人主要负责商品详情页面的优化。这次主要是借鉴淘宝的布局，做了较大量的优化。</p>\n<p>优化方面一是接口部分的抽离，将逻辑部分放在p层，视图放在v层，隔离开来，逻辑因此较为清晰，对比前人的过程式编程，感觉光编译器编译都快了很多。</p>\n<p>优化第二方面是布局的优化，还是老样子，一层constaintlayout解决问题。从爆红的过度绘制一下子变成了淡绿，打开页面的速度也快了很多。</p>\n<p>优化第三方面是父类的精简，经过仔细排查，最终抽丝剥茧下来了一个比较简单的activitybase，上层是rxactivity，在上层就是appcompatactivity。对比之前的fragmeng-&gt;appbasefragment-&gt;basefragment-&gt;rxbasefragment,以及对应的activity，光这一方面就精简了8层。打开速度快也不是没有原因的。</p>\n<p>优化第四方面是接口的生命周期绑定，之前只是在ondestroy中集中处理了接口，但是大部分的跳转，切换，接口并未做处理，这样在接口请求时切换了，就造成了泄漏。这次直接统一compose到了rxlifecycle中，连destroy中都不需要处理。</p>\n<p>不过这次让做一个属性动画，加入购物车的时候进行弹跳的一个动画布局，我搞了2天，原本准备搞个抛物线结束，结果三点计算抛物线公式忘了，自己推了2个小时，还推了个错的，debug了半天才发现。之后和ios商量，他们说应该用贝塞尔曲线，我又去翻以前的贝塞尔曲线的笔记，结果公式是以前就总结好的，但是好像是错的，怎么画都不对头。网上找了一圈还是没找到相关的对的例子。明天上班的时候去和ios的讨论讨论。</p>\n<p>以上为本周的工作内容。</p>\n<p>最近沉迷dnf无法自拔，结果今天给封号了一天，日。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本周主要任务是2.2.1的迭代计划，自从2.2.0发版以后，小程序端，ios端的进度都大大落后于android。我们也进入了喜闻乐见的等进度阶段。</p>\n<p>本周个人主要负责商品详情页面的优化。这次主要是借鉴淘宝的布局，做了较大量的优化。</p>\n<p>优化方面一是接口部分的抽离，将逻辑部分放在p层，视图放在v层，隔离开来，逻辑因此较为清晰，对比前人的过程式编程，感觉光编译器编译都快了很多。</p>\n<p>优化第二方面是布局的优化，还是老样子，一层constaintlayout解决问题。从爆红的过度绘制一下子变成了淡绿，打开页面的速度也快了很多。</p>\n<p>优化第三方面是父类的精简，经过仔细排查，最终抽丝剥茧下来了一个比较简单的activitybase，上层是rxactivity，在上层就是appcompatactivity。对比之前的fragmeng-&gt;appbasefragment-&gt;basefragment-&gt;rxbasefragment,以及对应的activity，光这一方面就精简了8层。打开速度快也不是没有原因的。</p>\n<p>优化第四方面是接口的生命周期绑定，之前只是在ondestroy中集中处理了接口，但是大部分的跳转，切换，接口并未做处理，这样在接口请求时切换了，就造成了泄漏。这次直接统一compose到了rxlifecycle中，连destroy中都不需要处理。</p>\n<p>不过这次让做一个属性动画，加入购物车的时候进行弹跳的一个动画布局，我搞了2天，原本准备搞个抛物线结束，结果三点计算抛物线公式忘了，自己推了2个小时，还推了个错的，debug了半天才发现。之后和ios商量，他们说应该用贝塞尔曲线，我又去翻以前的贝塞尔曲线的笔记，结果公式是以前就总结好的，但是好像是错的，怎么画都不对头。网上找了一圈还是没找到相关的对的例子。明天上班的时候去和ios的讨论讨论。</p>\n<p>以上为本周的工作内容。</p>\n<p>最近沉迷dnf无法自拔，结果今天给封号了一天，日。</p>\n"},{"title":"2018第三十周工作小结","date":"2018-08-01T02:12:30.000Z","_content":"\n因为人手不够的关系，这两周被抽调搞自动化编译渠道包的脚本制作中。\n\n自动化编译之前使用的是美团的方法，通过解压压缩包然后写到META-INF中，然后再app启动的时候解压文件，读取meta-inf，然后写到app的渠道中。\n\n但是这次做的是通过gradle的productFlavors进行变体构建，在编译时直接使用写好的falvors来进行编译。\n\n老方法的好处是编译快，但是打开app的过程中需要进行解压的操作，解压其实是一个比较耗时的过程，因此会降低app的启动时间。\n\n现在的方法是为了减少启动时间，但是大大增加了编译的时间，编译时间由原来的10分钟，暴涨到40-50分钟。\n\n不过好处是更换之后的启动速度有了良好的降低。\n\n言归正传\n\n这次脚本的写法，主要是在执行gradlew xxxRelease之前和之后的一些操作。\n\n之前：选定分支，从分支上面来拉最新的代码，之后修改version code，自动增1，然后将代码提交到服务器。\n\n中间：执行gradlew xxxrelease命令\n\n之后：编译完成之后，依次将文件从build目录中重命名并且移出build文件夹，放入上传文件夹，之后将mapping文件也放入上传文件夹。全部结束之后上传至ftp。\n","source":"_posts/2018第三十周工作小结.md","raw":"---\ntitle: 2018第三十周工作小结\ndate: 2018-08-01 10:12:30\ntags: 工作小结\n---\n\n因为人手不够的关系，这两周被抽调搞自动化编译渠道包的脚本制作中。\n\n自动化编译之前使用的是美团的方法，通过解压压缩包然后写到META-INF中，然后再app启动的时候解压文件，读取meta-inf，然后写到app的渠道中。\n\n但是这次做的是通过gradle的productFlavors进行变体构建，在编译时直接使用写好的falvors来进行编译。\n\n老方法的好处是编译快，但是打开app的过程中需要进行解压的操作，解压其实是一个比较耗时的过程，因此会降低app的启动时间。\n\n现在的方法是为了减少启动时间，但是大大增加了编译的时间，编译时间由原来的10分钟，暴涨到40-50分钟。\n\n不过好处是更换之后的启动速度有了良好的降低。\n\n言归正传\n\n这次脚本的写法，主要是在执行gradlew xxxRelease之前和之后的一些操作。\n\n之前：选定分支，从分支上面来拉最新的代码，之后修改version code，自动增1，然后将代码提交到服务器。\n\n中间：执行gradlew xxxrelease命令\n\n之后：编译完成之后，依次将文件从build目录中重命名并且移出build文件夹，放入上传文件夹，之后将mapping文件也放入上传文件夹。全部结束之后上传至ftp。\n","slug":"2018第三十周工作小结","published":1,"updated":"2019-03-12T09:26:33.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttwr000g3a8ka9rhxovg","content":"<p>因为人手不够的关系，这两周被抽调搞自动化编译渠道包的脚本制作中。</p>\n<p>自动化编译之前使用的是美团的方法，通过解压压缩包然后写到META-INF中，然后再app启动的时候解压文件，读取meta-inf，然后写到app的渠道中。</p>\n<p>但是这次做的是通过gradle的productFlavors进行变体构建，在编译时直接使用写好的falvors来进行编译。</p>\n<p>老方法的好处是编译快，但是打开app的过程中需要进行解压的操作，解压其实是一个比较耗时的过程，因此会降低app的启动时间。</p>\n<p>现在的方法是为了减少启动时间，但是大大增加了编译的时间，编译时间由原来的10分钟，暴涨到40-50分钟。</p>\n<p>不过好处是更换之后的启动速度有了良好的降低。</p>\n<p>言归正传</p>\n<p>这次脚本的写法，主要是在执行gradlew xxxRelease之前和之后的一些操作。</p>\n<p>之前：选定分支，从分支上面来拉最新的代码，之后修改version code，自动增1，然后将代码提交到服务器。</p>\n<p>中间：执行gradlew xxxrelease命令</p>\n<p>之后：编译完成之后，依次将文件从build目录中重命名并且移出build文件夹，放入上传文件夹，之后将mapping文件也放入上传文件夹。全部结束之后上传至ftp。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>因为人手不够的关系，这两周被抽调搞自动化编译渠道包的脚本制作中。</p>\n<p>自动化编译之前使用的是美团的方法，通过解压压缩包然后写到META-INF中，然后再app启动的时候解压文件，读取meta-inf，然后写到app的渠道中。</p>\n<p>但是这次做的是通过gradle的productFlavors进行变体构建，在编译时直接使用写好的falvors来进行编译。</p>\n<p>老方法的好处是编译快，但是打开app的过程中需要进行解压的操作，解压其实是一个比较耗时的过程，因此会降低app的启动时间。</p>\n<p>现在的方法是为了减少启动时间，但是大大增加了编译的时间，编译时间由原来的10分钟，暴涨到40-50分钟。</p>\n<p>不过好处是更换之后的启动速度有了良好的降低。</p>\n<p>言归正传</p>\n<p>这次脚本的写法，主要是在执行gradlew xxxRelease之前和之后的一些操作。</p>\n<p>之前：选定分支，从分支上面来拉最新的代码，之后修改version code，自动增1，然后将代码提交到服务器。</p>\n<p>中间：执行gradlew xxxrelease命令</p>\n<p>之后：编译完成之后，依次将文件从build目录中重命名并且移出build文件夹，放入上传文件夹，之后将mapping文件也放入上传文件夹。全部结束之后上传至ftp。</p>\n"},{"title":"2018第三周工作小结","date":"2018-01-21T13:20:48.000Z","_content":"\n首先总结一下上周工作计划。\n上周主要任务是进行图表的优化，添加了点击事件，处理好了相互通信的卡顿问题。\n收获了几个重要的知识点。对于我这种喜欢使用dataservice来进行数据获取的，需要养成一个习惯就是直接在dataservice里面直接将数据处理成合适的最简洁的数据，用来进行传递。否则使用eventbus会传递速度过于慢。\n另外就是关于处理点击事件和处理更改产生的bug，不算很大的问题。\n周四任务完成了，但是又加了一个任务，要把多阶贝塞尔曲线融进来。贝塞尔曲线找了个demo，但是多阶的还是不怎么会，周四感冒，周五工作效率接近于0.\n\n之后还是订一下下周的工作计划安排。\n1. 处理完毕多阶贝塞尔算法\n2. 订餐管理微信登陆token回调设置完成。\n\n手上的任务就这几个了。预定周4完成，除此之外需要每天都继续学习群英传。","source":"_posts/2018第三周工作小结.md","raw":"---\ntitle: 2018第三周工作小结\ndate: 2018-01-21 21:20:48\ntags: 工作小结\n---\n\n首先总结一下上周工作计划。\n上周主要任务是进行图表的优化，添加了点击事件，处理好了相互通信的卡顿问题。\n收获了几个重要的知识点。对于我这种喜欢使用dataservice来进行数据获取的，需要养成一个习惯就是直接在dataservice里面直接将数据处理成合适的最简洁的数据，用来进行传递。否则使用eventbus会传递速度过于慢。\n另外就是关于处理点击事件和处理更改产生的bug，不算很大的问题。\n周四任务完成了，但是又加了一个任务，要把多阶贝塞尔曲线融进来。贝塞尔曲线找了个demo，但是多阶的还是不怎么会，周四感冒，周五工作效率接近于0.\n\n之后还是订一下下周的工作计划安排。\n1. 处理完毕多阶贝塞尔算法\n2. 订餐管理微信登陆token回调设置完成。\n\n手上的任务就这几个了。预定周4完成，除此之外需要每天都继续学习群英传。","slug":"2018第三周工作小结","published":1,"updated":"2019-03-12T09:26:33.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttwt000i3a8k970ec0ck","content":"<p>首先总结一下上周工作计划。<br>上周主要任务是进行图表的优化，添加了点击事件，处理好了相互通信的卡顿问题。<br>收获了几个重要的知识点。对于我这种喜欢使用dataservice来进行数据获取的，需要养成一个习惯就是直接在dataservice里面直接将数据处理成合适的最简洁的数据，用来进行传递。否则使用eventbus会传递速度过于慢。<br>另外就是关于处理点击事件和处理更改产生的bug，不算很大的问题。<br>周四任务完成了，但是又加了一个任务，要把多阶贝塞尔曲线融进来。贝塞尔曲线找了个demo，但是多阶的还是不怎么会，周四感冒，周五工作效率接近于0.</p>\n<p>之后还是订一下下周的工作计划安排。</p>\n<ol>\n<li>处理完毕多阶贝塞尔算法</li>\n<li>订餐管理微信登陆token回调设置完成。</li>\n</ol>\n<p>手上的任务就这几个了。预定周4完成，除此之外需要每天都继续学习群英传。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>首先总结一下上周工作计划。<br>上周主要任务是进行图表的优化，添加了点击事件，处理好了相互通信的卡顿问题。<br>收获了几个重要的知识点。对于我这种喜欢使用dataservice来进行数据获取的，需要养成一个习惯就是直接在dataservice里面直接将数据处理成合适的最简洁的数据，用来进行传递。否则使用eventbus会传递速度过于慢。<br>另外就是关于处理点击事件和处理更改产生的bug，不算很大的问题。<br>周四任务完成了，但是又加了一个任务，要把多阶贝塞尔曲线融进来。贝塞尔曲线找了个demo，但是多阶的还是不怎么会，周四感冒，周五工作效率接近于0.</p>\n<p>之后还是订一下下周的工作计划安排。</p>\n<ol>\n<li>处理完毕多阶贝塞尔算法</li>\n<li>订餐管理微信登陆token回调设置完成。</li>\n</ol>\n<p>手上的任务就这几个了。预定周4完成，除此之外需要每天都继续学习群英传。</p>\n"},{"title":"2018第三季度复盘（第40周）","date":"2018-10-10T13:04:59.000Z","_content":"\n十一国庆过去了，回首一年过去3/4了，有必要做一个复盘操作了。\n\n- 项目\n\n过去的这些时间里面，绝大多数时间在项目中度过。\n刚开始独自一个人完成了软件从1.9.3到2.0.1一个大版本一个小版本的升级，之后进奎来了，两个人协助做了2.0.1到2.0.6版本的升级，然后又加了苏展，三个人从2.0.6升到了现在的2.3.0。\n\n细数了一下，在好搭的7个月里面，完成了11个版本。\n\n版本升级其实很耗费精力，尤其是换了3个产品，3个ui，设计风格都推翻重来了几次，更是极度累的。\n\n刚开始我以为我不会撑到试用期结束，后来我以为我不会撑过半年，结果也都撑过来了。长叹一声。\n\n项目的细节基本上都总结在工作小结里面了，所以略过不表。\n\n- 读书\n\n开年计划，准备读够10本书，并以此列了一些书单，但是后期项目忙了，大部分都鸽了，目前读了《Android群英传》、《javascript dom编程艺术》和《博弈论》，但是只能说读过。\n目前在读的《effective-java》算是做了一些笔记，不过才读到第六章，还有四章，估计月内能读完吧。\n之后需要读的就是《http权威指南》，说来发笑，做移动端的居然没读过这个，这个是决定月内要开读的。\n另外上次写的《csapp》这本书，仔细看看，实在是太过底层。底层打基础虽好，但是对目前这个阶段是没有什么意义的。\n读书暂时不立宏愿了。\n\n- 减肥\n\n失败\n\n- 掌握新的语言\n\n失败，俄语只能喊ypa\n\n- github每日更新\n\n失败，这个原因比较多，最大的原因是工作繁忙，另外染上了游戏的恶习，还好迷途知返。\n\n- 戒烟\n\n失败\n\n- 健身房一周去2-3次\n\n因为搬家健身房卡已经转让，不能说失败吧，至少当时是每周都去2-3次\n\n- 每日早饭必须要吃\n\n成功\n\n- 23:00前必须睡\n\n失败\n\n- 下一阶段计划\n\n此计划只适合个人\n\n1. 晚上只吃一碗饭\n2. github每日更新\n3. 制作自动化脚本，和建宇合作，看看能不能出售\n4. 没了\n\n此次计划比较简洁明了，可行性比较高。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2018第三季度复盘（第40周）.md","raw":"---\ntitle: 2018第三季度复盘（第40周）\ndate: 2018-10-10 21:04:59\ntags: 工作复盘\n---\n\n十一国庆过去了，回首一年过去3/4了，有必要做一个复盘操作了。\n\n- 项目\n\n过去的这些时间里面，绝大多数时间在项目中度过。\n刚开始独自一个人完成了软件从1.9.3到2.0.1一个大版本一个小版本的升级，之后进奎来了，两个人协助做了2.0.1到2.0.6版本的升级，然后又加了苏展，三个人从2.0.6升到了现在的2.3.0。\n\n细数了一下，在好搭的7个月里面，完成了11个版本。\n\n版本升级其实很耗费精力，尤其是换了3个产品，3个ui，设计风格都推翻重来了几次，更是极度累的。\n\n刚开始我以为我不会撑到试用期结束，后来我以为我不会撑过半年，结果也都撑过来了。长叹一声。\n\n项目的细节基本上都总结在工作小结里面了，所以略过不表。\n\n- 读书\n\n开年计划，准备读够10本书，并以此列了一些书单，但是后期项目忙了，大部分都鸽了，目前读了《Android群英传》、《javascript dom编程艺术》和《博弈论》，但是只能说读过。\n目前在读的《effective-java》算是做了一些笔记，不过才读到第六章，还有四章，估计月内能读完吧。\n之后需要读的就是《http权威指南》，说来发笑，做移动端的居然没读过这个，这个是决定月内要开读的。\n另外上次写的《csapp》这本书，仔细看看，实在是太过底层。底层打基础虽好，但是对目前这个阶段是没有什么意义的。\n读书暂时不立宏愿了。\n\n- 减肥\n\n失败\n\n- 掌握新的语言\n\n失败，俄语只能喊ypa\n\n- github每日更新\n\n失败，这个原因比较多，最大的原因是工作繁忙，另外染上了游戏的恶习，还好迷途知返。\n\n- 戒烟\n\n失败\n\n- 健身房一周去2-3次\n\n因为搬家健身房卡已经转让，不能说失败吧，至少当时是每周都去2-3次\n\n- 每日早饭必须要吃\n\n成功\n\n- 23:00前必须睡\n\n失败\n\n- 下一阶段计划\n\n此计划只适合个人\n\n1. 晚上只吃一碗饭\n2. github每日更新\n3. 制作自动化脚本，和建宇合作，看看能不能出售\n4. 没了\n\n此次计划比较简洁明了，可行性比较高。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2018第三季度复盘（第40周）","published":1,"updated":"2019-03-12T09:26:33.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttwv000k3a8koau588cc","content":"<p>十一国庆过去了，回首一年过去3/4了，有必要做一个复盘操作了。</p>\n<ul>\n<li>项目</li>\n</ul>\n<p>过去的这些时间里面，绝大多数时间在项目中度过。<br>刚开始独自一个人完成了软件从1.9.3到2.0.1一个大版本一个小版本的升级，之后进奎来了，两个人协助做了2.0.1到2.0.6版本的升级，然后又加了苏展，三个人从2.0.6升到了现在的2.3.0。</p>\n<p>细数了一下，在好搭的7个月里面，完成了11个版本。</p>\n<p>版本升级其实很耗费精力，尤其是换了3个产品，3个ui，设计风格都推翻重来了几次，更是极度累的。</p>\n<p>刚开始我以为我不会撑到试用期结束，后来我以为我不会撑过半年，结果也都撑过来了。长叹一声。</p>\n<p>项目的细节基本上都总结在工作小结里面了，所以略过不表。</p>\n<ul>\n<li>读书</li>\n</ul>\n<p>开年计划，准备读够10本书，并以此列了一些书单，但是后期项目忙了，大部分都鸽了，目前读了《Android群英传》、《javascript dom编程艺术》和《博弈论》，但是只能说读过。<br>目前在读的《effective-java》算是做了一些笔记，不过才读到第六章，还有四章，估计月内能读完吧。<br>之后需要读的就是《http权威指南》，说来发笑，做移动端的居然没读过这个，这个是决定月内要开读的。<br>另外上次写的《csapp》这本书，仔细看看，实在是太过底层。底层打基础虽好，但是对目前这个阶段是没有什么意义的。<br>读书暂时不立宏愿了。</p>\n<ul>\n<li>减肥</li>\n</ul>\n<p>失败</p>\n<ul>\n<li>掌握新的语言</li>\n</ul>\n<p>失败，俄语只能喊ypa</p>\n<ul>\n<li>github每日更新</li>\n</ul>\n<p>失败，这个原因比较多，最大的原因是工作繁忙，另外染上了游戏的恶习，还好迷途知返。</p>\n<ul>\n<li>戒烟</li>\n</ul>\n<p>失败</p>\n<ul>\n<li>健身房一周去2-3次</li>\n</ul>\n<p>因为搬家健身房卡已经转让，不能说失败吧，至少当时是每周都去2-3次</p>\n<ul>\n<li>每日早饭必须要吃</li>\n</ul>\n<p>成功</p>\n<ul>\n<li>23:00前必须睡</li>\n</ul>\n<p>失败</p>\n<ul>\n<li>下一阶段计划</li>\n</ul>\n<p>此计划只适合个人</p>\n<ol>\n<li>晚上只吃一碗饭</li>\n<li>github每日更新</li>\n<li>制作自动化脚本，和建宇合作，看看能不能出售</li>\n<li>没了</li>\n</ol>\n<p>此次计划比较简洁明了，可行性比较高。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>十一国庆过去了，回首一年过去3/4了，有必要做一个复盘操作了。</p>\n<ul>\n<li>项目</li>\n</ul>\n<p>过去的这些时间里面，绝大多数时间在项目中度过。<br>刚开始独自一个人完成了软件从1.9.3到2.0.1一个大版本一个小版本的升级，之后进奎来了，两个人协助做了2.0.1到2.0.6版本的升级，然后又加了苏展，三个人从2.0.6升到了现在的2.3.0。</p>\n<p>细数了一下，在好搭的7个月里面，完成了11个版本。</p>\n<p>版本升级其实很耗费精力，尤其是换了3个产品，3个ui，设计风格都推翻重来了几次，更是极度累的。</p>\n<p>刚开始我以为我不会撑到试用期结束，后来我以为我不会撑过半年，结果也都撑过来了。长叹一声。</p>\n<p>项目的细节基本上都总结在工作小结里面了，所以略过不表。</p>\n<ul>\n<li>读书</li>\n</ul>\n<p>开年计划，准备读够10本书，并以此列了一些书单，但是后期项目忙了，大部分都鸽了，目前读了《Android群英传》、《javascript dom编程艺术》和《博弈论》，但是只能说读过。<br>目前在读的《effective-java》算是做了一些笔记，不过才读到第六章，还有四章，估计月内能读完吧。<br>之后需要读的就是《http权威指南》，说来发笑，做移动端的居然没读过这个，这个是决定月内要开读的。<br>另外上次写的《csapp》这本书，仔细看看，实在是太过底层。底层打基础虽好，但是对目前这个阶段是没有什么意义的。<br>读书暂时不立宏愿了。</p>\n<ul>\n<li>减肥</li>\n</ul>\n<p>失败</p>\n<ul>\n<li>掌握新的语言</li>\n</ul>\n<p>失败，俄语只能喊ypa</p>\n<ul>\n<li>github每日更新</li>\n</ul>\n<p>失败，这个原因比较多，最大的原因是工作繁忙，另外染上了游戏的恶习，还好迷途知返。</p>\n<ul>\n<li>戒烟</li>\n</ul>\n<p>失败</p>\n<ul>\n<li>健身房一周去2-3次</li>\n</ul>\n<p>因为搬家健身房卡已经转让，不能说失败吧，至少当时是每周都去2-3次</p>\n<ul>\n<li>每日早饭必须要吃</li>\n</ul>\n<p>成功</p>\n<ul>\n<li>23:00前必须睡</li>\n</ul>\n<p>失败</p>\n<ul>\n<li>下一阶段计划</li>\n</ul>\n<p>此计划只适合个人</p>\n<ol>\n<li>晚上只吃一碗饭</li>\n<li>github每日更新</li>\n<li>制作自动化脚本，和建宇合作，看看能不能出售</li>\n<li>没了</li>\n</ol>\n<p>此次计划比较简洁明了，可行性比较高。</p>\n"},{"title":"2018第九周工作小结","date":"2018-03-02T15:13:30.000Z","_content":"\n这周是在崇杏的最后一周。\n\n主要将之前维护的项目做了一个代码复盘，针对了一些自己认为重要的地方加了注释，同时写了流程图，方便后来人看吧。\n\n图表化软件出现一个问题，关于视觉化的。\n之前对于网络接口设计原则，都是一个请求拉下来所有的接口，但是这次由于接口数据过于庞大，如果通过rxjjava使用一个observable转换来拉，一是处理来不及，二是请求极其容易超时，毕竟observable是需要每个都发送的，相当于将所有的请求依次排序了。所以我使用的是多个observable来拉，多个observable又出现了一个问题，有些observable由于接口拉下来的数据量并不大，所以响应很快，而另一些observable则数据量过大，服务器没有缓存要进行计算，响应十分缓慢。导致了一个现象，一个是评论的总数，一个是评论的详情，评论的总数由于数据缓慢，获取到的速度就慢于评论的详情，导致了评论的总数这个数字的ui一下子进行了刷新，而评论详情却在之后才进行刷新，双方不同步。\n\n再加上我本就使用的是轮询而不是推送的方式，导致轮询无法等待，极端情况会出现评论数字刷了2次，而评论详情却还没有刷的状态，十分的糟糕。\n\n但是由于是服务器的原因导致的不同的接口加载的速度不一致，因此我也没有办法做过多的优化，只能做一个刷新时间的设置，让用户可操控多少秒刷新一次，这样可以保证在一次刷新周期内，两处ui可以同步。\n\n不过这终究不是一个好的解决方法。我想了一下，最好的方法是使用推送，服务器将同步的数据推送上来，我直接显示，这是最好的。其次是使用等待策略，当一个ui数据好了，另一个没有好的时候，让好了的等待没有好的，等没有好的好了则一起刷新，但是又个风险，就是没有好的超时了，这次等待就遥遥无期了。\n\n总而言之，在崇杏的最后一周，是在不断的修改之前的需求，核对数据中度过的。仔细想想，太多坑，假如设计原型明确的话，完全没必要趟的，哎，但是设计之间自己都不明确，最后填坑的还的是我。\n\nfarewall，崇杏。\n","source":"_posts/2018第九周工作小结.md","raw":"---\ntitle: 2018第九周工作小结\ndate: 2018-03-02 23:13:30\ntags: 工作小结\n---\n\n这周是在崇杏的最后一周。\n\n主要将之前维护的项目做了一个代码复盘，针对了一些自己认为重要的地方加了注释，同时写了流程图，方便后来人看吧。\n\n图表化软件出现一个问题，关于视觉化的。\n之前对于网络接口设计原则，都是一个请求拉下来所有的接口，但是这次由于接口数据过于庞大，如果通过rxjjava使用一个observable转换来拉，一是处理来不及，二是请求极其容易超时，毕竟observable是需要每个都发送的，相当于将所有的请求依次排序了。所以我使用的是多个observable来拉，多个observable又出现了一个问题，有些observable由于接口拉下来的数据量并不大，所以响应很快，而另一些observable则数据量过大，服务器没有缓存要进行计算，响应十分缓慢。导致了一个现象，一个是评论的总数，一个是评论的详情，评论的总数由于数据缓慢，获取到的速度就慢于评论的详情，导致了评论的总数这个数字的ui一下子进行了刷新，而评论详情却在之后才进行刷新，双方不同步。\n\n再加上我本就使用的是轮询而不是推送的方式，导致轮询无法等待，极端情况会出现评论数字刷了2次，而评论详情却还没有刷的状态，十分的糟糕。\n\n但是由于是服务器的原因导致的不同的接口加载的速度不一致，因此我也没有办法做过多的优化，只能做一个刷新时间的设置，让用户可操控多少秒刷新一次，这样可以保证在一次刷新周期内，两处ui可以同步。\n\n不过这终究不是一个好的解决方法。我想了一下，最好的方法是使用推送，服务器将同步的数据推送上来，我直接显示，这是最好的。其次是使用等待策略，当一个ui数据好了，另一个没有好的时候，让好了的等待没有好的，等没有好的好了则一起刷新，但是又个风险，就是没有好的超时了，这次等待就遥遥无期了。\n\n总而言之，在崇杏的最后一周，是在不断的修改之前的需求，核对数据中度过的。仔细想想，太多坑，假如设计原型明确的话，完全没必要趟的，哎，但是设计之间自己都不明确，最后填坑的还的是我。\n\nfarewall，崇杏。\n","slug":"2018第九周工作小结","published":1,"updated":"2019-03-12T09:26:33.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttww000m3a8kjc2n8yjf","content":"<p>这周是在崇杏的最后一周。</p>\n<p>主要将之前维护的项目做了一个代码复盘，针对了一些自己认为重要的地方加了注释，同时写了流程图，方便后来人看吧。</p>\n<p>图表化软件出现一个问题，关于视觉化的。<br>之前对于网络接口设计原则，都是一个请求拉下来所有的接口，但是这次由于接口数据过于庞大，如果通过rxjjava使用一个observable转换来拉，一是处理来不及，二是请求极其容易超时，毕竟observable是需要每个都发送的，相当于将所有的请求依次排序了。所以我使用的是多个observable来拉，多个observable又出现了一个问题，有些observable由于接口拉下来的数据量并不大，所以响应很快，而另一些observable则数据量过大，服务器没有缓存要进行计算，响应十分缓慢。导致了一个现象，一个是评论的总数，一个是评论的详情，评论的总数由于数据缓慢，获取到的速度就慢于评论的详情，导致了评论的总数这个数字的ui一下子进行了刷新，而评论详情却在之后才进行刷新，双方不同步。</p>\n<p>再加上我本就使用的是轮询而不是推送的方式，导致轮询无法等待，极端情况会出现评论数字刷了2次，而评论详情却还没有刷的状态，十分的糟糕。</p>\n<p>但是由于是服务器的原因导致的不同的接口加载的速度不一致，因此我也没有办法做过多的优化，只能做一个刷新时间的设置，让用户可操控多少秒刷新一次，这样可以保证在一次刷新周期内，两处ui可以同步。</p>\n<p>不过这终究不是一个好的解决方法。我想了一下，最好的方法是使用推送，服务器将同步的数据推送上来，我直接显示，这是最好的。其次是使用等待策略，当一个ui数据好了，另一个没有好的时候，让好了的等待没有好的，等没有好的好了则一起刷新，但是又个风险，就是没有好的超时了，这次等待就遥遥无期了。</p>\n<p>总而言之，在崇杏的最后一周，是在不断的修改之前的需求，核对数据中度过的。仔细想想，太多坑，假如设计原型明确的话，完全没必要趟的，哎，但是设计之间自己都不明确，最后填坑的还的是我。</p>\n<p>farewall，崇杏。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这周是在崇杏的最后一周。</p>\n<p>主要将之前维护的项目做了一个代码复盘，针对了一些自己认为重要的地方加了注释，同时写了流程图，方便后来人看吧。</p>\n<p>图表化软件出现一个问题，关于视觉化的。<br>之前对于网络接口设计原则，都是一个请求拉下来所有的接口，但是这次由于接口数据过于庞大，如果通过rxjjava使用一个observable转换来拉，一是处理来不及，二是请求极其容易超时，毕竟observable是需要每个都发送的，相当于将所有的请求依次排序了。所以我使用的是多个observable来拉，多个observable又出现了一个问题，有些observable由于接口拉下来的数据量并不大，所以响应很快，而另一些observable则数据量过大，服务器没有缓存要进行计算，响应十分缓慢。导致了一个现象，一个是评论的总数，一个是评论的详情，评论的总数由于数据缓慢，获取到的速度就慢于评论的详情，导致了评论的总数这个数字的ui一下子进行了刷新，而评论详情却在之后才进行刷新，双方不同步。</p>\n<p>再加上我本就使用的是轮询而不是推送的方式，导致轮询无法等待，极端情况会出现评论数字刷了2次，而评论详情却还没有刷的状态，十分的糟糕。</p>\n<p>但是由于是服务器的原因导致的不同的接口加载的速度不一致，因此我也没有办法做过多的优化，只能做一个刷新时间的设置，让用户可操控多少秒刷新一次，这样可以保证在一次刷新周期内，两处ui可以同步。</p>\n<p>不过这终究不是一个好的解决方法。我想了一下，最好的方法是使用推送，服务器将同步的数据推送上来，我直接显示，这是最好的。其次是使用等待策略，当一个ui数据好了，另一个没有好的时候，让好了的等待没有好的，等没有好的好了则一起刷新，但是又个风险，就是没有好的超时了，这次等待就遥遥无期了。</p>\n<p>总而言之，在崇杏的最后一周，是在不断的修改之前的需求，核对数据中度过的。仔细想想，太多坑，假如设计原型明确的话，完全没必要趟的，哎，但是设计之间自己都不明确，最后填坑的还的是我。</p>\n<p>farewall，崇杏。</p>\n"},{"title":"2018第二十一周工作小结","date":"2018-05-28T03:29:49.000Z","_content":"\n这几周除了工作小结之外基本都没写别的，要改要改。\n\n这周主要是盒子2.0.4版本的升级。主要做了盒子部分的优化和搜索功能。\n\n盒子部分的问题这次主要是进行一次内存化的升级优化，将之前网页模式设计的盒子，变成一个本地保存的盒子。然后将不同的地方进行sp的存储，退出app的时候会进行上报，进入app的时候会根据是否有本地sp来进行选择性的恢复。\n\n盒子部分主要学到的几个点：\n\n- 维护对象长持有，可以让对象持有一个application context，这样对象就不会在运行中死去。刚开始使用的是dressingbox的context，这样与mainactivity生命一样，但是mainacitivity在登陆的过程会被杀死，这就导致了cartutil重刷。\n\n- 本地存储维护三个状态：一个是原始的购物车数据，一个是变化的购物车数据，一个是变化的盒子数据，这样就可以根据其存储状态，判断上次是否传输成功，以及数据库的状态。\n\n- 关于rxjava泄漏的修复，很多rxjava的处理没有注意，rxjava这种函数式编程核心还是回调以及接口，因此很多在onresume里面写的，或者在attachtowindow中写的没有注意在onpause或者ondestroy中取消，导致了较多的泄漏。不过注意到之后特意处理了一下，现在泄漏现象少很多。\n\n除了以上的问题，还有一些问题需要注意：\n\n- 任务的分配，由于目前我是组内来的最早的员工，任务分配一开始是由我来分配，但是我总有一种对别人不放心的感觉，怕分给别人被拖累，所以能自己做的还是自己弄了。但是我一个人毕竟是来不及的，因此造成了原本周三发的版本，搞到了周五晚上才发，差点延期。现在懂了，关于任务的分配还是力争要做到合情合理，不能过分积压，也不能一点都没有。\n\n- rn的学习。辣鸡rn，毁我青春。\n\n- 阿里云服务器的后台搭建。目前已经刷成了centos了，急需动手。\n","source":"_posts/2018第二十一周工作小结.md","raw":"---\ntitle: 2018第二十一周工作小结\ndate: 2018-05-28 11:29:49\ntags: 工作小结\n---\n\n这几周除了工作小结之外基本都没写别的，要改要改。\n\n这周主要是盒子2.0.4版本的升级。主要做了盒子部分的优化和搜索功能。\n\n盒子部分的问题这次主要是进行一次内存化的升级优化，将之前网页模式设计的盒子，变成一个本地保存的盒子。然后将不同的地方进行sp的存储，退出app的时候会进行上报，进入app的时候会根据是否有本地sp来进行选择性的恢复。\n\n盒子部分主要学到的几个点：\n\n- 维护对象长持有，可以让对象持有一个application context，这样对象就不会在运行中死去。刚开始使用的是dressingbox的context，这样与mainactivity生命一样，但是mainacitivity在登陆的过程会被杀死，这就导致了cartutil重刷。\n\n- 本地存储维护三个状态：一个是原始的购物车数据，一个是变化的购物车数据，一个是变化的盒子数据，这样就可以根据其存储状态，判断上次是否传输成功，以及数据库的状态。\n\n- 关于rxjava泄漏的修复，很多rxjava的处理没有注意，rxjava这种函数式编程核心还是回调以及接口，因此很多在onresume里面写的，或者在attachtowindow中写的没有注意在onpause或者ondestroy中取消，导致了较多的泄漏。不过注意到之后特意处理了一下，现在泄漏现象少很多。\n\n除了以上的问题，还有一些问题需要注意：\n\n- 任务的分配，由于目前我是组内来的最早的员工，任务分配一开始是由我来分配，但是我总有一种对别人不放心的感觉，怕分给别人被拖累，所以能自己做的还是自己弄了。但是我一个人毕竟是来不及的，因此造成了原本周三发的版本，搞到了周五晚上才发，差点延期。现在懂了，关于任务的分配还是力争要做到合情合理，不能过分积压，也不能一点都没有。\n\n- rn的学习。辣鸡rn，毁我青春。\n\n- 阿里云服务器的后台搭建。目前已经刷成了centos了，急需动手。\n","slug":"2018第二十一周工作小结","published":1,"updated":"2019-03-12T09:26:33.140Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttwx000p3a8kh84u9pyf","content":"<p>这几周除了工作小结之外基本都没写别的，要改要改。</p>\n<p>这周主要是盒子2.0.4版本的升级。主要做了盒子部分的优化和搜索功能。</p>\n<p>盒子部分的问题这次主要是进行一次内存化的升级优化，将之前网页模式设计的盒子，变成一个本地保存的盒子。然后将不同的地方进行sp的存储，退出app的时候会进行上报，进入app的时候会根据是否有本地sp来进行选择性的恢复。</p>\n<p>盒子部分主要学到的几个点：</p>\n<ul>\n<li><p>维护对象长持有，可以让对象持有一个application context，这样对象就不会在运行中死去。刚开始使用的是dressingbox的context，这样与mainactivity生命一样，但是mainacitivity在登陆的过程会被杀死，这就导致了cartutil重刷。</p>\n</li>\n<li><p>本地存储维护三个状态：一个是原始的购物车数据，一个是变化的购物车数据，一个是变化的盒子数据，这样就可以根据其存储状态，判断上次是否传输成功，以及数据库的状态。</p>\n</li>\n<li><p>关于rxjava泄漏的修复，很多rxjava的处理没有注意，rxjava这种函数式编程核心还是回调以及接口，因此很多在onresume里面写的，或者在attachtowindow中写的没有注意在onpause或者ondestroy中取消，导致了较多的泄漏。不过注意到之后特意处理了一下，现在泄漏现象少很多。</p>\n</li>\n</ul>\n<p>除了以上的问题，还有一些问题需要注意：</p>\n<ul>\n<li><p>任务的分配，由于目前我是组内来的最早的员工，任务分配一开始是由我来分配，但是我总有一种对别人不放心的感觉，怕分给别人被拖累，所以能自己做的还是自己弄了。但是我一个人毕竟是来不及的，因此造成了原本周三发的版本，搞到了周五晚上才发，差点延期。现在懂了，关于任务的分配还是力争要做到合情合理，不能过分积压，也不能一点都没有。</p>\n</li>\n<li><p>rn的学习。辣鸡rn，毁我青春。</p>\n</li>\n<li><p>阿里云服务器的后台搭建。目前已经刷成了centos了，急需动手。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>这几周除了工作小结之外基本都没写别的，要改要改。</p>\n<p>这周主要是盒子2.0.4版本的升级。主要做了盒子部分的优化和搜索功能。</p>\n<p>盒子部分的问题这次主要是进行一次内存化的升级优化，将之前网页模式设计的盒子，变成一个本地保存的盒子。然后将不同的地方进行sp的存储，退出app的时候会进行上报，进入app的时候会根据是否有本地sp来进行选择性的恢复。</p>\n<p>盒子部分主要学到的几个点：</p>\n<ul>\n<li><p>维护对象长持有，可以让对象持有一个application context，这样对象就不会在运行中死去。刚开始使用的是dressingbox的context，这样与mainactivity生命一样，但是mainacitivity在登陆的过程会被杀死，这就导致了cartutil重刷。</p>\n</li>\n<li><p>本地存储维护三个状态：一个是原始的购物车数据，一个是变化的购物车数据，一个是变化的盒子数据，这样就可以根据其存储状态，判断上次是否传输成功，以及数据库的状态。</p>\n</li>\n<li><p>关于rxjava泄漏的修复，很多rxjava的处理没有注意，rxjava这种函数式编程核心还是回调以及接口，因此很多在onresume里面写的，或者在attachtowindow中写的没有注意在onpause或者ondestroy中取消，导致了较多的泄漏。不过注意到之后特意处理了一下，现在泄漏现象少很多。</p>\n</li>\n</ul>\n<p>除了以上的问题，还有一些问题需要注意：</p>\n<ul>\n<li><p>任务的分配，由于目前我是组内来的最早的员工，任务分配一开始是由我来分配，但是我总有一种对别人不放心的感觉，怕分给别人被拖累，所以能自己做的还是自己弄了。但是我一个人毕竟是来不及的，因此造成了原本周三发的版本，搞到了周五晚上才发，差点延期。现在懂了，关于任务的分配还是力争要做到合情合理，不能过分积压，也不能一点都没有。</p>\n</li>\n<li><p>rn的学习。辣鸡rn，毁我青春。</p>\n</li>\n<li><p>阿里云服务器的后台搭建。目前已经刷成了centos了，急需动手。</p>\n</li>\n</ul>\n"},{"title":"2018第二十二周工作小结","date":"2018-06-04T06:28:49.000Z","_content":"\n上周的任务是完成了盒子2.0.5的上线。这次主要是做了一些小的修改和修复。\n\n工作并没有学到多少，清闲反而有些不习惯。\n\n除此之外学习了mongodb，和后台搭建的一些知识，做了记录。\n\n本周转正，祝顺利。\n","source":"_posts/2018第二十二周工作小结.md","raw":"---\ntitle: 2018第二十二周工作小结\ndate: 2018-06-04 14:28:49\ntags: 工作小结\n---\n\n上周的任务是完成了盒子2.0.5的上线。这次主要是做了一些小的修改和修复。\n\n工作并没有学到多少，清闲反而有些不习惯。\n\n除此之外学习了mongodb，和后台搭建的一些知识，做了记录。\n\n本周转正，祝顺利。\n","slug":"2018第二十二周工作小结","published":1,"updated":"2019-03-12T09:26:33.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttwy000r3a8kxnjffj9k","content":"<p>上周的任务是完成了盒子2.0.5的上线。这次主要是做了一些小的修改和修复。</p>\n<p>工作并没有学到多少，清闲反而有些不习惯。</p>\n<p>除此之外学习了mongodb，和后台搭建的一些知识，做了记录。</p>\n<p>本周转正，祝顺利。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>上周的任务是完成了盒子2.0.5的上线。这次主要是做了一些小的修改和修复。</p>\n<p>工作并没有学到多少，清闲反而有些不习惯。</p>\n<p>除此之外学习了mongodb，和后台搭建的一些知识，做了记录。</p>\n<p>本周转正，祝顺利。</p>\n"},{"title":"2018年二十七周工作小结","date":"2018-07-08T11:59:49.000Z","_content":"\n这周主要是完成了盒子2.1的迭代。ui部分进行了大规模的更改，写了较多的控件。\n\n不过这都不重要。这周的主要收获收获在对软件流程的突破。\n\n之前项目里面使用的是一个activity对应一个fragment，但是缺点在于启动模式基本上都是activityA -> fragmentA -> activityB -> fragmentB -> activityC -> fragmentC，这种启动模式，基本上类似于activity启动的时候每次都开启一个栈，每个栈是独立的。\n\n不过这周想到一个比较好的方法，写代码的时候，仍然是一个activity对应一个fragment，不过启动的时候流程进行绑定化。\n\n举个例子，我们有一个页面a用于介绍会员的优点，有一个页面b用于用户进行会员付费，有一个页面c进行付费成功的提示。\n\n一般的情况，一次付费流程，是一个整的，不会出现付费成功，返回仍然是会员付费页面的现状，而应该是付费成功了，点击返回这个流程就会进行关闭。\n\n鉴于上面的流程，衍生出了会员介绍页面：activityA, fragmentA；会员付费页面：activityB, fragmentB; 付费成功页面：activityC, fragmentC\n\n从最基础的会员介绍开始，我们启动activityA,activityA的oncreate只写一个方法，就是启动fragmentA,显示介绍页面。fragmentA中有跳转的接口，跳到会员支付页面fragmentB，这个使用自己写的startFragment方法进行跳转，fragmentB又有支付宝或者微信的回调接口，回调跳转到fragmentC支付成功页面。到了fragmentC支付成功页面，返回按钮触发的就是finish当前的activity，因此此时一旦触发，整个流程就结束了。\n\n那为什么仍然要写成activity -> fragment的模式呢？看上去好像activityB并没有使用。\n\n事实上业务上面有很多地方只有单独的一个接口，该接口是直接进入支付页面，因此此时可以使用start activityB -> start fragmentB -> start fragmentC这种模式，此时如果在fragmentB页面返回，会直接触发activtyB的销毁动作，也能因此成为一个独立的流程。\n\n这套方法的思想来自于activity的任务栈调度模式，模仿的是singletask，不过相对于activity的任务栈，在某些方面还是不足的，例如说重复创建，单一任务多次使用等。这套大概使用情景在于切片化，更多的好处还需要自己体会。\n\n不过称此夸一下，activity的启动，开销比较大，每次启动至少涉及到两次binder，而且activity的启动过于局限。fragment虽然没有完善的任务调度系统，不过好在碎片化开销不算大，哪怕我们知道他比较麻烦，但是起码也能保证一点就是写好了不会太差。\n\n目前对app的拆分大概能拆分成 application -> activitys ,activity -> fragments，感觉比以前的想法更为清晰。\n","source":"_posts/2018第二十七周工作小结.md","raw":"---\ntitle: 2018年二十七周工作小结\ndate: 2018-07-08 19:59:49\ntags: 工作小结\n---\n\n这周主要是完成了盒子2.1的迭代。ui部分进行了大规模的更改，写了较多的控件。\n\n不过这都不重要。这周的主要收获收获在对软件流程的突破。\n\n之前项目里面使用的是一个activity对应一个fragment，但是缺点在于启动模式基本上都是activityA -> fragmentA -> activityB -> fragmentB -> activityC -> fragmentC，这种启动模式，基本上类似于activity启动的时候每次都开启一个栈，每个栈是独立的。\n\n不过这周想到一个比较好的方法，写代码的时候，仍然是一个activity对应一个fragment，不过启动的时候流程进行绑定化。\n\n举个例子，我们有一个页面a用于介绍会员的优点，有一个页面b用于用户进行会员付费，有一个页面c进行付费成功的提示。\n\n一般的情况，一次付费流程，是一个整的，不会出现付费成功，返回仍然是会员付费页面的现状，而应该是付费成功了，点击返回这个流程就会进行关闭。\n\n鉴于上面的流程，衍生出了会员介绍页面：activityA, fragmentA；会员付费页面：activityB, fragmentB; 付费成功页面：activityC, fragmentC\n\n从最基础的会员介绍开始，我们启动activityA,activityA的oncreate只写一个方法，就是启动fragmentA,显示介绍页面。fragmentA中有跳转的接口，跳到会员支付页面fragmentB，这个使用自己写的startFragment方法进行跳转，fragmentB又有支付宝或者微信的回调接口，回调跳转到fragmentC支付成功页面。到了fragmentC支付成功页面，返回按钮触发的就是finish当前的activity，因此此时一旦触发，整个流程就结束了。\n\n那为什么仍然要写成activity -> fragment的模式呢？看上去好像activityB并没有使用。\n\n事实上业务上面有很多地方只有单独的一个接口，该接口是直接进入支付页面，因此此时可以使用start activityB -> start fragmentB -> start fragmentC这种模式，此时如果在fragmentB页面返回，会直接触发activtyB的销毁动作，也能因此成为一个独立的流程。\n\n这套方法的思想来自于activity的任务栈调度模式，模仿的是singletask，不过相对于activity的任务栈，在某些方面还是不足的，例如说重复创建，单一任务多次使用等。这套大概使用情景在于切片化，更多的好处还需要自己体会。\n\n不过称此夸一下，activity的启动，开销比较大，每次启动至少涉及到两次binder，而且activity的启动过于局限。fragment虽然没有完善的任务调度系统，不过好在碎片化开销不算大，哪怕我们知道他比较麻烦，但是起码也能保证一点就是写好了不会太差。\n\n目前对app的拆分大概能拆分成 application -> activitys ,activity -> fragments，感觉比以前的想法更为清晰。\n","slug":"2018第二十七周工作小结","published":1,"updated":"2019-03-12T09:26:33.140Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttx0000t3a8kwmnz325x","content":"<p>这周主要是完成了盒子2.1的迭代。ui部分进行了大规模的更改，写了较多的控件。</p>\n<p>不过这都不重要。这周的主要收获收获在对软件流程的突破。</p>\n<p>之前项目里面使用的是一个activity对应一个fragment，但是缺点在于启动模式基本上都是activityA -&gt; fragmentA -&gt; activityB -&gt; fragmentB -&gt; activityC -&gt; fragmentC，这种启动模式，基本上类似于activity启动的时候每次都开启一个栈，每个栈是独立的。</p>\n<p>不过这周想到一个比较好的方法，写代码的时候，仍然是一个activity对应一个fragment，不过启动的时候流程进行绑定化。</p>\n<p>举个例子，我们有一个页面a用于介绍会员的优点，有一个页面b用于用户进行会员付费，有一个页面c进行付费成功的提示。</p>\n<p>一般的情况，一次付费流程，是一个整的，不会出现付费成功，返回仍然是会员付费页面的现状，而应该是付费成功了，点击返回这个流程就会进行关闭。</p>\n<p>鉴于上面的流程，衍生出了会员介绍页面：activityA, fragmentA；会员付费页面：activityB, fragmentB; 付费成功页面：activityC, fragmentC</p>\n<p>从最基础的会员介绍开始，我们启动activityA,activityA的oncreate只写一个方法，就是启动fragmentA,显示介绍页面。fragmentA中有跳转的接口，跳到会员支付页面fragmentB，这个使用自己写的startFragment方法进行跳转，fragmentB又有支付宝或者微信的回调接口，回调跳转到fragmentC支付成功页面。到了fragmentC支付成功页面，返回按钮触发的就是finish当前的activity，因此此时一旦触发，整个流程就结束了。</p>\n<p>那为什么仍然要写成activity -&gt; fragment的模式呢？看上去好像activityB并没有使用。</p>\n<p>事实上业务上面有很多地方只有单独的一个接口，该接口是直接进入支付页面，因此此时可以使用start activityB -&gt; start fragmentB -&gt; start fragmentC这种模式，此时如果在fragmentB页面返回，会直接触发activtyB的销毁动作，也能因此成为一个独立的流程。</p>\n<p>这套方法的思想来自于activity的任务栈调度模式，模仿的是singletask，不过相对于activity的任务栈，在某些方面还是不足的，例如说重复创建，单一任务多次使用等。这套大概使用情景在于切片化，更多的好处还需要自己体会。</p>\n<p>不过称此夸一下，activity的启动，开销比较大，每次启动至少涉及到两次binder，而且activity的启动过于局限。fragment虽然没有完善的任务调度系统，不过好在碎片化开销不算大，哪怕我们知道他比较麻烦，但是起码也能保证一点就是写好了不会太差。</p>\n<p>目前对app的拆分大概能拆分成 application -&gt; activitys ,activity -&gt; fragments，感觉比以前的想法更为清晰。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这周主要是完成了盒子2.1的迭代。ui部分进行了大规模的更改，写了较多的控件。</p>\n<p>不过这都不重要。这周的主要收获收获在对软件流程的突破。</p>\n<p>之前项目里面使用的是一个activity对应一个fragment，但是缺点在于启动模式基本上都是activityA -&gt; fragmentA -&gt; activityB -&gt; fragmentB -&gt; activityC -&gt; fragmentC，这种启动模式，基本上类似于activity启动的时候每次都开启一个栈，每个栈是独立的。</p>\n<p>不过这周想到一个比较好的方法，写代码的时候，仍然是一个activity对应一个fragment，不过启动的时候流程进行绑定化。</p>\n<p>举个例子，我们有一个页面a用于介绍会员的优点，有一个页面b用于用户进行会员付费，有一个页面c进行付费成功的提示。</p>\n<p>一般的情况，一次付费流程，是一个整的，不会出现付费成功，返回仍然是会员付费页面的现状，而应该是付费成功了，点击返回这个流程就会进行关闭。</p>\n<p>鉴于上面的流程，衍生出了会员介绍页面：activityA, fragmentA；会员付费页面：activityB, fragmentB; 付费成功页面：activityC, fragmentC</p>\n<p>从最基础的会员介绍开始，我们启动activityA,activityA的oncreate只写一个方法，就是启动fragmentA,显示介绍页面。fragmentA中有跳转的接口，跳到会员支付页面fragmentB，这个使用自己写的startFragment方法进行跳转，fragmentB又有支付宝或者微信的回调接口，回调跳转到fragmentC支付成功页面。到了fragmentC支付成功页面，返回按钮触发的就是finish当前的activity，因此此时一旦触发，整个流程就结束了。</p>\n<p>那为什么仍然要写成activity -&gt; fragment的模式呢？看上去好像activityB并没有使用。</p>\n<p>事实上业务上面有很多地方只有单独的一个接口，该接口是直接进入支付页面，因此此时可以使用start activityB -&gt; start fragmentB -&gt; start fragmentC这种模式，此时如果在fragmentB页面返回，会直接触发activtyB的销毁动作，也能因此成为一个独立的流程。</p>\n<p>这套方法的思想来自于activity的任务栈调度模式，模仿的是singletask，不过相对于activity的任务栈，在某些方面还是不足的，例如说重复创建，单一任务多次使用等。这套大概使用情景在于切片化，更多的好处还需要自己体会。</p>\n<p>不过称此夸一下，activity的启动，开销比较大，每次启动至少涉及到两次binder，而且activity的启动过于局限。fragment虽然没有完善的任务调度系统，不过好在碎片化开销不算大，哪怕我们知道他比较麻烦，但是起码也能保证一点就是写好了不会太差。</p>\n<p>目前对app的拆分大概能拆分成 application -&gt; activitys ,activity -&gt; fragments，感觉比以前的想法更为清晰。</p>\n"},{"title":"2018年第二十五周工作小结","date":"2018-06-24T11:14:24.000Z","_content":"\n即将迭代盒子2.1版本，所以这周做了一些准备工作。\n\n首先是专题部分的完成，单纯的通过了recyclerview的联动实现了一些小的控件，性能还可以，但是绘制的时候发现总是出现掉帧的现象。\n\nandroid的刷新频率是60hz，所以每秒绘制60次，每16ms绘制一次，但是这次发现有些绘制时间高达19ms，导致一帧绘制不起来，出现了一些卡顿的现象。\n\n经过部分分析，发现一个是recyclerview图形层级比较高，带来了绘制卡顿，优化之后仍然绘制过慢。\n\n最后行动是将所有的view统一，撤销所有的background，将scrollview的内容做缓存，将所有的网络数据接口做24小时的内存缓存。目前结果是第一次加载时卡顿，之后正常。\n\n这周工作上面只做了这些事。\n\n另外这周对自己的水平产生了一些疑问，相对于苏展、朱曦他们大我一届的人来讲，我的水平和他们相差还是比较大的。他们关注点更多的在一些我看不到的地方，比如说计算机理论，算法方面，甚至计算机硬件方面。和他们聊天的时候觉得他们什么都懂，攒机、rom、编译器选择、各大ide的比较，甚至连喷windows，喷mac，喷linux，姿势水平都比我高很多。\n\n这让我想到刚工作的时候，上级带我做职业规划的时候说的一句话：如果局限在一个方面，三两年就会厌倦，只有持续的多方面发展，才能有一个完善的职业规划。\n\n他们恰巧是兴趣带动了行动，行动也反过来增加了兴趣。\n\n反过来看我，自从刚毕业的时候，进入了手机开发行业，至今刚好两年多，一直在android和java的深坑中刻苦攀爬，偶尔有个兴趣爱好，也是以金钱为导向。这样的确使得自己变得很累。\n\n如果想持之以恒的发展下去，必然要发展一些兴趣，而这些兴趣也必须以一些有效的手段来规划，才能达到不浪费时间的目的。\n\n暂时思考方向如上，行动方向暂时未知。\n","source":"_posts/2018第二十五周工作小结.md","raw":"---\ntitle: 2018年第二十五周工作小结\ndate: 2018-06-24 19:14:24\ntags: 工作小结\n---\n\n即将迭代盒子2.1版本，所以这周做了一些准备工作。\n\n首先是专题部分的完成，单纯的通过了recyclerview的联动实现了一些小的控件，性能还可以，但是绘制的时候发现总是出现掉帧的现象。\n\nandroid的刷新频率是60hz，所以每秒绘制60次，每16ms绘制一次，但是这次发现有些绘制时间高达19ms，导致一帧绘制不起来，出现了一些卡顿的现象。\n\n经过部分分析，发现一个是recyclerview图形层级比较高，带来了绘制卡顿，优化之后仍然绘制过慢。\n\n最后行动是将所有的view统一，撤销所有的background，将scrollview的内容做缓存，将所有的网络数据接口做24小时的内存缓存。目前结果是第一次加载时卡顿，之后正常。\n\n这周工作上面只做了这些事。\n\n另外这周对自己的水平产生了一些疑问，相对于苏展、朱曦他们大我一届的人来讲，我的水平和他们相差还是比较大的。他们关注点更多的在一些我看不到的地方，比如说计算机理论，算法方面，甚至计算机硬件方面。和他们聊天的时候觉得他们什么都懂，攒机、rom、编译器选择、各大ide的比较，甚至连喷windows，喷mac，喷linux，姿势水平都比我高很多。\n\n这让我想到刚工作的时候，上级带我做职业规划的时候说的一句话：如果局限在一个方面，三两年就会厌倦，只有持续的多方面发展，才能有一个完善的职业规划。\n\n他们恰巧是兴趣带动了行动，行动也反过来增加了兴趣。\n\n反过来看我，自从刚毕业的时候，进入了手机开发行业，至今刚好两年多，一直在android和java的深坑中刻苦攀爬，偶尔有个兴趣爱好，也是以金钱为导向。这样的确使得自己变得很累。\n\n如果想持之以恒的发展下去，必然要发展一些兴趣，而这些兴趣也必须以一些有效的手段来规划，才能达到不浪费时间的目的。\n\n暂时思考方向如上，行动方向暂时未知。\n","slug":"2018第二十五周工作小结","published":1,"updated":"2019-03-12T09:26:33.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttx1000v3a8kar0v86co","content":"<p>即将迭代盒子2.1版本，所以这周做了一些准备工作。</p>\n<p>首先是专题部分的完成，单纯的通过了recyclerview的联动实现了一些小的控件，性能还可以，但是绘制的时候发现总是出现掉帧的现象。</p>\n<p>android的刷新频率是60hz，所以每秒绘制60次，每16ms绘制一次，但是这次发现有些绘制时间高达19ms，导致一帧绘制不起来，出现了一些卡顿的现象。</p>\n<p>经过部分分析，发现一个是recyclerview图形层级比较高，带来了绘制卡顿，优化之后仍然绘制过慢。</p>\n<p>最后行动是将所有的view统一，撤销所有的background，将scrollview的内容做缓存，将所有的网络数据接口做24小时的内存缓存。目前结果是第一次加载时卡顿，之后正常。</p>\n<p>这周工作上面只做了这些事。</p>\n<p>另外这周对自己的水平产生了一些疑问，相对于苏展、朱曦他们大我一届的人来讲，我的水平和他们相差还是比较大的。他们关注点更多的在一些我看不到的地方，比如说计算机理论，算法方面，甚至计算机硬件方面。和他们聊天的时候觉得他们什么都懂，攒机、rom、编译器选择、各大ide的比较，甚至连喷windows，喷mac，喷linux，姿势水平都比我高很多。</p>\n<p>这让我想到刚工作的时候，上级带我做职业规划的时候说的一句话：如果局限在一个方面，三两年就会厌倦，只有持续的多方面发展，才能有一个完善的职业规划。</p>\n<p>他们恰巧是兴趣带动了行动，行动也反过来增加了兴趣。</p>\n<p>反过来看我，自从刚毕业的时候，进入了手机开发行业，至今刚好两年多，一直在android和java的深坑中刻苦攀爬，偶尔有个兴趣爱好，也是以金钱为导向。这样的确使得自己变得很累。</p>\n<p>如果想持之以恒的发展下去，必然要发展一些兴趣，而这些兴趣也必须以一些有效的手段来规划，才能达到不浪费时间的目的。</p>\n<p>暂时思考方向如上，行动方向暂时未知。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>即将迭代盒子2.1版本，所以这周做了一些准备工作。</p>\n<p>首先是专题部分的完成，单纯的通过了recyclerview的联动实现了一些小的控件，性能还可以，但是绘制的时候发现总是出现掉帧的现象。</p>\n<p>android的刷新频率是60hz，所以每秒绘制60次，每16ms绘制一次，但是这次发现有些绘制时间高达19ms，导致一帧绘制不起来，出现了一些卡顿的现象。</p>\n<p>经过部分分析，发现一个是recyclerview图形层级比较高，带来了绘制卡顿，优化之后仍然绘制过慢。</p>\n<p>最后行动是将所有的view统一，撤销所有的background，将scrollview的内容做缓存，将所有的网络数据接口做24小时的内存缓存。目前结果是第一次加载时卡顿，之后正常。</p>\n<p>这周工作上面只做了这些事。</p>\n<p>另外这周对自己的水平产生了一些疑问，相对于苏展、朱曦他们大我一届的人来讲，我的水平和他们相差还是比较大的。他们关注点更多的在一些我看不到的地方，比如说计算机理论，算法方面，甚至计算机硬件方面。和他们聊天的时候觉得他们什么都懂，攒机、rom、编译器选择、各大ide的比较，甚至连喷windows，喷mac，喷linux，姿势水平都比我高很多。</p>\n<p>这让我想到刚工作的时候，上级带我做职业规划的时候说的一句话：如果局限在一个方面，三两年就会厌倦，只有持续的多方面发展，才能有一个完善的职业规划。</p>\n<p>他们恰巧是兴趣带动了行动，行动也反过来增加了兴趣。</p>\n<p>反过来看我，自从刚毕业的时候，进入了手机开发行业，至今刚好两年多，一直在android和java的深坑中刻苦攀爬，偶尔有个兴趣爱好，也是以金钱为导向。这样的确使得自己变得很累。</p>\n<p>如果想持之以恒的发展下去，必然要发展一些兴趣，而这些兴趣也必须以一些有效的手段来规划，才能达到不浪费时间的目的。</p>\n<p>暂时思考方向如上，行动方向暂时未知。</p>\n"},{"title":"2018第二十八周工作小结","date":"2018-07-16T03:30:29.000Z","_content":"\n本周完成了盒子2.1.0的绝大多数功能，等着周一上架。\n\n这次开发遇到了巨大的问题。在上上周一根据时间计划安排来确定了时间，结果噩梦般的产品后续大概全面改版外加更新了接近100%的内容，然而deadline没有变。\n\n第28周的工作压力特别大，每天搞到9点多，周末还来加班，总算紧赶慢赶赶完了。\n\n总结一下工作遇到的内容。\n\n首先是功能开发，本次更新了整个流程，因此开发了不少新功能和新需求。\n\n盒子页面直接取消，变成了一个常驻的view，如果此时使用单独的view区域的话，工作量比较大，因此改成了单一的popupwindow，不过是常驻的，每个使用的地方直接发一个eventbus即可。\n\n订单流程的更改，做了实时订单更新的操作，由于需要与盒子同步，因此直接使用了cartutil中的更新类来实时更新，比较取巧。\n\n另外写了一些单独抽出来的页面，对于页面之间的回调，反转等写了较多的操作。\n\n遇到的问题除了一些比较小的之外，有印象的特殊的有2个。\n\n一个是妆容算法功能丢失问题，新的版本发现妆容无效了，debug发现妆容文件丢失，切release版本之后发现妆容有但是仍然无效。检查了一通之后发现是新的登陆流程简化把妆容也给简化了，导致妆容一直没有初始化。同时由于debug版本不会执行妆容文件的压缩，导致debug即使添加了登陆流程，也依旧无效。总结下来这个地方当时是2个不确定点，而且运行环境不同，也算一个不确定点。\n\n解决这个问题并没有花费太多时间，修改了初始妆容的地方，然后单步调试到了jni，发现native代码没有执行，之后对比编译脚本，发现是debug包不会打包压缩妆容的步骤。但是因为这个原因和leader产生了一些争执，他认为单步调试可以解决一切。但是事实上单步调试一般只会用在有唯一一个变量或者变量串行的情况下，而在变量并行的时候，如果看不懂流程，而是光调试，那是毫无作用的。\n\n还有一个问题，是关于和产品的交涉。由于第一版给的设计图基本上就是一个原型图，过于草率，当时开会大家过目之后觉得还可以，就这么做了。导致后期交涉十分无力。产品一天能改三版，设计又不懂逻辑，没版都能缺个七八个点，导致那边越改，我们这边越麻烦，火气也越大。\n\n事实上对于产品来讲，他们并不会意识到我们在做什么，他们很直观的认为某个功能不麻烦，于是一系列不麻烦的小功能凑成了一个大麻烦。这在前期还好，可改动的机会比较多。但是后期房子都起好了再让我们打个壁炉基本上就需要砸墙了。砸墙的时间是个巨大的问题。所以关于这种情况，我们理智沟通一下其实还是可以的，明确告知这个需求和那个需求或许会有冲突，如果非要加的话需要时间，而且不排除会有很多bug。这样产品也会为了项目周期的稳定性而进行必要的取舍。事实上很多需求，他们也不知道应不应该加。\n\n这周的工作大致如上。","source":"_posts/2018第二十八周工作小结.md","raw":"---\ntitle: 2018第二十八周工作小结\ndate: 2018-07-16 11:30:29\ntags: 工作小结\n---\n\n本周完成了盒子2.1.0的绝大多数功能，等着周一上架。\n\n这次开发遇到了巨大的问题。在上上周一根据时间计划安排来确定了时间，结果噩梦般的产品后续大概全面改版外加更新了接近100%的内容，然而deadline没有变。\n\n第28周的工作压力特别大，每天搞到9点多，周末还来加班，总算紧赶慢赶赶完了。\n\n总结一下工作遇到的内容。\n\n首先是功能开发，本次更新了整个流程，因此开发了不少新功能和新需求。\n\n盒子页面直接取消，变成了一个常驻的view，如果此时使用单独的view区域的话，工作量比较大，因此改成了单一的popupwindow，不过是常驻的，每个使用的地方直接发一个eventbus即可。\n\n订单流程的更改，做了实时订单更新的操作，由于需要与盒子同步，因此直接使用了cartutil中的更新类来实时更新，比较取巧。\n\n另外写了一些单独抽出来的页面，对于页面之间的回调，反转等写了较多的操作。\n\n遇到的问题除了一些比较小的之外，有印象的特殊的有2个。\n\n一个是妆容算法功能丢失问题，新的版本发现妆容无效了，debug发现妆容文件丢失，切release版本之后发现妆容有但是仍然无效。检查了一通之后发现是新的登陆流程简化把妆容也给简化了，导致妆容一直没有初始化。同时由于debug版本不会执行妆容文件的压缩，导致debug即使添加了登陆流程，也依旧无效。总结下来这个地方当时是2个不确定点，而且运行环境不同，也算一个不确定点。\n\n解决这个问题并没有花费太多时间，修改了初始妆容的地方，然后单步调试到了jni，发现native代码没有执行，之后对比编译脚本，发现是debug包不会打包压缩妆容的步骤。但是因为这个原因和leader产生了一些争执，他认为单步调试可以解决一切。但是事实上单步调试一般只会用在有唯一一个变量或者变量串行的情况下，而在变量并行的时候，如果看不懂流程，而是光调试，那是毫无作用的。\n\n还有一个问题，是关于和产品的交涉。由于第一版给的设计图基本上就是一个原型图，过于草率，当时开会大家过目之后觉得还可以，就这么做了。导致后期交涉十分无力。产品一天能改三版，设计又不懂逻辑，没版都能缺个七八个点，导致那边越改，我们这边越麻烦，火气也越大。\n\n事实上对于产品来讲，他们并不会意识到我们在做什么，他们很直观的认为某个功能不麻烦，于是一系列不麻烦的小功能凑成了一个大麻烦。这在前期还好，可改动的机会比较多。但是后期房子都起好了再让我们打个壁炉基本上就需要砸墙了。砸墙的时间是个巨大的问题。所以关于这种情况，我们理智沟通一下其实还是可以的，明确告知这个需求和那个需求或许会有冲突，如果非要加的话需要时间，而且不排除会有很多bug。这样产品也会为了项目周期的稳定性而进行必要的取舍。事实上很多需求，他们也不知道应不应该加。\n\n这周的工作大致如上。","slug":"2018第二十八周工作小结","published":1,"updated":"2019-03-12T09:26:33.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttx2000x3a8k9ol4exnc","content":"<p>本周完成了盒子2.1.0的绝大多数功能，等着周一上架。</p>\n<p>这次开发遇到了巨大的问题。在上上周一根据时间计划安排来确定了时间，结果噩梦般的产品后续大概全面改版外加更新了接近100%的内容，然而deadline没有变。</p>\n<p>第28周的工作压力特别大，每天搞到9点多，周末还来加班，总算紧赶慢赶赶完了。</p>\n<p>总结一下工作遇到的内容。</p>\n<p>首先是功能开发，本次更新了整个流程，因此开发了不少新功能和新需求。</p>\n<p>盒子页面直接取消，变成了一个常驻的view，如果此时使用单独的view区域的话，工作量比较大，因此改成了单一的popupwindow，不过是常驻的，每个使用的地方直接发一个eventbus即可。</p>\n<p>订单流程的更改，做了实时订单更新的操作，由于需要与盒子同步，因此直接使用了cartutil中的更新类来实时更新，比较取巧。</p>\n<p>另外写了一些单独抽出来的页面，对于页面之间的回调，反转等写了较多的操作。</p>\n<p>遇到的问题除了一些比较小的之外，有印象的特殊的有2个。</p>\n<p>一个是妆容算法功能丢失问题，新的版本发现妆容无效了，debug发现妆容文件丢失，切release版本之后发现妆容有但是仍然无效。检查了一通之后发现是新的登陆流程简化把妆容也给简化了，导致妆容一直没有初始化。同时由于debug版本不会执行妆容文件的压缩，导致debug即使添加了登陆流程，也依旧无效。总结下来这个地方当时是2个不确定点，而且运行环境不同，也算一个不确定点。</p>\n<p>解决这个问题并没有花费太多时间，修改了初始妆容的地方，然后单步调试到了jni，发现native代码没有执行，之后对比编译脚本，发现是debug包不会打包压缩妆容的步骤。但是因为这个原因和leader产生了一些争执，他认为单步调试可以解决一切。但是事实上单步调试一般只会用在有唯一一个变量或者变量串行的情况下，而在变量并行的时候，如果看不懂流程，而是光调试，那是毫无作用的。</p>\n<p>还有一个问题，是关于和产品的交涉。由于第一版给的设计图基本上就是一个原型图，过于草率，当时开会大家过目之后觉得还可以，就这么做了。导致后期交涉十分无力。产品一天能改三版，设计又不懂逻辑，没版都能缺个七八个点，导致那边越改，我们这边越麻烦，火气也越大。</p>\n<p>事实上对于产品来讲，他们并不会意识到我们在做什么，他们很直观的认为某个功能不麻烦，于是一系列不麻烦的小功能凑成了一个大麻烦。这在前期还好，可改动的机会比较多。但是后期房子都起好了再让我们打个壁炉基本上就需要砸墙了。砸墙的时间是个巨大的问题。所以关于这种情况，我们理智沟通一下其实还是可以的，明确告知这个需求和那个需求或许会有冲突，如果非要加的话需要时间，而且不排除会有很多bug。这样产品也会为了项目周期的稳定性而进行必要的取舍。事实上很多需求，他们也不知道应不应该加。</p>\n<p>这周的工作大致如上。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本周完成了盒子2.1.0的绝大多数功能，等着周一上架。</p>\n<p>这次开发遇到了巨大的问题。在上上周一根据时间计划安排来确定了时间，结果噩梦般的产品后续大概全面改版外加更新了接近100%的内容，然而deadline没有变。</p>\n<p>第28周的工作压力特别大，每天搞到9点多，周末还来加班，总算紧赶慢赶赶完了。</p>\n<p>总结一下工作遇到的内容。</p>\n<p>首先是功能开发，本次更新了整个流程，因此开发了不少新功能和新需求。</p>\n<p>盒子页面直接取消，变成了一个常驻的view，如果此时使用单独的view区域的话，工作量比较大，因此改成了单一的popupwindow，不过是常驻的，每个使用的地方直接发一个eventbus即可。</p>\n<p>订单流程的更改，做了实时订单更新的操作，由于需要与盒子同步，因此直接使用了cartutil中的更新类来实时更新，比较取巧。</p>\n<p>另外写了一些单独抽出来的页面，对于页面之间的回调，反转等写了较多的操作。</p>\n<p>遇到的问题除了一些比较小的之外，有印象的特殊的有2个。</p>\n<p>一个是妆容算法功能丢失问题，新的版本发现妆容无效了，debug发现妆容文件丢失，切release版本之后发现妆容有但是仍然无效。检查了一通之后发现是新的登陆流程简化把妆容也给简化了，导致妆容一直没有初始化。同时由于debug版本不会执行妆容文件的压缩，导致debug即使添加了登陆流程，也依旧无效。总结下来这个地方当时是2个不确定点，而且运行环境不同，也算一个不确定点。</p>\n<p>解决这个问题并没有花费太多时间，修改了初始妆容的地方，然后单步调试到了jni，发现native代码没有执行，之后对比编译脚本，发现是debug包不会打包压缩妆容的步骤。但是因为这个原因和leader产生了一些争执，他认为单步调试可以解决一切。但是事实上单步调试一般只会用在有唯一一个变量或者变量串行的情况下，而在变量并行的时候，如果看不懂流程，而是光调试，那是毫无作用的。</p>\n<p>还有一个问题，是关于和产品的交涉。由于第一版给的设计图基本上就是一个原型图，过于草率，当时开会大家过目之后觉得还可以，就这么做了。导致后期交涉十分无力。产品一天能改三版，设计又不懂逻辑，没版都能缺个七八个点，导致那边越改，我们这边越麻烦，火气也越大。</p>\n<p>事实上对于产品来讲，他们并不会意识到我们在做什么，他们很直观的认为某个功能不麻烦，于是一系列不麻烦的小功能凑成了一个大麻烦。这在前期还好，可改动的机会比较多。但是后期房子都起好了再让我们打个壁炉基本上就需要砸墙了。砸墙的时间是个巨大的问题。所以关于这种情况，我们理智沟通一下其实还是可以的，明确告知这个需求和那个需求或许会有冲突，如果非要加的话需要时间，而且不排除会有很多bug。这样产品也会为了项目周期的稳定性而进行必要的取舍。事实上很多需求，他们也不知道应不应该加。</p>\n<p>这周的工作大致如上。</p>\n"},{"title":"2018第二十周工作小结","date":"2018-05-20T13:29:59.000Z","_content":"\n这周周三上线了2.0.3版本，主要是针对盒子部分进行了流程的优化。\n\n这周有个比较大的感触，是产品为了完善用户转化率，不断的将一些要素提炼出来，然后放置在用户可见区域，不断的优化这一细节，导致最后呈现的版本，流程，和之前都不同了。这种产品思维，我可学习的地方很多。\n\n另外这周我可以说是入门了reactnative，我希望在移动端这边可以学习更多东西。所以通过reactnative，学习js的操作语法。同时对于ios的语法也要进行一定的学习。\n\n这次有一些想法，关于生活作息的。之前由于经常加班，导致精神紧张睡眠不足，晚上回去也没有时间进行学习。现在针对这个问题进行改变。\n\n每晚争取7。30左右下班，发版本晚一些可以。回来之后看一会儿书，10.30左右睡觉。保障8小时睡眠，然后第二天7点起床，七点半去公司，然后看2小时的书。\n","source":"_posts/2018第二十周工作小结.md","raw":"---\ntitle: 2018第二十周工作小结\ndate: 2018-05-20 21:29:59\ntags: 工作小结\n---\n\n这周周三上线了2.0.3版本，主要是针对盒子部分进行了流程的优化。\n\n这周有个比较大的感触，是产品为了完善用户转化率，不断的将一些要素提炼出来，然后放置在用户可见区域，不断的优化这一细节，导致最后呈现的版本，流程，和之前都不同了。这种产品思维，我可学习的地方很多。\n\n另外这周我可以说是入门了reactnative，我希望在移动端这边可以学习更多东西。所以通过reactnative，学习js的操作语法。同时对于ios的语法也要进行一定的学习。\n\n这次有一些想法，关于生活作息的。之前由于经常加班，导致精神紧张睡眠不足，晚上回去也没有时间进行学习。现在针对这个问题进行改变。\n\n每晚争取7。30左右下班，发版本晚一些可以。回来之后看一会儿书，10.30左右睡觉。保障8小时睡眠，然后第二天7点起床，七点半去公司，然后看2小时的书。\n","slug":"2018第二十周工作小结","published":1,"updated":"2019-03-12T09:26:33.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttx3000z3a8k2th4kmmc","content":"<p>这周周三上线了2.0.3版本，主要是针对盒子部分进行了流程的优化。</p>\n<p>这周有个比较大的感触，是产品为了完善用户转化率，不断的将一些要素提炼出来，然后放置在用户可见区域，不断的优化这一细节，导致最后呈现的版本，流程，和之前都不同了。这种产品思维，我可学习的地方很多。</p>\n<p>另外这周我可以说是入门了reactnative，我希望在移动端这边可以学习更多东西。所以通过reactnative，学习js的操作语法。同时对于ios的语法也要进行一定的学习。</p>\n<p>这次有一些想法，关于生活作息的。之前由于经常加班，导致精神紧张睡眠不足，晚上回去也没有时间进行学习。现在针对这个问题进行改变。</p>\n<p>每晚争取7。30左右下班，发版本晚一些可以。回来之后看一会儿书，10.30左右睡觉。保障8小时睡眠，然后第二天7点起床，七点半去公司，然后看2小时的书。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这周周三上线了2.0.3版本，主要是针对盒子部分进行了流程的优化。</p>\n<p>这周有个比较大的感触，是产品为了完善用户转化率，不断的将一些要素提炼出来，然后放置在用户可见区域，不断的优化这一细节，导致最后呈现的版本，流程，和之前都不同了。这种产品思维，我可学习的地方很多。</p>\n<p>另外这周我可以说是入门了reactnative，我希望在移动端这边可以学习更多东西。所以通过reactnative，学习js的操作语法。同时对于ios的语法也要进行一定的学习。</p>\n<p>这次有一些想法，关于生活作息的。之前由于经常加班，导致精神紧张睡眠不足，晚上回去也没有时间进行学习。现在针对这个问题进行改变。</p>\n<p>每晚争取7。30左右下班，发版本晚一些可以。回来之后看一会儿书，10.30左右睡觉。保障8小时睡眠，然后第二天7点起床，七点半去公司，然后看2小时的书。</p>\n"},{"title":"2018第二周工作小结","date":"2018-01-14T14:15:58.000Z","_content":"\n这周的工作小结拖到了周末才写，不过还是写一下吧。\n\n这周的主要工作还是搞那个williamchart的图表，解决了数据填充的问题，中间组件传输仍然是使用了eventbus来传输。\n\n一个技术难点突破是，在响应式中做上游下游的响应操作，这次主要是了解了rxjava的map和flatmap的差别。map主要是直接将第一个参数传到下游，这有一个问题，就是假如上游是一个observable，那仍然会传一个observable。因此map的使用场景主要是用在由上游传递一些固定参数的。flatmap则是可以将上游的observable进行转换，将observable获得的东西传到下游。\n\n除此之外还学到一个就是emitter，这个可以控制下游的生命周期，但是只可以控制onnext和oncomplete。但是忽略了这点会导致oncomplete无法执行。\n\n大概就是学了上面两个技术点，其余大部分时间用于处理graphq的语句，返回数值的处理了，没想到居然用了一周的时间。不过周五请假也算就用了四天。\n\n之后的任务，数据是好了，但是需要改ui了，点击的ui要改，滑动曲线的ui也要改，还有一些杂七杂八的ui。\n\n给自己定了3天的工作计划，希望周三晚上能处理完毕吧。\n\n这周开始给自己打分，以后每周都是周日开始写本周总结，并且定下下周的任务，之后按照下周的任务完成度来给自己打分。\n\n本周开始的话，那我给上周打个98分吧，少两分怕自己骄傲～","source":"_posts/2018第二周工作小结.md","raw":"---\ntitle: 2018第二周工作小结\ndate: 2018-01-14 22:15:58\ntags: 工作小结\n---\n\n这周的工作小结拖到了周末才写，不过还是写一下吧。\n\n这周的主要工作还是搞那个williamchart的图表，解决了数据填充的问题，中间组件传输仍然是使用了eventbus来传输。\n\n一个技术难点突破是，在响应式中做上游下游的响应操作，这次主要是了解了rxjava的map和flatmap的差别。map主要是直接将第一个参数传到下游，这有一个问题，就是假如上游是一个observable，那仍然会传一个observable。因此map的使用场景主要是用在由上游传递一些固定参数的。flatmap则是可以将上游的observable进行转换，将observable获得的东西传到下游。\n\n除此之外还学到一个就是emitter，这个可以控制下游的生命周期，但是只可以控制onnext和oncomplete。但是忽略了这点会导致oncomplete无法执行。\n\n大概就是学了上面两个技术点，其余大部分时间用于处理graphq的语句，返回数值的处理了，没想到居然用了一周的时间。不过周五请假也算就用了四天。\n\n之后的任务，数据是好了，但是需要改ui了，点击的ui要改，滑动曲线的ui也要改，还有一些杂七杂八的ui。\n\n给自己定了3天的工作计划，希望周三晚上能处理完毕吧。\n\n这周开始给自己打分，以后每周都是周日开始写本周总结，并且定下下周的任务，之后按照下周的任务完成度来给自己打分。\n\n本周开始的话，那我给上周打个98分吧，少两分怕自己骄傲～","slug":"2018第二周工作小结","published":1,"updated":"2019-03-12T09:26:33.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttx300113a8kygdusa6e","content":"<p>这周的工作小结拖到了周末才写，不过还是写一下吧。</p>\n<p>这周的主要工作还是搞那个williamchart的图表，解决了数据填充的问题，中间组件传输仍然是使用了eventbus来传输。</p>\n<p>一个技术难点突破是，在响应式中做上游下游的响应操作，这次主要是了解了rxjava的map和flatmap的差别。map主要是直接将第一个参数传到下游，这有一个问题，就是假如上游是一个observable，那仍然会传一个observable。因此map的使用场景主要是用在由上游传递一些固定参数的。flatmap则是可以将上游的observable进行转换，将observable获得的东西传到下游。</p>\n<p>除此之外还学到一个就是emitter，这个可以控制下游的生命周期，但是只可以控制onnext和oncomplete。但是忽略了这点会导致oncomplete无法执行。</p>\n<p>大概就是学了上面两个技术点，其余大部分时间用于处理graphq的语句，返回数值的处理了，没想到居然用了一周的时间。不过周五请假也算就用了四天。</p>\n<p>之后的任务，数据是好了，但是需要改ui了，点击的ui要改，滑动曲线的ui也要改，还有一些杂七杂八的ui。</p>\n<p>给自己定了3天的工作计划，希望周三晚上能处理完毕吧。</p>\n<p>这周开始给自己打分，以后每周都是周日开始写本周总结，并且定下下周的任务，之后按照下周的任务完成度来给自己打分。</p>\n<p>本周开始的话，那我给上周打个98分吧，少两分怕自己骄傲～</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这周的工作小结拖到了周末才写，不过还是写一下吧。</p>\n<p>这周的主要工作还是搞那个williamchart的图表，解决了数据填充的问题，中间组件传输仍然是使用了eventbus来传输。</p>\n<p>一个技术难点突破是，在响应式中做上游下游的响应操作，这次主要是了解了rxjava的map和flatmap的差别。map主要是直接将第一个参数传到下游，这有一个问题，就是假如上游是一个observable，那仍然会传一个observable。因此map的使用场景主要是用在由上游传递一些固定参数的。flatmap则是可以将上游的observable进行转换，将observable获得的东西传到下游。</p>\n<p>除此之外还学到一个就是emitter，这个可以控制下游的生命周期，但是只可以控制onnext和oncomplete。但是忽略了这点会导致oncomplete无法执行。</p>\n<p>大概就是学了上面两个技术点，其余大部分时间用于处理graphq的语句，返回数值的处理了，没想到居然用了一周的时间。不过周五请假也算就用了四天。</p>\n<p>之后的任务，数据是好了，但是需要改ui了，点击的ui要改，滑动曲线的ui也要改，还有一些杂七杂八的ui。</p>\n<p>给自己定了3天的工作计划，希望周三晚上能处理完毕吧。</p>\n<p>这周开始给自己打分，以后每周都是周日开始写本周总结，并且定下下周的任务，之后按照下周的任务完成度来给自己打分。</p>\n<p>本周开始的话，那我给上周打个98分吧，少两分怕自己骄傲～</p>\n"},{"title":"2018第五周工作小结","date":"2018-02-06T13:16:49.000Z","_content":"\n上周忘了写工作小结了。\n\n上周由于感冒发烧请假看病，导致工作效率十分低下。\n\n之前listview卡在了动画效果之上，当时需要对新的信息做一个动画插入的效果，由于listview本身没有这方面的api，假如将动画移到getview中进行的话，会导致每次getview的时候触发动画，而假如不使用listview，使用动态添加view的话，会失去缓存层，导致卡顿。\n\n之后想的是使用recyclerview自带的defaultanimation，不过使用这个需要做一些调整，也就是将新的消息切割开来，然后第一次加载是全部加载，之后的加载就是只加载新的。\n\n这个牵扯到了一个关于ArrayList的contains方法，了解之后重写了一下equals方法即可。\n\n上周就做了这些工作，很惭愧。\n","source":"_posts/2018第五周工作小结.md","raw":"---\ntitle: 2018第五周工作小结\ndate: 2018-02-06 21:16:49\ntags: 工作小结\n---\n\n上周忘了写工作小结了。\n\n上周由于感冒发烧请假看病，导致工作效率十分低下。\n\n之前listview卡在了动画效果之上，当时需要对新的信息做一个动画插入的效果，由于listview本身没有这方面的api，假如将动画移到getview中进行的话，会导致每次getview的时候触发动画，而假如不使用listview，使用动态添加view的话，会失去缓存层，导致卡顿。\n\n之后想的是使用recyclerview自带的defaultanimation，不过使用这个需要做一些调整，也就是将新的消息切割开来，然后第一次加载是全部加载，之后的加载就是只加载新的。\n\n这个牵扯到了一个关于ArrayList的contains方法，了解之后重写了一下equals方法即可。\n\n上周就做了这些工作，很惭愧。\n","slug":"2018第五周工作小结","published":1,"updated":"2019-03-12T09:26:33.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttx400133a8ktan7353x","content":"<p>上周忘了写工作小结了。</p>\n<p>上周由于感冒发烧请假看病，导致工作效率十分低下。</p>\n<p>之前listview卡在了动画效果之上，当时需要对新的信息做一个动画插入的效果，由于listview本身没有这方面的api，假如将动画移到getview中进行的话，会导致每次getview的时候触发动画，而假如不使用listview，使用动态添加view的话，会失去缓存层，导致卡顿。</p>\n<p>之后想的是使用recyclerview自带的defaultanimation，不过使用这个需要做一些调整，也就是将新的消息切割开来，然后第一次加载是全部加载，之后的加载就是只加载新的。</p>\n<p>这个牵扯到了一个关于ArrayList的contains方法，了解之后重写了一下equals方法即可。</p>\n<p>上周就做了这些工作，很惭愧。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>上周忘了写工作小结了。</p>\n<p>上周由于感冒发烧请假看病，导致工作效率十分低下。</p>\n<p>之前listview卡在了动画效果之上，当时需要对新的信息做一个动画插入的效果，由于listview本身没有这方面的api，假如将动画移到getview中进行的话，会导致每次getview的时候触发动画，而假如不使用listview，使用动态添加view的话，会失去缓存层，导致卡顿。</p>\n<p>之后想的是使用recyclerview自带的defaultanimation，不过使用这个需要做一些调整，也就是将新的消息切割开来，然后第一次加载是全部加载，之后的加载就是只加载新的。</p>\n<p>这个牵扯到了一个关于ArrayList的contains方法，了解之后重写了一下equals方法即可。</p>\n<p>上周就做了这些工作，很惭愧。</p>\n"},{"title":"2018第八周工作小结","date":"2018-02-25T17:23:28.000Z","_content":"\n差点忘了写周报了。\n这周就上了三天班，主要任务是完成了对wise的bugly热修复和热更新的功能集成。\n\n相对于之前使用的andfix，bugly基本上不论是功能，还是便捷性，都足够强大，最重要的是，bugly稳定，andfix则过于老了。\n\n这次对bugly的集成，也学习了对gradle分布编译打包的操作，以往都是使用build，这次发现其实使用gradle插件也可以实现，同时gradle插件还有对单元测试覆盖率的html图示，功能强大。\n\n另外学习到的一点就是debug带签名，和studio调试的时候直接使用release操作。\n\n无奈的是，我即使集成了bugly，对业务也没有什么需要用的提升之处。地推人员用的，和客户使用的都是不同的思想。\n\n哎，希望这一次找工作顺利，能够将自己学习到的东西真正的发挥到吧。","source":"_posts/2018第八周工作小结.md","raw":"---\ntitle: 2018第八周工作小结\ndate: 2018-02-26 01:23:28\ntags: 工作小结\n---\n\n差点忘了写周报了。\n这周就上了三天班，主要任务是完成了对wise的bugly热修复和热更新的功能集成。\n\n相对于之前使用的andfix，bugly基本上不论是功能，还是便捷性，都足够强大，最重要的是，bugly稳定，andfix则过于老了。\n\n这次对bugly的集成，也学习了对gradle分布编译打包的操作，以往都是使用build，这次发现其实使用gradle插件也可以实现，同时gradle插件还有对单元测试覆盖率的html图示，功能强大。\n\n另外学习到的一点就是debug带签名，和studio调试的时候直接使用release操作。\n\n无奈的是，我即使集成了bugly，对业务也没有什么需要用的提升之处。地推人员用的，和客户使用的都是不同的思想。\n\n哎，希望这一次找工作顺利，能够将自己学习到的东西真正的发挥到吧。","slug":"2018第八周工作小结","published":1,"updated":"2019-03-12T09:26:33.142Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttx500153a8kpcfvr0jv","content":"<p>差点忘了写周报了。<br>这周就上了三天班，主要任务是完成了对wise的bugly热修复和热更新的功能集成。</p>\n<p>相对于之前使用的andfix，bugly基本上不论是功能，还是便捷性，都足够强大，最重要的是，bugly稳定，andfix则过于老了。</p>\n<p>这次对bugly的集成，也学习了对gradle分布编译打包的操作，以往都是使用build，这次发现其实使用gradle插件也可以实现，同时gradle插件还有对单元测试覆盖率的html图示，功能强大。</p>\n<p>另外学习到的一点就是debug带签名，和studio调试的时候直接使用release操作。</p>\n<p>无奈的是，我即使集成了bugly，对业务也没有什么需要用的提升之处。地推人员用的，和客户使用的都是不同的思想。</p>\n<p>哎，希望这一次找工作顺利，能够将自己学习到的东西真正的发挥到吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>差点忘了写周报了。<br>这周就上了三天班，主要任务是完成了对wise的bugly热修复和热更新的功能集成。</p>\n<p>相对于之前使用的andfix，bugly基本上不论是功能，还是便捷性，都足够强大，最重要的是，bugly稳定，andfix则过于老了。</p>\n<p>这次对bugly的集成，也学习了对gradle分布编译打包的操作，以往都是使用build，这次发现其实使用gradle插件也可以实现，同时gradle插件还有对单元测试覆盖率的html图示，功能强大。</p>\n<p>另外学习到的一点就是debug带签名，和studio调试的时候直接使用release操作。</p>\n<p>无奈的是，我即使集成了bugly，对业务也没有什么需要用的提升之处。地推人员用的，和客户使用的都是不同的思想。</p>\n<p>哎，希望这一次找工作顺利，能够将自己学习到的东西真正的发挥到吧。</p>\n"},{"title":"2018第六周工作小结","date":"2018-02-10T15:28:18.000Z","_content":"\n这周大量的时间用于进行安卓知识的学习，项目上的进展为0。不过由于最近也没有什么项目需要进展，肺科医院订单后台的项目好像被停掉了，只有那个肺科医院的数据显示项目还在用。\n\n不过还是要安排一下下一周的任务，下一周连着周日只有3天班，因为周三我就请假回家过年了。\n\n1. 肺科医院数据显示任务的ui精简，一个是logo，一个是五星好评的那个功能\n\n2. 将肺科医院数据显示的那个改成mvp结构，并且写单元测试。\n\n就这两个任务，另外过年回去仍然要继续学习安卓方面的知识点。\n\n\n","source":"_posts/2018第六周工作小结.md","raw":"---\ntitle: 2018第六周工作小结\ndate: 2018-02-10 23:28:18\ntags: 工作小结\n---\n\n这周大量的时间用于进行安卓知识的学习，项目上的进展为0。不过由于最近也没有什么项目需要进展，肺科医院订单后台的项目好像被停掉了，只有那个肺科医院的数据显示项目还在用。\n\n不过还是要安排一下下一周的任务，下一周连着周日只有3天班，因为周三我就请假回家过年了。\n\n1. 肺科医院数据显示任务的ui精简，一个是logo，一个是五星好评的那个功能\n\n2. 将肺科医院数据显示的那个改成mvp结构，并且写单元测试。\n\n就这两个任务，另外过年回去仍然要继续学习安卓方面的知识点。\n\n\n","slug":"2018第六周工作小结","published":1,"updated":"2019-03-12T09:26:33.142Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttx600173a8k1136oqli","content":"<p>这周大量的时间用于进行安卓知识的学习，项目上的进展为0。不过由于最近也没有什么项目需要进展，肺科医院订单后台的项目好像被停掉了，只有那个肺科医院的数据显示项目还在用。</p>\n<p>不过还是要安排一下下一周的任务，下一周连着周日只有3天班，因为周三我就请假回家过年了。</p>\n<ol>\n<li><p>肺科医院数据显示任务的ui精简，一个是logo，一个是五星好评的那个功能</p>\n</li>\n<li><p>将肺科医院数据显示的那个改成mvp结构，并且写单元测试。</p>\n</li>\n</ol>\n<p>就这两个任务，另外过年回去仍然要继续学习安卓方面的知识点。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这周大量的时间用于进行安卓知识的学习，项目上的进展为0。不过由于最近也没有什么项目需要进展，肺科医院订单后台的项目好像被停掉了，只有那个肺科医院的数据显示项目还在用。</p>\n<p>不过还是要安排一下下一周的任务，下一周连着周日只有3天班，因为周三我就请假回家过年了。</p>\n<ol>\n<li><p>肺科医院数据显示任务的ui精简，一个是logo，一个是五星好评的那个功能</p>\n</li>\n<li><p>将肺科医院数据显示的那个改成mvp结构，并且写单元测试。</p>\n</li>\n</ol>\n<p>就这两个任务，另外过年回去仍然要继续学习安卓方面的知识点。</p>\n"},{"title":"2018第十一周工作小结","date":"2018-03-19T08:33:10.000Z","_content":"\n时光匆匆如水，我却总是忘了写周报。\n\n由于接口未好，导致前端的工作几乎停滞，每天除了看代码就是看代码。\n\n目前代码的阅读还算可以，复杂度与framework的复杂度相比还是不如的，但是对比我之前做的项目，架构却又好的太多太多了，所以自己还是有很大的必要从中进行学习的。\n\n目前大致任务就是检查2.0项目的必要内容，然后等接口来。\n\n这一周入门了go，希望能用go进行服务器端的开发任务。\n","source":"_posts/2018第十一周工作小结.md","raw":"---\ntitle: 2018第十一周工作小结\ndate: 2018-03-19 16:33:10\ntags: 工作小结\n---\n\n时光匆匆如水，我却总是忘了写周报。\n\n由于接口未好，导致前端的工作几乎停滞，每天除了看代码就是看代码。\n\n目前代码的阅读还算可以，复杂度与framework的复杂度相比还是不如的，但是对比我之前做的项目，架构却又好的太多太多了，所以自己还是有很大的必要从中进行学习的。\n\n目前大致任务就是检查2.0项目的必要内容，然后等接口来。\n\n这一周入门了go，希望能用go进行服务器端的开发任务。\n","slug":"2018第十一周工作小结","published":1,"updated":"2019-03-12T09:26:33.142Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttx700193a8khzhowzcx","content":"<p>时光匆匆如水，我却总是忘了写周报。</p>\n<p>由于接口未好，导致前端的工作几乎停滞，每天除了看代码就是看代码。</p>\n<p>目前代码的阅读还算可以，复杂度与framework的复杂度相比还是不如的，但是对比我之前做的项目，架构却又好的太多太多了，所以自己还是有很大的必要从中进行学习的。</p>\n<p>目前大致任务就是检查2.0项目的必要内容，然后等接口来。</p>\n<p>这一周入门了go，希望能用go进行服务器端的开发任务。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>时光匆匆如水，我却总是忘了写周报。</p>\n<p>由于接口未好，导致前端的工作几乎停滞，每天除了看代码就是看代码。</p>\n<p>目前代码的阅读还算可以，复杂度与framework的复杂度相比还是不如的，但是对比我之前做的项目，架构却又好的太多太多了，所以自己还是有很大的必要从中进行学习的。</p>\n<p>目前大致任务就是检查2.0项目的必要内容，然后等接口来。</p>\n<p>这一周入门了go，希望能用go进行服务器端的开发任务。</p>\n"},{"title":"2018第十七周工作小结","date":"2018-05-01T15:45:39.000Z","_content":"\n最近实在是太忙了，忙到github都忘了更新博客了。每天都在忙着需求，改bug，然后项目追着上线。累的半死不活的。\n\n好消息是项目终于给整上线了，坏消息是项目上线之后可能会更忙。\n\n来公司2个月还没到，一下子回到了刚毕业的时候在传音那种加班加点很累的生活方式。不过好的是，起码现在自己是在做自己的事情。\n\n上周来了个大牛，技术比我厉害，也跟着他学习到了不少东西。需要整理一下。主要是http/https，okhttp工作原理，还有序列化原理等等。这些是学到的东西。\n\n工作上面的总结感觉没啥好说的，有两个要写一下，一个是activity栈的工作原理，一个是fragment栈的工作原理。目前了解一些，但是不够深入。\n\n明天开始仍然是进入学习的阶段。就先这样吧。\n","source":"_posts/2018第十七周工作小结.md","raw":"---\ntitle: 2018第十七周工作小结\ndate: 2018-05-01 23:45:39\ntags: 工作小结\n---\n\n最近实在是太忙了，忙到github都忘了更新博客了。每天都在忙着需求，改bug，然后项目追着上线。累的半死不活的。\n\n好消息是项目终于给整上线了，坏消息是项目上线之后可能会更忙。\n\n来公司2个月还没到，一下子回到了刚毕业的时候在传音那种加班加点很累的生活方式。不过好的是，起码现在自己是在做自己的事情。\n\n上周来了个大牛，技术比我厉害，也跟着他学习到了不少东西。需要整理一下。主要是http/https，okhttp工作原理，还有序列化原理等等。这些是学到的东西。\n\n工作上面的总结感觉没啥好说的，有两个要写一下，一个是activity栈的工作原理，一个是fragment栈的工作原理。目前了解一些，但是不够深入。\n\n明天开始仍然是进入学习的阶段。就先这样吧。\n","slug":"2018第十七周工作小结","published":1,"updated":"2019-03-12T09:26:33.143Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttx8001b3a8k8iqjwcwd","content":"<p>最近实在是太忙了，忙到github都忘了更新博客了。每天都在忙着需求，改bug，然后项目追着上线。累的半死不活的。</p>\n<p>好消息是项目终于给整上线了，坏消息是项目上线之后可能会更忙。</p>\n<p>来公司2个月还没到，一下子回到了刚毕业的时候在传音那种加班加点很累的生活方式。不过好的是，起码现在自己是在做自己的事情。</p>\n<p>上周来了个大牛，技术比我厉害，也跟着他学习到了不少东西。需要整理一下。主要是http/https，okhttp工作原理，还有序列化原理等等。这些是学到的东西。</p>\n<p>工作上面的总结感觉没啥好说的，有两个要写一下，一个是activity栈的工作原理，一个是fragment栈的工作原理。目前了解一些，但是不够深入。</p>\n<p>明天开始仍然是进入学习的阶段。就先这样吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近实在是太忙了，忙到github都忘了更新博客了。每天都在忙着需求，改bug，然后项目追着上线。累的半死不活的。</p>\n<p>好消息是项目终于给整上线了，坏消息是项目上线之后可能会更忙。</p>\n<p>来公司2个月还没到，一下子回到了刚毕业的时候在传音那种加班加点很累的生活方式。不过好的是，起码现在自己是在做自己的事情。</p>\n<p>上周来了个大牛，技术比我厉害，也跟着他学习到了不少东西。需要整理一下。主要是http/https，okhttp工作原理，还有序列化原理等等。这些是学到的东西。</p>\n<p>工作上面的总结感觉没啥好说的，有两个要写一下，一个是activity栈的工作原理，一个是fragment栈的工作原理。目前了解一些，但是不够深入。</p>\n<p>明天开始仍然是进入学习的阶段。就先这样吧。</p>\n"},{"title":"2018第十三周工作小结","date":"2018-04-05T13:59:54.000Z","_content":"\n上周实在是太忙了，周六加班，周日睡了一天，结果工作小结都没有来的及写。\n\n不过还是写一下吧。\n\n上周主要任务是适配接口，当时想了一套wrapper来封装接口的做法。但是现在想想，那也只是一种取巧而已。其实数据结构的使用并没有那么复杂，而且在调整数据结构的时候也可以更大程度的理解流程。\n\n上周整周都在调试接口中度过，刚开始还差点没来得及，后来王洋回来调，才来的及的。\n\n这周他走了，在20号之前，整个项目是我一个人负责了。难受。想哭。\n","source":"_posts/2018第十三周工作小结.md","raw":"---\ntitle: 2018第十三周工作小结\ndate: 2018-04-05 21:59:54\ntags: 工作小结\n---\n\n上周实在是太忙了，周六加班，周日睡了一天，结果工作小结都没有来的及写。\n\n不过还是写一下吧。\n\n上周主要任务是适配接口，当时想了一套wrapper来封装接口的做法。但是现在想想，那也只是一种取巧而已。其实数据结构的使用并没有那么复杂，而且在调整数据结构的时候也可以更大程度的理解流程。\n\n上周整周都在调试接口中度过，刚开始还差点没来得及，后来王洋回来调，才来的及的。\n\n这周他走了，在20号之前，整个项目是我一个人负责了。难受。想哭。\n","slug":"2018第十三周工作小结","published":1,"updated":"2019-03-12T09:26:33.143Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttx9001d3a8kdjnh32gf","content":"<p>上周实在是太忙了，周六加班，周日睡了一天，结果工作小结都没有来的及写。</p>\n<p>不过还是写一下吧。</p>\n<p>上周主要任务是适配接口，当时想了一套wrapper来封装接口的做法。但是现在想想，那也只是一种取巧而已。其实数据结构的使用并没有那么复杂，而且在调整数据结构的时候也可以更大程度的理解流程。</p>\n<p>上周整周都在调试接口中度过，刚开始还差点没来得及，后来王洋回来调，才来的及的。</p>\n<p>这周他走了，在20号之前，整个项目是我一个人负责了。难受。想哭。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>上周实在是太忙了，周六加班，周日睡了一天，结果工作小结都没有来的及写。</p>\n<p>不过还是写一下吧。</p>\n<p>上周主要任务是适配接口，当时想了一套wrapper来封装接口的做法。但是现在想想，那也只是一种取巧而已。其实数据结构的使用并没有那么复杂，而且在调整数据结构的时候也可以更大程度的理解流程。</p>\n<p>上周整周都在调试接口中度过，刚开始还差点没来得及，后来王洋回来调，才来的及的。</p>\n<p>这周他走了，在20号之前，整个项目是我一个人负责了。难受。想哭。</p>\n"},{"title":"2018第十九周工作小结","date":"2018-05-12T15:34:44.000Z","_content":"\n这一周主要任务是完成了好搭盒子2.0.2版本升级和上线。\n\n2.0.2版本主要是将会员系统更改了一下，同时更改了大量的ui，大量的工作是在业务代码上面。\n\n业务上面的东西可总结的比较少，不过这一周暴露了不少的问题。\n\n第一，待人处事方面。可能性格上面的原因，我总喜欢说一些冷话。比如说“我之前说过这个地方有问题”，“我之前反馈过这边设计不合理”等等。说实话，和产品的沟通家了一些这种话，会导致别人心情不好。这周我发现了不少这个方面的问题，说完之后别人的脸色就不好了。这部分要改。\n\n第二，口头禅方面。我最近发现我的口头禅“真的”，“没办法啊”，“我能怎么办”，这些不好，事实上在说这些话的时候，我压根没进脑子，单纯的应付式的谈话。这样很不好，给人一种不放在心上的感觉。\n\n第三，责任方面。我这个人有种压力一大，就开始烦躁的情况。这周由于任务划分不对，我给进奎的任务前期比较少，导致很多任务挤压在我头上，造成了我周四晚上一波情绪大反弹，我把一些气撒在了产品的头上。这个事后我立即发现并且做出了道歉，但是还是发生了。\n\n第四，产品优化方面。我发现我写的很多代码，没有考虑到性能，导致app卡顿现象比较严重，由于任务排期比较重，一直没有回头看。现在发现了几个明显的优化点，一是会员状态信息，可以使用本地存储，然后每次读取的时候走内存，只有在一些特定的情况下，比如说用户走了交押金系统，用户走了交会员费系统这些接口后，我清除会员状态并且重拉一下状态信息。二是每次获取account的时候，走了四次io，开销太大，这部分也需要更改。三是盒子部分的加载问题，也可以仿照会员状态更改来进行更改。\n\n针对以上问题，大概定了以下几个措施去规避。\n\n针对待人处事这部分，我仔细观察了一下，一定要像剑飞一样，脾气不能差，好好说话，有问题就仔细说出来。\n\n针对口头禅这一方面，我之后的谈话交流中，一定要认真进行交流，如果中途有事，就仔细说一下，不能这种应付式的谈话。\n\n针对责任方面，我需要仿照之前王洋每次对任务的划分安排，好好使用worktile，将任务仔细的划分开来，力争做到每个点都做完，都设计完，然后责任划分清晰后在动手进行设计安排。\n\n针对产品优化方面，近期主要是处理会员状态和account状态，不过这部分的时间安排需要在功能完成之后进行。\n\n完。\n","source":"_posts/2018第十九周工作小结.md","raw":"---\ntitle: 2018第十九周工作小结\ndate: 2018-05-12 23:34:44\ntags: 工作小结\n---\n\n这一周主要任务是完成了好搭盒子2.0.2版本升级和上线。\n\n2.0.2版本主要是将会员系统更改了一下，同时更改了大量的ui，大量的工作是在业务代码上面。\n\n业务上面的东西可总结的比较少，不过这一周暴露了不少的问题。\n\n第一，待人处事方面。可能性格上面的原因，我总喜欢说一些冷话。比如说“我之前说过这个地方有问题”，“我之前反馈过这边设计不合理”等等。说实话，和产品的沟通家了一些这种话，会导致别人心情不好。这周我发现了不少这个方面的问题，说完之后别人的脸色就不好了。这部分要改。\n\n第二，口头禅方面。我最近发现我的口头禅“真的”，“没办法啊”，“我能怎么办”，这些不好，事实上在说这些话的时候，我压根没进脑子，单纯的应付式的谈话。这样很不好，给人一种不放在心上的感觉。\n\n第三，责任方面。我这个人有种压力一大，就开始烦躁的情况。这周由于任务划分不对，我给进奎的任务前期比较少，导致很多任务挤压在我头上，造成了我周四晚上一波情绪大反弹，我把一些气撒在了产品的头上。这个事后我立即发现并且做出了道歉，但是还是发生了。\n\n第四，产品优化方面。我发现我写的很多代码，没有考虑到性能，导致app卡顿现象比较严重，由于任务排期比较重，一直没有回头看。现在发现了几个明显的优化点，一是会员状态信息，可以使用本地存储，然后每次读取的时候走内存，只有在一些特定的情况下，比如说用户走了交押金系统，用户走了交会员费系统这些接口后，我清除会员状态并且重拉一下状态信息。二是每次获取account的时候，走了四次io，开销太大，这部分也需要更改。三是盒子部分的加载问题，也可以仿照会员状态更改来进行更改。\n\n针对以上问题，大概定了以下几个措施去规避。\n\n针对待人处事这部分，我仔细观察了一下，一定要像剑飞一样，脾气不能差，好好说话，有问题就仔细说出来。\n\n针对口头禅这一方面，我之后的谈话交流中，一定要认真进行交流，如果中途有事，就仔细说一下，不能这种应付式的谈话。\n\n针对责任方面，我需要仿照之前王洋每次对任务的划分安排，好好使用worktile，将任务仔细的划分开来，力争做到每个点都做完，都设计完，然后责任划分清晰后在动手进行设计安排。\n\n针对产品优化方面，近期主要是处理会员状态和account状态，不过这部分的时间安排需要在功能完成之后进行。\n\n完。\n","slug":"2018第十九周工作小结","published":1,"updated":"2019-03-12T09:26:33.143Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxa001f3a8k5h4g4xql","content":"<p>这一周主要任务是完成了好搭盒子2.0.2版本升级和上线。</p>\n<p>2.0.2版本主要是将会员系统更改了一下，同时更改了大量的ui，大量的工作是在业务代码上面。</p>\n<p>业务上面的东西可总结的比较少，不过这一周暴露了不少的问题。</p>\n<p>第一，待人处事方面。可能性格上面的原因，我总喜欢说一些冷话。比如说“我之前说过这个地方有问题”，“我之前反馈过这边设计不合理”等等。说实话，和产品的沟通家了一些这种话，会导致别人心情不好。这周我发现了不少这个方面的问题，说完之后别人的脸色就不好了。这部分要改。</p>\n<p>第二，口头禅方面。我最近发现我的口头禅“真的”，“没办法啊”，“我能怎么办”，这些不好，事实上在说这些话的时候，我压根没进脑子，单纯的应付式的谈话。这样很不好，给人一种不放在心上的感觉。</p>\n<p>第三，责任方面。我这个人有种压力一大，就开始烦躁的情况。这周由于任务划分不对，我给进奎的任务前期比较少，导致很多任务挤压在我头上，造成了我周四晚上一波情绪大反弹，我把一些气撒在了产品的头上。这个事后我立即发现并且做出了道歉，但是还是发生了。</p>\n<p>第四，产品优化方面。我发现我写的很多代码，没有考虑到性能，导致app卡顿现象比较严重，由于任务排期比较重，一直没有回头看。现在发现了几个明显的优化点，一是会员状态信息，可以使用本地存储，然后每次读取的时候走内存，只有在一些特定的情况下，比如说用户走了交押金系统，用户走了交会员费系统这些接口后，我清除会员状态并且重拉一下状态信息。二是每次获取account的时候，走了四次io，开销太大，这部分也需要更改。三是盒子部分的加载问题，也可以仿照会员状态更改来进行更改。</p>\n<p>针对以上问题，大概定了以下几个措施去规避。</p>\n<p>针对待人处事这部分，我仔细观察了一下，一定要像剑飞一样，脾气不能差，好好说话，有问题就仔细说出来。</p>\n<p>针对口头禅这一方面，我之后的谈话交流中，一定要认真进行交流，如果中途有事，就仔细说一下，不能这种应付式的谈话。</p>\n<p>针对责任方面，我需要仿照之前王洋每次对任务的划分安排，好好使用worktile，将任务仔细的划分开来，力争做到每个点都做完，都设计完，然后责任划分清晰后在动手进行设计安排。</p>\n<p>针对产品优化方面，近期主要是处理会员状态和account状态，不过这部分的时间安排需要在功能完成之后进行。</p>\n<p>完。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这一周主要任务是完成了好搭盒子2.0.2版本升级和上线。</p>\n<p>2.0.2版本主要是将会员系统更改了一下，同时更改了大量的ui，大量的工作是在业务代码上面。</p>\n<p>业务上面的东西可总结的比较少，不过这一周暴露了不少的问题。</p>\n<p>第一，待人处事方面。可能性格上面的原因，我总喜欢说一些冷话。比如说“我之前说过这个地方有问题”，“我之前反馈过这边设计不合理”等等。说实话，和产品的沟通家了一些这种话，会导致别人心情不好。这周我发现了不少这个方面的问题，说完之后别人的脸色就不好了。这部分要改。</p>\n<p>第二，口头禅方面。我最近发现我的口头禅“真的”，“没办法啊”，“我能怎么办”，这些不好，事实上在说这些话的时候，我压根没进脑子，单纯的应付式的谈话。这样很不好，给人一种不放在心上的感觉。</p>\n<p>第三，责任方面。我这个人有种压力一大，就开始烦躁的情况。这周由于任务划分不对，我给进奎的任务前期比较少，导致很多任务挤压在我头上，造成了我周四晚上一波情绪大反弹，我把一些气撒在了产品的头上。这个事后我立即发现并且做出了道歉，但是还是发生了。</p>\n<p>第四，产品优化方面。我发现我写的很多代码，没有考虑到性能，导致app卡顿现象比较严重，由于任务排期比较重，一直没有回头看。现在发现了几个明显的优化点，一是会员状态信息，可以使用本地存储，然后每次读取的时候走内存，只有在一些特定的情况下，比如说用户走了交押金系统，用户走了交会员费系统这些接口后，我清除会员状态并且重拉一下状态信息。二是每次获取account的时候，走了四次io，开销太大，这部分也需要更改。三是盒子部分的加载问题，也可以仿照会员状态更改来进行更改。</p>\n<p>针对以上问题，大概定了以下几个措施去规避。</p>\n<p>针对待人处事这部分，我仔细观察了一下，一定要像剑飞一样，脾气不能差，好好说话，有问题就仔细说出来。</p>\n<p>针对口头禅这一方面，我之后的谈话交流中，一定要认真进行交流，如果中途有事，就仔细说一下，不能这种应付式的谈话。</p>\n<p>针对责任方面，我需要仿照之前王洋每次对任务的划分安排，好好使用worktile，将任务仔细的划分开来，力争做到每个点都做完，都设计完，然后责任划分清晰后在动手进行设计安排。</p>\n<p>针对产品优化方面，近期主要是处理会员状态和account状态，不过这部分的时间安排需要在功能完成之后进行。</p>\n<p>完。</p>\n"},{"title":"2018第十二周工作小结","date":"2018-03-25T08:48:41.000Z","_content":"\n这周大部分任务都是处理项目相关的内容了。\n\n首先是项目部分的需求改动，主要这次是关于盒子的需求更改，内容不多，主要是vip费用部分，还有就是订单部分的更改。等待接口好了就可以动工。\n\n其次是将之前wantu图床改成oss图床，另外将原来下载方式也改成oss的。改下载方式其实就是换了个channel，但是wantu改成oss图床还没弄好，目前上传总是失败。需要搞一下。\n\n本周就做了这几个内容。\n\n下周接口好了就要开始加班了。\n","source":"_posts/2018第十二周工作小结.md","raw":"---\ntitle: 2018第十二周工作小结\ndate: 2018-03-25 16:48:41\ntags: 工作小结\n---\n\n这周大部分任务都是处理项目相关的内容了。\n\n首先是项目部分的需求改动，主要这次是关于盒子的需求更改，内容不多，主要是vip费用部分，还有就是订单部分的更改。等待接口好了就可以动工。\n\n其次是将之前wantu图床改成oss图床，另外将原来下载方式也改成oss的。改下载方式其实就是换了个channel，但是wantu改成oss图床还没弄好，目前上传总是失败。需要搞一下。\n\n本周就做了这几个内容。\n\n下周接口好了就要开始加班了。\n","slug":"2018第十二周工作小结","published":1,"updated":"2019-03-12T09:26:33.143Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxb001h3a8kwhb0snf0","content":"<p>这周大部分任务都是处理项目相关的内容了。</p>\n<p>首先是项目部分的需求改动，主要这次是关于盒子的需求更改，内容不多，主要是vip费用部分，还有就是订单部分的更改。等待接口好了就可以动工。</p>\n<p>其次是将之前wantu图床改成oss图床，另外将原来下载方式也改成oss的。改下载方式其实就是换了个channel，但是wantu改成oss图床还没弄好，目前上传总是失败。需要搞一下。</p>\n<p>本周就做了这几个内容。</p>\n<p>下周接口好了就要开始加班了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这周大部分任务都是处理项目相关的内容了。</p>\n<p>首先是项目部分的需求改动，主要这次是关于盒子的需求更改，内容不多，主要是vip费用部分，还有就是订单部分的更改。等待接口好了就可以动工。</p>\n<p>其次是将之前wantu图床改成oss图床，另外将原来下载方式也改成oss的。改下载方式其实就是换了个channel，但是wantu改成oss图床还没弄好，目前上传总是失败。需要搞一下。</p>\n<p>本周就做了这几个内容。</p>\n<p>下周接口好了就要开始加班了。</p>\n"},{"title":"2018第十五周工作小结","date":"2018-04-16T06:08:02.000Z","_content":"\n14周的工作小结没写，也就不写了。总结一下上一周，也就是十五周吧。\n\n15周周二的时候，完成了手头的开发任务，进入到了debug状态，面对的头上很多很多的bug，亚历山大。\n\n具体的bug，其实已经忘了差不多了，印象深刻的就2个，一个是当时butterknife的snapshot版本的bug，巨蛋疼，昨天能用的代码今天不能用了，还没办法搞，当时折腾了好久好久，连事件传递过程都全部debug一边，还是没查出问题。最后是涛哥反编译之后对比，才忽然发现bindviews导致的bug。\n\n由于这个bug，让我的开发周期硬生生拖慢了一天，然后无休无止的折腾后续的bug，后续的bug大多数都是流程的问题，流程相关导致的bug。总体上分为两种，一种是activity切换fragment，一种是activity切activity然后切fragment，目前用的是eventbus和arouter，加上startactivity和startfragment，总结下来发现关于activity管理的fragment栈我还是不是很懂。后续需要加强。\n\n其余的没啥好说的了。这一周很累，不过和在传音的时候那种没事做还被逼着加班的累却不同。\n\n在其位必谋其政，有所失也必然有所得。\n","source":"_posts/2018第十五周工作小结.md","raw":"---\ntitle: 2018第十五周工作小结\ndate: 2018-04-16 14:08:02\ntags: 工作小结\n---\n\n14周的工作小结没写，也就不写了。总结一下上一周，也就是十五周吧。\n\n15周周二的时候，完成了手头的开发任务，进入到了debug状态，面对的头上很多很多的bug，亚历山大。\n\n具体的bug，其实已经忘了差不多了，印象深刻的就2个，一个是当时butterknife的snapshot版本的bug，巨蛋疼，昨天能用的代码今天不能用了，还没办法搞，当时折腾了好久好久，连事件传递过程都全部debug一边，还是没查出问题。最后是涛哥反编译之后对比，才忽然发现bindviews导致的bug。\n\n由于这个bug，让我的开发周期硬生生拖慢了一天，然后无休无止的折腾后续的bug，后续的bug大多数都是流程的问题，流程相关导致的bug。总体上分为两种，一种是activity切换fragment，一种是activity切activity然后切fragment，目前用的是eventbus和arouter，加上startactivity和startfragment，总结下来发现关于activity管理的fragment栈我还是不是很懂。后续需要加强。\n\n其余的没啥好说的了。这一周很累，不过和在传音的时候那种没事做还被逼着加班的累却不同。\n\n在其位必谋其政，有所失也必然有所得。\n","slug":"2018第十五周工作小结","published":1,"updated":"2019-03-12T09:26:33.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxc001j3a8krjums0re","content":"<p>14周的工作小结没写，也就不写了。总结一下上一周，也就是十五周吧。</p>\n<p>15周周二的时候，完成了手头的开发任务，进入到了debug状态，面对的头上很多很多的bug，亚历山大。</p>\n<p>具体的bug，其实已经忘了差不多了，印象深刻的就2个，一个是当时butterknife的snapshot版本的bug，巨蛋疼，昨天能用的代码今天不能用了，还没办法搞，当时折腾了好久好久，连事件传递过程都全部debug一边，还是没查出问题。最后是涛哥反编译之后对比，才忽然发现bindviews导致的bug。</p>\n<p>由于这个bug，让我的开发周期硬生生拖慢了一天，然后无休无止的折腾后续的bug，后续的bug大多数都是流程的问题，流程相关导致的bug。总体上分为两种，一种是activity切换fragment，一种是activity切activity然后切fragment，目前用的是eventbus和arouter，加上startactivity和startfragment，总结下来发现关于activity管理的fragment栈我还是不是很懂。后续需要加强。</p>\n<p>其余的没啥好说的了。这一周很累，不过和在传音的时候那种没事做还被逼着加班的累却不同。</p>\n<p>在其位必谋其政，有所失也必然有所得。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>14周的工作小结没写，也就不写了。总结一下上一周，也就是十五周吧。</p>\n<p>15周周二的时候，完成了手头的开发任务，进入到了debug状态，面对的头上很多很多的bug，亚历山大。</p>\n<p>具体的bug，其实已经忘了差不多了，印象深刻的就2个，一个是当时butterknife的snapshot版本的bug，巨蛋疼，昨天能用的代码今天不能用了，还没办法搞，当时折腾了好久好久，连事件传递过程都全部debug一边，还是没查出问题。最后是涛哥反编译之后对比，才忽然发现bindviews导致的bug。</p>\n<p>由于这个bug，让我的开发周期硬生生拖慢了一天，然后无休无止的折腾后续的bug，后续的bug大多数都是流程的问题，流程相关导致的bug。总体上分为两种，一种是activity切换fragment，一种是activity切activity然后切fragment，目前用的是eventbus和arouter，加上startactivity和startfragment，总结下来发现关于activity管理的fragment栈我还是不是很懂。后续需要加强。</p>\n<p>其余的没啥好说的了。这一周很累，不过和在传音的时候那种没事做还被逼着加班的累却不同。</p>\n<p>在其位必谋其政，有所失也必然有所得。</p>\n"},{"title":"2018第十八周工作小结","date":"2018-05-07T16:24:47.000Z","_content":"\n5月份已经过去了，进入公司也已经超过2个月了，事实上给我带来的感觉不是很好。\n\nios的两位同事都离开了公司，他们的想法我也知道一些。\n\n和vp的聊天，发现可能对我还是有一些意见的。很担心转正的时候被使绊子。\n\n不过没办法，所有的事情光担心可不行。\n\n上周的工作主要是做了2.0.1版本的迭代。加了一些新的功能，例如微信绑定手机号，个性化推荐等等。\n\n主要问题是发版本的时候出现的，一个是关于constantlayout的布局使用不规范，基准view放在的错误的地方，导致27版本的buildtool的布局器编译不通过。后来采取的重新画布局的方法规避。\n\n这次编译也让我感觉了一些问题，虽然在debug阶段，或者说做别的事情上面，还可以，但是编译不是很熟练导致最后进行发版本的时候卡顿。\n\n现在使用台式机编译，效率好很多。但是还是要注意。\n\nps：和涛哥的谈话，说实话让我感觉我在他眼里有很多问题，我甚至觉得他有些劝退我。希望不是吧，希望只是我自己多想了。我并没有不努力。\n","source":"_posts/2018第十八周工作小结.md","raw":"---\ntitle: 2018第十八周工作小结\ndate: 2018-05-08 00:24:47\ntags: 工作小结\n---\n\n5月份已经过去了，进入公司也已经超过2个月了，事实上给我带来的感觉不是很好。\n\nios的两位同事都离开了公司，他们的想法我也知道一些。\n\n和vp的聊天，发现可能对我还是有一些意见的。很担心转正的时候被使绊子。\n\n不过没办法，所有的事情光担心可不行。\n\n上周的工作主要是做了2.0.1版本的迭代。加了一些新的功能，例如微信绑定手机号，个性化推荐等等。\n\n主要问题是发版本的时候出现的，一个是关于constantlayout的布局使用不规范，基准view放在的错误的地方，导致27版本的buildtool的布局器编译不通过。后来采取的重新画布局的方法规避。\n\n这次编译也让我感觉了一些问题，虽然在debug阶段，或者说做别的事情上面，还可以，但是编译不是很熟练导致最后进行发版本的时候卡顿。\n\n现在使用台式机编译，效率好很多。但是还是要注意。\n\nps：和涛哥的谈话，说实话让我感觉我在他眼里有很多问题，我甚至觉得他有些劝退我。希望不是吧，希望只是我自己多想了。我并没有不努力。\n","slug":"2018第十八周工作小结","published":1,"updated":"2019-03-12T09:26:33.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxd001l3a8kduqqnfoe","content":"<p>5月份已经过去了，进入公司也已经超过2个月了，事实上给我带来的感觉不是很好。</p>\n<p>ios的两位同事都离开了公司，他们的想法我也知道一些。</p>\n<p>和vp的聊天，发现可能对我还是有一些意见的。很担心转正的时候被使绊子。</p>\n<p>不过没办法，所有的事情光担心可不行。</p>\n<p>上周的工作主要是做了2.0.1版本的迭代。加了一些新的功能，例如微信绑定手机号，个性化推荐等等。</p>\n<p>主要问题是发版本的时候出现的，一个是关于constantlayout的布局使用不规范，基准view放在的错误的地方，导致27版本的buildtool的布局器编译不通过。后来采取的重新画布局的方法规避。</p>\n<p>这次编译也让我感觉了一些问题，虽然在debug阶段，或者说做别的事情上面，还可以，但是编译不是很熟练导致最后进行发版本的时候卡顿。</p>\n<p>现在使用台式机编译，效率好很多。但是还是要注意。</p>\n<p>ps：和涛哥的谈话，说实话让我感觉我在他眼里有很多问题，我甚至觉得他有些劝退我。希望不是吧，希望只是我自己多想了。我并没有不努力。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>5月份已经过去了，进入公司也已经超过2个月了，事实上给我带来的感觉不是很好。</p>\n<p>ios的两位同事都离开了公司，他们的想法我也知道一些。</p>\n<p>和vp的聊天，发现可能对我还是有一些意见的。很担心转正的时候被使绊子。</p>\n<p>不过没办法，所有的事情光担心可不行。</p>\n<p>上周的工作主要是做了2.0.1版本的迭代。加了一些新的功能，例如微信绑定手机号，个性化推荐等等。</p>\n<p>主要问题是发版本的时候出现的，一个是关于constantlayout的布局使用不规范，基准view放在的错误的地方，导致27版本的buildtool的布局器编译不通过。后来采取的重新画布局的方法规避。</p>\n<p>这次编译也让我感觉了一些问题，虽然在debug阶段，或者说做别的事情上面，还可以，但是编译不是很熟练导致最后进行发版本的时候卡顿。</p>\n<p>现在使用台式机编译，效率好很多。但是还是要注意。</p>\n<p>ps：和涛哥的谈话，说实话让我感觉我在他眼里有很多问题，我甚至觉得他有些劝退我。希望不是吧，希望只是我自己多想了。我并没有不努力。</p>\n"},{"title":"2018第十六周工作小结","date":"2018-04-22T09:01:05.000Z","_content":"\n这周简直是崩溃的一周。\n\n首先是上一周没有休息，加上上周由于假期多上了一天，导致连着9点到晚上10点多（甚至凌晨）13天，身体在周三的时候报警，整个人精神状态十分不佳，加上深陷在我写的bug中无法自拔，整个人基本上是废了的状态。\n\n昨天整整睡了一天，今天精神才缓过来。\n\n这一周的工作情况也不容乐观，一边开发加需求，一边修改bug，压力是在是太大，所有的东西都要我来改，十分十分的蛋疼。产品那边催，技术总监那边也在催，就是周五上线周五上线。\n\n可是我能怎么办呢？我除了硬着头皮上还能做什么呢？\n\n算了，额外的话不说了，说一下这周做了什么吧。\n\n这周重写了购物车的缓存，针对目前的需求针对化的重写了一些方法。但是bug太多，购物车和订单2个互联的东西，写起来说实话坑还蛮多的。目前还有关于购物车的删除事件的处理行为，这个很麻烦，不知道用什么来删除，目前使用的是遍历，效率十分的低。\n\n这周说实话就做了这么一些东西，下周就是埋点和功能的设计，今天还要解一些bug。难受\n","source":"_posts/2018第十六周工作小结.md","raw":"---\ntitle: 2018第十六周工作小结\ndate: 2018-04-22 17:01:05\ntags: 工作小结\n---\n\n这周简直是崩溃的一周。\n\n首先是上一周没有休息，加上上周由于假期多上了一天，导致连着9点到晚上10点多（甚至凌晨）13天，身体在周三的时候报警，整个人精神状态十分不佳，加上深陷在我写的bug中无法自拔，整个人基本上是废了的状态。\n\n昨天整整睡了一天，今天精神才缓过来。\n\n这一周的工作情况也不容乐观，一边开发加需求，一边修改bug，压力是在是太大，所有的东西都要我来改，十分十分的蛋疼。产品那边催，技术总监那边也在催，就是周五上线周五上线。\n\n可是我能怎么办呢？我除了硬着头皮上还能做什么呢？\n\n算了，额外的话不说了，说一下这周做了什么吧。\n\n这周重写了购物车的缓存，针对目前的需求针对化的重写了一些方法。但是bug太多，购物车和订单2个互联的东西，写起来说实话坑还蛮多的。目前还有关于购物车的删除事件的处理行为，这个很麻烦，不知道用什么来删除，目前使用的是遍历，效率十分的低。\n\n这周说实话就做了这么一些东西，下周就是埋点和功能的设计，今天还要解一些bug。难受\n","slug":"2018第十六周工作小结","published":1,"updated":"2019-03-12T09:26:33.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxd001n3a8kyo80wc5g","content":"<p>这周简直是崩溃的一周。</p>\n<p>首先是上一周没有休息，加上上周由于假期多上了一天，导致连着9点到晚上10点多（甚至凌晨）13天，身体在周三的时候报警，整个人精神状态十分不佳，加上深陷在我写的bug中无法自拔，整个人基本上是废了的状态。</p>\n<p>昨天整整睡了一天，今天精神才缓过来。</p>\n<p>这一周的工作情况也不容乐观，一边开发加需求，一边修改bug，压力是在是太大，所有的东西都要我来改，十分十分的蛋疼。产品那边催，技术总监那边也在催，就是周五上线周五上线。</p>\n<p>可是我能怎么办呢？我除了硬着头皮上还能做什么呢？</p>\n<p>算了，额外的话不说了，说一下这周做了什么吧。</p>\n<p>这周重写了购物车的缓存，针对目前的需求针对化的重写了一些方法。但是bug太多，购物车和订单2个互联的东西，写起来说实话坑还蛮多的。目前还有关于购物车的删除事件的处理行为，这个很麻烦，不知道用什么来删除，目前使用的是遍历，效率十分的低。</p>\n<p>这周说实话就做了这么一些东西，下周就是埋点和功能的设计，今天还要解一些bug。难受</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这周简直是崩溃的一周。</p>\n<p>首先是上一周没有休息，加上上周由于假期多上了一天，导致连着9点到晚上10点多（甚至凌晨）13天，身体在周三的时候报警，整个人精神状态十分不佳，加上深陷在我写的bug中无法自拔，整个人基本上是废了的状态。</p>\n<p>昨天整整睡了一天，今天精神才缓过来。</p>\n<p>这一周的工作情况也不容乐观，一边开发加需求，一边修改bug，压力是在是太大，所有的东西都要我来改，十分十分的蛋疼。产品那边催，技术总监那边也在催，就是周五上线周五上线。</p>\n<p>可是我能怎么办呢？我除了硬着头皮上还能做什么呢？</p>\n<p>算了，额外的话不说了，说一下这周做了什么吧。</p>\n<p>这周重写了购物车的缓存，针对目前的需求针对化的重写了一些方法。但是bug太多，购物车和订单2个互联的东西，写起来说实话坑还蛮多的。目前还有关于购物车的删除事件的处理行为，这个很麻烦，不知道用什么来删除，目前使用的是遍历，效率十分的低。</p>\n<p>这周说实话就做了这么一些东西，下周就是埋点和功能的设计，今天还要解一些bug。难受</p>\n"},{"title":"2018第十周工作小结","date":"2018-03-12T11:27:09.000Z","_content":"\n由于周末去了趟南京，休息不够，回来很早的躺下了，因此昨天没有写工作小结，今天补一下。\n\n第十周周三入职了好买衣，主要负责维护android端的任务。\n\n整个架构是clean架构，刚开始看起来还晕晕乎乎的，接触了几天发现这个架构的确设计的很牛逼，实体类，数据结构等等，都放在内层，和外层通过中间层沟通，外层是入口，解偶思想出色。\n\n另外就是学习如何进行打渠道包，打debug包，还有解决了gradlew编译不同过等问题。\n\n感觉做了很多都是不了解的工具方面的知识，其余的android的知识还没有完全开始。\n\n工作加油，努力！\n","source":"_posts/2018第十周工作小结.md","raw":"---\ntitle: 2018第十周工作小结\ndate: 2018-03-12 19:27:09\ntags: 工作小结\n---\n\n由于周末去了趟南京，休息不够，回来很早的躺下了，因此昨天没有写工作小结，今天补一下。\n\n第十周周三入职了好买衣，主要负责维护android端的任务。\n\n整个架构是clean架构，刚开始看起来还晕晕乎乎的，接触了几天发现这个架构的确设计的很牛逼，实体类，数据结构等等，都放在内层，和外层通过中间层沟通，外层是入口，解偶思想出色。\n\n另外就是学习如何进行打渠道包，打debug包，还有解决了gradlew编译不同过等问题。\n\n感觉做了很多都是不了解的工具方面的知识，其余的android的知识还没有完全开始。\n\n工作加油，努力！\n","slug":"2018第十周工作小结","published":1,"updated":"2019-03-12T09:26:33.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxe001p3a8kbzwi7wkm","content":"<p>由于周末去了趟南京，休息不够，回来很早的躺下了，因此昨天没有写工作小结，今天补一下。</p>\n<p>第十周周三入职了好买衣，主要负责维护android端的任务。</p>\n<p>整个架构是clean架构，刚开始看起来还晕晕乎乎的，接触了几天发现这个架构的确设计的很牛逼，实体类，数据结构等等，都放在内层，和外层通过中间层沟通，外层是入口，解偶思想出色。</p>\n<p>另外就是学习如何进行打渠道包，打debug包，还有解决了gradlew编译不同过等问题。</p>\n<p>感觉做了很多都是不了解的工具方面的知识，其余的android的知识还没有完全开始。</p>\n<p>工作加油，努力！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>由于周末去了趟南京，休息不够，回来很早的躺下了，因此昨天没有写工作小结，今天补一下。</p>\n<p>第十周周三入职了好买衣，主要负责维护android端的任务。</p>\n<p>整个架构是clean架构，刚开始看起来还晕晕乎乎的，接触了几天发现这个架构的确设计的很牛逼，实体类，数据结构等等，都放在内层，和外层通过中间层沟通，外层是入口，解偶思想出色。</p>\n<p>另外就是学习如何进行打渠道包，打debug包，还有解决了gradlew编译不同过等问题。</p>\n<p>感觉做了很多都是不了解的工具方面的知识，其余的android的知识还没有完全开始。</p>\n<p>工作加油，努力！</p>\n"},{"title":"2018第四周工作小结","date":"2018-01-28T09:45:07.000Z","_content":"\n这周把图表的那个做完，之后就继续做微信接口登陆的问题。\n图表的任务主要是收尾，将缓存什么的做了一下，持久层也做好了，将一些额外的feature结束，也就没任务了。没什么需要总结的。\n\n微信接口的问题，目前是商量好了使用v2的接口，获取到了一次性code，然后回传，这样在得到一次性token。\n需要继续做的事就是将返回的token想办法做一个有效期判定的措施，然后每次都根据这个进行判断。\n\n下周的任务，目前来看就这一个\n\n将微信token做一个持久化处理，然后针对返回的是否是404做一个注册操作。","source":"_posts/2018第四周工作小结.md","raw":"---\ntitle: 2018第四周工作小结\ndate: 2018-01-28 17:45:07\ntags: 工作小结\n---\n\n这周把图表的那个做完，之后就继续做微信接口登陆的问题。\n图表的任务主要是收尾，将缓存什么的做了一下，持久层也做好了，将一些额外的feature结束，也就没任务了。没什么需要总结的。\n\n微信接口的问题，目前是商量好了使用v2的接口，获取到了一次性code，然后回传，这样在得到一次性token。\n需要继续做的事就是将返回的token想办法做一个有效期判定的措施，然后每次都根据这个进行判断。\n\n下周的任务，目前来看就这一个\n\n将微信token做一个持久化处理，然后针对返回的是否是404做一个注册操作。","slug":"2018第四周工作小结","published":1,"updated":"2019-03-12T09:26:33.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxf001r3a8kcv7a8ozd","content":"<p>这周把图表的那个做完，之后就继续做微信接口登陆的问题。<br>图表的任务主要是收尾，将缓存什么的做了一下，持久层也做好了，将一些额外的feature结束，也就没任务了。没什么需要总结的。</p>\n<p>微信接口的问题，目前是商量好了使用v2的接口，获取到了一次性code，然后回传，这样在得到一次性token。<br>需要继续做的事就是将返回的token想办法做一个有效期判定的措施，然后每次都根据这个进行判断。</p>\n<p>下周的任务，目前来看就这一个</p>\n<p>将微信token做一个持久化处理，然后针对返回的是否是404做一个注册操作。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这周把图表的那个做完，之后就继续做微信接口登陆的问题。<br>图表的任务主要是收尾，将缓存什么的做了一下，持久层也做好了，将一些额外的feature结束，也就没任务了。没什么需要总结的。</p>\n<p>微信接口的问题，目前是商量好了使用v2的接口，获取到了一次性code，然后回传，这样在得到一次性token。<br>需要继续做的事就是将返回的token想办法做一个有效期判定的措施，然后每次都根据这个进行判断。</p>\n<p>下周的任务，目前来看就这一个</p>\n<p>将微信token做一个持久化处理，然后针对返回的是否是404做一个注册操作。</p>\n"},{"title":"Android性能优化","date":"2018-01-25T08:00:25.000Z","_content":"\n# 布局优化\n\n1. ui渲染机制\n\nandroid中，系统通过VSYNC信号触发对ui的渲染、重绘，间隔是16ms，即每秒60帧。\n如果系统每次渲染的时间都保持在16ms之内，那么我们看见的ui界面是非常流畅的，这需要讲所有程序的逻辑都保证在16ms之内，如果不能在16ms内完成绘制，就会造成丢帧现象。\n导致16ms*n一直显示同一帧，产生卡顿的现象\n\n\n2. 避免Overdraw\n\n过度绘制是指给布局绘制了重叠的背景，过度绘制会浪费很多的cpu、gpu资源。使用GPU OVERDRAW可以检查\n\n3. 优化布局层级\n\nandroid中，系统对view进行测量、布局和绘制时，都是通过对view树的遍历来进行操作的，如果一个view树太高，就会严重影响测量、布局和绘制的速度，因此优化布局的第一个方法就是降低view树的高度，树的高度不宜超过10层。\n\n使用RelativeLayout可以有效降低嵌套。\n\n4. 避免嵌套过多无用布局\n\n嵌套的布局会让view树的高度越来越高，因此在布局时，需要根据自身布局的特点来选择不同的layout组件，从而避免通过某一种layout组件来实现功能时的局限性，从而造成嵌套过多的情况发生。\n\n使用<include>可以复用标签\n使用<viewstub>可以实现view的延迟加载。viewstub只有在显示时才会去渲染整个布局，而view.gone，在初始化布局树的时候就已经添加在布局树上面了。\n\n\n5. Hierarcy Viewer\n\n使用Hierarcy可以很容易的看到布局结构，找到冗杂的布局进行优化。\n\n# 内存优化\n\n1. 什么是内存\n\n寄存器：速度最快的存储场所，因为寄存器位于处理器内部，在程序中无法控制\n栈：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中\n堆：存放由new创建的对象和数组，在堆中分配的内存，由java虚拟机的自动垃圾回收装置回收（gc）\n静态存储区域：静态存储区域就是指在固定的位置存放应用程序运行时一直存在的数据，java专门划分了一个静态存储区来管理一些特殊的数据变量，如静态的数据变量。\n常量池：jvm虚拟机必须为每个被装载的类型维护一个常量池，常量池就是该类型所用到常量的一个有序集合，包括直接常量和对其他类型、字段和方法的符号引用。\n\n```\n\tActivityManager manager = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);\n\tint heapSize = manager.getLargeMemoryClass();\n```\n\n使用如上代码可以获取heap的大小。\n\n2. 获取android系统内存信息\n\nProcess state: 在android k 以上设置中开启该功能，进行内存的监视。\n\n也可以使用 \n\n```\n\tadb shell dumpsys procstats\n```\n\nMeminfo: \n\n```\n\tadb shell dumpsys meminfo\n```\n\n3. 内存回收\n\n使用System.gc()可以建议系统进行gc，但系统是否采纳就不一定，有些对象因为算法的原因，不在回收，就会造成内存泄漏\n\n4. 内存优化实例\n\nbitmap优化：bitmap是造成内存占用过高，甚至是oom的最大威胁。可以使用适当分辨率和大小的图片，及时使用bitmap.recycle()回收内存，使用图片缓存（内存缓存或硬盘缓存）来减少该问题的发生。\n\n代码优化：\n1. 对常量使用static修饰符\n2. 使用静态方法，静态方法会比普通方法提高15%的访问速度\n3. 减少不必要的成员变量\n4. 减少不必要的对象，使用基础类型会比使用对象更加节省资源，同时更应避免频繁创建短作用域的变量。\n5. 尽量不用使用枚举，少用迭代器\n6. 对Cursor, Receiver, Sensor, File等对象，要非常注意对他们的创建，回收与注册，解注册。\n7. 避免使用IOC框架，注解和反射会带来性能的下降\n8. 使用RenderScript, OpenGL来进行非常复杂的绘图操作\n9. 使用SurfaceView来替代view进行大量、频繁的绘图操作\n10. 尽量使用视图缓存，而不是每次都执行inflate（）方法。","source":"_posts/Android性能优化.md","raw":"---\ntitle: Android性能优化\ndate: 2018-01-25 16:00:25\ntags: android\n---\n\n# 布局优化\n\n1. ui渲染机制\n\nandroid中，系统通过VSYNC信号触发对ui的渲染、重绘，间隔是16ms，即每秒60帧。\n如果系统每次渲染的时间都保持在16ms之内，那么我们看见的ui界面是非常流畅的，这需要讲所有程序的逻辑都保证在16ms之内，如果不能在16ms内完成绘制，就会造成丢帧现象。\n导致16ms*n一直显示同一帧，产生卡顿的现象\n\n\n2. 避免Overdraw\n\n过度绘制是指给布局绘制了重叠的背景，过度绘制会浪费很多的cpu、gpu资源。使用GPU OVERDRAW可以检查\n\n3. 优化布局层级\n\nandroid中，系统对view进行测量、布局和绘制时，都是通过对view树的遍历来进行操作的，如果一个view树太高，就会严重影响测量、布局和绘制的速度，因此优化布局的第一个方法就是降低view树的高度，树的高度不宜超过10层。\n\n使用RelativeLayout可以有效降低嵌套。\n\n4. 避免嵌套过多无用布局\n\n嵌套的布局会让view树的高度越来越高，因此在布局时，需要根据自身布局的特点来选择不同的layout组件，从而避免通过某一种layout组件来实现功能时的局限性，从而造成嵌套过多的情况发生。\n\n使用<include>可以复用标签\n使用<viewstub>可以实现view的延迟加载。viewstub只有在显示时才会去渲染整个布局，而view.gone，在初始化布局树的时候就已经添加在布局树上面了。\n\n\n5. Hierarcy Viewer\n\n使用Hierarcy可以很容易的看到布局结构，找到冗杂的布局进行优化。\n\n# 内存优化\n\n1. 什么是内存\n\n寄存器：速度最快的存储场所，因为寄存器位于处理器内部，在程序中无法控制\n栈：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中\n堆：存放由new创建的对象和数组，在堆中分配的内存，由java虚拟机的自动垃圾回收装置回收（gc）\n静态存储区域：静态存储区域就是指在固定的位置存放应用程序运行时一直存在的数据，java专门划分了一个静态存储区来管理一些特殊的数据变量，如静态的数据变量。\n常量池：jvm虚拟机必须为每个被装载的类型维护一个常量池，常量池就是该类型所用到常量的一个有序集合，包括直接常量和对其他类型、字段和方法的符号引用。\n\n```\n\tActivityManager manager = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);\n\tint heapSize = manager.getLargeMemoryClass();\n```\n\n使用如上代码可以获取heap的大小。\n\n2. 获取android系统内存信息\n\nProcess state: 在android k 以上设置中开启该功能，进行内存的监视。\n\n也可以使用 \n\n```\n\tadb shell dumpsys procstats\n```\n\nMeminfo: \n\n```\n\tadb shell dumpsys meminfo\n```\n\n3. 内存回收\n\n使用System.gc()可以建议系统进行gc，但系统是否采纳就不一定，有些对象因为算法的原因，不在回收，就会造成内存泄漏\n\n4. 内存优化实例\n\nbitmap优化：bitmap是造成内存占用过高，甚至是oom的最大威胁。可以使用适当分辨率和大小的图片，及时使用bitmap.recycle()回收内存，使用图片缓存（内存缓存或硬盘缓存）来减少该问题的发生。\n\n代码优化：\n1. 对常量使用static修饰符\n2. 使用静态方法，静态方法会比普通方法提高15%的访问速度\n3. 减少不必要的成员变量\n4. 减少不必要的对象，使用基础类型会比使用对象更加节省资源，同时更应避免频繁创建短作用域的变量。\n5. 尽量不用使用枚举，少用迭代器\n6. 对Cursor, Receiver, Sensor, File等对象，要非常注意对他们的创建，回收与注册，解注册。\n7. 避免使用IOC框架，注解和反射会带来性能的下降\n8. 使用RenderScript, OpenGL来进行非常复杂的绘图操作\n9. 使用SurfaceView来替代view进行大量、频繁的绘图操作\n10. 尽量使用视图缓存，而不是每次都执行inflate（）方法。","slug":"Android性能优化","published":1,"updated":"2019-03-12T09:26:33.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxg001t3a8kh8kfqb2h","content":"<h1 id=\"布局优化\"><a href=\"#布局优化\" class=\"headerlink\" title=\"布局优化\"></a>布局优化</h1><ol>\n<li>ui渲染机制</li>\n</ol>\n<p>android中，系统通过VSYNC信号触发对ui的渲染、重绘，间隔是16ms，即每秒60帧。<br>如果系统每次渲染的时间都保持在16ms之内，那么我们看见的ui界面是非常流畅的，这需要讲所有程序的逻辑都保证在16ms之内，如果不能在16ms内完成绘制，就会造成丢帧现象。<br>导致16ms*n一直显示同一帧，产生卡顿的现象</p>\n<ol start=\"2\">\n<li>避免Overdraw</li>\n</ol>\n<p>过度绘制是指给布局绘制了重叠的背景，过度绘制会浪费很多的cpu、gpu资源。使用GPU OVERDRAW可以检查</p>\n<ol start=\"3\">\n<li>优化布局层级</li>\n</ol>\n<p>android中，系统对view进行测量、布局和绘制时，都是通过对view树的遍历来进行操作的，如果一个view树太高，就会严重影响测量、布局和绘制的速度，因此优化布局的第一个方法就是降低view树的高度，树的高度不宜超过10层。</p>\n<p>使用RelativeLayout可以有效降低嵌套。</p>\n<ol start=\"4\">\n<li>避免嵌套过多无用布局</li>\n</ol>\n<p>嵌套的布局会让view树的高度越来越高，因此在布局时，需要根据自身布局的特点来选择不同的layout组件，从而避免通过某一种layout组件来实现功能时的局限性，从而造成嵌套过多的情况发生。</p>\n<p>使用<include>可以复用标签<br>使用<viewstub>可以实现view的延迟加载。viewstub只有在显示时才会去渲染整个布局，而view.gone，在初始化布局树的时候就已经添加在布局树上面了。</viewstub></include></p>\n<ol start=\"5\">\n<li>Hierarcy Viewer</li>\n</ol>\n<p>使用Hierarcy可以很容易的看到布局结构，找到冗杂的布局进行优化。</p>\n<h1 id=\"内存优化\"><a href=\"#内存优化\" class=\"headerlink\" title=\"内存优化\"></a>内存优化</h1><ol>\n<li>什么是内存</li>\n</ol>\n<p>寄存器：速度最快的存储场所，因为寄存器位于处理器内部，在程序中无法控制<br>栈：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中<br>堆：存放由new创建的对象和数组，在堆中分配的内存，由java虚拟机的自动垃圾回收装置回收（gc）<br>静态存储区域：静态存储区域就是指在固定的位置存放应用程序运行时一直存在的数据，java专门划分了一个静态存储区来管理一些特殊的数据变量，如静态的数据变量。<br>常量池：jvm虚拟机必须为每个被装载的类型维护一个常量池，常量池就是该类型所用到常量的一个有序集合，包括直接常量和对其他类型、字段和方法的符号引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ActivityManager manager = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class=\"line\">int heapSize = manager.getLargeMemoryClass();</span><br></pre></td></tr></table></figure>\n<p>使用如上代码可以获取heap的大小。</p>\n<ol start=\"2\">\n<li>获取android系统内存信息</li>\n</ol>\n<p>Process state: 在android k 以上设置中开启该功能，进行内存的监视。</p>\n<p>也可以使用 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell dumpsys procstats</span><br></pre></td></tr></table></figure>\n<p>Meminfo: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell dumpsys meminfo</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>内存回收</li>\n</ol>\n<p>使用System.gc()可以建议系统进行gc，但系统是否采纳就不一定，有些对象因为算法的原因，不在回收，就会造成内存泄漏</p>\n<ol start=\"4\">\n<li>内存优化实例</li>\n</ol>\n<p>bitmap优化：bitmap是造成内存占用过高，甚至是oom的最大威胁。可以使用适当分辨率和大小的图片，及时使用bitmap.recycle()回收内存，使用图片缓存（内存缓存或硬盘缓存）来减少该问题的发生。</p>\n<p>代码优化：</p>\n<ol>\n<li>对常量使用static修饰符</li>\n<li>使用静态方法，静态方法会比普通方法提高15%的访问速度</li>\n<li>减少不必要的成员变量</li>\n<li>减少不必要的对象，使用基础类型会比使用对象更加节省资源，同时更应避免频繁创建短作用域的变量。</li>\n<li>尽量不用使用枚举，少用迭代器</li>\n<li>对Cursor, Receiver, Sensor, File等对象，要非常注意对他们的创建，回收与注册，解注册。</li>\n<li>避免使用IOC框架，注解和反射会带来性能的下降</li>\n<li>使用RenderScript, OpenGL来进行非常复杂的绘图操作</li>\n<li>使用SurfaceView来替代view进行大量、频繁的绘图操作</li>\n<li>尽量使用视图缓存，而不是每次都执行inflate（）方法。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"布局优化\"><a href=\"#布局优化\" class=\"headerlink\" title=\"布局优化\"></a>布局优化</h1><ol>\n<li>ui渲染机制</li>\n</ol>\n<p>android中，系统通过VSYNC信号触发对ui的渲染、重绘，间隔是16ms，即每秒60帧。<br>如果系统每次渲染的时间都保持在16ms之内，那么我们看见的ui界面是非常流畅的，这需要讲所有程序的逻辑都保证在16ms之内，如果不能在16ms内完成绘制，就会造成丢帧现象。<br>导致16ms*n一直显示同一帧，产生卡顿的现象</p>\n<ol start=\"2\">\n<li>避免Overdraw</li>\n</ol>\n<p>过度绘制是指给布局绘制了重叠的背景，过度绘制会浪费很多的cpu、gpu资源。使用GPU OVERDRAW可以检查</p>\n<ol start=\"3\">\n<li>优化布局层级</li>\n</ol>\n<p>android中，系统对view进行测量、布局和绘制时，都是通过对view树的遍历来进行操作的，如果一个view树太高，就会严重影响测量、布局和绘制的速度，因此优化布局的第一个方法就是降低view树的高度，树的高度不宜超过10层。</p>\n<p>使用RelativeLayout可以有效降低嵌套。</p>\n<ol start=\"4\">\n<li>避免嵌套过多无用布局</li>\n</ol>\n<p>嵌套的布局会让view树的高度越来越高，因此在布局时，需要根据自身布局的特点来选择不同的layout组件，从而避免通过某一种layout组件来实现功能时的局限性，从而造成嵌套过多的情况发生。</p>\n<p>使用<include>可以复用标签<br>使用<viewstub>可以实现view的延迟加载。viewstub只有在显示时才会去渲染整个布局，而view.gone，在初始化布局树的时候就已经添加在布局树上面了。</viewstub></include></p>\n<ol start=\"5\">\n<li>Hierarcy Viewer</li>\n</ol>\n<p>使用Hierarcy可以很容易的看到布局结构，找到冗杂的布局进行优化。</p>\n<h1 id=\"内存优化\"><a href=\"#内存优化\" class=\"headerlink\" title=\"内存优化\"></a>内存优化</h1><ol>\n<li>什么是内存</li>\n</ol>\n<p>寄存器：速度最快的存储场所，因为寄存器位于处理器内部，在程序中无法控制<br>栈：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中<br>堆：存放由new创建的对象和数组，在堆中分配的内存，由java虚拟机的自动垃圾回收装置回收（gc）<br>静态存储区域：静态存储区域就是指在固定的位置存放应用程序运行时一直存在的数据，java专门划分了一个静态存储区来管理一些特殊的数据变量，如静态的数据变量。<br>常量池：jvm虚拟机必须为每个被装载的类型维护一个常量池，常量池就是该类型所用到常量的一个有序集合，包括直接常量和对其他类型、字段和方法的符号引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ActivityManager manager = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class=\"line\">int heapSize = manager.getLargeMemoryClass();</span><br></pre></td></tr></table></figure>\n<p>使用如上代码可以获取heap的大小。</p>\n<ol start=\"2\">\n<li>获取android系统内存信息</li>\n</ol>\n<p>Process state: 在android k 以上设置中开启该功能，进行内存的监视。</p>\n<p>也可以使用 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell dumpsys procstats</span><br></pre></td></tr></table></figure>\n<p>Meminfo: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell dumpsys meminfo</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>内存回收</li>\n</ol>\n<p>使用System.gc()可以建议系统进行gc，但系统是否采纳就不一定，有些对象因为算法的原因，不在回收，就会造成内存泄漏</p>\n<ol start=\"4\">\n<li>内存优化实例</li>\n</ol>\n<p>bitmap优化：bitmap是造成内存占用过高，甚至是oom的最大威胁。可以使用适当分辨率和大小的图片，及时使用bitmap.recycle()回收内存，使用图片缓存（内存缓存或硬盘缓存）来减少该问题的发生。</p>\n<p>代码优化：</p>\n<ol>\n<li>对常量使用static修饰符</li>\n<li>使用静态方法，静态方法会比普通方法提高15%的访问速度</li>\n<li>减少不必要的成员变量</li>\n<li>减少不必要的对象，使用基础类型会比使用对象更加节省资源，同时更应避免频繁创建短作用域的变量。</li>\n<li>尽量不用使用枚举，少用迭代器</li>\n<li>对Cursor, Receiver, Sensor, File等对象，要非常注意对他们的创建，回收与注册，解注册。</li>\n<li>避免使用IOC框架，注解和反射会带来性能的下降</li>\n<li>使用RenderScript, OpenGL来进行非常复杂的绘图操作</li>\n<li>使用SurfaceView来替代view进行大量、频繁的绘图操作</li>\n<li>尽量使用视图缓存，而不是每次都执行inflate（）方法。</li>\n</ol>\n"},{"title":"Android系统信息和安全机制","date":"2018-01-25T03:51:19.000Z","_content":"\n# Android系统信息获取\n\n获取系统的配置信息，通常从build和systemproperty两个方面获取\n\n1. android.os.Build\n\n该类里面的信息非常丰富，包含了系统编译时的大量设备、配置信息\n\n2. SystemProperty\n\n该类包含了许多系统配置属性值和参数，有一些和build是相同的。\n\n3. Android系统信息实例\n\n```\n\tString board = Build.BOARD;\n\tString brand = Build.BRAND;\n\n\tString os_version = System.getProperty(\"os.version\");\n\tString os_name = System.getProperty(\"os.name\");\n```\n\n# Android Apk应用信息获取之PackageManager\n\nPM主宰着应用的包管理\n\n1. ActivityInfo: 封装了在Mainifest文件中<activity></activity>和<receiver></receiver>之间的所有信息，包括name，icon, label, launchmod等\n\n2. ServiceInfo: ServiceInfo与ActivityInfo类似，封装了<service></service>之间的所有信息\n\n3. ApplicationInfo: 封装了 <application></application>之间的信息，特别的是，applicationinfo包含了很多flag，通过这些flag，可以很方便的判断应用的类型\n\n4. PackageInfo: 封装了所有的activity，service等信息\n\n5. ResolveInfo: 封装的是包含<intent>信息的上一级信息，所以可以返回Activityinfo, ServiceInfo等包含<intent>的信息，可以用来找到含有特定intent条件的包\n\n# Android Apk应用信息获取之ActivityMananger\n\nAM可以获取正在运行的应用程序信息。\n\n1. AcitivtyManager.MemoryInfo\n\n全局内存信息，availMem是系统可用内存，totalMem是总内存，threshold是低内存的阀值，lowMemory是检查是否处于低内存。\n\n2. Debug.MemoryInfo\n\n用于获取统计进程下的内存信息。数据是由dvm虚拟机提供的。\n\n3. RunningAppProcessInfo\n\n运行进程的信息\n\n4. RunningServiceInfo\n\n用于封装运行的服务信息。\n\n","source":"_posts/Android系统信息和安全机制.md","raw":"---\ntitle: Android系统信息和安全机制\ndate: 2018-01-25 11:51:19\ntags: android\n---\n\n# Android系统信息获取\n\n获取系统的配置信息，通常从build和systemproperty两个方面获取\n\n1. android.os.Build\n\n该类里面的信息非常丰富，包含了系统编译时的大量设备、配置信息\n\n2. SystemProperty\n\n该类包含了许多系统配置属性值和参数，有一些和build是相同的。\n\n3. Android系统信息实例\n\n```\n\tString board = Build.BOARD;\n\tString brand = Build.BRAND;\n\n\tString os_version = System.getProperty(\"os.version\");\n\tString os_name = System.getProperty(\"os.name\");\n```\n\n# Android Apk应用信息获取之PackageManager\n\nPM主宰着应用的包管理\n\n1. ActivityInfo: 封装了在Mainifest文件中<activity></activity>和<receiver></receiver>之间的所有信息，包括name，icon, label, launchmod等\n\n2. ServiceInfo: ServiceInfo与ActivityInfo类似，封装了<service></service>之间的所有信息\n\n3. ApplicationInfo: 封装了 <application></application>之间的信息，特别的是，applicationinfo包含了很多flag，通过这些flag，可以很方便的判断应用的类型\n\n4. PackageInfo: 封装了所有的activity，service等信息\n\n5. ResolveInfo: 封装的是包含<intent>信息的上一级信息，所以可以返回Activityinfo, ServiceInfo等包含<intent>的信息，可以用来找到含有特定intent条件的包\n\n# Android Apk应用信息获取之ActivityMananger\n\nAM可以获取正在运行的应用程序信息。\n\n1. AcitivtyManager.MemoryInfo\n\n全局内存信息，availMem是系统可用内存，totalMem是总内存，threshold是低内存的阀值，lowMemory是检查是否处于低内存。\n\n2. Debug.MemoryInfo\n\n用于获取统计进程下的内存信息。数据是由dvm虚拟机提供的。\n\n3. RunningAppProcessInfo\n\n运行进程的信息\n\n4. RunningServiceInfo\n\n用于封装运行的服务信息。\n\n","slug":"Android系统信息和安全机制","published":1,"updated":"2019-03-12T09:26:33.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxi001v3a8khac99wor","content":"<h1 id=\"Android系统信息获取\"><a href=\"#Android系统信息获取\" class=\"headerlink\" title=\"Android系统信息获取\"></a>Android系统信息获取</h1><p>获取系统的配置信息，通常从build和systemproperty两个方面获取</p>\n<ol>\n<li>android.os.Build</li>\n</ol>\n<p>该类里面的信息非常丰富，包含了系统编译时的大量设备、配置信息</p>\n<ol start=\"2\">\n<li>SystemProperty</li>\n</ol>\n<p>该类包含了许多系统配置属性值和参数，有一些和build是相同的。</p>\n<ol start=\"3\">\n<li>Android系统信息实例</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String board = Build.BOARD;</span><br><span class=\"line\">String brand = Build.BRAND;</span><br><span class=\"line\"></span><br><span class=\"line\">String os_version = System.getProperty(&quot;os.version&quot;);</span><br><span class=\"line\">String os_name = System.getProperty(&quot;os.name&quot;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"Android-Apk应用信息获取之PackageManager\"><a href=\"#Android-Apk应用信息获取之PackageManager\" class=\"headerlink\" title=\"Android Apk应用信息获取之PackageManager\"></a>Android Apk应用信息获取之PackageManager</h1><p>PM主宰着应用的包管理</p>\n<ol>\n<li><p>ActivityInfo: 封装了在Mainifest文件中<activity></activity>和<receiver></receiver>之间的所有信息，包括name，icon, label, launchmod等</p>\n</li>\n<li><p>ServiceInfo: ServiceInfo与ActivityInfo类似，封装了<service></service>之间的所有信息</p>\n</li>\n<li><p>ApplicationInfo: 封装了 <application></application>之间的信息，特别的是，applicationinfo包含了很多flag，通过这些flag，可以很方便的判断应用的类型</p>\n</li>\n<li><p>PackageInfo: 封装了所有的activity，service等信息</p>\n</li>\n<li><p>ResolveInfo: 封装的是包含<intent>信息的上一级信息，所以可以返回Activityinfo, ServiceInfo等包含<intent>的信息，可以用来找到含有特定intent条件的包</intent></intent></p>\n</li>\n</ol>\n<h1 id=\"Android-Apk应用信息获取之ActivityMananger\"><a href=\"#Android-Apk应用信息获取之ActivityMananger\" class=\"headerlink\" title=\"Android Apk应用信息获取之ActivityMananger\"></a>Android Apk应用信息获取之ActivityMananger</h1><p>AM可以获取正在运行的应用程序信息。</p>\n<ol>\n<li>AcitivtyManager.MemoryInfo</li>\n</ol>\n<p>全局内存信息，availMem是系统可用内存，totalMem是总内存，threshold是低内存的阀值，lowMemory是检查是否处于低内存。</p>\n<ol start=\"2\">\n<li>Debug.MemoryInfo</li>\n</ol>\n<p>用于获取统计进程下的内存信息。数据是由dvm虚拟机提供的。</p>\n<ol start=\"3\">\n<li>RunningAppProcessInfo</li>\n</ol>\n<p>运行进程的信息</p>\n<ol start=\"4\">\n<li>RunningServiceInfo</li>\n</ol>\n<p>用于封装运行的服务信息。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Android系统信息获取\"><a href=\"#Android系统信息获取\" class=\"headerlink\" title=\"Android系统信息获取\"></a>Android系统信息获取</h1><p>获取系统的配置信息，通常从build和systemproperty两个方面获取</p>\n<ol>\n<li>android.os.Build</li>\n</ol>\n<p>该类里面的信息非常丰富，包含了系统编译时的大量设备、配置信息</p>\n<ol start=\"2\">\n<li>SystemProperty</li>\n</ol>\n<p>该类包含了许多系统配置属性值和参数，有一些和build是相同的。</p>\n<ol start=\"3\">\n<li>Android系统信息实例</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String board = Build.BOARD;</span><br><span class=\"line\">String brand = Build.BRAND;</span><br><span class=\"line\"></span><br><span class=\"line\">String os_version = System.getProperty(&quot;os.version&quot;);</span><br><span class=\"line\">String os_name = System.getProperty(&quot;os.name&quot;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"Android-Apk应用信息获取之PackageManager\"><a href=\"#Android-Apk应用信息获取之PackageManager\" class=\"headerlink\" title=\"Android Apk应用信息获取之PackageManager\"></a>Android Apk应用信息获取之PackageManager</h1><p>PM主宰着应用的包管理</p>\n<ol>\n<li><p>ActivityInfo: 封装了在Mainifest文件中<activity></activity>和<receiver></receiver>之间的所有信息，包括name，icon, label, launchmod等</p>\n</li>\n<li><p>ServiceInfo: ServiceInfo与ActivityInfo类似，封装了<service></service>之间的所有信息</p>\n</li>\n<li><p>ApplicationInfo: 封装了 <application></application>之间的信息，特别的是，applicationinfo包含了很多flag，通过这些flag，可以很方便的判断应用的类型</p>\n</li>\n<li><p>PackageInfo: 封装了所有的activity，service等信息</p>\n</li>\n<li><p>ResolveInfo: 封装的是包含<intent>信息的上一级信息，所以可以返回Activityinfo, ServiceInfo等包含<intent>的信息，可以用来找到含有特定intent条件的包</intent></intent></p>\n</li>\n</ol>\n<h1 id=\"Android-Apk应用信息获取之ActivityMananger\"><a href=\"#Android-Apk应用信息获取之ActivityMananger\" class=\"headerlink\" title=\"Android Apk应用信息获取之ActivityMananger\"></a>Android Apk应用信息获取之ActivityMananger</h1><p>AM可以获取正在运行的应用程序信息。</p>\n<ol>\n<li>AcitivtyManager.MemoryInfo</li>\n</ol>\n<p>全局内存信息，availMem是系统可用内存，totalMem是总内存，threshold是低内存的阀值，lowMemory是检查是否处于低内存。</p>\n<ol start=\"2\">\n<li>Debug.MemoryInfo</li>\n</ol>\n<p>用于获取统计进程下的内存信息。数据是由dvm虚拟机提供的。</p>\n<ol start=\"3\">\n<li>RunningAppProcessInfo</li>\n</ol>\n<p>运行进程的信息</p>\n<ol start=\"4\">\n<li>RunningServiceInfo</li>\n</ol>\n<p>用于封装运行的服务信息。</p>\n"},{"title":"Butterknife源码学习","date":"2018-12-06T10:56:37.000Z","_content":"\n项目中用的butterknife是8.8.1版本，引入了两个包，一个是Butterknife,一个是ButterKnife-Annotations。\n\n# 基本原理\n\nbutterknife的基本原理其实很好理解，就是注入，通过代码中的注解，编译时进行解析，生成大量的代码，这些代码在运行时帮助提供对象\n\n# 源码解析\n\n```\n  @NonNull @UiThread\n  public static Unbinder bind(@NonNull Activity target) {\n    View sourceView = target.getWindow().getDecorView();\n    return createBinding(target, sourceView);\n  }\n```\n这段代码是默认的绑定代码，其调用了\n```\nprivate static Unbinder createBinding(@NonNull Object target, @NonNull View source) {\n    Class<?> targetClass = target.getClass();\n    if (debug) Log.d(TAG, \"Looking up binding for \" + targetClass.getName());\n    Constructor<? extends Unbinder> constructor = findBindingConstructorForClass(targetClass);\n\n    if (constructor == null) {\n      return Unbinder.EMPTY;\n    }\n\n    //noinspection TryWithIdenticalCatches Resolves to API 19+ only type.\n    try {\n      return constructor.newInstance(target, source);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Unable to invoke \" + constructor, e);\n    } catch (InstantiationException e) {\n      throw new RuntimeException(\"Unable to invoke \" + constructor, e);\n    } catch (InvocationTargetException e) {\n      Throwable cause = e.getCause();\n      if (cause instanceof RuntimeException) {\n        throw (RuntimeException) cause;\n      }\n      if (cause instanceof Error) {\n        throw (Error) cause;\n      }\n      throw new RuntimeException(\"Unable to create binding instance.\", cause);\n    }\n  }\n```\n这段话只是执行了findBindingConstructorForClass这个方法，返回了一个unbind\n\n```\n  @Nullable @CheckResult @UiThread\n  private static Constructor<? extends Unbinder> findBindingConstructorForClass(Class<?> cls) {\n    Constructor<? extends Unbinder> bindingCtor = BINDINGS.get(cls);\n    if (bindingCtor != null) {\n      if (debug) Log.d(TAG, \"HIT: Cached in binding map.\");\n      return bindingCtor;\n    }\n    String clsName = cls.getName();\n    if (clsName.startsWith(\"android.\") || clsName.startsWith(\"java.\")) {\n      if (debug) Log.d(TAG, \"MISS: Reached framework class. Abandoning search.\");\n      return null;\n    }\n    try {\n      Class<?> bindingClass = cls.getClassLoader().loadClass(clsName + \"_ViewBinding\");\n      //noinspection unchecked\n      bindingCtor = (Constructor<? extends Unbinder>) bindingClass.getConstructor(cls, View.class);\n      if (debug) Log.d(TAG, \"HIT: Loaded binding class and constructor.\");\n    } catch (ClassNotFoundException e) {\n      if (debug) Log.d(TAG, \"Not found. Trying superclass \" + cls.getSuperclass().getName());\n      bindingCtor = findBindingConstructorForClass(cls.getSuperclass());\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Unable to find binding constructor for \" + clsName, e);\n    }\n    BINDINGS.put(cls, bindingCtor);\n    return bindingCtor;\n  }\n\n```\nfindBindingConstructorForClass这个方法通过一个map存储下来由cls作为key的Constructor。构建过程主要是通过classloader来创建一个带有_ViewBinding后缀的java文件，同时通过class的getConstructor方法，返回的是指定的，或者是cls的参数类型构造器，或者是View.class的参数类型构造器。然后在createBinding中会通过这个构造器来构造这个类。传入的参数就是我们在调用Butterknife.bind（）中传入的两个参数，当然也可能是一个。\n\n# 总结一下\n\n当一个程序走到Butterknife.bind(this, rootview)的时候，此时正是编译时，annotation processing 会读取写出来的注解，通过butterknife processor 生成一个对应于这个类名的viewbinder内部类，这个viewbinder类包含了所有的findviewbyid和onclicklistener等方法。然后在调用Bind方法的时候，butterknife会去加载对应的viewbinder类，并调用他们的bind方法。\n\n# 疑惑\n\n通过阅读butterknife的代码，发现一个问题，什么是butterknife processor，他是如何工作的，他在哪儿？\n\n## annotation processor - 注解处理器\n\n注解处理器(Annotation Processor)是javac内置的一个用于编译时扫描和处理注解(Annotation)的工具\n\n由于注解处理器可以在程序编译阶段工作，所以我们可以在编译期间通过注解处理器进行我们需要的操作。比较常用的用法就是在编译期间获取相关注解数据，然后动态生成.java源文件\n\n## 为什么butterknife processor 在项目中不存在\n\n```\nannotationProcessor 'com.jakewharton:butterknife-compiler:9.0.0-rc2'\n```\n\n这段话的意义是调用butterknife-compiler作为一个编译处理器。在编译的时候，会自动调用butterknife-compiler的代码，来协助进行编译。\n\n由于调用的代码没有直接使用的意义，且没有提供开放的api，因此在studio中使用annotationprocessor，并不会看到相应的代码。\n\n## butterknife processor 是在扫描完注解之后执行，还是在扫描注解之前执行\n\n很明显，扫描完注解之后是生成viewbinder，这一步就已经用到了butterknife processor，而之后的bind，仅仅是调用了生成的代码类\n\n# 通过annotation-processor来实现一个butterknife框架\n\n自己实现原理也差不多，会加几层包装\n\n[实现方式](https://blog.csdn.net/android_jianbo/article/details/79180907)\n\n\n\n","source":"_posts/Butterknife源码学习.md","raw":"---\ntitle: Butterknife源码学习\ndate: 2018-12-06 18:56:37\ntags: android\n---\n\n项目中用的butterknife是8.8.1版本，引入了两个包，一个是Butterknife,一个是ButterKnife-Annotations。\n\n# 基本原理\n\nbutterknife的基本原理其实很好理解，就是注入，通过代码中的注解，编译时进行解析，生成大量的代码，这些代码在运行时帮助提供对象\n\n# 源码解析\n\n```\n  @NonNull @UiThread\n  public static Unbinder bind(@NonNull Activity target) {\n    View sourceView = target.getWindow().getDecorView();\n    return createBinding(target, sourceView);\n  }\n```\n这段代码是默认的绑定代码，其调用了\n```\nprivate static Unbinder createBinding(@NonNull Object target, @NonNull View source) {\n    Class<?> targetClass = target.getClass();\n    if (debug) Log.d(TAG, \"Looking up binding for \" + targetClass.getName());\n    Constructor<? extends Unbinder> constructor = findBindingConstructorForClass(targetClass);\n\n    if (constructor == null) {\n      return Unbinder.EMPTY;\n    }\n\n    //noinspection TryWithIdenticalCatches Resolves to API 19+ only type.\n    try {\n      return constructor.newInstance(target, source);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Unable to invoke \" + constructor, e);\n    } catch (InstantiationException e) {\n      throw new RuntimeException(\"Unable to invoke \" + constructor, e);\n    } catch (InvocationTargetException e) {\n      Throwable cause = e.getCause();\n      if (cause instanceof RuntimeException) {\n        throw (RuntimeException) cause;\n      }\n      if (cause instanceof Error) {\n        throw (Error) cause;\n      }\n      throw new RuntimeException(\"Unable to create binding instance.\", cause);\n    }\n  }\n```\n这段话只是执行了findBindingConstructorForClass这个方法，返回了一个unbind\n\n```\n  @Nullable @CheckResult @UiThread\n  private static Constructor<? extends Unbinder> findBindingConstructorForClass(Class<?> cls) {\n    Constructor<? extends Unbinder> bindingCtor = BINDINGS.get(cls);\n    if (bindingCtor != null) {\n      if (debug) Log.d(TAG, \"HIT: Cached in binding map.\");\n      return bindingCtor;\n    }\n    String clsName = cls.getName();\n    if (clsName.startsWith(\"android.\") || clsName.startsWith(\"java.\")) {\n      if (debug) Log.d(TAG, \"MISS: Reached framework class. Abandoning search.\");\n      return null;\n    }\n    try {\n      Class<?> bindingClass = cls.getClassLoader().loadClass(clsName + \"_ViewBinding\");\n      //noinspection unchecked\n      bindingCtor = (Constructor<? extends Unbinder>) bindingClass.getConstructor(cls, View.class);\n      if (debug) Log.d(TAG, \"HIT: Loaded binding class and constructor.\");\n    } catch (ClassNotFoundException e) {\n      if (debug) Log.d(TAG, \"Not found. Trying superclass \" + cls.getSuperclass().getName());\n      bindingCtor = findBindingConstructorForClass(cls.getSuperclass());\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Unable to find binding constructor for \" + clsName, e);\n    }\n    BINDINGS.put(cls, bindingCtor);\n    return bindingCtor;\n  }\n\n```\nfindBindingConstructorForClass这个方法通过一个map存储下来由cls作为key的Constructor。构建过程主要是通过classloader来创建一个带有_ViewBinding后缀的java文件，同时通过class的getConstructor方法，返回的是指定的，或者是cls的参数类型构造器，或者是View.class的参数类型构造器。然后在createBinding中会通过这个构造器来构造这个类。传入的参数就是我们在调用Butterknife.bind（）中传入的两个参数，当然也可能是一个。\n\n# 总结一下\n\n当一个程序走到Butterknife.bind(this, rootview)的时候，此时正是编译时，annotation processing 会读取写出来的注解，通过butterknife processor 生成一个对应于这个类名的viewbinder内部类，这个viewbinder类包含了所有的findviewbyid和onclicklistener等方法。然后在调用Bind方法的时候，butterknife会去加载对应的viewbinder类，并调用他们的bind方法。\n\n# 疑惑\n\n通过阅读butterknife的代码，发现一个问题，什么是butterknife processor，他是如何工作的，他在哪儿？\n\n## annotation processor - 注解处理器\n\n注解处理器(Annotation Processor)是javac内置的一个用于编译时扫描和处理注解(Annotation)的工具\n\n由于注解处理器可以在程序编译阶段工作，所以我们可以在编译期间通过注解处理器进行我们需要的操作。比较常用的用法就是在编译期间获取相关注解数据，然后动态生成.java源文件\n\n## 为什么butterknife processor 在项目中不存在\n\n```\nannotationProcessor 'com.jakewharton:butterknife-compiler:9.0.0-rc2'\n```\n\n这段话的意义是调用butterknife-compiler作为一个编译处理器。在编译的时候，会自动调用butterknife-compiler的代码，来协助进行编译。\n\n由于调用的代码没有直接使用的意义，且没有提供开放的api，因此在studio中使用annotationprocessor，并不会看到相应的代码。\n\n## butterknife processor 是在扫描完注解之后执行，还是在扫描注解之前执行\n\n很明显，扫描完注解之后是生成viewbinder，这一步就已经用到了butterknife processor，而之后的bind，仅仅是调用了生成的代码类\n\n# 通过annotation-processor来实现一个butterknife框架\n\n自己实现原理也差不多，会加几层包装\n\n[实现方式](https://blog.csdn.net/android_jianbo/article/details/79180907)\n\n\n\n","slug":"Butterknife源码学习","published":1,"updated":"2019-03-12T09:26:33.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxi001y3a8kxt9av0hk","content":"<p>项目中用的butterknife是8.8.1版本，引入了两个包，一个是Butterknife,一个是ButterKnife-Annotations。</p>\n<h1 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h1><p>butterknife的基本原理其实很好理解，就是注入，通过代码中的注解，编译时进行解析，生成大量的代码，这些代码在运行时帮助提供对象</p>\n<h1 id=\"源码解析\"><a href=\"#源码解析\" class=\"headerlink\" title=\"源码解析\"></a>源码解析</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@NonNull @UiThread</span><br><span class=\"line\">public static Unbinder bind(@NonNull Activity target) &#123;</span><br><span class=\"line\">  View sourceView = target.getWindow().getDecorView();</span><br><span class=\"line\">  return createBinding(target, sourceView);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码是默认的绑定代码，其调用了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static Unbinder createBinding(@NonNull Object target, @NonNull View source) &#123;</span><br><span class=\"line\">    Class&lt;?&gt; targetClass = target.getClass();</span><br><span class=\"line\">    if (debug) Log.d(TAG, &quot;Looking up binding for &quot; + targetClass.getName());</span><br><span class=\"line\">    Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (constructor == null) &#123;</span><br><span class=\"line\">      return Unbinder.EMPTY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //noinspection TryWithIdenticalCatches Resolves to API 19+ only type.</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      return constructor.newInstance(target, source);</span><br><span class=\"line\">    &#125; catch (IllegalAccessException e) &#123;</span><br><span class=\"line\">      throw new RuntimeException(&quot;Unable to invoke &quot; + constructor, e);</span><br><span class=\"line\">    &#125; catch (InstantiationException e) &#123;</span><br><span class=\"line\">      throw new RuntimeException(&quot;Unable to invoke &quot; + constructor, e);</span><br><span class=\"line\">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class=\"line\">      Throwable cause = e.getCause();</span><br><span class=\"line\">      if (cause instanceof RuntimeException) &#123;</span><br><span class=\"line\">        throw (RuntimeException) cause;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (cause instanceof Error) &#123;</span><br><span class=\"line\">        throw (Error) cause;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      throw new RuntimeException(&quot;Unable to create binding instance.&quot;, cause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这段话只是执行了findBindingConstructorForClass这个方法，返回了一个unbind</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Nullable @CheckResult @UiThread</span><br><span class=\"line\">private static Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123;</span><br><span class=\"line\">  Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);</span><br><span class=\"line\">  if (bindingCtor != null) &#123;</span><br><span class=\"line\">    if (debug) Log.d(TAG, &quot;HIT: Cached in binding map.&quot;);</span><br><span class=\"line\">    return bindingCtor;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  String clsName = cls.getName();</span><br><span class=\"line\">  if (clsName.startsWith(&quot;android.&quot;) || clsName.startsWith(&quot;java.&quot;)) &#123;</span><br><span class=\"line\">    if (debug) Log.d(TAG, &quot;MISS: Reached framework class. Abandoning search.&quot;);</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + &quot;_ViewBinding&quot;);</span><br><span class=\"line\">    //noinspection unchecked</span><br><span class=\"line\">    bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);</span><br><span class=\"line\">    if (debug) Log.d(TAG, &quot;HIT: Loaded binding class and constructor.&quot;);</span><br><span class=\"line\">  &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">    if (debug) Log.d(TAG, &quot;Not found. Trying superclass &quot; + cls.getSuperclass().getName());</span><br><span class=\"line\">    bindingCtor = findBindingConstructorForClass(cls.getSuperclass());</span><br><span class=\"line\">  &#125; catch (NoSuchMethodException e) &#123;</span><br><span class=\"line\">    throw new RuntimeException(&quot;Unable to find binding constructor for &quot; + clsName, e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  BINDINGS.put(cls, bindingCtor);</span><br><span class=\"line\">  return bindingCtor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>findBindingConstructorForClass这个方法通过一个map存储下来由cls作为key的Constructor。构建过程主要是通过classloader来创建一个带有_ViewBinding后缀的java文件，同时通过class的getConstructor方法，返回的是指定的，或者是cls的参数类型构造器，或者是View.class的参数类型构造器。然后在createBinding中会通过这个构造器来构造这个类。传入的参数就是我们在调用Butterknife.bind（）中传入的两个参数，当然也可能是一个。</p>\n<h1 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h1><p>当一个程序走到Butterknife.bind(this, rootview)的时候，此时正是编译时，annotation processing 会读取写出来的注解，通过butterknife processor 生成一个对应于这个类名的viewbinder内部类，这个viewbinder类包含了所有的findviewbyid和onclicklistener等方法。然后在调用Bind方法的时候，butterknife会去加载对应的viewbinder类，并调用他们的bind方法。</p>\n<h1 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h1><p>通过阅读butterknife的代码，发现一个问题，什么是butterknife processor，他是如何工作的，他在哪儿？</p>\n<h2 id=\"annotation-processor-注解处理器\"><a href=\"#annotation-processor-注解处理器\" class=\"headerlink\" title=\"annotation processor - 注解处理器\"></a>annotation processor - 注解处理器</h2><p>注解处理器(Annotation Processor)是javac内置的一个用于编译时扫描和处理注解(Annotation)的工具</p>\n<p>由于注解处理器可以在程序编译阶段工作，所以我们可以在编译期间通过注解处理器进行我们需要的操作。比较常用的用法就是在编译期间获取相关注解数据，然后动态生成.java源文件</p>\n<h2 id=\"为什么butterknife-processor-在项目中不存在\"><a href=\"#为什么butterknife-processor-在项目中不存在\" class=\"headerlink\" title=\"为什么butterknife processor 在项目中不存在\"></a>为什么butterknife processor 在项目中不存在</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">annotationProcessor &apos;com.jakewharton:butterknife-compiler:9.0.0-rc2&apos;</span><br></pre></td></tr></table></figure>\n<p>这段话的意义是调用butterknife-compiler作为一个编译处理器。在编译的时候，会自动调用butterknife-compiler的代码，来协助进行编译。</p>\n<p>由于调用的代码没有直接使用的意义，且没有提供开放的api，因此在studio中使用annotationprocessor，并不会看到相应的代码。</p>\n<h2 id=\"butterknife-processor-是在扫描完注解之后执行，还是在扫描注解之前执行\"><a href=\"#butterknife-processor-是在扫描完注解之后执行，还是在扫描注解之前执行\" class=\"headerlink\" title=\"butterknife processor 是在扫描完注解之后执行，还是在扫描注解之前执行\"></a>butterknife processor 是在扫描完注解之后执行，还是在扫描注解之前执行</h2><p>很明显，扫描完注解之后是生成viewbinder，这一步就已经用到了butterknife processor，而之后的bind，仅仅是调用了生成的代码类</p>\n<h1 id=\"通过annotation-processor来实现一个butterknife框架\"><a href=\"#通过annotation-processor来实现一个butterknife框架\" class=\"headerlink\" title=\"通过annotation-processor来实现一个butterknife框架\"></a>通过annotation-processor来实现一个butterknife框架</h1><p>自己实现原理也差不多，会加几层包装</p>\n<p><a href=\"https://blog.csdn.net/android_jianbo/article/details/79180907\" target=\"_blank\" rel=\"noopener\">实现方式</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>项目中用的butterknife是8.8.1版本，引入了两个包，一个是Butterknife,一个是ButterKnife-Annotations。</p>\n<h1 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h1><p>butterknife的基本原理其实很好理解，就是注入，通过代码中的注解，编译时进行解析，生成大量的代码，这些代码在运行时帮助提供对象</p>\n<h1 id=\"源码解析\"><a href=\"#源码解析\" class=\"headerlink\" title=\"源码解析\"></a>源码解析</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@NonNull @UiThread</span><br><span class=\"line\">public static Unbinder bind(@NonNull Activity target) &#123;</span><br><span class=\"line\">  View sourceView = target.getWindow().getDecorView();</span><br><span class=\"line\">  return createBinding(target, sourceView);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码是默认的绑定代码，其调用了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static Unbinder createBinding(@NonNull Object target, @NonNull View source) &#123;</span><br><span class=\"line\">    Class&lt;?&gt; targetClass = target.getClass();</span><br><span class=\"line\">    if (debug) Log.d(TAG, &quot;Looking up binding for &quot; + targetClass.getName());</span><br><span class=\"line\">    Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (constructor == null) &#123;</span><br><span class=\"line\">      return Unbinder.EMPTY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //noinspection TryWithIdenticalCatches Resolves to API 19+ only type.</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      return constructor.newInstance(target, source);</span><br><span class=\"line\">    &#125; catch (IllegalAccessException e) &#123;</span><br><span class=\"line\">      throw new RuntimeException(&quot;Unable to invoke &quot; + constructor, e);</span><br><span class=\"line\">    &#125; catch (InstantiationException e) &#123;</span><br><span class=\"line\">      throw new RuntimeException(&quot;Unable to invoke &quot; + constructor, e);</span><br><span class=\"line\">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class=\"line\">      Throwable cause = e.getCause();</span><br><span class=\"line\">      if (cause instanceof RuntimeException) &#123;</span><br><span class=\"line\">        throw (RuntimeException) cause;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (cause instanceof Error) &#123;</span><br><span class=\"line\">        throw (Error) cause;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      throw new RuntimeException(&quot;Unable to create binding instance.&quot;, cause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这段话只是执行了findBindingConstructorForClass这个方法，返回了一个unbind</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Nullable @CheckResult @UiThread</span><br><span class=\"line\">private static Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123;</span><br><span class=\"line\">  Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);</span><br><span class=\"line\">  if (bindingCtor != null) &#123;</span><br><span class=\"line\">    if (debug) Log.d(TAG, &quot;HIT: Cached in binding map.&quot;);</span><br><span class=\"line\">    return bindingCtor;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  String clsName = cls.getName();</span><br><span class=\"line\">  if (clsName.startsWith(&quot;android.&quot;) || clsName.startsWith(&quot;java.&quot;)) &#123;</span><br><span class=\"line\">    if (debug) Log.d(TAG, &quot;MISS: Reached framework class. Abandoning search.&quot;);</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + &quot;_ViewBinding&quot;);</span><br><span class=\"line\">    //noinspection unchecked</span><br><span class=\"line\">    bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);</span><br><span class=\"line\">    if (debug) Log.d(TAG, &quot;HIT: Loaded binding class and constructor.&quot;);</span><br><span class=\"line\">  &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">    if (debug) Log.d(TAG, &quot;Not found. Trying superclass &quot; + cls.getSuperclass().getName());</span><br><span class=\"line\">    bindingCtor = findBindingConstructorForClass(cls.getSuperclass());</span><br><span class=\"line\">  &#125; catch (NoSuchMethodException e) &#123;</span><br><span class=\"line\">    throw new RuntimeException(&quot;Unable to find binding constructor for &quot; + clsName, e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  BINDINGS.put(cls, bindingCtor);</span><br><span class=\"line\">  return bindingCtor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>findBindingConstructorForClass这个方法通过一个map存储下来由cls作为key的Constructor。构建过程主要是通过classloader来创建一个带有_ViewBinding后缀的java文件，同时通过class的getConstructor方法，返回的是指定的，或者是cls的参数类型构造器，或者是View.class的参数类型构造器。然后在createBinding中会通过这个构造器来构造这个类。传入的参数就是我们在调用Butterknife.bind（）中传入的两个参数，当然也可能是一个。</p>\n<h1 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h1><p>当一个程序走到Butterknife.bind(this, rootview)的时候，此时正是编译时，annotation processing 会读取写出来的注解，通过butterknife processor 生成一个对应于这个类名的viewbinder内部类，这个viewbinder类包含了所有的findviewbyid和onclicklistener等方法。然后在调用Bind方法的时候，butterknife会去加载对应的viewbinder类，并调用他们的bind方法。</p>\n<h1 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h1><p>通过阅读butterknife的代码，发现一个问题，什么是butterknife processor，他是如何工作的，他在哪儿？</p>\n<h2 id=\"annotation-processor-注解处理器\"><a href=\"#annotation-processor-注解处理器\" class=\"headerlink\" title=\"annotation processor - 注解处理器\"></a>annotation processor - 注解处理器</h2><p>注解处理器(Annotation Processor)是javac内置的一个用于编译时扫描和处理注解(Annotation)的工具</p>\n<p>由于注解处理器可以在程序编译阶段工作，所以我们可以在编译期间通过注解处理器进行我们需要的操作。比较常用的用法就是在编译期间获取相关注解数据，然后动态生成.java源文件</p>\n<h2 id=\"为什么butterknife-processor-在项目中不存在\"><a href=\"#为什么butterknife-processor-在项目中不存在\" class=\"headerlink\" title=\"为什么butterknife processor 在项目中不存在\"></a>为什么butterknife processor 在项目中不存在</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">annotationProcessor &apos;com.jakewharton:butterknife-compiler:9.0.0-rc2&apos;</span><br></pre></td></tr></table></figure>\n<p>这段话的意义是调用butterknife-compiler作为一个编译处理器。在编译的时候，会自动调用butterknife-compiler的代码，来协助进行编译。</p>\n<p>由于调用的代码没有直接使用的意义，且没有提供开放的api，因此在studio中使用annotationprocessor，并不会看到相应的代码。</p>\n<h2 id=\"butterknife-processor-是在扫描完注解之后执行，还是在扫描注解之前执行\"><a href=\"#butterknife-processor-是在扫描完注解之后执行，还是在扫描注解之前执行\" class=\"headerlink\" title=\"butterknife processor 是在扫描完注解之后执行，还是在扫描注解之前执行\"></a>butterknife processor 是在扫描完注解之后执行，还是在扫描注解之前执行</h2><p>很明显，扫描完注解之后是生成viewbinder，这一步就已经用到了butterknife processor，而之后的bind，仅仅是调用了生成的代码类</p>\n<h1 id=\"通过annotation-processor来实现一个butterknife框架\"><a href=\"#通过annotation-processor来实现一个butterknife框架\" class=\"headerlink\" title=\"通过annotation-processor来实现一个butterknife框架\"></a>通过annotation-processor来实现一个butterknife框架</h1><p>自己实现原理也差不多，会加几层包装</p>\n<p><a href=\"https://blog.csdn.net/android_jianbo/article/details/79180907\" target=\"_blank\" rel=\"noopener\">实现方式</a></p>\n"},{"title":"OSS服务器接入上传下载学习","date":"2018-03-22T07:20:50.000Z","_content":"\n主要是针对oss初始化的几种方式进行一个总结，下载上传部分精细的地方暂时不用深入（也没时间深入 lol）\n\n# 初始化\n\n## sts鉴权模式\n\n直接进行token的设置，即时自己单开一个请求获取ststoken，获取了token之后，将token的AccessKeyId，SecretKeyId，SecurityToken三个参数设置于OSSStsTokenCredentialProvider，然后用于初始化OSSCredentialProvider。之后便可以实例OSS的客户端了。\n\n该方法亦可以通过在OSSCredentialProvider的多态方法中加入token的回调接口，然后直接将这个参数进行oss的初始化。\n\n## 通过自签名模式进行初始化。\n\n自签名是将secretkeyid和secretkeyscret放在服务器端，然后请求的时候返回\n\n```\nsignature = \"OSS \" + AccessKeyId + \":\" + base64(hmac-sha1(AccessKeySecret, content))\n```\n\n本地重构一下OSSCredentialProvider的多态方法\n\n```\nString endpoint = \"http://oss-cn-hangzhou.aliyuncs.com\";\ncredentialProvider = new OSSCustomSignerCredentialProvider() {\n    @Override\n    public String signContent(String content) {\n        // 您需要在这里依照OSS规定的签名算法，实现加签一串字符内容，并把得到的签名传拼接上AccessKeyId后返回\n        // 一般实现是，将字符内容post到您的业务服务器，然后返回签名\n        // 如果因为某种原因加签失败，描述error信息后，返回nil\n        // 以下是用本地算法进行的演示\n        return \"OSS \" + AccessKeyId + \":\" + base64(hmac-sha1(AccessKeySecret, content));\n    }\n};\nOSS oss = new OSSClient(getApplicationContext(), endpoint, credentialProvider);\n```\n\n亦可以进行token的设置。\n\n## 直传模式\n\n后端返回policy，OSSAccessKeyId，Signature，然后组装body，带上file和filename，然后直接post给阿里云的服务器。\n\n简单粗暴，但是整个sdk基本上就没有使用了，sdk的分布下载，断点重传功能等等就白白浪废了。\n\n这个模式给web端用比较好。","source":"_posts/OSS服务器接入上传下载学习.md","raw":"---\ntitle: OSS服务器接入上传下载学习\ndate: 2018-03-22 15:20:50\ntags: android\n---\n\n主要是针对oss初始化的几种方式进行一个总结，下载上传部分精细的地方暂时不用深入（也没时间深入 lol）\n\n# 初始化\n\n## sts鉴权模式\n\n直接进行token的设置，即时自己单开一个请求获取ststoken，获取了token之后，将token的AccessKeyId，SecretKeyId，SecurityToken三个参数设置于OSSStsTokenCredentialProvider，然后用于初始化OSSCredentialProvider。之后便可以实例OSS的客户端了。\n\n该方法亦可以通过在OSSCredentialProvider的多态方法中加入token的回调接口，然后直接将这个参数进行oss的初始化。\n\n## 通过自签名模式进行初始化。\n\n自签名是将secretkeyid和secretkeyscret放在服务器端，然后请求的时候返回\n\n```\nsignature = \"OSS \" + AccessKeyId + \":\" + base64(hmac-sha1(AccessKeySecret, content))\n```\n\n本地重构一下OSSCredentialProvider的多态方法\n\n```\nString endpoint = \"http://oss-cn-hangzhou.aliyuncs.com\";\ncredentialProvider = new OSSCustomSignerCredentialProvider() {\n    @Override\n    public String signContent(String content) {\n        // 您需要在这里依照OSS规定的签名算法，实现加签一串字符内容，并把得到的签名传拼接上AccessKeyId后返回\n        // 一般实现是，将字符内容post到您的业务服务器，然后返回签名\n        // 如果因为某种原因加签失败，描述error信息后，返回nil\n        // 以下是用本地算法进行的演示\n        return \"OSS \" + AccessKeyId + \":\" + base64(hmac-sha1(AccessKeySecret, content));\n    }\n};\nOSS oss = new OSSClient(getApplicationContext(), endpoint, credentialProvider);\n```\n\n亦可以进行token的设置。\n\n## 直传模式\n\n后端返回policy，OSSAccessKeyId，Signature，然后组装body，带上file和filename，然后直接post给阿里云的服务器。\n\n简单粗暴，但是整个sdk基本上就没有使用了，sdk的分布下载，断点重传功能等等就白白浪废了。\n\n这个模式给web端用比较好。","slug":"OSS服务器接入上传下载学习","published":1,"updated":"2019-03-12T09:26:33.151Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxj00203a8knnhz0at5","content":"<p>主要是针对oss初始化的几种方式进行一个总结，下载上传部分精细的地方暂时不用深入（也没时间深入 lol）</p>\n<h1 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h1><h2 id=\"sts鉴权模式\"><a href=\"#sts鉴权模式\" class=\"headerlink\" title=\"sts鉴权模式\"></a>sts鉴权模式</h2><p>直接进行token的设置，即时自己单开一个请求获取ststoken，获取了token之后，将token的AccessKeyId，SecretKeyId，SecurityToken三个参数设置于OSSStsTokenCredentialProvider，然后用于初始化OSSCredentialProvider。之后便可以实例OSS的客户端了。</p>\n<p>该方法亦可以通过在OSSCredentialProvider的多态方法中加入token的回调接口，然后直接将这个参数进行oss的初始化。</p>\n<h2 id=\"通过自签名模式进行初始化。\"><a href=\"#通过自签名模式进行初始化。\" class=\"headerlink\" title=\"通过自签名模式进行初始化。\"></a>通过自签名模式进行初始化。</h2><p>自签名是将secretkeyid和secretkeyscret放在服务器端，然后请求的时候返回</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">signature = &quot;OSS &quot; + AccessKeyId + &quot;:&quot; + base64(hmac-sha1(AccessKeySecret, content))</span><br></pre></td></tr></table></figure>\n<p>本地重构一下OSSCredentialProvider的多态方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String endpoint = &quot;http://oss-cn-hangzhou.aliyuncs.com&quot;;</span><br><span class=\"line\">credentialProvider = new OSSCustomSignerCredentialProvider() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String signContent(String content) &#123;</span><br><span class=\"line\">        // 您需要在这里依照OSS规定的签名算法，实现加签一串字符内容，并把得到的签名传拼接上AccessKeyId后返回</span><br><span class=\"line\">        // 一般实现是，将字符内容post到您的业务服务器，然后返回签名</span><br><span class=\"line\">        // 如果因为某种原因加签失败，描述error信息后，返回nil</span><br><span class=\"line\">        // 以下是用本地算法进行的演示</span><br><span class=\"line\">        return &quot;OSS &quot; + AccessKeyId + &quot;:&quot; + base64(hmac-sha1(AccessKeySecret, content));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">OSS oss = new OSSClient(getApplicationContext(), endpoint, credentialProvider);</span><br></pre></td></tr></table></figure>\n<p>亦可以进行token的设置。</p>\n<h2 id=\"直传模式\"><a href=\"#直传模式\" class=\"headerlink\" title=\"直传模式\"></a>直传模式</h2><p>后端返回policy，OSSAccessKeyId，Signature，然后组装body，带上file和filename，然后直接post给阿里云的服务器。</p>\n<p>简单粗暴，但是整个sdk基本上就没有使用了，sdk的分布下载，断点重传功能等等就白白浪废了。</p>\n<p>这个模式给web端用比较好。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>主要是针对oss初始化的几种方式进行一个总结，下载上传部分精细的地方暂时不用深入（也没时间深入 lol）</p>\n<h1 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h1><h2 id=\"sts鉴权模式\"><a href=\"#sts鉴权模式\" class=\"headerlink\" title=\"sts鉴权模式\"></a>sts鉴权模式</h2><p>直接进行token的设置，即时自己单开一个请求获取ststoken，获取了token之后，将token的AccessKeyId，SecretKeyId，SecurityToken三个参数设置于OSSStsTokenCredentialProvider，然后用于初始化OSSCredentialProvider。之后便可以实例OSS的客户端了。</p>\n<p>该方法亦可以通过在OSSCredentialProvider的多态方法中加入token的回调接口，然后直接将这个参数进行oss的初始化。</p>\n<h2 id=\"通过自签名模式进行初始化。\"><a href=\"#通过自签名模式进行初始化。\" class=\"headerlink\" title=\"通过自签名模式进行初始化。\"></a>通过自签名模式进行初始化。</h2><p>自签名是将secretkeyid和secretkeyscret放在服务器端，然后请求的时候返回</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">signature = &quot;OSS &quot; + AccessKeyId + &quot;:&quot; + base64(hmac-sha1(AccessKeySecret, content))</span><br></pre></td></tr></table></figure>\n<p>本地重构一下OSSCredentialProvider的多态方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String endpoint = &quot;http://oss-cn-hangzhou.aliyuncs.com&quot;;</span><br><span class=\"line\">credentialProvider = new OSSCustomSignerCredentialProvider() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String signContent(String content) &#123;</span><br><span class=\"line\">        // 您需要在这里依照OSS规定的签名算法，实现加签一串字符内容，并把得到的签名传拼接上AccessKeyId后返回</span><br><span class=\"line\">        // 一般实现是，将字符内容post到您的业务服务器，然后返回签名</span><br><span class=\"line\">        // 如果因为某种原因加签失败，描述error信息后，返回nil</span><br><span class=\"line\">        // 以下是用本地算法进行的演示</span><br><span class=\"line\">        return &quot;OSS &quot; + AccessKeyId + &quot;:&quot; + base64(hmac-sha1(AccessKeySecret, content));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">OSS oss = new OSSClient(getApplicationContext(), endpoint, credentialProvider);</span><br></pre></td></tr></table></figure>\n<p>亦可以进行token的设置。</p>\n<h2 id=\"直传模式\"><a href=\"#直传模式\" class=\"headerlink\" title=\"直传模式\"></a>直传模式</h2><p>后端返回policy，OSSAccessKeyId，Signature，然后组装body，带上file和filename，然后直接post给阿里云的服务器。</p>\n<p>简单粗暴，但是整个sdk基本上就没有使用了，sdk的分布下载，断点重传功能等等就白白浪废了。</p>\n<p>这个模式给web端用比较好。</p>\n"},{"title":"android8.0-feature一览","date":"2018-03-22T14:16:52.000Z","_content":"\nandroid p出来了，是时候了解一波新特性了。\n\n# Notification Channels\n\n这个是从Android 8.0 引入的概念，目的是提供统一的系统来帮助用户管理通知，开发者可以为需要发送的每个不同的通知类型创建一个通知渠道。还可以创建通知渠道来反映应用的用户做出的选择。例如，可以为聊天应用的用户创建的每个聊天组建立单独的通知渠道。\n\n假如不使用channel的话，会不给发通知。\n\n## 创建流程\n\n- 创建渠道\n\n```\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            NotificationManager manager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);\n\n            NotificationChannel mChannel = new NotificationChannel(\"channel_01\",\n                    \"消息推送\", NotificationManager.IMPORTANCE_DEFAULT);\n            manager.createNotificationChannel(mChannel);\n        }\n```\n\n- 构建通知\n\n```\n\t\tContext context = DJApplication.getInstance();\n        Notification.Builder builder = new Notification.Builder(context);\n        builder.setTicker(\"开始下载\");\n        builder.setSmallIcon(R.mipmap.ic_launcher);\n        builder.setLargeIcon(BitmapFactory.decodeResource(DJApplication.getInstance().getResources(), R.mipmap.ic_launcher));\n        builder.setAutoCancel(true);\n        PendingIntent pIntent = PendingIntent.getActivity(context, 0, new Intent(), PendingIntent.FLAG_UPDATE_CURRENT);\n        builder.setContentTitle(\"下载中\");\n        builder.setContentIntent(pIntent);\n        builder.setContentText(text);\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            builder.setChannelId(\"channel_01\");\n        }\n        manager.notify(1,  builder.build());\n```\n\n# 安装权限问题\n\n这次更新之后，下载和安装权限分离了，安装需要使用\n\n```\n<uses-permission android:name=\"android.permission.REQUEST_INSTALL_PACKAGES\" />\n```\n\n该权限可以确保下载完成之后吊起安装程序","source":"_posts/android8-0-feature一览.md","raw":"---\ntitle: android8.0-feature一览\ndate: 2018-03-22 22:16:52\ntags: android\n---\n\nandroid p出来了，是时候了解一波新特性了。\n\n# Notification Channels\n\n这个是从Android 8.0 引入的概念，目的是提供统一的系统来帮助用户管理通知，开发者可以为需要发送的每个不同的通知类型创建一个通知渠道。还可以创建通知渠道来反映应用的用户做出的选择。例如，可以为聊天应用的用户创建的每个聊天组建立单独的通知渠道。\n\n假如不使用channel的话，会不给发通知。\n\n## 创建流程\n\n- 创建渠道\n\n```\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            NotificationManager manager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);\n\n            NotificationChannel mChannel = new NotificationChannel(\"channel_01\",\n                    \"消息推送\", NotificationManager.IMPORTANCE_DEFAULT);\n            manager.createNotificationChannel(mChannel);\n        }\n```\n\n- 构建通知\n\n```\n\t\tContext context = DJApplication.getInstance();\n        Notification.Builder builder = new Notification.Builder(context);\n        builder.setTicker(\"开始下载\");\n        builder.setSmallIcon(R.mipmap.ic_launcher);\n        builder.setLargeIcon(BitmapFactory.decodeResource(DJApplication.getInstance().getResources(), R.mipmap.ic_launcher));\n        builder.setAutoCancel(true);\n        PendingIntent pIntent = PendingIntent.getActivity(context, 0, new Intent(), PendingIntent.FLAG_UPDATE_CURRENT);\n        builder.setContentTitle(\"下载中\");\n        builder.setContentIntent(pIntent);\n        builder.setContentText(text);\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            builder.setChannelId(\"channel_01\");\n        }\n        manager.notify(1,  builder.build());\n```\n\n# 安装权限问题\n\n这次更新之后，下载和安装权限分离了，安装需要使用\n\n```\n<uses-permission android:name=\"android.permission.REQUEST_INSTALL_PACKAGES\" />\n```\n\n该权限可以确保下载完成之后吊起安装程序","slug":"android8-0-feature一览","published":1,"updated":"2019-03-12T09:26:33.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxk00223a8k5pch0m8y","content":"<p>android p出来了，是时候了解一波新特性了。</p>\n<h1 id=\"Notification-Channels\"><a href=\"#Notification-Channels\" class=\"headerlink\" title=\"Notification Channels\"></a>Notification Channels</h1><p>这个是从Android 8.0 引入的概念，目的是提供统一的系统来帮助用户管理通知，开发者可以为需要发送的每个不同的通知类型创建一个通知渠道。还可以创建通知渠道来反映应用的用户做出的选择。例如，可以为聊天应用的用户创建的每个聊天组建立单独的通知渠道。</p>\n<p>假如不使用channel的话，会不给发通知。</p>\n<h2 id=\"创建流程\"><a href=\"#创建流程\" class=\"headerlink\" title=\"创建流程\"></a>创建流程</h2><ul>\n<li>创建渠道</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class=\"line\">            NotificationManager manager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class=\"line\"></span><br><span class=\"line\">            NotificationChannel mChannel = new NotificationChannel(&quot;channel_01&quot;,</span><br><span class=\"line\">                    &quot;消息推送&quot;, NotificationManager.IMPORTANCE_DEFAULT);</span><br><span class=\"line\">            manager.createNotificationChannel(mChannel);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>构建通知</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Context context = DJApplication.getInstance();</span><br><span class=\"line\">      Notification.Builder builder = new Notification.Builder(context);</span><br><span class=\"line\">      builder.setTicker(&quot;开始下载&quot;);</span><br><span class=\"line\">      builder.setSmallIcon(R.mipmap.ic_launcher);</span><br><span class=\"line\">      builder.setLargeIcon(BitmapFactory.decodeResource(DJApplication.getInstance().getResources(), R.mipmap.ic_launcher));</span><br><span class=\"line\">      builder.setAutoCancel(true);</span><br><span class=\"line\">      PendingIntent pIntent = PendingIntent.getActivity(context, 0, new Intent(), PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class=\"line\">      builder.setContentTitle(&quot;下载中&quot;);</span><br><span class=\"line\">      builder.setContentIntent(pIntent);</span><br><span class=\"line\">      builder.setContentText(text);</span><br><span class=\"line\">      if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class=\"line\">          builder.setChannelId(&quot;channel_01&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      manager.notify(1,  builder.build());</span><br></pre></td></tr></table></figure>\n<h1 id=\"安装权限问题\"><a href=\"#安装权限问题\" class=\"headerlink\" title=\"安装权限问题\"></a>安装权限问题</h1><p>这次更新之后，下载和安装权限分离了，安装需要使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>该权限可以确保下载完成之后吊起安装程序</p>\n","site":{"data":{}},"excerpt":"","more":"<p>android p出来了，是时候了解一波新特性了。</p>\n<h1 id=\"Notification-Channels\"><a href=\"#Notification-Channels\" class=\"headerlink\" title=\"Notification Channels\"></a>Notification Channels</h1><p>这个是从Android 8.0 引入的概念，目的是提供统一的系统来帮助用户管理通知，开发者可以为需要发送的每个不同的通知类型创建一个通知渠道。还可以创建通知渠道来反映应用的用户做出的选择。例如，可以为聊天应用的用户创建的每个聊天组建立单独的通知渠道。</p>\n<p>假如不使用channel的话，会不给发通知。</p>\n<h2 id=\"创建流程\"><a href=\"#创建流程\" class=\"headerlink\" title=\"创建流程\"></a>创建流程</h2><ul>\n<li>创建渠道</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class=\"line\">            NotificationManager manager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class=\"line\"></span><br><span class=\"line\">            NotificationChannel mChannel = new NotificationChannel(&quot;channel_01&quot;,</span><br><span class=\"line\">                    &quot;消息推送&quot;, NotificationManager.IMPORTANCE_DEFAULT);</span><br><span class=\"line\">            manager.createNotificationChannel(mChannel);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>构建通知</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Context context = DJApplication.getInstance();</span><br><span class=\"line\">      Notification.Builder builder = new Notification.Builder(context);</span><br><span class=\"line\">      builder.setTicker(&quot;开始下载&quot;);</span><br><span class=\"line\">      builder.setSmallIcon(R.mipmap.ic_launcher);</span><br><span class=\"line\">      builder.setLargeIcon(BitmapFactory.decodeResource(DJApplication.getInstance().getResources(), R.mipmap.ic_launcher));</span><br><span class=\"line\">      builder.setAutoCancel(true);</span><br><span class=\"line\">      PendingIntent pIntent = PendingIntent.getActivity(context, 0, new Intent(), PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class=\"line\">      builder.setContentTitle(&quot;下载中&quot;);</span><br><span class=\"line\">      builder.setContentIntent(pIntent);</span><br><span class=\"line\">      builder.setContentText(text);</span><br><span class=\"line\">      if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class=\"line\">          builder.setChannelId(&quot;channel_01&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      manager.notify(1,  builder.build());</span><br></pre></td></tr></table></figure>\n<h1 id=\"安装权限问题\"><a href=\"#安装权限问题\" class=\"headerlink\" title=\"安装权限问题\"></a>安装权限问题</h1><p>这次更新之后，下载和安装权限分离了，安装需要使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>该权限可以确保下载完成之后吊起安装程序</p>\n"},{"title":"androidMVP架构学习","date":"2018-02-10T08:08:48.000Z","_content":"\nMVP衍生自mvc，mvc中v层可以由model层进行操作，model将结果呈现于view，control获取反馈传给model，然后model可以进行一系列的操作。\n\nmvp中的p代替了c，同时不允许m直接操作v了，所有的逻辑会落在p层里面，用户的操作反馈给p，p进行操作好之后传给m，m弄完之后仍然由p进行操作对v进行填充，这就导致了v层十分薄弱，大量的逻辑落在了p层。 \n","source":"_posts/androidMVP架构学习.md","raw":"---\ntitle: androidMVP架构学习\ndate: 2018-02-10 16:08:48\ntags: 架构\n---\n\nMVP衍生自mvc，mvc中v层可以由model层进行操作，model将结果呈现于view，control获取反馈传给model，然后model可以进行一系列的操作。\n\nmvp中的p代替了c，同时不允许m直接操作v了，所有的逻辑会落在p层里面，用户的操作反馈给p，p进行操作好之后传给m，m弄完之后仍然由p进行操作对v进行填充，这就导致了v层十分薄弱，大量的逻辑落在了p层。 \n","slug":"androidMVP架构学习","published":1,"updated":"2019-03-12T09:26:33.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxl00253a8k17rgvlnu","content":"<p>MVP衍生自mvc，mvc中v层可以由model层进行操作，model将结果呈现于view，control获取反馈传给model，然后model可以进行一系列的操作。</p>\n<p>mvp中的p代替了c，同时不允许m直接操作v了，所有的逻辑会落在p层里面，用户的操作反馈给p，p进行操作好之后传给m，m弄完之后仍然由p进行操作对v进行填充，这就导致了v层十分薄弱，大量的逻辑落在了p层。 </p>\n","site":{"data":{}},"excerpt":"","more":"<p>MVP衍生自mvc，mvc中v层可以由model层进行操作，model将结果呈现于view，control获取反馈传给model，然后model可以进行一系列的操作。</p>\n<p>mvp中的p代替了c，同时不允许m直接操作v了，所有的逻辑会落在p层里面，用户的操作反馈给p，p进行操作好之后传给m，m弄完之后仍然由p进行操作对v进行填充，这就导致了v层十分薄弱，大量的逻辑落在了p层。 </p>\n"},{"title":"androidscroll分析笔记","date":"2018-01-13T07:42:18.000Z","_content":"\n# android坐标系\n\n在android中，将屏幕最左上角的顶点作为android坐标系的原点，往右是x轴正方向，往下是y轴正方向。\n\n# 视图坐标系\n\n视图坐标系原点以父视图左上角为坐标原点。\n\n# 触控事件 - MotionEvent\n\n```\n\tpublic static final int ACTION_DOWN = 0;//单击触摸按下动作\n\tpublic static final int ACTION_UP = 1;//单击触摸离开动作\n\tpublic static final int ACTION_MOVE = 2;//触摸点移动动作\n\tpublic static final int ACTION_CANCEL = 3;//触摸动作取消\n\tpublic static final int ACTION_OUTSIDE = 4;//触摸动作超出边界\n\tpublic static final int ACTION_POINTER_DOWN = 5;//多点触摸按下动作\n\tpublic static final int ACTION_POINTER_UP = 6;//多点离开动作\n```\n\n## ACTION_CANCEL\n\n当你的手指（或者其它）移动屏幕的时候会触发这个事件，比如当你的手指在屏幕上拖动一个listView或者一个ScrollView而不是去按上面的按钮时会触发这个事件。\n\n在设计设置页面的滑动开关时，如果不监听ACTION_CANCEL，在滑动到中间时，如果你手指上下移动，就是移动到开关控件之外，则此时会触发ACTION_CANCEL，而不是ACTION_UP，造成开关的按钮停顿在中间位置。\n\n意思就是，当用户保持按下操作，并从你的控件转移到外层控件时，会触发ACTION_CANCEL，建议进行处理～\n\n当前的手势被中断，不会再接收到关于它的记录。\n推荐将这个事件作为 ACTION_UP 来看待，但是要区别于普通的 ACTION_UP\n\n话说回来，平常还真碰不到这个事件，习惯上就直接当 ACTION_UP 处理了就\n\n例如：上层 View 是一个 RecyclerView，它收到了一个 ACTION_DOWN 事件，由于这个可能是点击事件，所以它先传递给对应 ItemView，询问 ItemView 是否需要这个事件，然而接下来又传递过来了一个 ACTION_MOVE 事件，且移动的方向和 RecyclerView 的可滑动方向一致，所以 RecyclerView 判断这个事件是滚动事件，于是要收回事件处理权，这时候对应的 ItemView 会收到一个 ACTION_CANCEL ，并且不会再收到后续事件。\n\n## ACTION_OUTSIDE\n\n一个触摸事件已经发生了UI元素的正常范围之外。因此不再提供完整的手势，只提供 运动/触摸 的初始位置。dialog,popupwindow中比较常见\n\n## ACTION_POINTER_DOWN\n\n这个代表用户的第二根手指（之后动手的一根）触摸了屏幕，可以getactionindex获取某一根手指的数字来判断\n\n## ACTION_POINTER_UP\n\n同第二根手指离开了屏幕\n\n# 获取坐标的方法\n\n## View提供的方法（以父布局为坐标系）\ngetTop():自身到其父布局顶点的距离\ngetLeft():\ngetRight():\ngetBottom():\n\n## MotionEvent提供的方法\ngetX():获取点击事件距离空间左边的距离\ngetY():\ngetRawX():获取点击事件距离整个屏幕左边的距离\ngetRawY():\n\n# 实现滑动效果的7种方法\n\n1. layout方法\n在ACTION_MOVE中计算偏移量，在action_down中记录触摸点的坐标，并且在move中进行计算偏移量，然后调用view的layout方法来进行调整。\n\n2. offsetLeftAndRight和offsetTopAndBottom\n使用方法和layout一样，差别是一个需要x的偏移一个需要y的偏移\n\n3. LayoutParams\n\nlayoutParams保留了一个view的参数，可以改变view的layoutParams然后setLayoutParams进行更改。\n\n4. scrollto和scrollby\n\nscrollby(offsetx，offsety)，该方法会造成所有子view移动。因此需要对view的父view使用这个方法，\n\n5. Scroller\n\nscroller可以通过重写view的computeScroll方法，通过获取当前滚动值，来进行不断的瞬间移动，实现整体上的平移效果\nps：computeScroll方法是不会自动调用的，只能通过invalidate() -> draw() -> computeScroll()来间接调用该方法。\n之后使用startScroll即可。\n\n6. 属性动画\n\n7. ViewDragHelper\n\nviewdraghelper是谷歌在support库中提供的drawerlayout和slidingpanelayout两个布局中使用的，用法较为复杂。\n\n1. 初始化viewdraghelper\n\n```\n\tmViewDragHelper = ViewDragHelper.create(this, callback);\n```\n\n2. 拦截事件\n\n将事件传递给viewdraghelper处理\n```\n\t@Override\n\tpublic boolean onInterceptTouchEvent(MotionEvent ev){\n\t\treturn mViewDragHelper.shouldInterceptTouchEvent(ev);\n\t}\n\t@Override\n\tpublic boolean onTouchEvent(MotionEvent ev){\n\t\tmViewDragHelper.processTouchEvent(event);\n\t\treturn true;\n\t}\n```\n\n3. 处理computeScroll()\n\n与scroller相似的，需要处理一个computescroll()方法，因为viewdraghelper内部也是使用scroller实现平滑移动的。\n\n```\n\t@Override\n\tpublic void computeScroll(){\n\t\tif(mViewdragHelper.continueSettling(true)){\n\t\t\tViewCompat.postInvalidateOnAnimation(this);\n\t\t}\n\t}\n```\n\n4. 处理回调\n\n```\n\tprivate ViewDragHelper.Callback callback = new ViewDragHelper.Callback(){\n\t\t@Override\n\t\tpublic boolean tryCaptureView(View child, int pointerId){\n\t\t\treturn false;\n\t\t}\n\t}\n```\n使用上述回调，对child进行判断，如果是需要拖动view，就可以返回true\n\n```\n\t@Override\n\tpublic int clampViewPositionVertical(View child, int top, int dy){\n\t\treturn top;\n\t}\n\t@Override\n\tpublic int clampViewPositionHorizontal(View child, int left, int dx){\n\t\treturn left;\n\t}\n```\n\n使用如上方法，来对滑动效果进行设置，返回的top和left为垂直和水平方向上面的距离。dy表示比较前一次的增量\n\n5. 拖动结束之后，子View回到原来的位置\n\n该效果可以通过监听action_up事件，并通过调用Scroller类来实现。\n在viewdraghelper中可以重写onViewRelased()方法来实现。\n\n```\n\t@Override\n\tpublic void onViewReleased(View releasedChild, float xvel, float yvel){\n\t\tsuper.onViewReleased(releasedChild, xvel, yvel);\n\t\tif(mMianView.getLeft()<500){\n\t\t\tmViewDragHelper.smoothSlideViewTo(mMainView, 0, 0);\n\t\t\tViewCompat.postInvalidateOnAnimation(DragViewGroup.this);\n\t\t}else{\n\t\t\tmViewDragHelper.smoothSlideViewTo(mMainView, 300, 0);\n\t\t\tViewCompat.postInvalidateOnAnimation(DragViewGroup.this);\n\t\t}\n\t}\n```\n\n这样就可以做到滑动距离小于500时回到原来的位置。\n\n除了以上内容，还有大量的监听事件可以用来处理各种事件。\nonViewCaptured():在用户触摸到view后回调\nonViewDragStateChanged():在拖拽状态改变时回调\nonViewPositionChanged():这个事件在位置改变时回调","source":"_posts/androidscroll分析笔记.md","raw":"---\ntitle: androidscroll分析笔记\ndate: 2018-01-13 15:42:18\ntags: android\n---\n\n# android坐标系\n\n在android中，将屏幕最左上角的顶点作为android坐标系的原点，往右是x轴正方向，往下是y轴正方向。\n\n# 视图坐标系\n\n视图坐标系原点以父视图左上角为坐标原点。\n\n# 触控事件 - MotionEvent\n\n```\n\tpublic static final int ACTION_DOWN = 0;//单击触摸按下动作\n\tpublic static final int ACTION_UP = 1;//单击触摸离开动作\n\tpublic static final int ACTION_MOVE = 2;//触摸点移动动作\n\tpublic static final int ACTION_CANCEL = 3;//触摸动作取消\n\tpublic static final int ACTION_OUTSIDE = 4;//触摸动作超出边界\n\tpublic static final int ACTION_POINTER_DOWN = 5;//多点触摸按下动作\n\tpublic static final int ACTION_POINTER_UP = 6;//多点离开动作\n```\n\n## ACTION_CANCEL\n\n当你的手指（或者其它）移动屏幕的时候会触发这个事件，比如当你的手指在屏幕上拖动一个listView或者一个ScrollView而不是去按上面的按钮时会触发这个事件。\n\n在设计设置页面的滑动开关时，如果不监听ACTION_CANCEL，在滑动到中间时，如果你手指上下移动，就是移动到开关控件之外，则此时会触发ACTION_CANCEL，而不是ACTION_UP，造成开关的按钮停顿在中间位置。\n\n意思就是，当用户保持按下操作，并从你的控件转移到外层控件时，会触发ACTION_CANCEL，建议进行处理～\n\n当前的手势被中断，不会再接收到关于它的记录。\n推荐将这个事件作为 ACTION_UP 来看待，但是要区别于普通的 ACTION_UP\n\n话说回来，平常还真碰不到这个事件，习惯上就直接当 ACTION_UP 处理了就\n\n例如：上层 View 是一个 RecyclerView，它收到了一个 ACTION_DOWN 事件，由于这个可能是点击事件，所以它先传递给对应 ItemView，询问 ItemView 是否需要这个事件，然而接下来又传递过来了一个 ACTION_MOVE 事件，且移动的方向和 RecyclerView 的可滑动方向一致，所以 RecyclerView 判断这个事件是滚动事件，于是要收回事件处理权，这时候对应的 ItemView 会收到一个 ACTION_CANCEL ，并且不会再收到后续事件。\n\n## ACTION_OUTSIDE\n\n一个触摸事件已经发生了UI元素的正常范围之外。因此不再提供完整的手势，只提供 运动/触摸 的初始位置。dialog,popupwindow中比较常见\n\n## ACTION_POINTER_DOWN\n\n这个代表用户的第二根手指（之后动手的一根）触摸了屏幕，可以getactionindex获取某一根手指的数字来判断\n\n## ACTION_POINTER_UP\n\n同第二根手指离开了屏幕\n\n# 获取坐标的方法\n\n## View提供的方法（以父布局为坐标系）\ngetTop():自身到其父布局顶点的距离\ngetLeft():\ngetRight():\ngetBottom():\n\n## MotionEvent提供的方法\ngetX():获取点击事件距离空间左边的距离\ngetY():\ngetRawX():获取点击事件距离整个屏幕左边的距离\ngetRawY():\n\n# 实现滑动效果的7种方法\n\n1. layout方法\n在ACTION_MOVE中计算偏移量，在action_down中记录触摸点的坐标，并且在move中进行计算偏移量，然后调用view的layout方法来进行调整。\n\n2. offsetLeftAndRight和offsetTopAndBottom\n使用方法和layout一样，差别是一个需要x的偏移一个需要y的偏移\n\n3. LayoutParams\n\nlayoutParams保留了一个view的参数，可以改变view的layoutParams然后setLayoutParams进行更改。\n\n4. scrollto和scrollby\n\nscrollby(offsetx，offsety)，该方法会造成所有子view移动。因此需要对view的父view使用这个方法，\n\n5. Scroller\n\nscroller可以通过重写view的computeScroll方法，通过获取当前滚动值，来进行不断的瞬间移动，实现整体上的平移效果\nps：computeScroll方法是不会自动调用的，只能通过invalidate() -> draw() -> computeScroll()来间接调用该方法。\n之后使用startScroll即可。\n\n6. 属性动画\n\n7. ViewDragHelper\n\nviewdraghelper是谷歌在support库中提供的drawerlayout和slidingpanelayout两个布局中使用的，用法较为复杂。\n\n1. 初始化viewdraghelper\n\n```\n\tmViewDragHelper = ViewDragHelper.create(this, callback);\n```\n\n2. 拦截事件\n\n将事件传递给viewdraghelper处理\n```\n\t@Override\n\tpublic boolean onInterceptTouchEvent(MotionEvent ev){\n\t\treturn mViewDragHelper.shouldInterceptTouchEvent(ev);\n\t}\n\t@Override\n\tpublic boolean onTouchEvent(MotionEvent ev){\n\t\tmViewDragHelper.processTouchEvent(event);\n\t\treturn true;\n\t}\n```\n\n3. 处理computeScroll()\n\n与scroller相似的，需要处理一个computescroll()方法，因为viewdraghelper内部也是使用scroller实现平滑移动的。\n\n```\n\t@Override\n\tpublic void computeScroll(){\n\t\tif(mViewdragHelper.continueSettling(true)){\n\t\t\tViewCompat.postInvalidateOnAnimation(this);\n\t\t}\n\t}\n```\n\n4. 处理回调\n\n```\n\tprivate ViewDragHelper.Callback callback = new ViewDragHelper.Callback(){\n\t\t@Override\n\t\tpublic boolean tryCaptureView(View child, int pointerId){\n\t\t\treturn false;\n\t\t}\n\t}\n```\n使用上述回调，对child进行判断，如果是需要拖动view，就可以返回true\n\n```\n\t@Override\n\tpublic int clampViewPositionVertical(View child, int top, int dy){\n\t\treturn top;\n\t}\n\t@Override\n\tpublic int clampViewPositionHorizontal(View child, int left, int dx){\n\t\treturn left;\n\t}\n```\n\n使用如上方法，来对滑动效果进行设置，返回的top和left为垂直和水平方向上面的距离。dy表示比较前一次的增量\n\n5. 拖动结束之后，子View回到原来的位置\n\n该效果可以通过监听action_up事件，并通过调用Scroller类来实现。\n在viewdraghelper中可以重写onViewRelased()方法来实现。\n\n```\n\t@Override\n\tpublic void onViewReleased(View releasedChild, float xvel, float yvel){\n\t\tsuper.onViewReleased(releasedChild, xvel, yvel);\n\t\tif(mMianView.getLeft()<500){\n\t\t\tmViewDragHelper.smoothSlideViewTo(mMainView, 0, 0);\n\t\t\tViewCompat.postInvalidateOnAnimation(DragViewGroup.this);\n\t\t}else{\n\t\t\tmViewDragHelper.smoothSlideViewTo(mMainView, 300, 0);\n\t\t\tViewCompat.postInvalidateOnAnimation(DragViewGroup.this);\n\t\t}\n\t}\n```\n\n这样就可以做到滑动距离小于500时回到原来的位置。\n\n除了以上内容，还有大量的监听事件可以用来处理各种事件。\nonViewCaptured():在用户触摸到view后回调\nonViewDragStateChanged():在拖拽状态改变时回调\nonViewPositionChanged():这个事件在位置改变时回调","slug":"androidscroll分析笔记","published":1,"updated":"2019-03-12T09:26:33.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxm00273a8kjx4xxc8n","content":"<h1 id=\"android坐标系\"><a href=\"#android坐标系\" class=\"headerlink\" title=\"android坐标系\"></a>android坐标系</h1><p>在android中，将屏幕最左上角的顶点作为android坐标系的原点，往右是x轴正方向，往下是y轴正方向。</p>\n<h1 id=\"视图坐标系\"><a href=\"#视图坐标系\" class=\"headerlink\" title=\"视图坐标系\"></a>视图坐标系</h1><p>视图坐标系原点以父视图左上角为坐标原点。</p>\n<h1 id=\"触控事件-MotionEvent\"><a href=\"#触控事件-MotionEvent\" class=\"headerlink\" title=\"触控事件 - MotionEvent\"></a>触控事件 - MotionEvent</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final int ACTION_DOWN = 0;//单击触摸按下动作</span><br><span class=\"line\">public static final int ACTION_UP = 1;//单击触摸离开动作</span><br><span class=\"line\">public static final int ACTION_MOVE = 2;//触摸点移动动作</span><br><span class=\"line\">public static final int ACTION_CANCEL = 3;//触摸动作取消</span><br><span class=\"line\">public static final int ACTION_OUTSIDE = 4;//触摸动作超出边界</span><br><span class=\"line\">public static final int ACTION_POINTER_DOWN = 5;//多点触摸按下动作</span><br><span class=\"line\">public static final int ACTION_POINTER_UP = 6;//多点离开动作</span><br></pre></td></tr></table></figure>\n<h2 id=\"ACTION-CANCEL\"><a href=\"#ACTION-CANCEL\" class=\"headerlink\" title=\"ACTION_CANCEL\"></a>ACTION_CANCEL</h2><p>当你的手指（或者其它）移动屏幕的时候会触发这个事件，比如当你的手指在屏幕上拖动一个listView或者一个ScrollView而不是去按上面的按钮时会触发这个事件。</p>\n<p>在设计设置页面的滑动开关时，如果不监听ACTION_CANCEL，在滑动到中间时，如果你手指上下移动，就是移动到开关控件之外，则此时会触发ACTION_CANCEL，而不是ACTION_UP，造成开关的按钮停顿在中间位置。</p>\n<p>意思就是，当用户保持按下操作，并从你的控件转移到外层控件时，会触发ACTION_CANCEL，建议进行处理～</p>\n<p>当前的手势被中断，不会再接收到关于它的记录。<br>推荐将这个事件作为 ACTION_UP 来看待，但是要区别于普通的 ACTION_UP</p>\n<p>话说回来，平常还真碰不到这个事件，习惯上就直接当 ACTION_UP 处理了就</p>\n<p>例如：上层 View 是一个 RecyclerView，它收到了一个 ACTION_DOWN 事件，由于这个可能是点击事件，所以它先传递给对应 ItemView，询问 ItemView 是否需要这个事件，然而接下来又传递过来了一个 ACTION_MOVE 事件，且移动的方向和 RecyclerView 的可滑动方向一致，所以 RecyclerView 判断这个事件是滚动事件，于是要收回事件处理权，这时候对应的 ItemView 会收到一个 ACTION_CANCEL ，并且不会再收到后续事件。</p>\n<h2 id=\"ACTION-OUTSIDE\"><a href=\"#ACTION-OUTSIDE\" class=\"headerlink\" title=\"ACTION_OUTSIDE\"></a>ACTION_OUTSIDE</h2><p>一个触摸事件已经发生了UI元素的正常范围之外。因此不再提供完整的手势，只提供 运动/触摸 的初始位置。dialog,popupwindow中比较常见</p>\n<h2 id=\"ACTION-POINTER-DOWN\"><a href=\"#ACTION-POINTER-DOWN\" class=\"headerlink\" title=\"ACTION_POINTER_DOWN\"></a>ACTION_POINTER_DOWN</h2><p>这个代表用户的第二根手指（之后动手的一根）触摸了屏幕，可以getactionindex获取某一根手指的数字来判断</p>\n<h2 id=\"ACTION-POINTER-UP\"><a href=\"#ACTION-POINTER-UP\" class=\"headerlink\" title=\"ACTION_POINTER_UP\"></a>ACTION_POINTER_UP</h2><p>同第二根手指离开了屏幕</p>\n<h1 id=\"获取坐标的方法\"><a href=\"#获取坐标的方法\" class=\"headerlink\" title=\"获取坐标的方法\"></a>获取坐标的方法</h1><h2 id=\"View提供的方法（以父布局为坐标系）\"><a href=\"#View提供的方法（以父布局为坐标系）\" class=\"headerlink\" title=\"View提供的方法（以父布局为坐标系）\"></a>View提供的方法（以父布局为坐标系）</h2><p>getTop():自身到其父布局顶点的距离<br>getLeft():<br>getRight():<br>getBottom():</p>\n<h2 id=\"MotionEvent提供的方法\"><a href=\"#MotionEvent提供的方法\" class=\"headerlink\" title=\"MotionEvent提供的方法\"></a>MotionEvent提供的方法</h2><p>getX():获取点击事件距离空间左边的距离<br>getY():<br>getRawX():获取点击事件距离整个屏幕左边的距离<br>getRawY():</p>\n<h1 id=\"实现滑动效果的7种方法\"><a href=\"#实现滑动效果的7种方法\" class=\"headerlink\" title=\"实现滑动效果的7种方法\"></a>实现滑动效果的7种方法</h1><ol>\n<li><p>layout方法<br>在ACTION_MOVE中计算偏移量，在action_down中记录触摸点的坐标，并且在move中进行计算偏移量，然后调用view的layout方法来进行调整。</p>\n</li>\n<li><p>offsetLeftAndRight和offsetTopAndBottom<br>使用方法和layout一样，差别是一个需要x的偏移一个需要y的偏移</p>\n</li>\n<li><p>LayoutParams</p>\n</li>\n</ol>\n<p>layoutParams保留了一个view的参数，可以改变view的layoutParams然后setLayoutParams进行更改。</p>\n<ol start=\"4\">\n<li>scrollto和scrollby</li>\n</ol>\n<p>scrollby(offsetx，offsety)，该方法会造成所有子view移动。因此需要对view的父view使用这个方法，</p>\n<ol start=\"5\">\n<li>Scroller</li>\n</ol>\n<p>scroller可以通过重写view的computeScroll方法，通过获取当前滚动值，来进行不断的瞬间移动，实现整体上的平移效果<br>ps：computeScroll方法是不会自动调用的，只能通过invalidate() -&gt; draw() -&gt; computeScroll()来间接调用该方法。<br>之后使用startScroll即可。</p>\n<ol start=\"6\">\n<li><p>属性动画</p>\n</li>\n<li><p>ViewDragHelper</p>\n</li>\n</ol>\n<p>viewdraghelper是谷歌在support库中提供的drawerlayout和slidingpanelayout两个布局中使用的，用法较为复杂。</p>\n<ol>\n<li>初始化viewdraghelper</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mViewDragHelper = ViewDragHelper.create(this, callback);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>拦截事件</li>\n</ol>\n<p>将事件传递给viewdraghelper处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onInterceptTouchEvent(MotionEvent ev)&#123;</span><br><span class=\"line\">\treturn mViewDragHelper.shouldInterceptTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onTouchEvent(MotionEvent ev)&#123;</span><br><span class=\"line\">\tmViewDragHelper.processTouchEvent(event);</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\">\n<li>处理computeScroll()</li>\n</ol>\n<p>与scroller相似的，需要处理一个computescroll()方法，因为viewdraghelper内部也是使用scroller实现平滑移动的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void computeScroll()&#123;</span><br><span class=\"line\">\tif(mViewdragHelper.continueSettling(true))&#123;</span><br><span class=\"line\">\t\tViewCompat.postInvalidateOnAnimation(this);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>处理回调</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private ViewDragHelper.Callback callback = new ViewDragHelper.Callback()&#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic boolean tryCaptureView(View child, int pointerId)&#123;</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用上述回调，对child进行判断，如果是需要拖动view，就可以返回true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public int clampViewPositionVertical(View child, int top, int dy)&#123;</span><br><span class=\"line\">\treturn top;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public int clampViewPositionHorizontal(View child, int left, int dx)&#123;</span><br><span class=\"line\">\treturn left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用如上方法，来对滑动效果进行设置，返回的top和left为垂直和水平方向上面的距离。dy表示比较前一次的增量</p>\n<ol start=\"5\">\n<li>拖动结束之后，子View回到原来的位置</li>\n</ol>\n<p>该效果可以通过监听action_up事件，并通过调用Scroller类来实现。<br>在viewdraghelper中可以重写onViewRelased()方法来实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void onViewReleased(View releasedChild, float xvel, float yvel)&#123;</span><br><span class=\"line\">\tsuper.onViewReleased(releasedChild, xvel, yvel);</span><br><span class=\"line\">\tif(mMianView.getLeft()&lt;500)&#123;</span><br><span class=\"line\">\t\tmViewDragHelper.smoothSlideViewTo(mMainView, 0, 0);</span><br><span class=\"line\">\t\tViewCompat.postInvalidateOnAnimation(DragViewGroup.this);</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">\t\tmViewDragHelper.smoothSlideViewTo(mMainView, 300, 0);</span><br><span class=\"line\">\t\tViewCompat.postInvalidateOnAnimation(DragViewGroup.this);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就可以做到滑动距离小于500时回到原来的位置。</p>\n<p>除了以上内容，还有大量的监听事件可以用来处理各种事件。<br>onViewCaptured():在用户触摸到view后回调<br>onViewDragStateChanged():在拖拽状态改变时回调<br>onViewPositionChanged():这个事件在位置改变时回调</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"android坐标系\"><a href=\"#android坐标系\" class=\"headerlink\" title=\"android坐标系\"></a>android坐标系</h1><p>在android中，将屏幕最左上角的顶点作为android坐标系的原点，往右是x轴正方向，往下是y轴正方向。</p>\n<h1 id=\"视图坐标系\"><a href=\"#视图坐标系\" class=\"headerlink\" title=\"视图坐标系\"></a>视图坐标系</h1><p>视图坐标系原点以父视图左上角为坐标原点。</p>\n<h1 id=\"触控事件-MotionEvent\"><a href=\"#触控事件-MotionEvent\" class=\"headerlink\" title=\"触控事件 - MotionEvent\"></a>触控事件 - MotionEvent</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final int ACTION_DOWN = 0;//单击触摸按下动作</span><br><span class=\"line\">public static final int ACTION_UP = 1;//单击触摸离开动作</span><br><span class=\"line\">public static final int ACTION_MOVE = 2;//触摸点移动动作</span><br><span class=\"line\">public static final int ACTION_CANCEL = 3;//触摸动作取消</span><br><span class=\"line\">public static final int ACTION_OUTSIDE = 4;//触摸动作超出边界</span><br><span class=\"line\">public static final int ACTION_POINTER_DOWN = 5;//多点触摸按下动作</span><br><span class=\"line\">public static final int ACTION_POINTER_UP = 6;//多点离开动作</span><br></pre></td></tr></table></figure>\n<h2 id=\"ACTION-CANCEL\"><a href=\"#ACTION-CANCEL\" class=\"headerlink\" title=\"ACTION_CANCEL\"></a>ACTION_CANCEL</h2><p>当你的手指（或者其它）移动屏幕的时候会触发这个事件，比如当你的手指在屏幕上拖动一个listView或者一个ScrollView而不是去按上面的按钮时会触发这个事件。</p>\n<p>在设计设置页面的滑动开关时，如果不监听ACTION_CANCEL，在滑动到中间时，如果你手指上下移动，就是移动到开关控件之外，则此时会触发ACTION_CANCEL，而不是ACTION_UP，造成开关的按钮停顿在中间位置。</p>\n<p>意思就是，当用户保持按下操作，并从你的控件转移到外层控件时，会触发ACTION_CANCEL，建议进行处理～</p>\n<p>当前的手势被中断，不会再接收到关于它的记录。<br>推荐将这个事件作为 ACTION_UP 来看待，但是要区别于普通的 ACTION_UP</p>\n<p>话说回来，平常还真碰不到这个事件，习惯上就直接当 ACTION_UP 处理了就</p>\n<p>例如：上层 View 是一个 RecyclerView，它收到了一个 ACTION_DOWN 事件，由于这个可能是点击事件，所以它先传递给对应 ItemView，询问 ItemView 是否需要这个事件，然而接下来又传递过来了一个 ACTION_MOVE 事件，且移动的方向和 RecyclerView 的可滑动方向一致，所以 RecyclerView 判断这个事件是滚动事件，于是要收回事件处理权，这时候对应的 ItemView 会收到一个 ACTION_CANCEL ，并且不会再收到后续事件。</p>\n<h2 id=\"ACTION-OUTSIDE\"><a href=\"#ACTION-OUTSIDE\" class=\"headerlink\" title=\"ACTION_OUTSIDE\"></a>ACTION_OUTSIDE</h2><p>一个触摸事件已经发生了UI元素的正常范围之外。因此不再提供完整的手势，只提供 运动/触摸 的初始位置。dialog,popupwindow中比较常见</p>\n<h2 id=\"ACTION-POINTER-DOWN\"><a href=\"#ACTION-POINTER-DOWN\" class=\"headerlink\" title=\"ACTION_POINTER_DOWN\"></a>ACTION_POINTER_DOWN</h2><p>这个代表用户的第二根手指（之后动手的一根）触摸了屏幕，可以getactionindex获取某一根手指的数字来判断</p>\n<h2 id=\"ACTION-POINTER-UP\"><a href=\"#ACTION-POINTER-UP\" class=\"headerlink\" title=\"ACTION_POINTER_UP\"></a>ACTION_POINTER_UP</h2><p>同第二根手指离开了屏幕</p>\n<h1 id=\"获取坐标的方法\"><a href=\"#获取坐标的方法\" class=\"headerlink\" title=\"获取坐标的方法\"></a>获取坐标的方法</h1><h2 id=\"View提供的方法（以父布局为坐标系）\"><a href=\"#View提供的方法（以父布局为坐标系）\" class=\"headerlink\" title=\"View提供的方法（以父布局为坐标系）\"></a>View提供的方法（以父布局为坐标系）</h2><p>getTop():自身到其父布局顶点的距离<br>getLeft():<br>getRight():<br>getBottom():</p>\n<h2 id=\"MotionEvent提供的方法\"><a href=\"#MotionEvent提供的方法\" class=\"headerlink\" title=\"MotionEvent提供的方法\"></a>MotionEvent提供的方法</h2><p>getX():获取点击事件距离空间左边的距离<br>getY():<br>getRawX():获取点击事件距离整个屏幕左边的距离<br>getRawY():</p>\n<h1 id=\"实现滑动效果的7种方法\"><a href=\"#实现滑动效果的7种方法\" class=\"headerlink\" title=\"实现滑动效果的7种方法\"></a>实现滑动效果的7种方法</h1><ol>\n<li><p>layout方法<br>在ACTION_MOVE中计算偏移量，在action_down中记录触摸点的坐标，并且在move中进行计算偏移量，然后调用view的layout方法来进行调整。</p>\n</li>\n<li><p>offsetLeftAndRight和offsetTopAndBottom<br>使用方法和layout一样，差别是一个需要x的偏移一个需要y的偏移</p>\n</li>\n<li><p>LayoutParams</p>\n</li>\n</ol>\n<p>layoutParams保留了一个view的参数，可以改变view的layoutParams然后setLayoutParams进行更改。</p>\n<ol start=\"4\">\n<li>scrollto和scrollby</li>\n</ol>\n<p>scrollby(offsetx，offsety)，该方法会造成所有子view移动。因此需要对view的父view使用这个方法，</p>\n<ol start=\"5\">\n<li>Scroller</li>\n</ol>\n<p>scroller可以通过重写view的computeScroll方法，通过获取当前滚动值，来进行不断的瞬间移动，实现整体上的平移效果<br>ps：computeScroll方法是不会自动调用的，只能通过invalidate() -&gt; draw() -&gt; computeScroll()来间接调用该方法。<br>之后使用startScroll即可。</p>\n<ol start=\"6\">\n<li><p>属性动画</p>\n</li>\n<li><p>ViewDragHelper</p>\n</li>\n</ol>\n<p>viewdraghelper是谷歌在support库中提供的drawerlayout和slidingpanelayout两个布局中使用的，用法较为复杂。</p>\n<ol>\n<li>初始化viewdraghelper</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mViewDragHelper = ViewDragHelper.create(this, callback);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>拦截事件</li>\n</ol>\n<p>将事件传递给viewdraghelper处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onInterceptTouchEvent(MotionEvent ev)&#123;</span><br><span class=\"line\">\treturn mViewDragHelper.shouldInterceptTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onTouchEvent(MotionEvent ev)&#123;</span><br><span class=\"line\">\tmViewDragHelper.processTouchEvent(event);</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\">\n<li>处理computeScroll()</li>\n</ol>\n<p>与scroller相似的，需要处理一个computescroll()方法，因为viewdraghelper内部也是使用scroller实现平滑移动的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void computeScroll()&#123;</span><br><span class=\"line\">\tif(mViewdragHelper.continueSettling(true))&#123;</span><br><span class=\"line\">\t\tViewCompat.postInvalidateOnAnimation(this);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>处理回调</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private ViewDragHelper.Callback callback = new ViewDragHelper.Callback()&#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic boolean tryCaptureView(View child, int pointerId)&#123;</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用上述回调，对child进行判断，如果是需要拖动view，就可以返回true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public int clampViewPositionVertical(View child, int top, int dy)&#123;</span><br><span class=\"line\">\treturn top;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public int clampViewPositionHorizontal(View child, int left, int dx)&#123;</span><br><span class=\"line\">\treturn left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用如上方法，来对滑动效果进行设置，返回的top和left为垂直和水平方向上面的距离。dy表示比较前一次的增量</p>\n<ol start=\"5\">\n<li>拖动结束之后，子View回到原来的位置</li>\n</ol>\n<p>该效果可以通过监听action_up事件，并通过调用Scroller类来实现。<br>在viewdraghelper中可以重写onViewRelased()方法来实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void onViewReleased(View releasedChild, float xvel, float yvel)&#123;</span><br><span class=\"line\">\tsuper.onViewReleased(releasedChild, xvel, yvel);</span><br><span class=\"line\">\tif(mMianView.getLeft()&lt;500)&#123;</span><br><span class=\"line\">\t\tmViewDragHelper.smoothSlideViewTo(mMainView, 0, 0);</span><br><span class=\"line\">\t\tViewCompat.postInvalidateOnAnimation(DragViewGroup.this);</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">\t\tmViewDragHelper.smoothSlideViewTo(mMainView, 300, 0);</span><br><span class=\"line\">\t\tViewCompat.postInvalidateOnAnimation(DragViewGroup.this);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就可以做到滑动距离小于500时回到原来的位置。</p>\n<p>除了以上内容，还有大量的监听事件可以用来处理各种事件。<br>onViewCaptured():在用户触摸到view后回调<br>onViewDragStateChanged():在拖拽状态改变时回调<br>onViewPositionChanged():这个事件在位置改变时回调</p>\n"},{"title":"android事件拦截机制分析","date":"2018-01-03T11:04:36.000Z","_content":"由于Android是树状结构，嵌套会导致事件发生区域重叠，针对重叠区域的处理，就叫事件拦截机制。\n\n我们现在假设有一个嵌套结构\n\n第一层： a-ViewGroup\n第二层： b-ViewGroup\n第三层： c-View\n\n重写viewgroup的三个方法：\n```\n@Override\npublic boolean dispatchTouchEvent(MotionEvent ev){\n\tLogUtil.i(name+\"dispatch\");\n\treturn super.dispatchTouchEvent(ev);\n}\n```\n\n```\n@Override\npublic boolean onInterceptTouchEvent(MotionEvent ev){\n\tLogUtil.i(name+\"intecept\");\n\treturn super.onInterceptTouchEvent(ev);\n}\n```\n\n```\n@Override\npublic boolean onTouchEvent(MotionEvent ev){\n\tLogUtil.i(name+\"onTouch\");\n\treturn super.onTouchEvent(ev);\n}\n```\n\n由于view不需要重写onInterceptTouchEvent,只需要重写另外的两个事件即可。\n\n# 点击c --正常情况\n\nLog显示为\n```\na dispatch\na intercept\nb dispatch\nb intercept\nc dispatch\nc ontouch\nb ontouch\na ontouch\n```\n\n事件的传递顺序为a->b->c， 事件传递的时候是先执行dispatchTouchEvent()方法，之后在执行onInterceptTouchEvent()方法。\n事件处理的顺序为c->b->a\n\n事件传递的返回值很容易理解：True,拦截，不继续;False,不拦截，继续流程。\n事件处理的返回值也类似：True,处理了，不用审核了;False,给上级处理。\n\n初始情况下，返回值都是false。\n\n# 让a的onInterceptTouchEvent()返回true\n\n```\na dispatch\na intercept\na ontouch\n```\n\n很明显是a处截断了。\n\n# 让b的onInterceptTouchEvent()返回true\n\n```\na dispatch\na intercept\nb dispatch\nb intercept\nb ontouch\na ontouch\n```\n\n很明显是b处截断了。\n\n# 让c的onInterceptTouchEvent()返回true\n\n```\na dispatch\na intercept\nb dispatch\nb intercept\nc dispatch\nc ontouch\n```\n\n解释一下ontouchevent为true的意义。\n假如ontouchevent为false，代表这个ontouch事件没有结束，因此还会继续找别的事件来进行处理直到返回的ontouchevent为true。有一些view自己写了默认的ontouch事件，因此假如想继承一个有功能的view而又不想它产生ontouch效果，可以返回true来截断默认的ontouch事件。\n一般情况下false可以起到添加额外效果的功能。","source":"_posts/android事件拦截机制分析.md","raw":"---\ntitle: android事件拦截机制分析\ndate: 2018-01-03 19:04:36\ntags: android\n---\n由于Android是树状结构，嵌套会导致事件发生区域重叠，针对重叠区域的处理，就叫事件拦截机制。\n\n我们现在假设有一个嵌套结构\n\n第一层： a-ViewGroup\n第二层： b-ViewGroup\n第三层： c-View\n\n重写viewgroup的三个方法：\n```\n@Override\npublic boolean dispatchTouchEvent(MotionEvent ev){\n\tLogUtil.i(name+\"dispatch\");\n\treturn super.dispatchTouchEvent(ev);\n}\n```\n\n```\n@Override\npublic boolean onInterceptTouchEvent(MotionEvent ev){\n\tLogUtil.i(name+\"intecept\");\n\treturn super.onInterceptTouchEvent(ev);\n}\n```\n\n```\n@Override\npublic boolean onTouchEvent(MotionEvent ev){\n\tLogUtil.i(name+\"onTouch\");\n\treturn super.onTouchEvent(ev);\n}\n```\n\n由于view不需要重写onInterceptTouchEvent,只需要重写另外的两个事件即可。\n\n# 点击c --正常情况\n\nLog显示为\n```\na dispatch\na intercept\nb dispatch\nb intercept\nc dispatch\nc ontouch\nb ontouch\na ontouch\n```\n\n事件的传递顺序为a->b->c， 事件传递的时候是先执行dispatchTouchEvent()方法，之后在执行onInterceptTouchEvent()方法。\n事件处理的顺序为c->b->a\n\n事件传递的返回值很容易理解：True,拦截，不继续;False,不拦截，继续流程。\n事件处理的返回值也类似：True,处理了，不用审核了;False,给上级处理。\n\n初始情况下，返回值都是false。\n\n# 让a的onInterceptTouchEvent()返回true\n\n```\na dispatch\na intercept\na ontouch\n```\n\n很明显是a处截断了。\n\n# 让b的onInterceptTouchEvent()返回true\n\n```\na dispatch\na intercept\nb dispatch\nb intercept\nb ontouch\na ontouch\n```\n\n很明显是b处截断了。\n\n# 让c的onInterceptTouchEvent()返回true\n\n```\na dispatch\na intercept\nb dispatch\nb intercept\nc dispatch\nc ontouch\n```\n\n解释一下ontouchevent为true的意义。\n假如ontouchevent为false，代表这个ontouch事件没有结束，因此还会继续找别的事件来进行处理直到返回的ontouchevent为true。有一些view自己写了默认的ontouch事件，因此假如想继承一个有功能的view而又不想它产生ontouch效果，可以返回true来截断默认的ontouch事件。\n一般情况下false可以起到添加额外效果的功能。","slug":"android事件拦截机制分析","published":1,"updated":"2019-03-12T09:26:33.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxn002a3a8kwktkh6dp","content":"<p>由于Android是树状结构，嵌套会导致事件发生区域重叠，针对重叠区域的处理，就叫事件拦截机制。</p>\n<p>我们现在假设有一个嵌套结构</p>\n<p>第一层： a-ViewGroup<br>第二层： b-ViewGroup<br>第三层： c-View</p>\n<p>重写viewgroup的三个方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean dispatchTouchEvent(MotionEvent ev)&#123;</span><br><span class=\"line\">\tLogUtil.i(name+&quot;dispatch&quot;);</span><br><span class=\"line\">\treturn super.dispatchTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onInterceptTouchEvent(MotionEvent ev)&#123;</span><br><span class=\"line\">\tLogUtil.i(name+&quot;intecept&quot;);</span><br><span class=\"line\">\treturn super.onInterceptTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onTouchEvent(MotionEvent ev)&#123;</span><br><span class=\"line\">\tLogUtil.i(name+&quot;onTouch&quot;);</span><br><span class=\"line\">\treturn super.onTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于view不需要重写onInterceptTouchEvent,只需要重写另外的两个事件即可。</p>\n<h1 id=\"点击c-–正常情况\"><a href=\"#点击c-–正常情况\" class=\"headerlink\" title=\"点击c –正常情况\"></a>点击c –正常情况</h1><p>Log显示为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a dispatch</span><br><span class=\"line\">a intercept</span><br><span class=\"line\">b dispatch</span><br><span class=\"line\">b intercept</span><br><span class=\"line\">c dispatch</span><br><span class=\"line\">c ontouch</span><br><span class=\"line\">b ontouch</span><br><span class=\"line\">a ontouch</span><br></pre></td></tr></table></figure></p>\n<p>事件的传递顺序为a-&gt;b-&gt;c， 事件传递的时候是先执行dispatchTouchEvent()方法，之后在执行onInterceptTouchEvent()方法。<br>事件处理的顺序为c-&gt;b-&gt;a</p>\n<p>事件传递的返回值很容易理解：True,拦截，不继续;False,不拦截，继续流程。<br>事件处理的返回值也类似：True,处理了，不用审核了;False,给上级处理。</p>\n<p>初始情况下，返回值都是false。</p>\n<h1 id=\"让a的onInterceptTouchEvent-返回true\"><a href=\"#让a的onInterceptTouchEvent-返回true\" class=\"headerlink\" title=\"让a的onInterceptTouchEvent()返回true\"></a>让a的onInterceptTouchEvent()返回true</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a dispatch</span><br><span class=\"line\">a intercept</span><br><span class=\"line\">a ontouch</span><br></pre></td></tr></table></figure>\n<p>很明显是a处截断了。</p>\n<h1 id=\"让b的onInterceptTouchEvent-返回true\"><a href=\"#让b的onInterceptTouchEvent-返回true\" class=\"headerlink\" title=\"让b的onInterceptTouchEvent()返回true\"></a>让b的onInterceptTouchEvent()返回true</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a dispatch</span><br><span class=\"line\">a intercept</span><br><span class=\"line\">b dispatch</span><br><span class=\"line\">b intercept</span><br><span class=\"line\">b ontouch</span><br><span class=\"line\">a ontouch</span><br></pre></td></tr></table></figure>\n<p>很明显是b处截断了。</p>\n<h1 id=\"让c的onInterceptTouchEvent-返回true\"><a href=\"#让c的onInterceptTouchEvent-返回true\" class=\"headerlink\" title=\"让c的onInterceptTouchEvent()返回true\"></a>让c的onInterceptTouchEvent()返回true</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a dispatch</span><br><span class=\"line\">a intercept</span><br><span class=\"line\">b dispatch</span><br><span class=\"line\">b intercept</span><br><span class=\"line\">c dispatch</span><br><span class=\"line\">c ontouch</span><br></pre></td></tr></table></figure>\n<p>解释一下ontouchevent为true的意义。<br>假如ontouchevent为false，代表这个ontouch事件没有结束，因此还会继续找别的事件来进行处理直到返回的ontouchevent为true。有一些view自己写了默认的ontouch事件，因此假如想继承一个有功能的view而又不想它产生ontouch效果，可以返回true来截断默认的ontouch事件。<br>一般情况下false可以起到添加额外效果的功能。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>由于Android是树状结构，嵌套会导致事件发生区域重叠，针对重叠区域的处理，就叫事件拦截机制。</p>\n<p>我们现在假设有一个嵌套结构</p>\n<p>第一层： a-ViewGroup<br>第二层： b-ViewGroup<br>第三层： c-View</p>\n<p>重写viewgroup的三个方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean dispatchTouchEvent(MotionEvent ev)&#123;</span><br><span class=\"line\">\tLogUtil.i(name+&quot;dispatch&quot;);</span><br><span class=\"line\">\treturn super.dispatchTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onInterceptTouchEvent(MotionEvent ev)&#123;</span><br><span class=\"line\">\tLogUtil.i(name+&quot;intecept&quot;);</span><br><span class=\"line\">\treturn super.onInterceptTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onTouchEvent(MotionEvent ev)&#123;</span><br><span class=\"line\">\tLogUtil.i(name+&quot;onTouch&quot;);</span><br><span class=\"line\">\treturn super.onTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于view不需要重写onInterceptTouchEvent,只需要重写另外的两个事件即可。</p>\n<h1 id=\"点击c-–正常情况\"><a href=\"#点击c-–正常情况\" class=\"headerlink\" title=\"点击c –正常情况\"></a>点击c –正常情况</h1><p>Log显示为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a dispatch</span><br><span class=\"line\">a intercept</span><br><span class=\"line\">b dispatch</span><br><span class=\"line\">b intercept</span><br><span class=\"line\">c dispatch</span><br><span class=\"line\">c ontouch</span><br><span class=\"line\">b ontouch</span><br><span class=\"line\">a ontouch</span><br></pre></td></tr></table></figure></p>\n<p>事件的传递顺序为a-&gt;b-&gt;c， 事件传递的时候是先执行dispatchTouchEvent()方法，之后在执行onInterceptTouchEvent()方法。<br>事件处理的顺序为c-&gt;b-&gt;a</p>\n<p>事件传递的返回值很容易理解：True,拦截，不继续;False,不拦截，继续流程。<br>事件处理的返回值也类似：True,处理了，不用审核了;False,给上级处理。</p>\n<p>初始情况下，返回值都是false。</p>\n<h1 id=\"让a的onInterceptTouchEvent-返回true\"><a href=\"#让a的onInterceptTouchEvent-返回true\" class=\"headerlink\" title=\"让a的onInterceptTouchEvent()返回true\"></a>让a的onInterceptTouchEvent()返回true</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a dispatch</span><br><span class=\"line\">a intercept</span><br><span class=\"line\">a ontouch</span><br></pre></td></tr></table></figure>\n<p>很明显是a处截断了。</p>\n<h1 id=\"让b的onInterceptTouchEvent-返回true\"><a href=\"#让b的onInterceptTouchEvent-返回true\" class=\"headerlink\" title=\"让b的onInterceptTouchEvent()返回true\"></a>让b的onInterceptTouchEvent()返回true</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a dispatch</span><br><span class=\"line\">a intercept</span><br><span class=\"line\">b dispatch</span><br><span class=\"line\">b intercept</span><br><span class=\"line\">b ontouch</span><br><span class=\"line\">a ontouch</span><br></pre></td></tr></table></figure>\n<p>很明显是b处截断了。</p>\n<h1 id=\"让c的onInterceptTouchEvent-返回true\"><a href=\"#让c的onInterceptTouchEvent-返回true\" class=\"headerlink\" title=\"让c的onInterceptTouchEvent()返回true\"></a>让c的onInterceptTouchEvent()返回true</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a dispatch</span><br><span class=\"line\">a intercept</span><br><span class=\"line\">b dispatch</span><br><span class=\"line\">b intercept</span><br><span class=\"line\">c dispatch</span><br><span class=\"line\">c ontouch</span><br></pre></td></tr></table></figure>\n<p>解释一下ontouchevent为true的意义。<br>假如ontouchevent为false，代表这个ontouch事件没有结束，因此还会继续找别的事件来进行处理直到返回的ontouchevent为true。有一些view自己写了默认的ontouch事件，因此假如想继承一个有功能的view而又不想它产生ontouch效果，可以返回true来截断默认的ontouch事件。<br>一般情况下false可以起到添加额外效果的功能。</p>\n"},{"title":"android事件分发机制","date":"2018-01-03T15:10:07.000Z","_content":"\n假如一个button\n```\n\tbutton.setOnClickListener(new OnClickListener(){\n\t\t@Override\n\t\tpublic void onClick(View v){\n\t\t\tLog.d(\"TAG\",\"onClick execute\");\n\t\t}\n\t})\n```\n\n同时设置ontouch事件\n\n```\n\tbutton.setOnTouchListener(new OnTouchListener(){\n\t\t@Override\n\t\tpublic boolean onTouch(View v, MotionEvent event){\n\t\t\tLog.d(\"TAG\",\"onTouch execute, action \"+ event.getAction());\n\t\t\treturn false;\n\t\t}\n\t})\n```\n\n点击按钮log如下\n```\nonTouch execute, action 0\nonTouch execute, action 1\nonClick execute\n```\n\nonTouch是优先于onClick执行的，并且onTouch执行了2次，一次是ACTION_DOWN,一次是ACTION_UP。\n顺序是先经过onTouch，在传递到onClick。\n\n将ontouch返回值改为true，在运行一次，会发现onClick不再执行，这就是拦截了。\n\n# dispatchTouchEvent\n\n任何view被触摸，一定会执行dispatchTouchEvent这个方法。\n\n```\npublic boolean dispatchTouchEvent(MotionEvent event) {  \n    if (mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED &&  \n            mOnTouchListener.onTouch(this, event)) {  \n        return true;  \n    }  \n    return onTouchEvent(event);  \n}  \n```\n\n这段代码很明显的指出了，首先会执行的是set的onTouchListener的onTouch事件，之后才会执行自身的onTouchEvent事件。\n\n```\npublic boolean onTouchEvent(MotionEvent event) {  \n    final int viewFlags = mViewFlags;  \n    if ((viewFlags & ENABLED_MASK) == DISABLED) {  \n        // A disabled view that is clickable still consumes the touch  \n        // events, it just doesn't respond to them.  \n        return (((viewFlags & CLICKABLE) == CLICKABLE ||  \n                (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE));  \n    }  \n    if (mTouchDelegate != null) {  \n        if (mTouchDelegate.onTouchEvent(event)) {  \n            return true;  \n        }  \n    }  \n    if (((viewFlags & CLICKABLE) == CLICKABLE ||  \n            (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {  \n        switch (event.getAction()) {  \n            case MotionEvent.ACTION_UP:  \n                boolean prepressed = (mPrivateFlags & PREPRESSED) != 0;  \n                if ((mPrivateFlags & PRESSED) != 0 || prepressed) {  \n                    // take focus if we don't have it already and we should in  \n                    // touch mode.  \n                    boolean focusTaken = false;  \n                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {  \n                        focusTaken = requestFocus();  \n                    }  \n                    if (!mHasPerformedLongPress) {  \n                        // This is a tap, so remove the longpress check  \n                        removeLongPressCallback();  \n                        // Only perform take click actions if we were in the pressed state  \n                        if (!focusTaken) {  \n                            // Use a Runnable and post this rather than calling  \n                            // performClick directly. This lets other visual state  \n                            // of the view update before click actions start.  \n                            if (mPerformClick == null) {  \n                                mPerformClick = new PerformClick();  \n                            }  \n                            if (!post(mPerformClick)) {  \n                                performClick();  \n                            }  \n                        }  \n                    }  \n                    if (mUnsetPressedState == null) {  \n                        mUnsetPressedState = new UnsetPressedState();  \n                    }  \n                    if (prepressed) {  \n                        mPrivateFlags |= PRESSED;  \n                        refreshDrawableState();  \n                        postDelayed(mUnsetPressedState,  \n                                ViewConfiguration.getPressedStateDuration());  \n                    } else if (!post(mUnsetPressedState)) {  \n                        // If the post failed, unpress right now  \n                        mUnsetPressedState.run();  \n                    }  \n                    removeTapCallback();  \n                }  \n                break;  \n            case MotionEvent.ACTION_DOWN:  \n                if (mPendingCheckForTap == null) {  \n                    mPendingCheckForTap = new CheckForTap();  \n                }  \n                mPrivateFlags |= PREPRESSED;  \n                mHasPerformedLongPress = false;  \n                postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());  \n                break;  \n            case MotionEvent.ACTION_CANCEL:  \n                mPrivateFlags &= ~PRESSED;  \n                refreshDrawableState();  \n                removeTapCallback();  \n                break;  \n            case MotionEvent.ACTION_MOVE:  \n                final int x = (int) event.getX();  \n                final int y = (int) event.getY();  \n                // Be lenient about moving outside of buttons  \n                int slop = mTouchSlop;  \n                if ((x < 0 - slop) || (x >= getWidth() + slop) ||  \n                        (y < 0 - slop) || (y >= getHeight() + slop)) {  \n                    // Outside button  \n                    removeTapCallback();  \n                    if ((mPrivateFlags & PRESSED) != 0) {  \n                        // Remove any future long press/tap checks  \n                        removeLongPressCallback();  \n                        // Need to switch from pressed to not pressed  \n                        mPrivateFlags &= ~PRESSED;  \n                        refreshDrawableState();  \n                    }  \n                }  \n                break;  \n        }  \n        return true;  \n    }  \n    return false;  \n}  \n```\n\n当事件为MotionEvent.ACTION_UP时，如果该控件可点击，会执行performClick()\n\n```\npublic boolean performClick() {  \n    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);  \n    if (mOnClickListener != null) {  \n        playSoundEffect(SoundEffectConstants.CLICK);  \n        mOnClickListener.onClick(this);  \n        return true;  \n    }  \n    return false;  \n}\n```\n\n从源码可以看出，基本上每一次事件，都会return 一个true，也就是消耗掉这次事件了。而之后的事件会重新进入，这也和之前的截断事件机制符合。\n\n# onTouch和onTouchEvent有什么区别，又该如何使用？\n\n从源码中可以看出，这两个方法都是在View的dispatchTouchEvent中调用的，onTouch优先于onTouchEvent执行。如果在onTouch方法中通过返回true将事件消费掉，onTouchEvent将不会再执行。\n另外需要注意的是，onTouch能够得到执行需要两个前提条件，第一mOnTouchListener的值不能为空，第二当前点击的控件必须是enable的。因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。\n\n# 为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？\n比如说左右滑的时候，还是正常的左右滑。\n但是上下滑的时候，会出现一个问题，就是listview无法上下滑动，这主要是事件被scrollview给消耗掉了，需要在触摸的时候，scrollview不进行截断操作，让事件能够传递下去。","source":"_posts/android事件分发机制.md","raw":"---\ntitle: android事件分发机制\ndate: 2018-01-03 23:10:07\ntags: android\n---\n\n假如一个button\n```\n\tbutton.setOnClickListener(new OnClickListener(){\n\t\t@Override\n\t\tpublic void onClick(View v){\n\t\t\tLog.d(\"TAG\",\"onClick execute\");\n\t\t}\n\t})\n```\n\n同时设置ontouch事件\n\n```\n\tbutton.setOnTouchListener(new OnTouchListener(){\n\t\t@Override\n\t\tpublic boolean onTouch(View v, MotionEvent event){\n\t\t\tLog.d(\"TAG\",\"onTouch execute, action \"+ event.getAction());\n\t\t\treturn false;\n\t\t}\n\t})\n```\n\n点击按钮log如下\n```\nonTouch execute, action 0\nonTouch execute, action 1\nonClick execute\n```\n\nonTouch是优先于onClick执行的，并且onTouch执行了2次，一次是ACTION_DOWN,一次是ACTION_UP。\n顺序是先经过onTouch，在传递到onClick。\n\n将ontouch返回值改为true，在运行一次，会发现onClick不再执行，这就是拦截了。\n\n# dispatchTouchEvent\n\n任何view被触摸，一定会执行dispatchTouchEvent这个方法。\n\n```\npublic boolean dispatchTouchEvent(MotionEvent event) {  \n    if (mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED &&  \n            mOnTouchListener.onTouch(this, event)) {  \n        return true;  \n    }  \n    return onTouchEvent(event);  \n}  \n```\n\n这段代码很明显的指出了，首先会执行的是set的onTouchListener的onTouch事件，之后才会执行自身的onTouchEvent事件。\n\n```\npublic boolean onTouchEvent(MotionEvent event) {  \n    final int viewFlags = mViewFlags;  \n    if ((viewFlags & ENABLED_MASK) == DISABLED) {  \n        // A disabled view that is clickable still consumes the touch  \n        // events, it just doesn't respond to them.  \n        return (((viewFlags & CLICKABLE) == CLICKABLE ||  \n                (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE));  \n    }  \n    if (mTouchDelegate != null) {  \n        if (mTouchDelegate.onTouchEvent(event)) {  \n            return true;  \n        }  \n    }  \n    if (((viewFlags & CLICKABLE) == CLICKABLE ||  \n            (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {  \n        switch (event.getAction()) {  \n            case MotionEvent.ACTION_UP:  \n                boolean prepressed = (mPrivateFlags & PREPRESSED) != 0;  \n                if ((mPrivateFlags & PRESSED) != 0 || prepressed) {  \n                    // take focus if we don't have it already and we should in  \n                    // touch mode.  \n                    boolean focusTaken = false;  \n                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {  \n                        focusTaken = requestFocus();  \n                    }  \n                    if (!mHasPerformedLongPress) {  \n                        // This is a tap, so remove the longpress check  \n                        removeLongPressCallback();  \n                        // Only perform take click actions if we were in the pressed state  \n                        if (!focusTaken) {  \n                            // Use a Runnable and post this rather than calling  \n                            // performClick directly. This lets other visual state  \n                            // of the view update before click actions start.  \n                            if (mPerformClick == null) {  \n                                mPerformClick = new PerformClick();  \n                            }  \n                            if (!post(mPerformClick)) {  \n                                performClick();  \n                            }  \n                        }  \n                    }  \n                    if (mUnsetPressedState == null) {  \n                        mUnsetPressedState = new UnsetPressedState();  \n                    }  \n                    if (prepressed) {  \n                        mPrivateFlags |= PRESSED;  \n                        refreshDrawableState();  \n                        postDelayed(mUnsetPressedState,  \n                                ViewConfiguration.getPressedStateDuration());  \n                    } else if (!post(mUnsetPressedState)) {  \n                        // If the post failed, unpress right now  \n                        mUnsetPressedState.run();  \n                    }  \n                    removeTapCallback();  \n                }  \n                break;  \n            case MotionEvent.ACTION_DOWN:  \n                if (mPendingCheckForTap == null) {  \n                    mPendingCheckForTap = new CheckForTap();  \n                }  \n                mPrivateFlags |= PREPRESSED;  \n                mHasPerformedLongPress = false;  \n                postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());  \n                break;  \n            case MotionEvent.ACTION_CANCEL:  \n                mPrivateFlags &= ~PRESSED;  \n                refreshDrawableState();  \n                removeTapCallback();  \n                break;  \n            case MotionEvent.ACTION_MOVE:  \n                final int x = (int) event.getX();  \n                final int y = (int) event.getY();  \n                // Be lenient about moving outside of buttons  \n                int slop = mTouchSlop;  \n                if ((x < 0 - slop) || (x >= getWidth() + slop) ||  \n                        (y < 0 - slop) || (y >= getHeight() + slop)) {  \n                    // Outside button  \n                    removeTapCallback();  \n                    if ((mPrivateFlags & PRESSED) != 0) {  \n                        // Remove any future long press/tap checks  \n                        removeLongPressCallback();  \n                        // Need to switch from pressed to not pressed  \n                        mPrivateFlags &= ~PRESSED;  \n                        refreshDrawableState();  \n                    }  \n                }  \n                break;  \n        }  \n        return true;  \n    }  \n    return false;  \n}  \n```\n\n当事件为MotionEvent.ACTION_UP时，如果该控件可点击，会执行performClick()\n\n```\npublic boolean performClick() {  \n    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);  \n    if (mOnClickListener != null) {  \n        playSoundEffect(SoundEffectConstants.CLICK);  \n        mOnClickListener.onClick(this);  \n        return true;  \n    }  \n    return false;  \n}\n```\n\n从源码可以看出，基本上每一次事件，都会return 一个true，也就是消耗掉这次事件了。而之后的事件会重新进入，这也和之前的截断事件机制符合。\n\n# onTouch和onTouchEvent有什么区别，又该如何使用？\n\n从源码中可以看出，这两个方法都是在View的dispatchTouchEvent中调用的，onTouch优先于onTouchEvent执行。如果在onTouch方法中通过返回true将事件消费掉，onTouchEvent将不会再执行。\n另外需要注意的是，onTouch能够得到执行需要两个前提条件，第一mOnTouchListener的值不能为空，第二当前点击的控件必须是enable的。因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。\n\n# 为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？\n比如说左右滑的时候，还是正常的左右滑。\n但是上下滑的时候，会出现一个问题，就是listview无法上下滑动，这主要是事件被scrollview给消耗掉了，需要在触摸的时候，scrollview不进行截断操作，让事件能够传递下去。","slug":"android事件分发机制","published":1,"updated":"2019-03-12T09:26:33.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxo002c3a8k33u8sgcj","content":"<p>假如一个button<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.setOnClickListener(new OnClickListener()&#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onClick(View v)&#123;</span><br><span class=\"line\">\t\tLog.d(&quot;TAG&quot;,&quot;onClick execute&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>同时设置ontouch事件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.setOnTouchListener(new OnTouchListener()&#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic boolean onTouch(View v, MotionEvent event)&#123;</span><br><span class=\"line\">\t\tLog.d(&quot;TAG&quot;,&quot;onTouch execute, action &quot;+ event.getAction());</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>点击按钮log如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onTouch execute, action 0</span><br><span class=\"line\">onTouch execute, action 1</span><br><span class=\"line\">onClick execute</span><br></pre></td></tr></table></figure></p>\n<p>onTouch是优先于onClick执行的，并且onTouch执行了2次，一次是ACTION_DOWN,一次是ACTION_UP。<br>顺序是先经过onTouch，在传递到onClick。</p>\n<p>将ontouch返回值改为true，在运行一次，会发现onClick不再执行，这就是拦截了。</p>\n<h1 id=\"dispatchTouchEvent\"><a href=\"#dispatchTouchEvent\" class=\"headerlink\" title=\"dispatchTouchEvent\"></a>dispatchTouchEvent</h1><p>任何view被触摸，一定会执行dispatchTouchEvent这个方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean dispatchTouchEvent(MotionEvent event) &#123;  </span><br><span class=\"line\">    if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;  </span><br><span class=\"line\">            mOnTouchListener.onTouch(this, event)) &#123;  </span><br><span class=\"line\">        return true;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return onTouchEvent(event);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码很明显的指出了，首先会执行的是set的onTouchListener的onTouch事件，之后才会执行自身的onTouchEvent事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean onTouchEvent(MotionEvent event) &#123;  </span><br><span class=\"line\">    final int viewFlags = mViewFlags;  </span><br><span class=\"line\">    if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;  </span><br><span class=\"line\">        // A disabled view that is clickable still consumes the touch  </span><br><span class=\"line\">        // events, it just doesn&apos;t respond to them.  </span><br><span class=\"line\">        return (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  </span><br><span class=\"line\">                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    if (mTouchDelegate != null) &#123;  </span><br><span class=\"line\">        if (mTouchDelegate.onTouchEvent(event)) &#123;  </span><br><span class=\"line\">            return true;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  </span><br><span class=\"line\">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;  </span><br><span class=\"line\">        switch (event.getAction()) &#123;  </span><br><span class=\"line\">            case MotionEvent.ACTION_UP:  </span><br><span class=\"line\">                boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0;  </span><br><span class=\"line\">                if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) &#123;  </span><br><span class=\"line\">                    // take focus if we don&apos;t have it already and we should in  </span><br><span class=\"line\">                    // touch mode.  </span><br><span class=\"line\">                    boolean focusTaken = false;  </span><br><span class=\"line\">                    if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;  </span><br><span class=\"line\">                        focusTaken = requestFocus();  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    if (!mHasPerformedLongPress) &#123;  </span><br><span class=\"line\">                        // This is a tap, so remove the longpress check  </span><br><span class=\"line\">                        removeLongPressCallback();  </span><br><span class=\"line\">                        // Only perform take click actions if we were in the pressed state  </span><br><span class=\"line\">                        if (!focusTaken) &#123;  </span><br><span class=\"line\">                            // Use a Runnable and post this rather than calling  </span><br><span class=\"line\">                            // performClick directly. This lets other visual state  </span><br><span class=\"line\">                            // of the view update before click actions start.  </span><br><span class=\"line\">                            if (mPerformClick == null) &#123;  </span><br><span class=\"line\">                                mPerformClick = new PerformClick();  </span><br><span class=\"line\">                            &#125;  </span><br><span class=\"line\">                            if (!post(mPerformClick)) &#123;  </span><br><span class=\"line\">                                performClick();  </span><br><span class=\"line\">                            &#125;  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    if (mUnsetPressedState == null) &#123;  </span><br><span class=\"line\">                        mUnsetPressedState = new UnsetPressedState();  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    if (prepressed) &#123;  </span><br><span class=\"line\">                        mPrivateFlags |= PRESSED;  </span><br><span class=\"line\">                        refreshDrawableState();  </span><br><span class=\"line\">                        postDelayed(mUnsetPressedState,  </span><br><span class=\"line\">                                ViewConfiguration.getPressedStateDuration());  </span><br><span class=\"line\">                    &#125; else if (!post(mUnsetPressedState)) &#123;  </span><br><span class=\"line\">                        // If the post failed, unpress right now  </span><br><span class=\"line\">                        mUnsetPressedState.run();  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    removeTapCallback();  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">            case MotionEvent.ACTION_DOWN:  </span><br><span class=\"line\">                if (mPendingCheckForTap == null) &#123;  </span><br><span class=\"line\">                    mPendingCheckForTap = new CheckForTap();  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                mPrivateFlags |= PREPRESSED;  </span><br><span class=\"line\">                mHasPerformedLongPress = false;  </span><br><span class=\"line\">                postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">            case MotionEvent.ACTION_CANCEL:  </span><br><span class=\"line\">                mPrivateFlags &amp;= ~PRESSED;  </span><br><span class=\"line\">                refreshDrawableState();  </span><br><span class=\"line\">                removeTapCallback();  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">            case MotionEvent.ACTION_MOVE:  </span><br><span class=\"line\">                final int x = (int) event.getX();  </span><br><span class=\"line\">                final int y = (int) event.getY();  </span><br><span class=\"line\">                // Be lenient about moving outside of buttons  </span><br><span class=\"line\">                int slop = mTouchSlop;  </span><br><span class=\"line\">                if ((x &lt; 0 - slop) || (x &gt;= getWidth() + slop) ||  </span><br><span class=\"line\">                        (y &lt; 0 - slop) || (y &gt;= getHeight() + slop)) &#123;  </span><br><span class=\"line\">                    // Outside button  </span><br><span class=\"line\">                    removeTapCallback();  </span><br><span class=\"line\">                    if ((mPrivateFlags &amp; PRESSED) != 0) &#123;  </span><br><span class=\"line\">                        // Remove any future long press/tap checks  </span><br><span class=\"line\">                        removeLongPressCallback();  </span><br><span class=\"line\">                        // Need to switch from pressed to not pressed  </span><br><span class=\"line\">                        mPrivateFlags &amp;= ~PRESSED;  </span><br><span class=\"line\">                        refreshDrawableState();  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        return true;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return false;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当事件为MotionEvent.ACTION_UP时，如果该控件可点击，会执行performClick()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean performClick() &#123;  </span><br><span class=\"line\">    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);  </span><br><span class=\"line\">    if (mOnClickListener != null) &#123;  </span><br><span class=\"line\">        playSoundEffect(SoundEffectConstants.CLICK);  </span><br><span class=\"line\">        mOnClickListener.onClick(this);  </span><br><span class=\"line\">        return true;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return false;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从源码可以看出，基本上每一次事件，都会return 一个true，也就是消耗掉这次事件了。而之后的事件会重新进入，这也和之前的截断事件机制符合。</p>\n<h1 id=\"onTouch和onTouchEvent有什么区别，又该如何使用？\"><a href=\"#onTouch和onTouchEvent有什么区别，又该如何使用？\" class=\"headerlink\" title=\"onTouch和onTouchEvent有什么区别，又该如何使用？\"></a>onTouch和onTouchEvent有什么区别，又该如何使用？</h1><p>从源码中可以看出，这两个方法都是在View的dispatchTouchEvent中调用的，onTouch优先于onTouchEvent执行。如果在onTouch方法中通过返回true将事件消费掉，onTouchEvent将不会再执行。<br>另外需要注意的是，onTouch能够得到执行需要两个前提条件，第一mOnTouchListener的值不能为空，第二当前点击的控件必须是enable的。因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。</p>\n<h1 id=\"为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？\"><a href=\"#为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？\" class=\"headerlink\" title=\"为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？\"></a>为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？</h1><p>比如说左右滑的时候，还是正常的左右滑。<br>但是上下滑的时候，会出现一个问题，就是listview无法上下滑动，这主要是事件被scrollview给消耗掉了，需要在触摸的时候，scrollview不进行截断操作，让事件能够传递下去。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>假如一个button<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.setOnClickListener(new OnClickListener()&#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onClick(View v)&#123;</span><br><span class=\"line\">\t\tLog.d(&quot;TAG&quot;,&quot;onClick execute&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>同时设置ontouch事件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.setOnTouchListener(new OnTouchListener()&#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic boolean onTouch(View v, MotionEvent event)&#123;</span><br><span class=\"line\">\t\tLog.d(&quot;TAG&quot;,&quot;onTouch execute, action &quot;+ event.getAction());</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>点击按钮log如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onTouch execute, action 0</span><br><span class=\"line\">onTouch execute, action 1</span><br><span class=\"line\">onClick execute</span><br></pre></td></tr></table></figure></p>\n<p>onTouch是优先于onClick执行的，并且onTouch执行了2次，一次是ACTION_DOWN,一次是ACTION_UP。<br>顺序是先经过onTouch，在传递到onClick。</p>\n<p>将ontouch返回值改为true，在运行一次，会发现onClick不再执行，这就是拦截了。</p>\n<h1 id=\"dispatchTouchEvent\"><a href=\"#dispatchTouchEvent\" class=\"headerlink\" title=\"dispatchTouchEvent\"></a>dispatchTouchEvent</h1><p>任何view被触摸，一定会执行dispatchTouchEvent这个方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean dispatchTouchEvent(MotionEvent event) &#123;  </span><br><span class=\"line\">    if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;  </span><br><span class=\"line\">            mOnTouchListener.onTouch(this, event)) &#123;  </span><br><span class=\"line\">        return true;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return onTouchEvent(event);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码很明显的指出了，首先会执行的是set的onTouchListener的onTouch事件，之后才会执行自身的onTouchEvent事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean onTouchEvent(MotionEvent event) &#123;  </span><br><span class=\"line\">    final int viewFlags = mViewFlags;  </span><br><span class=\"line\">    if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;  </span><br><span class=\"line\">        // A disabled view that is clickable still consumes the touch  </span><br><span class=\"line\">        // events, it just doesn&apos;t respond to them.  </span><br><span class=\"line\">        return (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  </span><br><span class=\"line\">                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    if (mTouchDelegate != null) &#123;  </span><br><span class=\"line\">        if (mTouchDelegate.onTouchEvent(event)) &#123;  </span><br><span class=\"line\">            return true;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  </span><br><span class=\"line\">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;  </span><br><span class=\"line\">        switch (event.getAction()) &#123;  </span><br><span class=\"line\">            case MotionEvent.ACTION_UP:  </span><br><span class=\"line\">                boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0;  </span><br><span class=\"line\">                if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) &#123;  </span><br><span class=\"line\">                    // take focus if we don&apos;t have it already and we should in  </span><br><span class=\"line\">                    // touch mode.  </span><br><span class=\"line\">                    boolean focusTaken = false;  </span><br><span class=\"line\">                    if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;  </span><br><span class=\"line\">                        focusTaken = requestFocus();  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    if (!mHasPerformedLongPress) &#123;  </span><br><span class=\"line\">                        // This is a tap, so remove the longpress check  </span><br><span class=\"line\">                        removeLongPressCallback();  </span><br><span class=\"line\">                        // Only perform take click actions if we were in the pressed state  </span><br><span class=\"line\">                        if (!focusTaken) &#123;  </span><br><span class=\"line\">                            // Use a Runnable and post this rather than calling  </span><br><span class=\"line\">                            // performClick directly. This lets other visual state  </span><br><span class=\"line\">                            // of the view update before click actions start.  </span><br><span class=\"line\">                            if (mPerformClick == null) &#123;  </span><br><span class=\"line\">                                mPerformClick = new PerformClick();  </span><br><span class=\"line\">                            &#125;  </span><br><span class=\"line\">                            if (!post(mPerformClick)) &#123;  </span><br><span class=\"line\">                                performClick();  </span><br><span class=\"line\">                            &#125;  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    if (mUnsetPressedState == null) &#123;  </span><br><span class=\"line\">                        mUnsetPressedState = new UnsetPressedState();  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    if (prepressed) &#123;  </span><br><span class=\"line\">                        mPrivateFlags |= PRESSED;  </span><br><span class=\"line\">                        refreshDrawableState();  </span><br><span class=\"line\">                        postDelayed(mUnsetPressedState,  </span><br><span class=\"line\">                                ViewConfiguration.getPressedStateDuration());  </span><br><span class=\"line\">                    &#125; else if (!post(mUnsetPressedState)) &#123;  </span><br><span class=\"line\">                        // If the post failed, unpress right now  </span><br><span class=\"line\">                        mUnsetPressedState.run();  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    removeTapCallback();  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">            case MotionEvent.ACTION_DOWN:  </span><br><span class=\"line\">                if (mPendingCheckForTap == null) &#123;  </span><br><span class=\"line\">                    mPendingCheckForTap = new CheckForTap();  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                mPrivateFlags |= PREPRESSED;  </span><br><span class=\"line\">                mHasPerformedLongPress = false;  </span><br><span class=\"line\">                postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">            case MotionEvent.ACTION_CANCEL:  </span><br><span class=\"line\">                mPrivateFlags &amp;= ~PRESSED;  </span><br><span class=\"line\">                refreshDrawableState();  </span><br><span class=\"line\">                removeTapCallback();  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">            case MotionEvent.ACTION_MOVE:  </span><br><span class=\"line\">                final int x = (int) event.getX();  </span><br><span class=\"line\">                final int y = (int) event.getY();  </span><br><span class=\"line\">                // Be lenient about moving outside of buttons  </span><br><span class=\"line\">                int slop = mTouchSlop;  </span><br><span class=\"line\">                if ((x &lt; 0 - slop) || (x &gt;= getWidth() + slop) ||  </span><br><span class=\"line\">                        (y &lt; 0 - slop) || (y &gt;= getHeight() + slop)) &#123;  </span><br><span class=\"line\">                    // Outside button  </span><br><span class=\"line\">                    removeTapCallback();  </span><br><span class=\"line\">                    if ((mPrivateFlags &amp; PRESSED) != 0) &#123;  </span><br><span class=\"line\">                        // Remove any future long press/tap checks  </span><br><span class=\"line\">                        removeLongPressCallback();  </span><br><span class=\"line\">                        // Need to switch from pressed to not pressed  </span><br><span class=\"line\">                        mPrivateFlags &amp;= ~PRESSED;  </span><br><span class=\"line\">                        refreshDrawableState();  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        return true;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return false;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当事件为MotionEvent.ACTION_UP时，如果该控件可点击，会执行performClick()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean performClick() &#123;  </span><br><span class=\"line\">    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);  </span><br><span class=\"line\">    if (mOnClickListener != null) &#123;  </span><br><span class=\"line\">        playSoundEffect(SoundEffectConstants.CLICK);  </span><br><span class=\"line\">        mOnClickListener.onClick(this);  </span><br><span class=\"line\">        return true;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return false;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从源码可以看出，基本上每一次事件，都会return 一个true，也就是消耗掉这次事件了。而之后的事件会重新进入，这也和之前的截断事件机制符合。</p>\n<h1 id=\"onTouch和onTouchEvent有什么区别，又该如何使用？\"><a href=\"#onTouch和onTouchEvent有什么区别，又该如何使用？\" class=\"headerlink\" title=\"onTouch和onTouchEvent有什么区别，又该如何使用？\"></a>onTouch和onTouchEvent有什么区别，又该如何使用？</h1><p>从源码中可以看出，这两个方法都是在View的dispatchTouchEvent中调用的，onTouch优先于onTouchEvent执行。如果在onTouch方法中通过返回true将事件消费掉，onTouchEvent将不会再执行。<br>另外需要注意的是，onTouch能够得到执行需要两个前提条件，第一mOnTouchListener的值不能为空，第二当前点击的控件必须是enable的。因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。</p>\n<h1 id=\"为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？\"><a href=\"#为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？\" class=\"headerlink\" title=\"为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？\"></a>为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？</h1><p>比如说左右滑的时候，还是正常的左右滑。<br>但是上下滑的时候，会出现一个问题，就是listview无法上下滑动，这主要是事件被scrollview给消耗掉了，需要在触摸的时候，scrollview不进行截断操作，让事件能够传递下去。</p>\n"},{"title":"android持久化存储","date":"2018-01-03T06:57:26.000Z","_content":"\n# 内部存储（internalStorage）\n\ndata文件夹就是我们常说的内部存储，其中有两个文件夹需要关注，一个是app文件夹，一个是data文件夹。\n\n## app文件夹\n\napp文件夹里存放着我们所有安装的app的apk文件。\n\n## data文件夹\n\n这个文件夹里面都是一些包名，打开这些包名会看到：\n\n1. data/data/包名/shared_prefs\n2. data/data/包名/databases\n3. data/data/包名/files\n4. data/data/包名/cache\n\nsharedPreferenced的时候，数据持久化存储于本地，其实就是存在这个文件中的xml文件里面。\n数据库文件就是存储于databases文件夹中。\n普通数据存储在files中。\n缓存文件存储在cache文件夹中。\n\n\n# 外部存储（externalStorage）\n\n外部存储是我们平时操作最多的，外部存储一般就是我们看到的storage文件夹，当然也有mnt文件夹，不同厂家有可能不一样。\n一般来讲storage文件夹中有一个sdcard文件夹，这个文件夹中的文件又分为两类，一类是公有目录，一类是私有目录。公有目录又分为九大类，比如说DCIM、DOWNLOAD等这种系统为我们创建的文件夹。私有目录就是android这种文件夹，这个文件夹打开之后里面有一个data文件夹，打开这个data文件夹，里面有许多包名组成的文件夹。\n\n# 存储操作\n\n## 文件存储\n\n文件存储的所有文件默认放在/data/data/<packagename>/file/目录下\n\n### 文件写入\n\n```\npublic void save(String inputText){\n\tFIleOutputStream out = null;\n\tBufferedWriter writer = null;\n\ttry{\n\t\tout = openFileOutput(\"data\", Context.MODE_PRIVATE);\n\t\twriter = new BufferedWriter(new OutputStreamWriter(out));\n\t\twriter.write(inputText);\n\t}catch(FileNotFoundException e){\n\t\te.printStackTrace();\n\t}catch(IOException e){\n\t\te.printStackTrace();\n\t}finally{\n\t\tif(writer != null){\n\t\t\ttry{\n\t\t\t\twriter.close();\n\t\t\t}catch(IOException e){\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### 文件读取\n\n```\npublic String load(){\n\tFileInputStream in = null;\n\tBufferedReader reader = null;\n\tStringBuilder content = new StringBuilder();\n\ttry{\n\t\tin = openFileInput(\"data\");\n\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\tString line = \"\";\n\t\twhile((line = reader.readLine()) != null){\n\t\t\tcontent.append(line);\n\t\t}\n\t}catch(FileNotFoundException e){\n\t\te.printStackTrace();\n\t}catch(IOException e){\n\t\te.printStackTrace();\n\t}finally{\n\t\tif(reader != null){\n\t\t\ttry{\n\t\t\t\treader.close();\n\t\t\t}catch(IOException e){\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\treturn content.toString();\n}\n```\n\n## SharePreferences\n\nSharepreference默认放在/data/data/<packagename>/file/目录下\n\n### SharedPreferences写入\n\n```\n\tSharedPreferences.Editor editor = getSharedPreferences(\"data\", MODE_PRIVATE).edit();\n\teditor.putString(\"et_inputText\", \"sharePreferences test\");\n\teditor.commit();\n```\n\n### SharedPreferences读取\n\n```\n\tSharedPreferences sp = getSharedPreferences(\"data\", MODE_PRIVATE);\n\tString input = sp.getString(\"et_inputText\", \"请输入用户名\");//第二个参数是为空的默认信息\n```\n\n## SQLite数据库存储\n\nsqlite文件默认放在/data/data/<packagename>/datanases/目录下\n\n```\npublic class MyDataBaseHelper extends SQLiteOpenHelper{\n\tprivate static final String CREATE_BOOK = \"create table Book(id integer primary key autoincrement, author text, price real, pages integer, name text)\";\n\tprivate static final String CREATE_CATEGORY = \"create table Category(id integer primary key autoincrement, category_name text, category_code integer)\";\n\tprivate Context mContext;\n\tpublic MyDataBaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version){\n\t\tsuper(context, name, factory, version);\n\t\tmContext = context;\n\t}\n\t@Override\n\tpublic void onCreate(SQLiteDatabase db){\n\t\tdb.execSQL(CREATE_BOOK);\n\t\tdb.execSQL(CREATE_CATEGORY);\n\t\tToast.makeText(mContext, \"create succeed\", Toast.LENGTH_SHORT).show();\n\t}\n\t@Override\n\tpublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion){\n\t\tdb.execSQL(\"drop table if exists Book\");\n\t\tdb.execSQL(\"drop table if exists Category\");\n\t\tonCreate(db);\n\t}\n}\n```\n\n### 创建数据库\n\n```\n\tdbHelper = new MyDataBaseHelper(this, \"BookStore.db\", null, 2);\n```\n\n\n### 插入数据\n\n```\n\tSQLiteDatabase db = dbHelper.getWritableDatabase();\n\tContentValues values = new ContentValues();\n\tvalues.put(\"name\", \"Effective Java\");\n\tvalues.put(\"author\", \"Joshua Bloch\");\n\tvalues.put(\"pages\", 454);\n\tvalues.put(\"price\", 16.96);\n\tdb.insert(\"Book\", null, values);\n```\n\n### 更新数据\n\n```\n\tContentValues values = new ContentValues();\n\tvalues.put(\"price\", 198.00);\n\tSQLiteDatabase db = dbHelper.getReadableDatabase();\n\tdb.updata(\"Book\", values, \"name=?\",new String[]{'Android Programme'});\n```\n\n### 删除行\n\n```\n\tSQLiteDatabase db = dbHelper.getWritableDatabase();\n\tdb.delete(\"Book\", \"pages > ?\", new String[]{\"500\"});\n```","source":"_posts/android持久化存储.md","raw":"---\ntitle: android持久化存储\ndate: 2018-01-03 14:57:26\ntags: android\n---\n\n# 内部存储（internalStorage）\n\ndata文件夹就是我们常说的内部存储，其中有两个文件夹需要关注，一个是app文件夹，一个是data文件夹。\n\n## app文件夹\n\napp文件夹里存放着我们所有安装的app的apk文件。\n\n## data文件夹\n\n这个文件夹里面都是一些包名，打开这些包名会看到：\n\n1. data/data/包名/shared_prefs\n2. data/data/包名/databases\n3. data/data/包名/files\n4. data/data/包名/cache\n\nsharedPreferenced的时候，数据持久化存储于本地，其实就是存在这个文件中的xml文件里面。\n数据库文件就是存储于databases文件夹中。\n普通数据存储在files中。\n缓存文件存储在cache文件夹中。\n\n\n# 外部存储（externalStorage）\n\n外部存储是我们平时操作最多的，外部存储一般就是我们看到的storage文件夹，当然也有mnt文件夹，不同厂家有可能不一样。\n一般来讲storage文件夹中有一个sdcard文件夹，这个文件夹中的文件又分为两类，一类是公有目录，一类是私有目录。公有目录又分为九大类，比如说DCIM、DOWNLOAD等这种系统为我们创建的文件夹。私有目录就是android这种文件夹，这个文件夹打开之后里面有一个data文件夹，打开这个data文件夹，里面有许多包名组成的文件夹。\n\n# 存储操作\n\n## 文件存储\n\n文件存储的所有文件默认放在/data/data/<packagename>/file/目录下\n\n### 文件写入\n\n```\npublic void save(String inputText){\n\tFIleOutputStream out = null;\n\tBufferedWriter writer = null;\n\ttry{\n\t\tout = openFileOutput(\"data\", Context.MODE_PRIVATE);\n\t\twriter = new BufferedWriter(new OutputStreamWriter(out));\n\t\twriter.write(inputText);\n\t}catch(FileNotFoundException e){\n\t\te.printStackTrace();\n\t}catch(IOException e){\n\t\te.printStackTrace();\n\t}finally{\n\t\tif(writer != null){\n\t\t\ttry{\n\t\t\t\twriter.close();\n\t\t\t}catch(IOException e){\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### 文件读取\n\n```\npublic String load(){\n\tFileInputStream in = null;\n\tBufferedReader reader = null;\n\tStringBuilder content = new StringBuilder();\n\ttry{\n\t\tin = openFileInput(\"data\");\n\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\tString line = \"\";\n\t\twhile((line = reader.readLine()) != null){\n\t\t\tcontent.append(line);\n\t\t}\n\t}catch(FileNotFoundException e){\n\t\te.printStackTrace();\n\t}catch(IOException e){\n\t\te.printStackTrace();\n\t}finally{\n\t\tif(reader != null){\n\t\t\ttry{\n\t\t\t\treader.close();\n\t\t\t}catch(IOException e){\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\treturn content.toString();\n}\n```\n\n## SharePreferences\n\nSharepreference默认放在/data/data/<packagename>/file/目录下\n\n### SharedPreferences写入\n\n```\n\tSharedPreferences.Editor editor = getSharedPreferences(\"data\", MODE_PRIVATE).edit();\n\teditor.putString(\"et_inputText\", \"sharePreferences test\");\n\teditor.commit();\n```\n\n### SharedPreferences读取\n\n```\n\tSharedPreferences sp = getSharedPreferences(\"data\", MODE_PRIVATE);\n\tString input = sp.getString(\"et_inputText\", \"请输入用户名\");//第二个参数是为空的默认信息\n```\n\n## SQLite数据库存储\n\nsqlite文件默认放在/data/data/<packagename>/datanases/目录下\n\n```\npublic class MyDataBaseHelper extends SQLiteOpenHelper{\n\tprivate static final String CREATE_BOOK = \"create table Book(id integer primary key autoincrement, author text, price real, pages integer, name text)\";\n\tprivate static final String CREATE_CATEGORY = \"create table Category(id integer primary key autoincrement, category_name text, category_code integer)\";\n\tprivate Context mContext;\n\tpublic MyDataBaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version){\n\t\tsuper(context, name, factory, version);\n\t\tmContext = context;\n\t}\n\t@Override\n\tpublic void onCreate(SQLiteDatabase db){\n\t\tdb.execSQL(CREATE_BOOK);\n\t\tdb.execSQL(CREATE_CATEGORY);\n\t\tToast.makeText(mContext, \"create succeed\", Toast.LENGTH_SHORT).show();\n\t}\n\t@Override\n\tpublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion){\n\t\tdb.execSQL(\"drop table if exists Book\");\n\t\tdb.execSQL(\"drop table if exists Category\");\n\t\tonCreate(db);\n\t}\n}\n```\n\n### 创建数据库\n\n```\n\tdbHelper = new MyDataBaseHelper(this, \"BookStore.db\", null, 2);\n```\n\n\n### 插入数据\n\n```\n\tSQLiteDatabase db = dbHelper.getWritableDatabase();\n\tContentValues values = new ContentValues();\n\tvalues.put(\"name\", \"Effective Java\");\n\tvalues.put(\"author\", \"Joshua Bloch\");\n\tvalues.put(\"pages\", 454);\n\tvalues.put(\"price\", 16.96);\n\tdb.insert(\"Book\", null, values);\n```\n\n### 更新数据\n\n```\n\tContentValues values = new ContentValues();\n\tvalues.put(\"price\", 198.00);\n\tSQLiteDatabase db = dbHelper.getReadableDatabase();\n\tdb.updata(\"Book\", values, \"name=?\",new String[]{'Android Programme'});\n```\n\n### 删除行\n\n```\n\tSQLiteDatabase db = dbHelper.getWritableDatabase();\n\tdb.delete(\"Book\", \"pages > ?\", new String[]{\"500\"});\n```","slug":"android持久化存储","published":1,"updated":"2019-03-12T09:26:33.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxp002f3a8kkdbr5gv2","content":"<h1 id=\"内部存储（internalStorage）\"><a href=\"#内部存储（internalStorage）\" class=\"headerlink\" title=\"内部存储（internalStorage）\"></a>内部存储（internalStorage）</h1><p>data文件夹就是我们常说的内部存储，其中有两个文件夹需要关注，一个是app文件夹，一个是data文件夹。</p>\n<h2 id=\"app文件夹\"><a href=\"#app文件夹\" class=\"headerlink\" title=\"app文件夹\"></a>app文件夹</h2><p>app文件夹里存放着我们所有安装的app的apk文件。</p>\n<h2 id=\"data文件夹\"><a href=\"#data文件夹\" class=\"headerlink\" title=\"data文件夹\"></a>data文件夹</h2><p>这个文件夹里面都是一些包名，打开这些包名会看到：</p>\n<ol>\n<li>data/data/包名/shared_prefs</li>\n<li>data/data/包名/databases</li>\n<li>data/data/包名/files</li>\n<li>data/data/包名/cache</li>\n</ol>\n<p>sharedPreferenced的时候，数据持久化存储于本地，其实就是存在这个文件中的xml文件里面。<br>数据库文件就是存储于databases文件夹中。<br>普通数据存储在files中。<br>缓存文件存储在cache文件夹中。</p>\n<h1 id=\"外部存储（externalStorage）\"><a href=\"#外部存储（externalStorage）\" class=\"headerlink\" title=\"外部存储（externalStorage）\"></a>外部存储（externalStorage）</h1><p>外部存储是我们平时操作最多的，外部存储一般就是我们看到的storage文件夹，当然也有mnt文件夹，不同厂家有可能不一样。<br>一般来讲storage文件夹中有一个sdcard文件夹，这个文件夹中的文件又分为两类，一类是公有目录，一类是私有目录。公有目录又分为九大类，比如说DCIM、DOWNLOAD等这种系统为我们创建的文件夹。私有目录就是android这种文件夹，这个文件夹打开之后里面有一个data文件夹，打开这个data文件夹，里面有许多包名组成的文件夹。</p>\n<h1 id=\"存储操作\"><a href=\"#存储操作\" class=\"headerlink\" title=\"存储操作\"></a>存储操作</h1><h2 id=\"文件存储\"><a href=\"#文件存储\" class=\"headerlink\" title=\"文件存储\"></a>文件存储</h2><p>文件存储的所有文件默认放在/data/data/<packagename>/file/目录下</packagename></p>\n<h3 id=\"文件写入\"><a href=\"#文件写入\" class=\"headerlink\" title=\"文件写入\"></a>文件写入</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void save(String inputText)&#123;</span><br><span class=\"line\">\tFIleOutputStream out = null;</span><br><span class=\"line\">\tBufferedWriter writer = null;</span><br><span class=\"line\">\ttry&#123;</span><br><span class=\"line\">\t\tout = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE);</span><br><span class=\"line\">\t\twriter = new BufferedWriter(new OutputStreamWriter(out));</span><br><span class=\"line\">\t\twriter.write(inputText);</span><br><span class=\"line\">\t&#125;catch(FileNotFoundException e)&#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;catch(IOException e)&#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;finally&#123;</span><br><span class=\"line\">\t\tif(writer != null)&#123;</span><br><span class=\"line\">\t\t\ttry&#123;</span><br><span class=\"line\">\t\t\t\twriter.close();</span><br><span class=\"line\">\t\t\t&#125;catch(IOException e)&#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"文件读取\"><a href=\"#文件读取\" class=\"headerlink\" title=\"文件读取\"></a>文件读取</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String load()&#123;</span><br><span class=\"line\">\tFileInputStream in = null;</span><br><span class=\"line\">\tBufferedReader reader = null;</span><br><span class=\"line\">\tStringBuilder content = new StringBuilder();</span><br><span class=\"line\">\ttry&#123;</span><br><span class=\"line\">\t\tin = openFileInput(&quot;data&quot;);</span><br><span class=\"line\">\t\treader = new BufferedReader(new InputStreamReader(in));</span><br><span class=\"line\">\t\tString line = &quot;&quot;;</span><br><span class=\"line\">\t\twhile((line = reader.readLine()) != null)&#123;</span><br><span class=\"line\">\t\t\tcontent.append(line);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;catch(FileNotFoundException e)&#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;catch(IOException e)&#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;finally&#123;</span><br><span class=\"line\">\t\tif(reader != null)&#123;</span><br><span class=\"line\">\t\t\ttry&#123;</span><br><span class=\"line\">\t\t\t\treader.close();</span><br><span class=\"line\">\t\t\t&#125;catch(IOException e)&#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn content.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"SharePreferences\"><a href=\"#SharePreferences\" class=\"headerlink\" title=\"SharePreferences\"></a>SharePreferences</h2><p>Sharepreference默认放在/data/data/<packagename>/file/目录下</packagename></p>\n<h3 id=\"SharedPreferences写入\"><a href=\"#SharedPreferences写入\" class=\"headerlink\" title=\"SharedPreferences写入\"></a>SharedPreferences写入</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SharedPreferences.Editor editor = getSharedPreferences(&quot;data&quot;, MODE_PRIVATE).edit();</span><br><span class=\"line\">editor.putString(&quot;et_inputText&quot;, &quot;sharePreferences test&quot;);</span><br><span class=\"line\">editor.commit();</span><br></pre></td></tr></table></figure>\n<h3 id=\"SharedPreferences读取\"><a href=\"#SharedPreferences读取\" class=\"headerlink\" title=\"SharedPreferences读取\"></a>SharedPreferences读取</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SharedPreferences sp = getSharedPreferences(&quot;data&quot;, MODE_PRIVATE);</span><br><span class=\"line\">String input = sp.getString(&quot;et_inputText&quot;, &quot;请输入用户名&quot;);//第二个参数是为空的默认信息</span><br></pre></td></tr></table></figure>\n<h2 id=\"SQLite数据库存储\"><a href=\"#SQLite数据库存储\" class=\"headerlink\" title=\"SQLite数据库存储\"></a>SQLite数据库存储</h2><p>sqlite文件默认放在/data/data/<packagename>/datanases/目录下</packagename></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyDataBaseHelper extends SQLiteOpenHelper&#123;</span><br><span class=\"line\">\tprivate static final String CREATE_BOOK = &quot;create table Book(id integer primary key autoincrement, author text, price real, pages integer, name text)&quot;;</span><br><span class=\"line\">\tprivate static final String CREATE_CATEGORY = &quot;create table Category(id integer primary key autoincrement, category_name text, category_code integer)&quot;;</span><br><span class=\"line\">\tprivate Context mContext;</span><br><span class=\"line\">\tpublic MyDataBaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version)&#123;</span><br><span class=\"line\">\t\tsuper(context, name, factory, version);</span><br><span class=\"line\">\t\tmContext = context;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onCreate(SQLiteDatabase db)&#123;</span><br><span class=\"line\">\t\tdb.execSQL(CREATE_BOOK);</span><br><span class=\"line\">\t\tdb.execSQL(CREATE_CATEGORY);</span><br><span class=\"line\">\t\tToast.makeText(mContext, &quot;create succeed&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)&#123;</span><br><span class=\"line\">\t\tdb.execSQL(&quot;drop table if exists Book&quot;);</span><br><span class=\"line\">\t\tdb.execSQL(&quot;drop table if exists Category&quot;);</span><br><span class=\"line\">\t\tonCreate(db);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dbHelper = new MyDataBaseHelper(this, &quot;BookStore.db&quot;, null, 2);</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class=\"line\">ContentValues values = new ContentValues();</span><br><span class=\"line\">values.put(&quot;name&quot;, &quot;Effective Java&quot;);</span><br><span class=\"line\">values.put(&quot;author&quot;, &quot;Joshua Bloch&quot;);</span><br><span class=\"line\">values.put(&quot;pages&quot;, 454);</span><br><span class=\"line\">values.put(&quot;price&quot;, 16.96);</span><br><span class=\"line\">db.insert(&quot;Book&quot;, null, values);</span><br></pre></td></tr></table></figure>\n<h3 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ContentValues values = new ContentValues();</span><br><span class=\"line\">values.put(&quot;price&quot;, 198.00);</span><br><span class=\"line\">SQLiteDatabase db = dbHelper.getReadableDatabase();</span><br><span class=\"line\">db.updata(&quot;Book&quot;, values, &quot;name=?&quot;,new String[]&#123;&apos;Android Programme&apos;&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除行\"><a href=\"#删除行\" class=\"headerlink\" title=\"删除行\"></a>删除行</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class=\"line\">db.delete(&quot;Book&quot;, &quot;pages &gt; ?&quot;, new String[]&#123;&quot;500&quot;&#125;);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"内部存储（internalStorage）\"><a href=\"#内部存储（internalStorage）\" class=\"headerlink\" title=\"内部存储（internalStorage）\"></a>内部存储（internalStorage）</h1><p>data文件夹就是我们常说的内部存储，其中有两个文件夹需要关注，一个是app文件夹，一个是data文件夹。</p>\n<h2 id=\"app文件夹\"><a href=\"#app文件夹\" class=\"headerlink\" title=\"app文件夹\"></a>app文件夹</h2><p>app文件夹里存放着我们所有安装的app的apk文件。</p>\n<h2 id=\"data文件夹\"><a href=\"#data文件夹\" class=\"headerlink\" title=\"data文件夹\"></a>data文件夹</h2><p>这个文件夹里面都是一些包名，打开这些包名会看到：</p>\n<ol>\n<li>data/data/包名/shared_prefs</li>\n<li>data/data/包名/databases</li>\n<li>data/data/包名/files</li>\n<li>data/data/包名/cache</li>\n</ol>\n<p>sharedPreferenced的时候，数据持久化存储于本地，其实就是存在这个文件中的xml文件里面。<br>数据库文件就是存储于databases文件夹中。<br>普通数据存储在files中。<br>缓存文件存储在cache文件夹中。</p>\n<h1 id=\"外部存储（externalStorage）\"><a href=\"#外部存储（externalStorage）\" class=\"headerlink\" title=\"外部存储（externalStorage）\"></a>外部存储（externalStorage）</h1><p>外部存储是我们平时操作最多的，外部存储一般就是我们看到的storage文件夹，当然也有mnt文件夹，不同厂家有可能不一样。<br>一般来讲storage文件夹中有一个sdcard文件夹，这个文件夹中的文件又分为两类，一类是公有目录，一类是私有目录。公有目录又分为九大类，比如说DCIM、DOWNLOAD等这种系统为我们创建的文件夹。私有目录就是android这种文件夹，这个文件夹打开之后里面有一个data文件夹，打开这个data文件夹，里面有许多包名组成的文件夹。</p>\n<h1 id=\"存储操作\"><a href=\"#存储操作\" class=\"headerlink\" title=\"存储操作\"></a>存储操作</h1><h2 id=\"文件存储\"><a href=\"#文件存储\" class=\"headerlink\" title=\"文件存储\"></a>文件存储</h2><p>文件存储的所有文件默认放在/data/data/<packagename>/file/目录下</packagename></p>\n<h3 id=\"文件写入\"><a href=\"#文件写入\" class=\"headerlink\" title=\"文件写入\"></a>文件写入</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void save(String inputText)&#123;</span><br><span class=\"line\">\tFIleOutputStream out = null;</span><br><span class=\"line\">\tBufferedWriter writer = null;</span><br><span class=\"line\">\ttry&#123;</span><br><span class=\"line\">\t\tout = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE);</span><br><span class=\"line\">\t\twriter = new BufferedWriter(new OutputStreamWriter(out));</span><br><span class=\"line\">\t\twriter.write(inputText);</span><br><span class=\"line\">\t&#125;catch(FileNotFoundException e)&#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;catch(IOException e)&#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;finally&#123;</span><br><span class=\"line\">\t\tif(writer != null)&#123;</span><br><span class=\"line\">\t\t\ttry&#123;</span><br><span class=\"line\">\t\t\t\twriter.close();</span><br><span class=\"line\">\t\t\t&#125;catch(IOException e)&#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"文件读取\"><a href=\"#文件读取\" class=\"headerlink\" title=\"文件读取\"></a>文件读取</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String load()&#123;</span><br><span class=\"line\">\tFileInputStream in = null;</span><br><span class=\"line\">\tBufferedReader reader = null;</span><br><span class=\"line\">\tStringBuilder content = new StringBuilder();</span><br><span class=\"line\">\ttry&#123;</span><br><span class=\"line\">\t\tin = openFileInput(&quot;data&quot;);</span><br><span class=\"line\">\t\treader = new BufferedReader(new InputStreamReader(in));</span><br><span class=\"line\">\t\tString line = &quot;&quot;;</span><br><span class=\"line\">\t\twhile((line = reader.readLine()) != null)&#123;</span><br><span class=\"line\">\t\t\tcontent.append(line);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;catch(FileNotFoundException e)&#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;catch(IOException e)&#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;finally&#123;</span><br><span class=\"line\">\t\tif(reader != null)&#123;</span><br><span class=\"line\">\t\t\ttry&#123;</span><br><span class=\"line\">\t\t\t\treader.close();</span><br><span class=\"line\">\t\t\t&#125;catch(IOException e)&#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn content.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"SharePreferences\"><a href=\"#SharePreferences\" class=\"headerlink\" title=\"SharePreferences\"></a>SharePreferences</h2><p>Sharepreference默认放在/data/data/<packagename>/file/目录下</packagename></p>\n<h3 id=\"SharedPreferences写入\"><a href=\"#SharedPreferences写入\" class=\"headerlink\" title=\"SharedPreferences写入\"></a>SharedPreferences写入</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SharedPreferences.Editor editor = getSharedPreferences(&quot;data&quot;, MODE_PRIVATE).edit();</span><br><span class=\"line\">editor.putString(&quot;et_inputText&quot;, &quot;sharePreferences test&quot;);</span><br><span class=\"line\">editor.commit();</span><br></pre></td></tr></table></figure>\n<h3 id=\"SharedPreferences读取\"><a href=\"#SharedPreferences读取\" class=\"headerlink\" title=\"SharedPreferences读取\"></a>SharedPreferences读取</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SharedPreferences sp = getSharedPreferences(&quot;data&quot;, MODE_PRIVATE);</span><br><span class=\"line\">String input = sp.getString(&quot;et_inputText&quot;, &quot;请输入用户名&quot;);//第二个参数是为空的默认信息</span><br></pre></td></tr></table></figure>\n<h2 id=\"SQLite数据库存储\"><a href=\"#SQLite数据库存储\" class=\"headerlink\" title=\"SQLite数据库存储\"></a>SQLite数据库存储</h2><p>sqlite文件默认放在/data/data/<packagename>/datanases/目录下</packagename></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyDataBaseHelper extends SQLiteOpenHelper&#123;</span><br><span class=\"line\">\tprivate static final String CREATE_BOOK = &quot;create table Book(id integer primary key autoincrement, author text, price real, pages integer, name text)&quot;;</span><br><span class=\"line\">\tprivate static final String CREATE_CATEGORY = &quot;create table Category(id integer primary key autoincrement, category_name text, category_code integer)&quot;;</span><br><span class=\"line\">\tprivate Context mContext;</span><br><span class=\"line\">\tpublic MyDataBaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version)&#123;</span><br><span class=\"line\">\t\tsuper(context, name, factory, version);</span><br><span class=\"line\">\t\tmContext = context;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onCreate(SQLiteDatabase db)&#123;</span><br><span class=\"line\">\t\tdb.execSQL(CREATE_BOOK);</span><br><span class=\"line\">\t\tdb.execSQL(CREATE_CATEGORY);</span><br><span class=\"line\">\t\tToast.makeText(mContext, &quot;create succeed&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)&#123;</span><br><span class=\"line\">\t\tdb.execSQL(&quot;drop table if exists Book&quot;);</span><br><span class=\"line\">\t\tdb.execSQL(&quot;drop table if exists Category&quot;);</span><br><span class=\"line\">\t\tonCreate(db);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dbHelper = new MyDataBaseHelper(this, &quot;BookStore.db&quot;, null, 2);</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class=\"line\">ContentValues values = new ContentValues();</span><br><span class=\"line\">values.put(&quot;name&quot;, &quot;Effective Java&quot;);</span><br><span class=\"line\">values.put(&quot;author&quot;, &quot;Joshua Bloch&quot;);</span><br><span class=\"line\">values.put(&quot;pages&quot;, 454);</span><br><span class=\"line\">values.put(&quot;price&quot;, 16.96);</span><br><span class=\"line\">db.insert(&quot;Book&quot;, null, values);</span><br></pre></td></tr></table></figure>\n<h3 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ContentValues values = new ContentValues();</span><br><span class=\"line\">values.put(&quot;price&quot;, 198.00);</span><br><span class=\"line\">SQLiteDatabase db = dbHelper.getReadableDatabase();</span><br><span class=\"line\">db.updata(&quot;Book&quot;, values, &quot;name=?&quot;,new String[]&#123;&apos;Android Programme&apos;&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除行\"><a href=\"#删除行\" class=\"headerlink\" title=\"删除行\"></a>删除行</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class=\"line\">db.delete(&quot;Book&quot;, &quot;pages &gt; ?&quot;, new String[]&#123;&quot;500&quot;&#125;);</span><br></pre></td></tr></table></figure>"},{"title":"android横竖屏切换总结","date":"2018-02-22T16:08:15.000Z","_content":"\n昨天看网上一个关于横竖屏切换的总结，里面说不设置activity的configChanges时，在竖屏切换横屏时会进行两次生命周期的加载，看到这个就很疑惑，为什么两次呢？结果试了一下，大相径庭。\n\n设备 samsung-galaxy-mega2\n\n+ 不设置configChanges时，从横屏切换到竖屏时的生命周期\n\nonPause -> onSaveInstanceState -> onStop -> onDestroy -> onCreate -> onStart -> onRestoreInstanceState -> onResume\n\n很明显，是一次activity的销毁和重建，onPause之后便进行了onSaveInstanceState 而onResume之前也进行了onRestoreInstanceState。很正常\n\n+ 不设置configChanges时，从竖屏切换到横屏时的生命周期\n\nonPause -> onSaveInstanceState -> onStop -> onDestroy -> onCreate -> onStart -> onRestoreInstanceState -> onResume\n\n和1状态一毛一样。并没有走两次。\n\n+ 设置configChanges = \"orientation\"时，从横屏切换到竖屏时的生命周期\n\nonPause -> onSaveInstanceState -> onStop -> onDestroy -> onCreate -> onStart -> onRestoreInstanceState -> onResume\n\n也是一毛一样\n\n+ 设置configChanges = \"orientation\"时，从竖屏切换到横屏的生命周期\n\nonPause -> onSaveInstanceState -> onStop -> onDestroy -> onCreate -> onStart -> onRestoreInstanceState -> onResume\n\n也是一毛一样\n\n这就代表着configChanges = \"orientation\"没有任何作用\n\n+ 设置configChanges = \"orientation|keyboardHidden\"时，从横屏切换到竖屏 && 竖屏切换到横屏的生命周期\n\nonPause -> onSaveInstanceState -> onStop -> onDestroy -> onCreate -> onStart -> onRestoreInstanceState -> onResume\n\n依旧一毛一样\n\n+ 设置configChanges = \"orientation|keyboardHidden|screensize\"时，从横屏切换到竖屏 && 竖屏切换到横屏的生命周期\n\n只走了onConfigurationChanged这一个方法。\n\n+ 只设置configChanges = \"screensize\" || 只设置configChanges = \"orientation\",从横屏切换到竖屏 || 竖屏切换到横屏的生命周期\n\nonPause -> onSaveInstanceState -> onStop -> onDestroy -> onCreate -> onStart -> onRestoreInstanceState -> onResume\n\n代表只设置一个是无效的\n\n+ 只设置configChanges = \"keyboardHidden|screensize\",从横屏切换到竖屏 && 竖屏切换到横屏的生命周期\n\nonPause -> onSaveInstanceState -> onStop -> onDestroy -> onCreate -> onStart -> onRestoreInstanceState -> onResume\n\n仍旧无效\n\n+ 只设置configChanges = \"orientation|screensize\",从横屏切换到竖屏 || 竖屏切换到横屏的生命周期\n\n只走了onConfigurationChanged这一个方法。\n\n\n###### 总结\n\n若activity的configChanges没有设置，或者设置却没有同时设置 orientation 和 screensize时，会导致activity销毁重建。\n\n而若是设置了configChanges = \"orientation|screensize\",则不会销毁，只会走onConfigurationChanged。\n\n和网上的内容大相径庭。若是偏信网上的内容，这部分的知识点就是错误的理解。\n\n###### 心得\n\n实践出真知！！！！！不能过于相信网上的内容，要自己动手实践一下。\n","source":"_posts/android横竖屏切换总结.md","raw":"---\ntitle: android横竖屏切换总结\ndate: 2018-02-23 00:08:15\ntags: android\n---\n\n昨天看网上一个关于横竖屏切换的总结，里面说不设置activity的configChanges时，在竖屏切换横屏时会进行两次生命周期的加载，看到这个就很疑惑，为什么两次呢？结果试了一下，大相径庭。\n\n设备 samsung-galaxy-mega2\n\n+ 不设置configChanges时，从横屏切换到竖屏时的生命周期\n\nonPause -> onSaveInstanceState -> onStop -> onDestroy -> onCreate -> onStart -> onRestoreInstanceState -> onResume\n\n很明显，是一次activity的销毁和重建，onPause之后便进行了onSaveInstanceState 而onResume之前也进行了onRestoreInstanceState。很正常\n\n+ 不设置configChanges时，从竖屏切换到横屏时的生命周期\n\nonPause -> onSaveInstanceState -> onStop -> onDestroy -> onCreate -> onStart -> onRestoreInstanceState -> onResume\n\n和1状态一毛一样。并没有走两次。\n\n+ 设置configChanges = \"orientation\"时，从横屏切换到竖屏时的生命周期\n\nonPause -> onSaveInstanceState -> onStop -> onDestroy -> onCreate -> onStart -> onRestoreInstanceState -> onResume\n\n也是一毛一样\n\n+ 设置configChanges = \"orientation\"时，从竖屏切换到横屏的生命周期\n\nonPause -> onSaveInstanceState -> onStop -> onDestroy -> onCreate -> onStart -> onRestoreInstanceState -> onResume\n\n也是一毛一样\n\n这就代表着configChanges = \"orientation\"没有任何作用\n\n+ 设置configChanges = \"orientation|keyboardHidden\"时，从横屏切换到竖屏 && 竖屏切换到横屏的生命周期\n\nonPause -> onSaveInstanceState -> onStop -> onDestroy -> onCreate -> onStart -> onRestoreInstanceState -> onResume\n\n依旧一毛一样\n\n+ 设置configChanges = \"orientation|keyboardHidden|screensize\"时，从横屏切换到竖屏 && 竖屏切换到横屏的生命周期\n\n只走了onConfigurationChanged这一个方法。\n\n+ 只设置configChanges = \"screensize\" || 只设置configChanges = \"orientation\",从横屏切换到竖屏 || 竖屏切换到横屏的生命周期\n\nonPause -> onSaveInstanceState -> onStop -> onDestroy -> onCreate -> onStart -> onRestoreInstanceState -> onResume\n\n代表只设置一个是无效的\n\n+ 只设置configChanges = \"keyboardHidden|screensize\",从横屏切换到竖屏 && 竖屏切换到横屏的生命周期\n\nonPause -> onSaveInstanceState -> onStop -> onDestroy -> onCreate -> onStart -> onRestoreInstanceState -> onResume\n\n仍旧无效\n\n+ 只设置configChanges = \"orientation|screensize\",从横屏切换到竖屏 || 竖屏切换到横屏的生命周期\n\n只走了onConfigurationChanged这一个方法。\n\n\n###### 总结\n\n若activity的configChanges没有设置，或者设置却没有同时设置 orientation 和 screensize时，会导致activity销毁重建。\n\n而若是设置了configChanges = \"orientation|screensize\",则不会销毁，只会走onConfigurationChanged。\n\n和网上的内容大相径庭。若是偏信网上的内容，这部分的知识点就是错误的理解。\n\n###### 心得\n\n实践出真知！！！！！不能过于相信网上的内容，要自己动手实践一下。\n","slug":"android横竖屏切换总结","published":1,"updated":"2019-03-12T09:26:33.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxq002h3a8kacaipbgd","content":"<p>昨天看网上一个关于横竖屏切换的总结，里面说不设置activity的configChanges时，在竖屏切换横屏时会进行两次生命周期的加载，看到这个就很疑惑，为什么两次呢？结果试了一下，大相径庭。</p>\n<p>设备 samsung-galaxy-mega2</p>\n<ul>\n<li>不设置configChanges时，从横屏切换到竖屏时的生命周期</li>\n</ul>\n<p>onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume</p>\n<p>很明显，是一次activity的销毁和重建，onPause之后便进行了onSaveInstanceState 而onResume之前也进行了onRestoreInstanceState。很正常</p>\n<ul>\n<li>不设置configChanges时，从竖屏切换到横屏时的生命周期</li>\n</ul>\n<p>onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume</p>\n<p>和1状态一毛一样。并没有走两次。</p>\n<ul>\n<li>设置configChanges = “orientation”时，从横屏切换到竖屏时的生命周期</li>\n</ul>\n<p>onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume</p>\n<p>也是一毛一样</p>\n<ul>\n<li>设置configChanges = “orientation”时，从竖屏切换到横屏的生命周期</li>\n</ul>\n<p>onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume</p>\n<p>也是一毛一样</p>\n<p>这就代表着configChanges = “orientation”没有任何作用</p>\n<ul>\n<li>设置configChanges = “orientation|keyboardHidden”时，从横屏切换到竖屏 &amp;&amp; 竖屏切换到横屏的生命周期</li>\n</ul>\n<p>onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume</p>\n<p>依旧一毛一样</p>\n<ul>\n<li>设置configChanges = “orientation|keyboardHidden|screensize”时，从横屏切换到竖屏 &amp;&amp; 竖屏切换到横屏的生命周期</li>\n</ul>\n<p>只走了onConfigurationChanged这一个方法。</p>\n<ul>\n<li>只设置configChanges = “screensize” || 只设置configChanges = “orientation”,从横屏切换到竖屏 || 竖屏切换到横屏的生命周期</li>\n</ul>\n<p>onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume</p>\n<p>代表只设置一个是无效的</p>\n<ul>\n<li>只设置configChanges = “keyboardHidden|screensize”,从横屏切换到竖屏 &amp;&amp; 竖屏切换到横屏的生命周期</li>\n</ul>\n<p>onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume</p>\n<p>仍旧无效</p>\n<ul>\n<li>只设置configChanges = “orientation|screensize”,从横屏切换到竖屏 || 竖屏切换到横屏的生命周期</li>\n</ul>\n<p>只走了onConfigurationChanged这一个方法。</p>\n<h6 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h6><p>若activity的configChanges没有设置，或者设置却没有同时设置 orientation 和 screensize时，会导致activity销毁重建。</p>\n<p>而若是设置了configChanges = “orientation|screensize”,则不会销毁，只会走onConfigurationChanged。</p>\n<p>和网上的内容大相径庭。若是偏信网上的内容，这部分的知识点就是错误的理解。</p>\n<h6 id=\"心得\"><a href=\"#心得\" class=\"headerlink\" title=\"心得\"></a>心得</h6><p>实践出真知！！！！！不能过于相信网上的内容，要自己动手实践一下。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>昨天看网上一个关于横竖屏切换的总结，里面说不设置activity的configChanges时，在竖屏切换横屏时会进行两次生命周期的加载，看到这个就很疑惑，为什么两次呢？结果试了一下，大相径庭。</p>\n<p>设备 samsung-galaxy-mega2</p>\n<ul>\n<li>不设置configChanges时，从横屏切换到竖屏时的生命周期</li>\n</ul>\n<p>onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume</p>\n<p>很明显，是一次activity的销毁和重建，onPause之后便进行了onSaveInstanceState 而onResume之前也进行了onRestoreInstanceState。很正常</p>\n<ul>\n<li>不设置configChanges时，从竖屏切换到横屏时的生命周期</li>\n</ul>\n<p>onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume</p>\n<p>和1状态一毛一样。并没有走两次。</p>\n<ul>\n<li>设置configChanges = “orientation”时，从横屏切换到竖屏时的生命周期</li>\n</ul>\n<p>onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume</p>\n<p>也是一毛一样</p>\n<ul>\n<li>设置configChanges = “orientation”时，从竖屏切换到横屏的生命周期</li>\n</ul>\n<p>onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume</p>\n<p>也是一毛一样</p>\n<p>这就代表着configChanges = “orientation”没有任何作用</p>\n<ul>\n<li>设置configChanges = “orientation|keyboardHidden”时，从横屏切换到竖屏 &amp;&amp; 竖屏切换到横屏的生命周期</li>\n</ul>\n<p>onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume</p>\n<p>依旧一毛一样</p>\n<ul>\n<li>设置configChanges = “orientation|keyboardHidden|screensize”时，从横屏切换到竖屏 &amp;&amp; 竖屏切换到横屏的生命周期</li>\n</ul>\n<p>只走了onConfigurationChanged这一个方法。</p>\n<ul>\n<li>只设置configChanges = “screensize” || 只设置configChanges = “orientation”,从横屏切换到竖屏 || 竖屏切换到横屏的生命周期</li>\n</ul>\n<p>onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume</p>\n<p>代表只设置一个是无效的</p>\n<ul>\n<li>只设置configChanges = “keyboardHidden|screensize”,从横屏切换到竖屏 &amp;&amp; 竖屏切换到横屏的生命周期</li>\n</ul>\n<p>onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume</p>\n<p>仍旧无效</p>\n<ul>\n<li>只设置configChanges = “orientation|screensize”,从横屏切换到竖屏 || 竖屏切换到横屏的生命周期</li>\n</ul>\n<p>只走了onConfigurationChanged这一个方法。</p>\n<h6 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h6><p>若activity的configChanges没有设置，或者设置却没有同时设置 orientation 和 screensize时，会导致activity销毁重建。</p>\n<p>而若是设置了configChanges = “orientation|screensize”,则不会销毁，只会走onConfigurationChanged。</p>\n<p>和网上的内容大相径庭。若是偏信网上的内容，这部分的知识点就是错误的理解。</p>\n<h6 id=\"心得\"><a href=\"#心得\" class=\"headerlink\" title=\"心得\"></a>心得</h6><p>实践出真知！！！！！不能过于相信网上的内容，要自己动手实践一下。</p>\n"},{"title":"android消息推送","date":"2018-01-07T10:48:46.000Z","_content":"之前与服务器通信的时候，使用的是handler轮询的机制，固定几秒来查一次接口数据。\n\n这样做有两个弊端，一个是当app被注销的时候，无法实现通知的功能。另一个是轮询无法达到实时性的地步。\n\n同时无法实现消息推送的功能。\n\nim通信的原理：客户端a发送消息->服务端处理->发送给客户端b\n\n消息推送的原理：客户端a发送消息->服务端处理->发送给客户端a\n\n\n# 长连接和短连接\n\n1. 长连接：客户端和服务器之间始终建立着一个通信连接，在连接没有中断之前，客户端和服务器之间可以随时通信\n典型范例 socket\n长连接实现的实时通讯，称作推送\n\n2. 短连接：通信双方有数据交互时，就建立一个连接，数据发送完成后，断开此连接\n典型范例 http\n短连接实现的实时通讯，称作轮询\n","source":"_posts/android消息推送.md","raw":"---\ntitle: android消息推送\ndate: 2018-01-07 18:48:46\ntags: android\n---\n之前与服务器通信的时候，使用的是handler轮询的机制，固定几秒来查一次接口数据。\n\n这样做有两个弊端，一个是当app被注销的时候，无法实现通知的功能。另一个是轮询无法达到实时性的地步。\n\n同时无法实现消息推送的功能。\n\nim通信的原理：客户端a发送消息->服务端处理->发送给客户端b\n\n消息推送的原理：客户端a发送消息->服务端处理->发送给客户端a\n\n\n# 长连接和短连接\n\n1. 长连接：客户端和服务器之间始终建立着一个通信连接，在连接没有中断之前，客户端和服务器之间可以随时通信\n典型范例 socket\n长连接实现的实时通讯，称作推送\n\n2. 短连接：通信双方有数据交互时，就建立一个连接，数据发送完成后，断开此连接\n典型范例 http\n短连接实现的实时通讯，称作轮询\n","slug":"android消息推送","published":1,"updated":"2019-03-12T09:26:33.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxr002j3a8kdsqcq820","content":"<p>之前与服务器通信的时候，使用的是handler轮询的机制，固定几秒来查一次接口数据。</p>\n<p>这样做有两个弊端，一个是当app被注销的时候，无法实现通知的功能。另一个是轮询无法达到实时性的地步。</p>\n<p>同时无法实现消息推送的功能。</p>\n<p>im通信的原理：客户端a发送消息-&gt;服务端处理-&gt;发送给客户端b</p>\n<p>消息推送的原理：客户端a发送消息-&gt;服务端处理-&gt;发送给客户端a</p>\n<h1 id=\"长连接和短连接\"><a href=\"#长连接和短连接\" class=\"headerlink\" title=\"长连接和短连接\"></a>长连接和短连接</h1><ol>\n<li><p>长连接：客户端和服务器之间始终建立着一个通信连接，在连接没有中断之前，客户端和服务器之间可以随时通信<br>典型范例 socket<br>长连接实现的实时通讯，称作推送</p>\n</li>\n<li><p>短连接：通信双方有数据交互时，就建立一个连接，数据发送完成后，断开此连接<br>典型范例 http<br>短连接实现的实时通讯，称作轮询</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>之前与服务器通信的时候，使用的是handler轮询的机制，固定几秒来查一次接口数据。</p>\n<p>这样做有两个弊端，一个是当app被注销的时候，无法实现通知的功能。另一个是轮询无法达到实时性的地步。</p>\n<p>同时无法实现消息推送的功能。</p>\n<p>im通信的原理：客户端a发送消息-&gt;服务端处理-&gt;发送给客户端b</p>\n<p>消息推送的原理：客户端a发送消息-&gt;服务端处理-&gt;发送给客户端a</p>\n<h1 id=\"长连接和短连接\"><a href=\"#长连接和短连接\" class=\"headerlink\" title=\"长连接和短连接\"></a>长连接和短连接</h1><ol>\n<li><p>长连接：客户端和服务器之间始终建立着一个通信连接，在连接没有中断之前，客户端和服务器之间可以随时通信<br>典型范例 socket<br>长连接实现的实时通讯，称作推送</p>\n</li>\n<li><p>短连接：通信双方有数据交互时，就建立一个连接，数据发送完成后，断开此连接<br>典型范例 http<br>短连接实现的实时通讯，称作轮询</p>\n</li>\n</ol>\n"},{"title":"android渠道包打包取舍以及打包流程分析","date":"2018-10-20T08:20:28.000Z","_content":"\n# 前述\n\n刚开始接手好搭的时候，用的是美团的多渠道打包方案，但是当时前人写的代码有些问题。\n\n当时的流程大致是：打包一个包，然后解压，修改META-INFO,之后重新压缩，过程中会生成一个额外的包含渠道名的文件。\n\n这样的好处是解压之后重新压缩，并不需要重新编译，也不需要重新签名。\n\n但是当时在apk启动的时候使用的读取渠道包的方式也是和官网提供的一样，没有变化。是启动时解压apk，然后读取相对应的文件。\n\n# 过去方式的缺点\n\n由于需要启动的时候解压apk，整个过程耗时大约200ms，而且是每次都会出现的。加上前人对于性能的优化也不是很在心，当时刚接手的时候启动速度十分慢（大约1-2秒的卡顿）。\n\n后来不得已，出于性能的考虑，对这个动了刀子。\n\n# 变化\n\n由于刚开始的渠道包并不算太多，因此第一个考虑就是使用gradle的变体来进行更改。\n\n变体是官方提供的，使用变体的话，平时打包也可以直接选定打什么包。对于项目来讲，省了不少时间。\n\n# 变体带来的缺点\n\n后期由于项目规模大了起来，增加了5个渠道，全渠道打包时间一下子长了很多，由刚开始的40分钟，猛增到一小时20多分钟。同时市场那边的意思是后期还会继续扩充渠道。\n\n因此现在必须要更改一下这个打包方式。\n\n# 想法1-raw\n\n第一种想法是脱离美团打包，通过自己设置资源文件夹下面的raw目录，来进行打包，raw文件在android里面是不会编译成二进制文件的，会原样保留到apk里面。在app启动的时候直接读raw文件。\n但是这种想法刚说出来就被进奎否了，当时的问题出在raw文件需要进行重新编译，否则不会出现在R.java中，而如果使用apktool重新编译，效率基本上和变体是55开。\n\n# 想法2-asset\n\n第二种想法是第一种想法的补充，既然raw文件需要通过编译来生成r，那我们找一个不需要编译的，想法很简单，打包之后直接塞一个文件到asset里面，这个文件就是配置文件，每次打包之后，解压，然后复制相对应渠道的配置文件到asset里面，这样就可以避免需要回编译的目的了。但是这个方法需要进行重新签名。\n\n# 想法3-美团方案优化\n\n在目前不需要配置额外的配置目录的情况下，想法2其实是有些牛刀小用了。事实上我们完全可以在美团的打包方案上面进行优化。美团提供的打包方案，当时细细想想，完全没有必要每次启动apk的时候都去读取。仅仅需要第一次打开app的时候，读取并写入sp中，之后每次读取sp，如果没有在去重新读取即可。这样可以省了好多事情。\n\n# 总结\n\n鉴于目前项目的规格以及需求，仅仅在需要扩充渠道的时候，仅仅需要重启美团的优化方案，同时优化每次编译的选项即可。但是在后续需要用到不同配置文件的时候，就需要使用想法2的方法，美团的方案不够支持那么详细。\n\n同时鉴于此，也算研究了一下app打包流程，顺便总结一下。\n\n# 打包流程\n\n![打包流程](/images/android/androidpackageimage.png)\n\n从官方图可以很明显的看出流程变化。\n\n1. 资源文件是通过aapt来进行打包的，aapt全称是Android Asset Packaging Tool，可以看出来，aapt打包生成了2个东西，一个是R,一个是compiled resources，像想法一之中的raw就是生成在r里面，compiled resources 是asset文件夹下面的东西，这些东西不会参与打包，而是直接被压缩进apk.\n\n关于asset和raw我之前一直认为raw是原封不动，不会编译成二进制，今天才知道两个相同点都是原封不动不会被编译成二进制。差别就是读写方式不同。因此想法1本来就是错误的。\n\n2. java编译器同时编译三者，一是代码，二是r文件，三是aidl编译下来的java接口。编译成class之后，然后和第三方class一起并到dex中（dex是好几个class合并起来的）。\n看到这边有个疑问，为什么是class？我们所知道的第三方包，有时候是使用aar的形式来进行依赖的，aar包含了资源文件，但是我查了一下，如果是aar的话。将会被打包到class.jar中，应该就是先打包到jar中，然后又会被放到dex中\n\n3. asset， resource， dex 三者就可以打包成一个apk了，此时使用apkbuilder即可，打包成一个未签名的apk。\n\n4. apk好了之后使用jarsigner来进行签名\n\n5. 按理说签名完之后就应该结束了，为什么还会有个zipaligh呢？\n\nzipalign的效果：zipalign是一个对齐工具，android基于linux，因此资源也是仿照linux来的，在多进程需要寻找资源的时候，最好的方式是按照linux架构来设计数据摆放位置，因此最好的是放在4字节层，这样子的话系统就不需要读取所有的文件，而直接可以类似链表的形式知道什么资源在什么地方。这样节省了大量的内存。因此这个步骤我们称之为对齐\n\n","source":"_posts/android渠道包打包取舍以及打包流程分析.md","raw":"---\ntitle: android渠道包打包取舍以及打包流程分析\ndate: 2018-10-20 16:20:28\ntags: android\n---\n\n# 前述\n\n刚开始接手好搭的时候，用的是美团的多渠道打包方案，但是当时前人写的代码有些问题。\n\n当时的流程大致是：打包一个包，然后解压，修改META-INFO,之后重新压缩，过程中会生成一个额外的包含渠道名的文件。\n\n这样的好处是解压之后重新压缩，并不需要重新编译，也不需要重新签名。\n\n但是当时在apk启动的时候使用的读取渠道包的方式也是和官网提供的一样，没有变化。是启动时解压apk，然后读取相对应的文件。\n\n# 过去方式的缺点\n\n由于需要启动的时候解压apk，整个过程耗时大约200ms，而且是每次都会出现的。加上前人对于性能的优化也不是很在心，当时刚接手的时候启动速度十分慢（大约1-2秒的卡顿）。\n\n后来不得已，出于性能的考虑，对这个动了刀子。\n\n# 变化\n\n由于刚开始的渠道包并不算太多，因此第一个考虑就是使用gradle的变体来进行更改。\n\n变体是官方提供的，使用变体的话，平时打包也可以直接选定打什么包。对于项目来讲，省了不少时间。\n\n# 变体带来的缺点\n\n后期由于项目规模大了起来，增加了5个渠道，全渠道打包时间一下子长了很多，由刚开始的40分钟，猛增到一小时20多分钟。同时市场那边的意思是后期还会继续扩充渠道。\n\n因此现在必须要更改一下这个打包方式。\n\n# 想法1-raw\n\n第一种想法是脱离美团打包，通过自己设置资源文件夹下面的raw目录，来进行打包，raw文件在android里面是不会编译成二进制文件的，会原样保留到apk里面。在app启动的时候直接读raw文件。\n但是这种想法刚说出来就被进奎否了，当时的问题出在raw文件需要进行重新编译，否则不会出现在R.java中，而如果使用apktool重新编译，效率基本上和变体是55开。\n\n# 想法2-asset\n\n第二种想法是第一种想法的补充，既然raw文件需要通过编译来生成r，那我们找一个不需要编译的，想法很简单，打包之后直接塞一个文件到asset里面，这个文件就是配置文件，每次打包之后，解压，然后复制相对应渠道的配置文件到asset里面，这样就可以避免需要回编译的目的了。但是这个方法需要进行重新签名。\n\n# 想法3-美团方案优化\n\n在目前不需要配置额外的配置目录的情况下，想法2其实是有些牛刀小用了。事实上我们完全可以在美团的打包方案上面进行优化。美团提供的打包方案，当时细细想想，完全没有必要每次启动apk的时候都去读取。仅仅需要第一次打开app的时候，读取并写入sp中，之后每次读取sp，如果没有在去重新读取即可。这样可以省了好多事情。\n\n# 总结\n\n鉴于目前项目的规格以及需求，仅仅在需要扩充渠道的时候，仅仅需要重启美团的优化方案，同时优化每次编译的选项即可。但是在后续需要用到不同配置文件的时候，就需要使用想法2的方法，美团的方案不够支持那么详细。\n\n同时鉴于此，也算研究了一下app打包流程，顺便总结一下。\n\n# 打包流程\n\n![打包流程](/images/android/androidpackageimage.png)\n\n从官方图可以很明显的看出流程变化。\n\n1. 资源文件是通过aapt来进行打包的，aapt全称是Android Asset Packaging Tool，可以看出来，aapt打包生成了2个东西，一个是R,一个是compiled resources，像想法一之中的raw就是生成在r里面，compiled resources 是asset文件夹下面的东西，这些东西不会参与打包，而是直接被压缩进apk.\n\n关于asset和raw我之前一直认为raw是原封不动，不会编译成二进制，今天才知道两个相同点都是原封不动不会被编译成二进制。差别就是读写方式不同。因此想法1本来就是错误的。\n\n2. java编译器同时编译三者，一是代码，二是r文件，三是aidl编译下来的java接口。编译成class之后，然后和第三方class一起并到dex中（dex是好几个class合并起来的）。\n看到这边有个疑问，为什么是class？我们所知道的第三方包，有时候是使用aar的形式来进行依赖的，aar包含了资源文件，但是我查了一下，如果是aar的话。将会被打包到class.jar中，应该就是先打包到jar中，然后又会被放到dex中\n\n3. asset， resource， dex 三者就可以打包成一个apk了，此时使用apkbuilder即可，打包成一个未签名的apk。\n\n4. apk好了之后使用jarsigner来进行签名\n\n5. 按理说签名完之后就应该结束了，为什么还会有个zipaligh呢？\n\nzipalign的效果：zipalign是一个对齐工具，android基于linux，因此资源也是仿照linux来的，在多进程需要寻找资源的时候，最好的方式是按照linux架构来设计数据摆放位置，因此最好的是放在4字节层，这样子的话系统就不需要读取所有的文件，而直接可以类似链表的形式知道什么资源在什么地方。这样节省了大量的内存。因此这个步骤我们称之为对齐\n\n","slug":"android渠道包打包取舍以及打包流程分析","published":1,"updated":"2019-03-12T09:26:33.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxs002l3a8ku39kottj","content":"<h1 id=\"前述\"><a href=\"#前述\" class=\"headerlink\" title=\"前述\"></a>前述</h1><p>刚开始接手好搭的时候，用的是美团的多渠道打包方案，但是当时前人写的代码有些问题。</p>\n<p>当时的流程大致是：打包一个包，然后解压，修改META-INFO,之后重新压缩，过程中会生成一个额外的包含渠道名的文件。</p>\n<p>这样的好处是解压之后重新压缩，并不需要重新编译，也不需要重新签名。</p>\n<p>但是当时在apk启动的时候使用的读取渠道包的方式也是和官网提供的一样，没有变化。是启动时解压apk，然后读取相对应的文件。</p>\n<h1 id=\"过去方式的缺点\"><a href=\"#过去方式的缺点\" class=\"headerlink\" title=\"过去方式的缺点\"></a>过去方式的缺点</h1><p>由于需要启动的时候解压apk，整个过程耗时大约200ms，而且是每次都会出现的。加上前人对于性能的优化也不是很在心，当时刚接手的时候启动速度十分慢（大约1-2秒的卡顿）。</p>\n<p>后来不得已，出于性能的考虑，对这个动了刀子。</p>\n<h1 id=\"变化\"><a href=\"#变化\" class=\"headerlink\" title=\"变化\"></a>变化</h1><p>由于刚开始的渠道包并不算太多，因此第一个考虑就是使用gradle的变体来进行更改。</p>\n<p>变体是官方提供的，使用变体的话，平时打包也可以直接选定打什么包。对于项目来讲，省了不少时间。</p>\n<h1 id=\"变体带来的缺点\"><a href=\"#变体带来的缺点\" class=\"headerlink\" title=\"变体带来的缺点\"></a>变体带来的缺点</h1><p>后期由于项目规模大了起来，增加了5个渠道，全渠道打包时间一下子长了很多，由刚开始的40分钟，猛增到一小时20多分钟。同时市场那边的意思是后期还会继续扩充渠道。</p>\n<p>因此现在必须要更改一下这个打包方式。</p>\n<h1 id=\"想法1-raw\"><a href=\"#想法1-raw\" class=\"headerlink\" title=\"想法1-raw\"></a>想法1-raw</h1><p>第一种想法是脱离美团打包，通过自己设置资源文件夹下面的raw目录，来进行打包，raw文件在android里面是不会编译成二进制文件的，会原样保留到apk里面。在app启动的时候直接读raw文件。<br>但是这种想法刚说出来就被进奎否了，当时的问题出在raw文件需要进行重新编译，否则不会出现在R.java中，而如果使用apktool重新编译，效率基本上和变体是55开。</p>\n<h1 id=\"想法2-asset\"><a href=\"#想法2-asset\" class=\"headerlink\" title=\"想法2-asset\"></a>想法2-asset</h1><p>第二种想法是第一种想法的补充，既然raw文件需要通过编译来生成r，那我们找一个不需要编译的，想法很简单，打包之后直接塞一个文件到asset里面，这个文件就是配置文件，每次打包之后，解压，然后复制相对应渠道的配置文件到asset里面，这样就可以避免需要回编译的目的了。但是这个方法需要进行重新签名。</p>\n<h1 id=\"想法3-美团方案优化\"><a href=\"#想法3-美团方案优化\" class=\"headerlink\" title=\"想法3-美团方案优化\"></a>想法3-美团方案优化</h1><p>在目前不需要配置额外的配置目录的情况下，想法2其实是有些牛刀小用了。事实上我们完全可以在美团的打包方案上面进行优化。美团提供的打包方案，当时细细想想，完全没有必要每次启动apk的时候都去读取。仅仅需要第一次打开app的时候，读取并写入sp中，之后每次读取sp，如果没有在去重新读取即可。这样可以省了好多事情。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>鉴于目前项目的规格以及需求，仅仅在需要扩充渠道的时候，仅仅需要重启美团的优化方案，同时优化每次编译的选项即可。但是在后续需要用到不同配置文件的时候，就需要使用想法2的方法，美团的方案不够支持那么详细。</p>\n<p>同时鉴于此，也算研究了一下app打包流程，顺便总结一下。</p>\n<h1 id=\"打包流程\"><a href=\"#打包流程\" class=\"headerlink\" title=\"打包流程\"></a>打包流程</h1><p><img src=\"/images/android/androidpackageimage.png\" alt=\"打包流程\"></p>\n<p>从官方图可以很明显的看出流程变化。</p>\n<ol>\n<li>资源文件是通过aapt来进行打包的，aapt全称是Android Asset Packaging Tool，可以看出来，aapt打包生成了2个东西，一个是R,一个是compiled resources，像想法一之中的raw就是生成在r里面，compiled resources 是asset文件夹下面的东西，这些东西不会参与打包，而是直接被压缩进apk.</li>\n</ol>\n<p>关于asset和raw我之前一直认为raw是原封不动，不会编译成二进制，今天才知道两个相同点都是原封不动不会被编译成二进制。差别就是读写方式不同。因此想法1本来就是错误的。</p>\n<ol start=\"2\">\n<li><p>java编译器同时编译三者，一是代码，二是r文件，三是aidl编译下来的java接口。编译成class之后，然后和第三方class一起并到dex中（dex是好几个class合并起来的）。<br>看到这边有个疑问，为什么是class？我们所知道的第三方包，有时候是使用aar的形式来进行依赖的，aar包含了资源文件，但是我查了一下，如果是aar的话。将会被打包到class.jar中，应该就是先打包到jar中，然后又会被放到dex中</p>\n</li>\n<li><p>asset， resource， dex 三者就可以打包成一个apk了，此时使用apkbuilder即可，打包成一个未签名的apk。</p>\n</li>\n<li><p>apk好了之后使用jarsigner来进行签名</p>\n</li>\n<li><p>按理说签名完之后就应该结束了，为什么还会有个zipaligh呢？</p>\n</li>\n</ol>\n<p>zipalign的效果：zipalign是一个对齐工具，android基于linux，因此资源也是仿照linux来的，在多进程需要寻找资源的时候，最好的方式是按照linux架构来设计数据摆放位置，因此最好的是放在4字节层，这样子的话系统就不需要读取所有的文件，而直接可以类似链表的形式知道什么资源在什么地方。这样节省了大量的内存。因此这个步骤我们称之为对齐</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前述\"><a href=\"#前述\" class=\"headerlink\" title=\"前述\"></a>前述</h1><p>刚开始接手好搭的时候，用的是美团的多渠道打包方案，但是当时前人写的代码有些问题。</p>\n<p>当时的流程大致是：打包一个包，然后解压，修改META-INFO,之后重新压缩，过程中会生成一个额外的包含渠道名的文件。</p>\n<p>这样的好处是解压之后重新压缩，并不需要重新编译，也不需要重新签名。</p>\n<p>但是当时在apk启动的时候使用的读取渠道包的方式也是和官网提供的一样，没有变化。是启动时解压apk，然后读取相对应的文件。</p>\n<h1 id=\"过去方式的缺点\"><a href=\"#过去方式的缺点\" class=\"headerlink\" title=\"过去方式的缺点\"></a>过去方式的缺点</h1><p>由于需要启动的时候解压apk，整个过程耗时大约200ms，而且是每次都会出现的。加上前人对于性能的优化也不是很在心，当时刚接手的时候启动速度十分慢（大约1-2秒的卡顿）。</p>\n<p>后来不得已，出于性能的考虑，对这个动了刀子。</p>\n<h1 id=\"变化\"><a href=\"#变化\" class=\"headerlink\" title=\"变化\"></a>变化</h1><p>由于刚开始的渠道包并不算太多，因此第一个考虑就是使用gradle的变体来进行更改。</p>\n<p>变体是官方提供的，使用变体的话，平时打包也可以直接选定打什么包。对于项目来讲，省了不少时间。</p>\n<h1 id=\"变体带来的缺点\"><a href=\"#变体带来的缺点\" class=\"headerlink\" title=\"变体带来的缺点\"></a>变体带来的缺点</h1><p>后期由于项目规模大了起来，增加了5个渠道，全渠道打包时间一下子长了很多，由刚开始的40分钟，猛增到一小时20多分钟。同时市场那边的意思是后期还会继续扩充渠道。</p>\n<p>因此现在必须要更改一下这个打包方式。</p>\n<h1 id=\"想法1-raw\"><a href=\"#想法1-raw\" class=\"headerlink\" title=\"想法1-raw\"></a>想法1-raw</h1><p>第一种想法是脱离美团打包，通过自己设置资源文件夹下面的raw目录，来进行打包，raw文件在android里面是不会编译成二进制文件的，会原样保留到apk里面。在app启动的时候直接读raw文件。<br>但是这种想法刚说出来就被进奎否了，当时的问题出在raw文件需要进行重新编译，否则不会出现在R.java中，而如果使用apktool重新编译，效率基本上和变体是55开。</p>\n<h1 id=\"想法2-asset\"><a href=\"#想法2-asset\" class=\"headerlink\" title=\"想法2-asset\"></a>想法2-asset</h1><p>第二种想法是第一种想法的补充，既然raw文件需要通过编译来生成r，那我们找一个不需要编译的，想法很简单，打包之后直接塞一个文件到asset里面，这个文件就是配置文件，每次打包之后，解压，然后复制相对应渠道的配置文件到asset里面，这样就可以避免需要回编译的目的了。但是这个方法需要进行重新签名。</p>\n<h1 id=\"想法3-美团方案优化\"><a href=\"#想法3-美团方案优化\" class=\"headerlink\" title=\"想法3-美团方案优化\"></a>想法3-美团方案优化</h1><p>在目前不需要配置额外的配置目录的情况下，想法2其实是有些牛刀小用了。事实上我们完全可以在美团的打包方案上面进行优化。美团提供的打包方案，当时细细想想，完全没有必要每次启动apk的时候都去读取。仅仅需要第一次打开app的时候，读取并写入sp中，之后每次读取sp，如果没有在去重新读取即可。这样可以省了好多事情。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>鉴于目前项目的规格以及需求，仅仅在需要扩充渠道的时候，仅仅需要重启美团的优化方案，同时优化每次编译的选项即可。但是在后续需要用到不同配置文件的时候，就需要使用想法2的方法，美团的方案不够支持那么详细。</p>\n<p>同时鉴于此，也算研究了一下app打包流程，顺便总结一下。</p>\n<h1 id=\"打包流程\"><a href=\"#打包流程\" class=\"headerlink\" title=\"打包流程\"></a>打包流程</h1><p><img src=\"/images/android/androidpackageimage.png\" alt=\"打包流程\"></p>\n<p>从官方图可以很明显的看出流程变化。</p>\n<ol>\n<li>资源文件是通过aapt来进行打包的，aapt全称是Android Asset Packaging Tool，可以看出来，aapt打包生成了2个东西，一个是R,一个是compiled resources，像想法一之中的raw就是生成在r里面，compiled resources 是asset文件夹下面的东西，这些东西不会参与打包，而是直接被压缩进apk.</li>\n</ol>\n<p>关于asset和raw我之前一直认为raw是原封不动，不会编译成二进制，今天才知道两个相同点都是原封不动不会被编译成二进制。差别就是读写方式不同。因此想法1本来就是错误的。</p>\n<ol start=\"2\">\n<li><p>java编译器同时编译三者，一是代码，二是r文件，三是aidl编译下来的java接口。编译成class之后，然后和第三方class一起并到dex中（dex是好几个class合并起来的）。<br>看到这边有个疑问，为什么是class？我们所知道的第三方包，有时候是使用aar的形式来进行依赖的，aar包含了资源文件，但是我查了一下，如果是aar的话。将会被打包到class.jar中，应该就是先打包到jar中，然后又会被放到dex中</p>\n</li>\n<li><p>asset， resource， dex 三者就可以打包成一个apk了，此时使用apkbuilder即可，打包成一个未签名的apk。</p>\n</li>\n<li><p>apk好了之后使用jarsigner来进行签名</p>\n</li>\n<li><p>按理说签名完之后就应该结束了，为什么还会有个zipaligh呢？</p>\n</li>\n</ol>\n<p>zipalign的效果：zipalign是一个对齐工具，android基于linux，因此资源也是仿照linux来的，在多进程需要寻找资源的时候，最好的方式是按照linux架构来设计数据摆放位置，因此最好的是放在4字节层，这样子的话系统就不需要读取所有的文件，而直接可以类似链表的形式知道什么资源在什么地方。这样节省了大量的内存。因此这个步骤我们称之为对齐</p>\n"},{"title":"android自定义注解","date":"2018-02-10T11:55:54.000Z","_content":"\n注解是一种元数据，可以添加到java代码中，类、方法、变量、参数、包都可以被注解，注解对注解的代码没有直接的影响。\n\n注解是在解析的过程中做出了相应的处理，注解仅仅是一个标记。\n\n定义一个注解的关键字是@interface\n\n### 元注解\n\n元注解共有四种 @Retention, @Target, @Inherited, @Documented\n\n+ @Retention 保留的范围，默认值为class，可选值有三种\n\nSOURCE:只在源码中可用\nCLASS:在源码和字节码中可用\nRUNTIME:在源码、字节码、运行时均可用\n\n+ @Target: 表示可以用来修饰哪些元素，如TYPE/METHOD/CONSTRUCTOR/FIELD/PARAMETER等，未标识及代表可以修饰所有\n\n+ @Inherited:是否可以被继承，默认为false\n\n+ @Documented: 是否会被保存到javadoc文档中\n\n### 自定义注解--实现findViewById()\n\n第一步定义注解：\n```\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ViewInject {\n\n    int value();\n\n    /* parent view id */\n    int parentId() default 0;\n}\n```\n\n第二步处理注解：\n```\npublic class ViewUtils {\n\n    private ViewUtils() {\n    }\n\n    public static void inject(Activity activity) {\n        injectObject(activity, new ViewFinder(activity));\n    }\n\n    @SuppressWarnings(\"ConstantConditions\")\n    private static void injectObject(Object handler, ViewFinder finder) {\n\n        Class<?> handlerType = handler.getClass();\n\n        // inject view\n        Field[] fields = handlerType.getDeclaredFields();\n        if (fields != null && fields.length > 0) {\n            for (Field field : fields) {\n                ViewInject viewInject = field.getAnnotation(ViewInject.class);\n                if (viewInject != null) {\n                    try {\n                        View view = finder.findViewById(viewInject.value(), viewInject.parentId());\n                        if (view != null) {\n                            field.setAccessible(true);\n                            field.set(handler, view);\n                        }\n                    } catch (Throwable e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n\n    }\n\n}\n```\n\n```\npublic class ViewFinder {\n\n\n    private Activity activity;\n\n\n    public ViewFinder(Activity activity) {\n        this.activity = activity;\n    }\n\n    public View findViewById(int id) {\n        return  activity.findViewById(id);\n    }\n\n    public View findViewById(int id, int pid) {\n        View pView = null;\n        if (pid > 0) {\n            pView = this.findViewById(pid);\n        }\n\n        View view = null;\n        if (pView != null) {\n            view = pView.findViewById(id);\n        } else {\n            view = this.findViewById(id);\n        }\n        return view;\n    }\n\n\n}\n```\n\n第三步 activity调用\n```\npublic class DIYAnnotationActivity extends AppCompatActivity {\n\n\n    @ViewInject(R.id.textView)\n    private TextView textView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_annotation);\n\n        ViewUtils.inject(this);\n\n        textView.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                textView.setText(\"成功了！\");\n            }\n        });\n\n    }\n\n\n}\n```\n\n基本上是通过获取activity实例，然后通过反射遍历field找到用到这个注解的地方，然后进行findviewbyid的进行，之后返回view的实例","source":"_posts/android自定义注解.md","raw":"---\ntitle: android自定义注解\ndate: 2018-02-10 19:55:54\ntags: android\n---\n\n注解是一种元数据，可以添加到java代码中，类、方法、变量、参数、包都可以被注解，注解对注解的代码没有直接的影响。\n\n注解是在解析的过程中做出了相应的处理，注解仅仅是一个标记。\n\n定义一个注解的关键字是@interface\n\n### 元注解\n\n元注解共有四种 @Retention, @Target, @Inherited, @Documented\n\n+ @Retention 保留的范围，默认值为class，可选值有三种\n\nSOURCE:只在源码中可用\nCLASS:在源码和字节码中可用\nRUNTIME:在源码、字节码、运行时均可用\n\n+ @Target: 表示可以用来修饰哪些元素，如TYPE/METHOD/CONSTRUCTOR/FIELD/PARAMETER等，未标识及代表可以修饰所有\n\n+ @Inherited:是否可以被继承，默认为false\n\n+ @Documented: 是否会被保存到javadoc文档中\n\n### 自定义注解--实现findViewById()\n\n第一步定义注解：\n```\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ViewInject {\n\n    int value();\n\n    /* parent view id */\n    int parentId() default 0;\n}\n```\n\n第二步处理注解：\n```\npublic class ViewUtils {\n\n    private ViewUtils() {\n    }\n\n    public static void inject(Activity activity) {\n        injectObject(activity, new ViewFinder(activity));\n    }\n\n    @SuppressWarnings(\"ConstantConditions\")\n    private static void injectObject(Object handler, ViewFinder finder) {\n\n        Class<?> handlerType = handler.getClass();\n\n        // inject view\n        Field[] fields = handlerType.getDeclaredFields();\n        if (fields != null && fields.length > 0) {\n            for (Field field : fields) {\n                ViewInject viewInject = field.getAnnotation(ViewInject.class);\n                if (viewInject != null) {\n                    try {\n                        View view = finder.findViewById(viewInject.value(), viewInject.parentId());\n                        if (view != null) {\n                            field.setAccessible(true);\n                            field.set(handler, view);\n                        }\n                    } catch (Throwable e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n\n    }\n\n}\n```\n\n```\npublic class ViewFinder {\n\n\n    private Activity activity;\n\n\n    public ViewFinder(Activity activity) {\n        this.activity = activity;\n    }\n\n    public View findViewById(int id) {\n        return  activity.findViewById(id);\n    }\n\n    public View findViewById(int id, int pid) {\n        View pView = null;\n        if (pid > 0) {\n            pView = this.findViewById(pid);\n        }\n\n        View view = null;\n        if (pView != null) {\n            view = pView.findViewById(id);\n        } else {\n            view = this.findViewById(id);\n        }\n        return view;\n    }\n\n\n}\n```\n\n第三步 activity调用\n```\npublic class DIYAnnotationActivity extends AppCompatActivity {\n\n\n    @ViewInject(R.id.textView)\n    private TextView textView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_annotation);\n\n        ViewUtils.inject(this);\n\n        textView.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                textView.setText(\"成功了！\");\n            }\n        });\n\n    }\n\n\n}\n```\n\n基本上是通过获取activity实例，然后通过反射遍历field找到用到这个注解的地方，然后进行findviewbyid的进行，之后返回view的实例","slug":"android自定义注解","published":1,"updated":"2019-03-12T09:26:33.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxt002n3a8ke0bmv6wa","content":"<p>注解是一种元数据，可以添加到java代码中，类、方法、变量、参数、包都可以被注解，注解对注解的代码没有直接的影响。</p>\n<p>注解是在解析的过程中做出了相应的处理，注解仅仅是一个标记。</p>\n<p>定义一个注解的关键字是@interface</p>\n<h3 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h3><p>元注解共有四种 @Retention, @Target, @Inherited, @Documented</p>\n<ul>\n<li>@Retention 保留的范围，默认值为class，可选值有三种</li>\n</ul>\n<p>SOURCE:只在源码中可用<br>CLASS:在源码和字节码中可用<br>RUNTIME:在源码、字节码、运行时均可用</p>\n<ul>\n<li><p>@Target: 表示可以用来修饰哪些元素，如TYPE/METHOD/CONSTRUCTOR/FIELD/PARAMETER等，未标识及代表可以修饰所有</p>\n</li>\n<li><p>@Inherited:是否可以被继承，默认为false</p>\n</li>\n<li><p>@Documented: 是否会被保存到javadoc文档中</p>\n</li>\n</ul>\n<h3 id=\"自定义注解–实现findViewById\"><a href=\"#自定义注解–实现findViewById\" class=\"headerlink\" title=\"自定义注解–实现findViewById()\"></a>自定义注解–实现findViewById()</h3><p>第一步定义注解：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(ElementType.FIELD)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">public @interface ViewInject &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    int value();</span><br><span class=\"line\"></span><br><span class=\"line\">    /* parent view id */</span><br><span class=\"line\">    int parentId() default 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第二步处理注解：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ViewUtils &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private ViewUtils() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void inject(Activity activity) &#123;</span><br><span class=\"line\">        injectObject(activity, new ViewFinder(activity));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @SuppressWarnings(&quot;ConstantConditions&quot;)</span><br><span class=\"line\">    private static void injectObject(Object handler, ViewFinder finder) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Class&lt;?&gt; handlerType = handler.getClass();</span><br><span class=\"line\"></span><br><span class=\"line\">        // inject view</span><br><span class=\"line\">        Field[] fields = handlerType.getDeclaredFields();</span><br><span class=\"line\">        if (fields != null &amp;&amp; fields.length &gt; 0) &#123;</span><br><span class=\"line\">            for (Field field : fields) &#123;</span><br><span class=\"line\">                ViewInject viewInject = field.getAnnotation(ViewInject.class);</span><br><span class=\"line\">                if (viewInject != null) &#123;</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        View view = finder.findViewById(viewInject.value(), viewInject.parentId());</span><br><span class=\"line\">                        if (view != null) &#123;</span><br><span class=\"line\">                            field.setAccessible(true);</span><br><span class=\"line\">                            field.set(handler, view);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; catch (Throwable e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ViewFinder &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private Activity activity;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public ViewFinder(Activity activity) &#123;</span><br><span class=\"line\">        this.activity = activity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public View findViewById(int id) &#123;</span><br><span class=\"line\">        return  activity.findViewById(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public View findViewById(int id, int pid) &#123;</span><br><span class=\"line\">        View pView = null;</span><br><span class=\"line\">        if (pid &gt; 0) &#123;</span><br><span class=\"line\">            pView = this.findViewById(pid);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        View view = null;</span><br><span class=\"line\">        if (pView != null) &#123;</span><br><span class=\"line\">            view = pView.findViewById(id);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            view = this.findViewById(id);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return view;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第三步 activity调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DIYAnnotationActivity extends AppCompatActivity &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @ViewInject(R.id.textView)</span><br><span class=\"line\">    private TextView textView;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_annotation);</span><br><span class=\"line\"></span><br><span class=\"line\">        ViewUtils.inject(this);</span><br><span class=\"line\"></span><br><span class=\"line\">        textView.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onClick(View view) &#123;</span><br><span class=\"line\">                textView.setText(&quot;成功了！&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>基本上是通过获取activity实例，然后通过反射遍历field找到用到这个注解的地方，然后进行findviewbyid的进行，之后返回view的实例</p>\n","site":{"data":{}},"excerpt":"","more":"<p>注解是一种元数据，可以添加到java代码中，类、方法、变量、参数、包都可以被注解，注解对注解的代码没有直接的影响。</p>\n<p>注解是在解析的过程中做出了相应的处理，注解仅仅是一个标记。</p>\n<p>定义一个注解的关键字是@interface</p>\n<h3 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h3><p>元注解共有四种 @Retention, @Target, @Inherited, @Documented</p>\n<ul>\n<li>@Retention 保留的范围，默认值为class，可选值有三种</li>\n</ul>\n<p>SOURCE:只在源码中可用<br>CLASS:在源码和字节码中可用<br>RUNTIME:在源码、字节码、运行时均可用</p>\n<ul>\n<li><p>@Target: 表示可以用来修饰哪些元素，如TYPE/METHOD/CONSTRUCTOR/FIELD/PARAMETER等，未标识及代表可以修饰所有</p>\n</li>\n<li><p>@Inherited:是否可以被继承，默认为false</p>\n</li>\n<li><p>@Documented: 是否会被保存到javadoc文档中</p>\n</li>\n</ul>\n<h3 id=\"自定义注解–实现findViewById\"><a href=\"#自定义注解–实现findViewById\" class=\"headerlink\" title=\"自定义注解–实现findViewById()\"></a>自定义注解–实现findViewById()</h3><p>第一步定义注解：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(ElementType.FIELD)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">public @interface ViewInject &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    int value();</span><br><span class=\"line\"></span><br><span class=\"line\">    /* parent view id */</span><br><span class=\"line\">    int parentId() default 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第二步处理注解：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ViewUtils &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private ViewUtils() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void inject(Activity activity) &#123;</span><br><span class=\"line\">        injectObject(activity, new ViewFinder(activity));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @SuppressWarnings(&quot;ConstantConditions&quot;)</span><br><span class=\"line\">    private static void injectObject(Object handler, ViewFinder finder) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Class&lt;?&gt; handlerType = handler.getClass();</span><br><span class=\"line\"></span><br><span class=\"line\">        // inject view</span><br><span class=\"line\">        Field[] fields = handlerType.getDeclaredFields();</span><br><span class=\"line\">        if (fields != null &amp;&amp; fields.length &gt; 0) &#123;</span><br><span class=\"line\">            for (Field field : fields) &#123;</span><br><span class=\"line\">                ViewInject viewInject = field.getAnnotation(ViewInject.class);</span><br><span class=\"line\">                if (viewInject != null) &#123;</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        View view = finder.findViewById(viewInject.value(), viewInject.parentId());</span><br><span class=\"line\">                        if (view != null) &#123;</span><br><span class=\"line\">                            field.setAccessible(true);</span><br><span class=\"line\">                            field.set(handler, view);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; catch (Throwable e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ViewFinder &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private Activity activity;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public ViewFinder(Activity activity) &#123;</span><br><span class=\"line\">        this.activity = activity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public View findViewById(int id) &#123;</span><br><span class=\"line\">        return  activity.findViewById(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public View findViewById(int id, int pid) &#123;</span><br><span class=\"line\">        View pView = null;</span><br><span class=\"line\">        if (pid &gt; 0) &#123;</span><br><span class=\"line\">            pView = this.findViewById(pid);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        View view = null;</span><br><span class=\"line\">        if (pView != null) &#123;</span><br><span class=\"line\">            view = pView.findViewById(id);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            view = this.findViewById(id);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return view;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第三步 activity调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DIYAnnotationActivity extends AppCompatActivity &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @ViewInject(R.id.textView)</span><br><span class=\"line\">    private TextView textView;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_annotation);</span><br><span class=\"line\"></span><br><span class=\"line\">        ViewUtils.inject(this);</span><br><span class=\"line\"></span><br><span class=\"line\">        textView.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onClick(View view) &#123;</span><br><span class=\"line\">                textView.setText(&quot;成功了！&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>基本上是通过获取activity实例，然后通过反射遍历field找到用到这个注解的地方，然后进行findviewbyid的进行，之后返回view的实例</p>\n"},{"title":"binder机制学习","date":"2018-10-18T14:42:23.000Z","_content":"binder平时总听过，但是原理只知道是ipc，也就是进程间通信。但是真正的原理其实还是不理解。\n\n# binder位置\n\nbinder介于framework和systemservice之间，属于让开发者来调用系统层接口的方法。\n\n# ipc\n\nipc全称是inter-process communication,进程间通讯\n\nipc的方式有很多种，socket，共享内存，管道，消息队列\n\n## socket\n\nsocket实现进程间通讯，是基于tcpip协议来实现的，一般实现tcp，如果是udp也是可以的，udp是两个socket但是无连接。\n通过tcp实现ipc的原理\n```\n客户端程序通过socket发送一系列信息到传输层的tcp，然后往下传，通过网络层，网络接口层，然后在往上传到网络层，然后传到服务端的传输层tcp，然后由服务器的socket接收到，之后回传也是相同的\n```\n\n缺点是需传输效率较低，一般只用在不同机器，或者跨网络的通行\n\n## 共享内存\n\n共享内存的ipc，传输的对象一般都是可描述的，所以都用序列化，创建共享内存就使用memoryfile即可\n\n这样构建的内存可以让其他进程共享\n\n共享内存的优点在于无需复制，速度快，共享缓冲区直接附加到进程虚拟地址空间。缺点在于同步问题不好解决\n\n## 消息队列\n\n消息队列就是messagequeue\n实现的思路\n```\n在进程a中创建一个message，讲这个message对象通过imessenger.send(message)方法传递到进程b中\nsend(message)会使用一个parcel对象对message对象编集，再将parcel对象传递到进程b中，然后解编集，得到一个和进程a中message对象内容一样的对象，在将message对象加入到b的消息队列里面，handler会处理它\n```\n消息队列的好处是比较方便，缺点是信息复制2次，有额外的cpu消耗，不是很适合频繁或者信息量大的通信\n\n## 管道\n\n管道是比较古老的通信方式，包括无名管道和有名管道，前者是父子进程间的通信，后者用于运行同一机器上的任意两个进程间的通信。实现方式是pipe，利用管道的有handler（此处需要研究一下handler的实现原理）\n\n管道创建时分配了一个page大小的内存（page？）缓存区大小比较有限\n\n# Binder\n\nbinder ipc属于c/s结构，client部分是用户代码，最终会调用binder driver的transact接口，binder driver会调用server\n\nclient:用户需要实现的代码，如aidl自动生成的接口类\nbinder driver：在内核层实现的driver\nserver：这个server就是service中onbind返回的ibinder对象\n\nbinder driver这块并不需要用户知道，server中会开启一个线程池（防止任务积压，也需要做好同步措施）去处理客户端调用\n\n对于调用binder driver中的transact接口，客户端可以手动调用，也可以通过aidl的方式生成的代理类来调用，服务端可以继承binder对象，也可以继承aidl生成的接口类的stub对象\n\n# 实现环节\n\n//todo\n\n","source":"_posts/binder机制学习.md","raw":"---\ntitle: binder机制学习\ndate: 2018-10-18 22:42:23\ntags:\n---\nbinder平时总听过，但是原理只知道是ipc，也就是进程间通信。但是真正的原理其实还是不理解。\n\n# binder位置\n\nbinder介于framework和systemservice之间，属于让开发者来调用系统层接口的方法。\n\n# ipc\n\nipc全称是inter-process communication,进程间通讯\n\nipc的方式有很多种，socket，共享内存，管道，消息队列\n\n## socket\n\nsocket实现进程间通讯，是基于tcpip协议来实现的，一般实现tcp，如果是udp也是可以的，udp是两个socket但是无连接。\n通过tcp实现ipc的原理\n```\n客户端程序通过socket发送一系列信息到传输层的tcp，然后往下传，通过网络层，网络接口层，然后在往上传到网络层，然后传到服务端的传输层tcp，然后由服务器的socket接收到，之后回传也是相同的\n```\n\n缺点是需传输效率较低，一般只用在不同机器，或者跨网络的通行\n\n## 共享内存\n\n共享内存的ipc，传输的对象一般都是可描述的，所以都用序列化，创建共享内存就使用memoryfile即可\n\n这样构建的内存可以让其他进程共享\n\n共享内存的优点在于无需复制，速度快，共享缓冲区直接附加到进程虚拟地址空间。缺点在于同步问题不好解决\n\n## 消息队列\n\n消息队列就是messagequeue\n实现的思路\n```\n在进程a中创建一个message，讲这个message对象通过imessenger.send(message)方法传递到进程b中\nsend(message)会使用一个parcel对象对message对象编集，再将parcel对象传递到进程b中，然后解编集，得到一个和进程a中message对象内容一样的对象，在将message对象加入到b的消息队列里面，handler会处理它\n```\n消息队列的好处是比较方便，缺点是信息复制2次，有额外的cpu消耗，不是很适合频繁或者信息量大的通信\n\n## 管道\n\n管道是比较古老的通信方式，包括无名管道和有名管道，前者是父子进程间的通信，后者用于运行同一机器上的任意两个进程间的通信。实现方式是pipe，利用管道的有handler（此处需要研究一下handler的实现原理）\n\n管道创建时分配了一个page大小的内存（page？）缓存区大小比较有限\n\n# Binder\n\nbinder ipc属于c/s结构，client部分是用户代码，最终会调用binder driver的transact接口，binder driver会调用server\n\nclient:用户需要实现的代码，如aidl自动生成的接口类\nbinder driver：在内核层实现的driver\nserver：这个server就是service中onbind返回的ibinder对象\n\nbinder driver这块并不需要用户知道，server中会开启一个线程池（防止任务积压，也需要做好同步措施）去处理客户端调用\n\n对于调用binder driver中的transact接口，客户端可以手动调用，也可以通过aidl的方式生成的代理类来调用，服务端可以继承binder对象，也可以继承aidl生成的接口类的stub对象\n\n# 实现环节\n\n//todo\n\n","slug":"binder机制学习","published":1,"updated":"2019-03-12T09:26:33.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxt002p3a8kkl8w3mb0","content":"<p>binder平时总听过，但是原理只知道是ipc，也就是进程间通信。但是真正的原理其实还是不理解。</p>\n<h1 id=\"binder位置\"><a href=\"#binder位置\" class=\"headerlink\" title=\"binder位置\"></a>binder位置</h1><p>binder介于framework和systemservice之间，属于让开发者来调用系统层接口的方法。</p>\n<h1 id=\"ipc\"><a href=\"#ipc\" class=\"headerlink\" title=\"ipc\"></a>ipc</h1><p>ipc全称是inter-process communication,进程间通讯</p>\n<p>ipc的方式有很多种，socket，共享内存，管道，消息队列</p>\n<h2 id=\"socket\"><a href=\"#socket\" class=\"headerlink\" title=\"socket\"></a>socket</h2><p>socket实现进程间通讯，是基于tcpip协议来实现的，一般实现tcp，如果是udp也是可以的，udp是两个socket但是无连接。<br>通过tcp实现ipc的原理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端程序通过socket发送一系列信息到传输层的tcp，然后往下传，通过网络层，网络接口层，然后在往上传到网络层，然后传到服务端的传输层tcp，然后由服务器的socket接收到，之后回传也是相同的</span><br></pre></td></tr></table></figure></p>\n<p>缺点是需传输效率较低，一般只用在不同机器，或者跨网络的通行</p>\n<h2 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h2><p>共享内存的ipc，传输的对象一般都是可描述的，所以都用序列化，创建共享内存就使用memoryfile即可</p>\n<p>这样构建的内存可以让其他进程共享</p>\n<p>共享内存的优点在于无需复制，速度快，共享缓冲区直接附加到进程虚拟地址空间。缺点在于同步问题不好解决</p>\n<h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><p>消息队列就是messagequeue<br>实现的思路<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在进程a中创建一个message，讲这个message对象通过imessenger.send(message)方法传递到进程b中</span><br><span class=\"line\">send(message)会使用一个parcel对象对message对象编集，再将parcel对象传递到进程b中，然后解编集，得到一个和进程a中message对象内容一样的对象，在将message对象加入到b的消息队列里面，handler会处理它</span><br></pre></td></tr></table></figure></p>\n<p>消息队列的好处是比较方便，缺点是信息复制2次，有额外的cpu消耗，不是很适合频繁或者信息量大的通信</p>\n<h2 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h2><p>管道是比较古老的通信方式，包括无名管道和有名管道，前者是父子进程间的通信，后者用于运行同一机器上的任意两个进程间的通信。实现方式是pipe，利用管道的有handler（此处需要研究一下handler的实现原理）</p>\n<p>管道创建时分配了一个page大小的内存（page？）缓存区大小比较有限</p>\n<h1 id=\"Binder\"><a href=\"#Binder\" class=\"headerlink\" title=\"Binder\"></a>Binder</h1><p>binder ipc属于c/s结构，client部分是用户代码，最终会调用binder driver的transact接口，binder driver会调用server</p>\n<p>client:用户需要实现的代码，如aidl自动生成的接口类<br>binder driver：在内核层实现的driver<br>server：这个server就是service中onbind返回的ibinder对象</p>\n<p>binder driver这块并不需要用户知道，server中会开启一个线程池（防止任务积压，也需要做好同步措施）去处理客户端调用</p>\n<p>对于调用binder driver中的transact接口，客户端可以手动调用，也可以通过aidl的方式生成的代理类来调用，服务端可以继承binder对象，也可以继承aidl生成的接口类的stub对象</p>\n<h1 id=\"实现环节\"><a href=\"#实现环节\" class=\"headerlink\" title=\"实现环节\"></a>实现环节</h1><p>//todo</p>\n","site":{"data":{}},"excerpt":"","more":"<p>binder平时总听过，但是原理只知道是ipc，也就是进程间通信。但是真正的原理其实还是不理解。</p>\n<h1 id=\"binder位置\"><a href=\"#binder位置\" class=\"headerlink\" title=\"binder位置\"></a>binder位置</h1><p>binder介于framework和systemservice之间，属于让开发者来调用系统层接口的方法。</p>\n<h1 id=\"ipc\"><a href=\"#ipc\" class=\"headerlink\" title=\"ipc\"></a>ipc</h1><p>ipc全称是inter-process communication,进程间通讯</p>\n<p>ipc的方式有很多种，socket，共享内存，管道，消息队列</p>\n<h2 id=\"socket\"><a href=\"#socket\" class=\"headerlink\" title=\"socket\"></a>socket</h2><p>socket实现进程间通讯，是基于tcpip协议来实现的，一般实现tcp，如果是udp也是可以的，udp是两个socket但是无连接。<br>通过tcp实现ipc的原理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端程序通过socket发送一系列信息到传输层的tcp，然后往下传，通过网络层，网络接口层，然后在往上传到网络层，然后传到服务端的传输层tcp，然后由服务器的socket接收到，之后回传也是相同的</span><br></pre></td></tr></table></figure></p>\n<p>缺点是需传输效率较低，一般只用在不同机器，或者跨网络的通行</p>\n<h2 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h2><p>共享内存的ipc，传输的对象一般都是可描述的，所以都用序列化，创建共享内存就使用memoryfile即可</p>\n<p>这样构建的内存可以让其他进程共享</p>\n<p>共享内存的优点在于无需复制，速度快，共享缓冲区直接附加到进程虚拟地址空间。缺点在于同步问题不好解决</p>\n<h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><p>消息队列就是messagequeue<br>实现的思路<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在进程a中创建一个message，讲这个message对象通过imessenger.send(message)方法传递到进程b中</span><br><span class=\"line\">send(message)会使用一个parcel对象对message对象编集，再将parcel对象传递到进程b中，然后解编集，得到一个和进程a中message对象内容一样的对象，在将message对象加入到b的消息队列里面，handler会处理它</span><br></pre></td></tr></table></figure></p>\n<p>消息队列的好处是比较方便，缺点是信息复制2次，有额外的cpu消耗，不是很适合频繁或者信息量大的通信</p>\n<h2 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h2><p>管道是比较古老的通信方式，包括无名管道和有名管道，前者是父子进程间的通信，后者用于运行同一机器上的任意两个进程间的通信。实现方式是pipe，利用管道的有handler（此处需要研究一下handler的实现原理）</p>\n<p>管道创建时分配了一个page大小的内存（page？）缓存区大小比较有限</p>\n<h1 id=\"Binder\"><a href=\"#Binder\" class=\"headerlink\" title=\"Binder\"></a>Binder</h1><p>binder ipc属于c/s结构，client部分是用户代码，最终会调用binder driver的transact接口，binder driver会调用server</p>\n<p>client:用户需要实现的代码，如aidl自动生成的接口类<br>binder driver：在内核层实现的driver<br>server：这个server就是service中onbind返回的ibinder对象</p>\n<p>binder driver这块并不需要用户知道，server中会开启一个线程池（防止任务积压，也需要做好同步措施）去处理客户端调用</p>\n<p>对于调用binder driver中的transact接口，客户端可以手动调用，也可以通过aidl的方式生成的代理类来调用，服务端可以继承binder对象，也可以继承aidl生成的接口类的stub对象</p>\n<h1 id=\"实现环节\"><a href=\"#实现环节\" class=\"headerlink\" title=\"实现环节\"></a>实现环节</h1><p>//todo</p>\n"},{"title":"clean架构学习","date":"2018-03-07T01:50:22.000Z","_content":"\n# clean架构图\n\n![clean架构图](/images/架构/clean架构图.jpg)\n\n# 核心思想\n\n内层不能依赖外层，即内层不知道有关外层的任何事情，所以这个架构是向内依赖的。\n\n# 特性\n\nClean架构可以使你的代码有如下特性：\n\n- 独立于架构\n\n- 易于测试\n\n- 独立于UI\n\n- 独立于数据库\n\n- 独立于任何外部类库\n\n# clean在android中的体现\n\n- 外层：实现层\n\n- 中层：接口适配层\n\n- 内层：逻辑层\n\n接口实现层是体现架构细节的地方。实现架构的代码是所有不用来解决问题的代码，这包括所有与安卓相关的东西，比如创建Activity和Fragment，发送Intent以及其他联网与数据库的架构相关的代码。\n\n添加接口适配层的目的就是桥接逻辑层和架构层的代码。\n\n最重要的是逻辑层，这里包含了真正解决问题的代码。这一层不包含任何实现架构的代码，不用模拟器也应能运行这里的代码。这样一来你的逻辑代码就有了易于测试、开发和维护的优点。这就是Clean架构的一个主要的好处。\n\n# 结构\n\n一般来说一个安卓应用的结构如下：\n\n外层项目包：UI，Storage，Network等等。\n\n中层项目包：Presenter，Converter。\n\n内层项目包：Interactor，Model，Repository，Executor。\n\n## 外层\n\n外层体现了框架的细节。\n\nUI – 包括所有的Activity，Fragment，Adapter和其他UI相关的Android代码。\n\nStorage – 用于让交互类获取和存储数据的接口实现类，包含了数据库相关的代码。包括了如ContentProvider或DBFlow等组件。\n\nNetwork – 网络操作。\n\n## 中层\n\n桥接实现代码与逻辑代码的Glue Code。\n\nPresenter – presenter处理UI事件，如单击事件，通常包含内层Interactor的回调方法。\n\nConverter – 负责将内外层的模型互相转换。\n\n## 内层\n\n内层包含了最高级的代码，里面都是POJO类，这一层的类和对象不知道外层的任何信息，且应能在任何JVM下运行。\n\nInteractor – Interactor中包含了解决问题的逻辑代码。这里的代码在后台执行，并通过回调方法向外层传递事件。在其他项目中这个模块被称为用例Use Case。一个项目中可能有很多小Interactor，这符合单一职责原则，而且这样更容易让人接受。\n\nModel – 在业务逻辑代码中操作的业务模型。\n\nRepository – 包含接口让外层类实现，如操作数据库的类等。Interactor用这些接口的实现类来读取和存储数据。这也叫资源库模式Repository Pattern。\n\nExecutor – 通过Worker Thread Executor让Interactor在后台执行。一般不需要修改这个包里的代码。\n\n","source":"_posts/clean架构学习.md","raw":"---\ntitle: clean架构学习\ndate: 2018-03-07 09:50:22\ntags: 架构\n---\n\n# clean架构图\n\n![clean架构图](/images/架构/clean架构图.jpg)\n\n# 核心思想\n\n内层不能依赖外层，即内层不知道有关外层的任何事情，所以这个架构是向内依赖的。\n\n# 特性\n\nClean架构可以使你的代码有如下特性：\n\n- 独立于架构\n\n- 易于测试\n\n- 独立于UI\n\n- 独立于数据库\n\n- 独立于任何外部类库\n\n# clean在android中的体现\n\n- 外层：实现层\n\n- 中层：接口适配层\n\n- 内层：逻辑层\n\n接口实现层是体现架构细节的地方。实现架构的代码是所有不用来解决问题的代码，这包括所有与安卓相关的东西，比如创建Activity和Fragment，发送Intent以及其他联网与数据库的架构相关的代码。\n\n添加接口适配层的目的就是桥接逻辑层和架构层的代码。\n\n最重要的是逻辑层，这里包含了真正解决问题的代码。这一层不包含任何实现架构的代码，不用模拟器也应能运行这里的代码。这样一来你的逻辑代码就有了易于测试、开发和维护的优点。这就是Clean架构的一个主要的好处。\n\n# 结构\n\n一般来说一个安卓应用的结构如下：\n\n外层项目包：UI，Storage，Network等等。\n\n中层项目包：Presenter，Converter。\n\n内层项目包：Interactor，Model，Repository，Executor。\n\n## 外层\n\n外层体现了框架的细节。\n\nUI – 包括所有的Activity，Fragment，Adapter和其他UI相关的Android代码。\n\nStorage – 用于让交互类获取和存储数据的接口实现类，包含了数据库相关的代码。包括了如ContentProvider或DBFlow等组件。\n\nNetwork – 网络操作。\n\n## 中层\n\n桥接实现代码与逻辑代码的Glue Code。\n\nPresenter – presenter处理UI事件，如单击事件，通常包含内层Interactor的回调方法。\n\nConverter – 负责将内外层的模型互相转换。\n\n## 内层\n\n内层包含了最高级的代码，里面都是POJO类，这一层的类和对象不知道外层的任何信息，且应能在任何JVM下运行。\n\nInteractor – Interactor中包含了解决问题的逻辑代码。这里的代码在后台执行，并通过回调方法向外层传递事件。在其他项目中这个模块被称为用例Use Case。一个项目中可能有很多小Interactor，这符合单一职责原则，而且这样更容易让人接受。\n\nModel – 在业务逻辑代码中操作的业务模型。\n\nRepository – 包含接口让外层类实现，如操作数据库的类等。Interactor用这些接口的实现类来读取和存储数据。这也叫资源库模式Repository Pattern。\n\nExecutor – 通过Worker Thread Executor让Interactor在后台执行。一般不需要修改这个包里的代码。\n\n","slug":"clean架构学习","published":1,"updated":"2019-03-12T09:26:33.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxu002r3a8k8j9lnnyq","content":"<h1 id=\"clean架构图\"><a href=\"#clean架构图\" class=\"headerlink\" title=\"clean架构图\"></a>clean架构图</h1><p><img src=\"/images/架构/clean架构图.jpg\" alt=\"clean架构图\"></p>\n<h1 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h1><p>内层不能依赖外层，即内层不知道有关外层的任何事情，所以这个架构是向内依赖的。</p>\n<h1 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h1><p>Clean架构可以使你的代码有如下特性：</p>\n<ul>\n<li><p>独立于架构</p>\n</li>\n<li><p>易于测试</p>\n</li>\n<li><p>独立于UI</p>\n</li>\n<li><p>独立于数据库</p>\n</li>\n<li><p>独立于任何外部类库</p>\n</li>\n</ul>\n<h1 id=\"clean在android中的体现\"><a href=\"#clean在android中的体现\" class=\"headerlink\" title=\"clean在android中的体现\"></a>clean在android中的体现</h1><ul>\n<li><p>外层：实现层</p>\n</li>\n<li><p>中层：接口适配层</p>\n</li>\n<li><p>内层：逻辑层</p>\n</li>\n</ul>\n<p>接口实现层是体现架构细节的地方。实现架构的代码是所有不用来解决问题的代码，这包括所有与安卓相关的东西，比如创建Activity和Fragment，发送Intent以及其他联网与数据库的架构相关的代码。</p>\n<p>添加接口适配层的目的就是桥接逻辑层和架构层的代码。</p>\n<p>最重要的是逻辑层，这里包含了真正解决问题的代码。这一层不包含任何实现架构的代码，不用模拟器也应能运行这里的代码。这样一来你的逻辑代码就有了易于测试、开发和维护的优点。这就是Clean架构的一个主要的好处。</p>\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><p>一般来说一个安卓应用的结构如下：</p>\n<p>外层项目包：UI，Storage，Network等等。</p>\n<p>中层项目包：Presenter，Converter。</p>\n<p>内层项目包：Interactor，Model，Repository，Executor。</p>\n<h2 id=\"外层\"><a href=\"#外层\" class=\"headerlink\" title=\"外层\"></a>外层</h2><p>外层体现了框架的细节。</p>\n<p>UI – 包括所有的Activity，Fragment，Adapter和其他UI相关的Android代码。</p>\n<p>Storage – 用于让交互类获取和存储数据的接口实现类，包含了数据库相关的代码。包括了如ContentProvider或DBFlow等组件。</p>\n<p>Network – 网络操作。</p>\n<h2 id=\"中层\"><a href=\"#中层\" class=\"headerlink\" title=\"中层\"></a>中层</h2><p>桥接实现代码与逻辑代码的Glue Code。</p>\n<p>Presenter – presenter处理UI事件，如单击事件，通常包含内层Interactor的回调方法。</p>\n<p>Converter – 负责将内外层的模型互相转换。</p>\n<h2 id=\"内层\"><a href=\"#内层\" class=\"headerlink\" title=\"内层\"></a>内层</h2><p>内层包含了最高级的代码，里面都是POJO类，这一层的类和对象不知道外层的任何信息，且应能在任何JVM下运行。</p>\n<p>Interactor – Interactor中包含了解决问题的逻辑代码。这里的代码在后台执行，并通过回调方法向外层传递事件。在其他项目中这个模块被称为用例Use Case。一个项目中可能有很多小Interactor，这符合单一职责原则，而且这样更容易让人接受。</p>\n<p>Model – 在业务逻辑代码中操作的业务模型。</p>\n<p>Repository – 包含接口让外层类实现，如操作数据库的类等。Interactor用这些接口的实现类来读取和存储数据。这也叫资源库模式Repository Pattern。</p>\n<p>Executor – 通过Worker Thread Executor让Interactor在后台执行。一般不需要修改这个包里的代码。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"clean架构图\"><a href=\"#clean架构图\" class=\"headerlink\" title=\"clean架构图\"></a>clean架构图</h1><p><img src=\"/images/架构/clean架构图.jpg\" alt=\"clean架构图\"></p>\n<h1 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h1><p>内层不能依赖外层，即内层不知道有关外层的任何事情，所以这个架构是向内依赖的。</p>\n<h1 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h1><p>Clean架构可以使你的代码有如下特性：</p>\n<ul>\n<li><p>独立于架构</p>\n</li>\n<li><p>易于测试</p>\n</li>\n<li><p>独立于UI</p>\n</li>\n<li><p>独立于数据库</p>\n</li>\n<li><p>独立于任何外部类库</p>\n</li>\n</ul>\n<h1 id=\"clean在android中的体现\"><a href=\"#clean在android中的体现\" class=\"headerlink\" title=\"clean在android中的体现\"></a>clean在android中的体现</h1><ul>\n<li><p>外层：实现层</p>\n</li>\n<li><p>中层：接口适配层</p>\n</li>\n<li><p>内层：逻辑层</p>\n</li>\n</ul>\n<p>接口实现层是体现架构细节的地方。实现架构的代码是所有不用来解决问题的代码，这包括所有与安卓相关的东西，比如创建Activity和Fragment，发送Intent以及其他联网与数据库的架构相关的代码。</p>\n<p>添加接口适配层的目的就是桥接逻辑层和架构层的代码。</p>\n<p>最重要的是逻辑层，这里包含了真正解决问题的代码。这一层不包含任何实现架构的代码，不用模拟器也应能运行这里的代码。这样一来你的逻辑代码就有了易于测试、开发和维护的优点。这就是Clean架构的一个主要的好处。</p>\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><p>一般来说一个安卓应用的结构如下：</p>\n<p>外层项目包：UI，Storage，Network等等。</p>\n<p>中层项目包：Presenter，Converter。</p>\n<p>内层项目包：Interactor，Model，Repository，Executor。</p>\n<h2 id=\"外层\"><a href=\"#外层\" class=\"headerlink\" title=\"外层\"></a>外层</h2><p>外层体现了框架的细节。</p>\n<p>UI – 包括所有的Activity，Fragment，Adapter和其他UI相关的Android代码。</p>\n<p>Storage – 用于让交互类获取和存储数据的接口实现类，包含了数据库相关的代码。包括了如ContentProvider或DBFlow等组件。</p>\n<p>Network – 网络操作。</p>\n<h2 id=\"中层\"><a href=\"#中层\" class=\"headerlink\" title=\"中层\"></a>中层</h2><p>桥接实现代码与逻辑代码的Glue Code。</p>\n<p>Presenter – presenter处理UI事件，如单击事件，通常包含内层Interactor的回调方法。</p>\n<p>Converter – 负责将内外层的模型互相转换。</p>\n<h2 id=\"内层\"><a href=\"#内层\" class=\"headerlink\" title=\"内层\"></a>内层</h2><p>内层包含了最高级的代码，里面都是POJO类，这一层的类和对象不知道外层的任何信息，且应能在任何JVM下运行。</p>\n<p>Interactor – Interactor中包含了解决问题的逻辑代码。这里的代码在后台执行，并通过回调方法向外层传递事件。在其他项目中这个模块被称为用例Use Case。一个项目中可能有很多小Interactor，这符合单一职责原则，而且这样更容易让人接受。</p>\n<p>Model – 在业务逻辑代码中操作的业务模型。</p>\n<p>Repository – 包含接口让外层类实现，如操作数据库的类等。Interactor用这些接口的实现类来读取和存储数据。这也叫资源库模式Repository Pattern。</p>\n<p>Executor – 通过Worker Thread Executor让Interactor在后台执行。一般不需要修改这个包里的代码。</p>\n"},{"title":"gradlew编译报错小结","date":"2018-03-09T03:34:35.000Z","_content":"\n出现了一个问题，使用gradlew进行分渠道打包编译的时候，报错。\n但是直接使用build，assemblebuild等操作都是可以的。\n排查发现网上有个相同的问题，回答者说是java9不稳定。\n因此需要替换一下jdk版本。\n\n\n编译的时候需要修改gradle.properties\n增加一行：org.gradle.java.home=/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home\n用于表明编译使用的jdk版本\n\n即可","source":"_posts/gradlew编译报错小结.md","raw":"---\ntitle: gradlew编译报错小结\ndate: 2018-03-09 11:34:35\ntags: 日常bug\n---\n\n出现了一个问题，使用gradlew进行分渠道打包编译的时候，报错。\n但是直接使用build，assemblebuild等操作都是可以的。\n排查发现网上有个相同的问题，回答者说是java9不稳定。\n因此需要替换一下jdk版本。\n\n\n编译的时候需要修改gradle.properties\n增加一行：org.gradle.java.home=/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home\n用于表明编译使用的jdk版本\n\n即可","slug":"gradlew编译报错小结","published":1,"updated":"2019-03-12T09:26:33.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxv002t3a8ka334cm4y","content":"<p>出现了一个问题，使用gradlew进行分渠道打包编译的时候，报错。<br>但是直接使用build，assemblebuild等操作都是可以的。<br>排查发现网上有个相同的问题，回答者说是java9不稳定。<br>因此需要替换一下jdk版本。</p>\n<p>编译的时候需要修改gradle.properties<br>增加一行：org.gradle.java.home=/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home<br>用于表明编译使用的jdk版本</p>\n<p>即可</p>\n","site":{"data":{}},"excerpt":"","more":"<p>出现了一个问题，使用gradlew进行分渠道打包编译的时候，报错。<br>但是直接使用build，assemblebuild等操作都是可以的。<br>排查发现网上有个相同的问题，回答者说是java9不稳定。<br>因此需要替换一下jdk版本。</p>\n<p>编译的时候需要修改gradle.properties<br>增加一行：org.gradle.java.home=/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home<br>用于表明编译使用的jdk版本</p>\n<p>即可</p>\n"},{"title":"http知识杂烩","date":"2018-03-27T14:45:05.000Z","_content":"\n今天被后台怼了，主要是没加\n```\n@Headers({\"Content-Type: application/json\"})\n```\n\n导致请求没有过到服务器，然后我还挺着老脸去问为啥没用。丢人呐。\n\n所以今天开一个杂烩贴，用于将http遇到的问题总结下来。\n\n## Content-Type\n\nContent-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定文件接收方将以什么形式、什么编码读取这个文件\n\n### application/json\n\napplication/json是一种正常的以json形式读取传输文件的方式。\njson全名是javascript object notation，形式是{\"key\":\"value\"}的形式\n\n对象表示为键值对\n数据由逗号分隔\n花括号保存对象\n方括号保存数组\n\n### application/x-www-form-urlencoded\n\n首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。\n\n### multipart/form-data\n\n这是使用表单上传文件时必须的。\n\n示例：\n```\nPOST http://www.example.com HTTP/1.1\nContent-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA\n\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA\nContent-Disposition: form-data; name=\"text\"\n\ntitle\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA\nContent-Disposition: form-data; name=\"file\"; filename=\"chrome.png\"\nContent-Type: image/png\n\nPNG ... content of chrome.png ...\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA--\n```\n\n首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 --boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 --boundary-- 标示结束。\n\n### text/xml\n\n示例：\n```\nPOST http://www.example.com HTTP/1.1 \nContent-Type: text/xml\n\n<?xml version=\"1.0\"?>\n<methodCall>\n    <methodName>examples.getStateName</methodName>\n    <params>\n        <param>\n            <value><i4>41</i4></value>\n        </param>\n    </params>\n</methodCall>\n```\n\n这个就和android里面的xml差不多，用途还挺多的，不过就是太大了，也能解析成类似于json的形式。\n\n## RequestBody拓展\n\nrequestBody的拓展其实比较有用，今次项目中用到，若不是不支持urlencode，获取也不会关注。\n\n在okhttp里面加入一个继承自Interceptor的拦截器，将请求拦截下来，针对不同的请求进行操作，例如加上一个token，批量操作header等。\n\n操作的过程就是对requestbody拓展的过程，就是将原有的src的requestbody，和extend的requestbody进行融合。\n\n需要写三个方法，contentType、contentLength、writeTo。\n\n<!-- contenttype是contenttype。contentlength是src.contentlength()+extend.contentlength()+1。writeto是写操作，先写src，后写extend，需要对不同的contenttype加上不同的连接符，sink.writeUtf8(\",\")或者sink.writeUtf8(\"&\")等等。\n\n如此便可以自由的截断和拓展相关requestbody了。 -->\n\n对requestbody的拓展，如果是json有一个问题，就是}{这两个符号不好处理，暂时没有找到方法。\n\n但是对于x-www-form-urlencoded这种连接的文本比较容易操作，中间加一个&即可。\n\n## http url拓展\n\nurl的拓展主要是针对末尾增加query，或者parameter这种。\n\n使用的方法也是差不多的方法，通过拦截器获取request，然后从request中取出url，对url进行拼装，之后在使用新的url来重新组装一个request，之后返回即可。\n\n有一点需要注意的，不是所有的请求都会从url中获取参数，这个开发中需要注意。\n\n\n\n","source":"_posts/http知识杂烩.md","raw":"---\ntitle: http知识杂烩\ndate: 2018-03-27 22:45:05\ntags: http\n---\n\n今天被后台怼了，主要是没加\n```\n@Headers({\"Content-Type: application/json\"})\n```\n\n导致请求没有过到服务器，然后我还挺着老脸去问为啥没用。丢人呐。\n\n所以今天开一个杂烩贴，用于将http遇到的问题总结下来。\n\n## Content-Type\n\nContent-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定文件接收方将以什么形式、什么编码读取这个文件\n\n### application/json\n\napplication/json是一种正常的以json形式读取传输文件的方式。\njson全名是javascript object notation，形式是{\"key\":\"value\"}的形式\n\n对象表示为键值对\n数据由逗号分隔\n花括号保存对象\n方括号保存数组\n\n### application/x-www-form-urlencoded\n\n首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。\n\n### multipart/form-data\n\n这是使用表单上传文件时必须的。\n\n示例：\n```\nPOST http://www.example.com HTTP/1.1\nContent-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA\n\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA\nContent-Disposition: form-data; name=\"text\"\n\ntitle\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA\nContent-Disposition: form-data; name=\"file\"; filename=\"chrome.png\"\nContent-Type: image/png\n\nPNG ... content of chrome.png ...\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA--\n```\n\n首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 --boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 --boundary-- 标示结束。\n\n### text/xml\n\n示例：\n```\nPOST http://www.example.com HTTP/1.1 \nContent-Type: text/xml\n\n<?xml version=\"1.0\"?>\n<methodCall>\n    <methodName>examples.getStateName</methodName>\n    <params>\n        <param>\n            <value><i4>41</i4></value>\n        </param>\n    </params>\n</methodCall>\n```\n\n这个就和android里面的xml差不多，用途还挺多的，不过就是太大了，也能解析成类似于json的形式。\n\n## RequestBody拓展\n\nrequestBody的拓展其实比较有用，今次项目中用到，若不是不支持urlencode，获取也不会关注。\n\n在okhttp里面加入一个继承自Interceptor的拦截器，将请求拦截下来，针对不同的请求进行操作，例如加上一个token，批量操作header等。\n\n操作的过程就是对requestbody拓展的过程，就是将原有的src的requestbody，和extend的requestbody进行融合。\n\n需要写三个方法，contentType、contentLength、writeTo。\n\n<!-- contenttype是contenttype。contentlength是src.contentlength()+extend.contentlength()+1。writeto是写操作，先写src，后写extend，需要对不同的contenttype加上不同的连接符，sink.writeUtf8(\",\")或者sink.writeUtf8(\"&\")等等。\n\n如此便可以自由的截断和拓展相关requestbody了。 -->\n\n对requestbody的拓展，如果是json有一个问题，就是}{这两个符号不好处理，暂时没有找到方法。\n\n但是对于x-www-form-urlencoded这种连接的文本比较容易操作，中间加一个&即可。\n\n## http url拓展\n\nurl的拓展主要是针对末尾增加query，或者parameter这种。\n\n使用的方法也是差不多的方法，通过拦截器获取request，然后从request中取出url，对url进行拼装，之后在使用新的url来重新组装一个request，之后返回即可。\n\n有一点需要注意的，不是所有的请求都会从url中获取参数，这个开发中需要注意。\n\n\n\n","slug":"http知识杂烩","published":1,"updated":"2019-03-12T09:26:33.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxw002v3a8kebasigmj","content":"<p>今天被后台怼了，主要是没加<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Headers(&#123;&quot;Content-Type: application/json&quot;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>导致请求没有过到服务器，然后我还挺着老脸去问为啥没用。丢人呐。</p>\n<p>所以今天开一个杂烩贴，用于将http遇到的问题总结下来。</p>\n<h2 id=\"Content-Type\"><a href=\"#Content-Type\" class=\"headerlink\" title=\"Content-Type\"></a>Content-Type</h2><p>Content-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定文件接收方将以什么形式、什么编码读取这个文件</p>\n<h3 id=\"application-json\"><a href=\"#application-json\" class=\"headerlink\" title=\"application/json\"></a>application/json</h3><p>application/json是一种正常的以json形式读取传输文件的方式。<br>json全名是javascript object notation，形式是{“key”:”value”}的形式</p>\n<p>对象表示为键值对<br>数据由逗号分隔<br>花括号保存对象<br>方括号保存数组</p>\n<h3 id=\"application-x-www-form-urlencoded\"><a href=\"#application-x-www-form-urlencoded\" class=\"headerlink\" title=\"application/x-www-form-urlencoded\"></a>application/x-www-form-urlencoded</h3><p>首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。</p>\n<h3 id=\"multipart-form-data\"><a href=\"#multipart-form-data\" class=\"headerlink\" title=\"multipart/form-data\"></a>multipart/form-data</h3><p>这是使用表单上传文件时必须的。</p>\n<p>示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST http://www.example.com HTTP/1.1</span><br><span class=\"line\">Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class=\"line\"></span><br><span class=\"line\">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class=\"line\">Content-Disposition: form-data; name=&quot;text&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">title</span><br><span class=\"line\">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class=\"line\">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;</span><br><span class=\"line\">Content-Type: image/png</span><br><span class=\"line\"></span><br><span class=\"line\">PNG ... content of chrome.png ...</span><br><span class=\"line\">------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</span><br></pre></td></tr></table></figure></p>\n<p>首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 –boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。</p>\n<h3 id=\"text-xml\"><a href=\"#text-xml\" class=\"headerlink\" title=\"text/xml\"></a>text/xml</h3><p>示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST http://www.example.com HTTP/1.1 </span><br><span class=\"line\">Content-Type: text/xml</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">&lt;methodCall&gt;</span><br><span class=\"line\">    &lt;methodName&gt;examples.getStateName&lt;/methodName&gt;</span><br><span class=\"line\">    &lt;params&gt;</span><br><span class=\"line\">        &lt;param&gt;</span><br><span class=\"line\">            &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt;</span><br><span class=\"line\">        &lt;/param&gt;</span><br><span class=\"line\">    &lt;/params&gt;</span><br><span class=\"line\">&lt;/methodCall&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这个就和android里面的xml差不多，用途还挺多的，不过就是太大了，也能解析成类似于json的形式。</p>\n<h2 id=\"RequestBody拓展\"><a href=\"#RequestBody拓展\" class=\"headerlink\" title=\"RequestBody拓展\"></a>RequestBody拓展</h2><p>requestBody的拓展其实比较有用，今次项目中用到，若不是不支持urlencode，获取也不会关注。</p>\n<p>在okhttp里面加入一个继承自Interceptor的拦截器，将请求拦截下来，针对不同的请求进行操作，例如加上一个token，批量操作header等。</p>\n<p>操作的过程就是对requestbody拓展的过程，就是将原有的src的requestbody，和extend的requestbody进行融合。</p>\n<p>需要写三个方法，contentType、contentLength、writeTo。</p>\n<!-- contenttype是contenttype。contentlength是src.contentlength()+extend.contentlength()+1。writeto是写操作，先写src，后写extend，需要对不同的contenttype加上不同的连接符，sink.writeUtf8(\",\")或者sink.writeUtf8(\"&\")等等。\n\n如此便可以自由的截断和拓展相关requestbody了。 -->\n<p>对requestbody的拓展，如果是json有一个问题，就是}{这两个符号不好处理，暂时没有找到方法。</p>\n<p>但是对于x-www-form-urlencoded这种连接的文本比较容易操作，中间加一个&amp;即可。</p>\n<h2 id=\"http-url拓展\"><a href=\"#http-url拓展\" class=\"headerlink\" title=\"http url拓展\"></a>http url拓展</h2><p>url的拓展主要是针对末尾增加query，或者parameter这种。</p>\n<p>使用的方法也是差不多的方法，通过拦截器获取request，然后从request中取出url，对url进行拼装，之后在使用新的url来重新组装一个request，之后返回即可。</p>\n<p>有一点需要注意的，不是所有的请求都会从url中获取参数，这个开发中需要注意。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天被后台怼了，主要是没加<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Headers(&#123;&quot;Content-Type: application/json&quot;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>导致请求没有过到服务器，然后我还挺着老脸去问为啥没用。丢人呐。</p>\n<p>所以今天开一个杂烩贴，用于将http遇到的问题总结下来。</p>\n<h2 id=\"Content-Type\"><a href=\"#Content-Type\" class=\"headerlink\" title=\"Content-Type\"></a>Content-Type</h2><p>Content-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定文件接收方将以什么形式、什么编码读取这个文件</p>\n<h3 id=\"application-json\"><a href=\"#application-json\" class=\"headerlink\" title=\"application/json\"></a>application/json</h3><p>application/json是一种正常的以json形式读取传输文件的方式。<br>json全名是javascript object notation，形式是{“key”:”value”}的形式</p>\n<p>对象表示为键值对<br>数据由逗号分隔<br>花括号保存对象<br>方括号保存数组</p>\n<h3 id=\"application-x-www-form-urlencoded\"><a href=\"#application-x-www-form-urlencoded\" class=\"headerlink\" title=\"application/x-www-form-urlencoded\"></a>application/x-www-form-urlencoded</h3><p>首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。</p>\n<h3 id=\"multipart-form-data\"><a href=\"#multipart-form-data\" class=\"headerlink\" title=\"multipart/form-data\"></a>multipart/form-data</h3><p>这是使用表单上传文件时必须的。</p>\n<p>示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST http://www.example.com HTTP/1.1</span><br><span class=\"line\">Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class=\"line\"></span><br><span class=\"line\">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class=\"line\">Content-Disposition: form-data; name=&quot;text&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">title</span><br><span class=\"line\">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class=\"line\">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;</span><br><span class=\"line\">Content-Type: image/png</span><br><span class=\"line\"></span><br><span class=\"line\">PNG ... content of chrome.png ...</span><br><span class=\"line\">------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</span><br></pre></td></tr></table></figure></p>\n<p>首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 –boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。</p>\n<h3 id=\"text-xml\"><a href=\"#text-xml\" class=\"headerlink\" title=\"text/xml\"></a>text/xml</h3><p>示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST http://www.example.com HTTP/1.1 </span><br><span class=\"line\">Content-Type: text/xml</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">&lt;methodCall&gt;</span><br><span class=\"line\">    &lt;methodName&gt;examples.getStateName&lt;/methodName&gt;</span><br><span class=\"line\">    &lt;params&gt;</span><br><span class=\"line\">        &lt;param&gt;</span><br><span class=\"line\">            &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt;</span><br><span class=\"line\">        &lt;/param&gt;</span><br><span class=\"line\">    &lt;/params&gt;</span><br><span class=\"line\">&lt;/methodCall&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这个就和android里面的xml差不多，用途还挺多的，不过就是太大了，也能解析成类似于json的形式。</p>\n<h2 id=\"RequestBody拓展\"><a href=\"#RequestBody拓展\" class=\"headerlink\" title=\"RequestBody拓展\"></a>RequestBody拓展</h2><p>requestBody的拓展其实比较有用，今次项目中用到，若不是不支持urlencode，获取也不会关注。</p>\n<p>在okhttp里面加入一个继承自Interceptor的拦截器，将请求拦截下来，针对不同的请求进行操作，例如加上一个token，批量操作header等。</p>\n<p>操作的过程就是对requestbody拓展的过程，就是将原有的src的requestbody，和extend的requestbody进行融合。</p>\n<p>需要写三个方法，contentType、contentLength、writeTo。</p>\n<!-- contenttype是contenttype。contentlength是src.contentlength()+extend.contentlength()+1。writeto是写操作，先写src，后写extend，需要对不同的contenttype加上不同的连接符，sink.writeUtf8(\",\")或者sink.writeUtf8(\"&\")等等。\n\n如此便可以自由的截断和拓展相关requestbody了。 -->\n<p>对requestbody的拓展，如果是json有一个问题，就是}{这两个符号不好处理，暂时没有找到方法。</p>\n<p>但是对于x-www-form-urlencoded这种连接的文本比较容易操作，中间加一个&amp;即可。</p>\n<h2 id=\"http-url拓展\"><a href=\"#http-url拓展\" class=\"headerlink\" title=\"http url拓展\"></a>http url拓展</h2><p>url的拓展主要是针对末尾增加query，或者parameter这种。</p>\n<p>使用的方法也是差不多的方法，通过拦截器获取request，然后从request中取出url，对url进行拼装，之后在使用新的url来重新组装一个request，之后返回即可。</p>\n<p>有一点需要注意的，不是所有的请求都会从url中获取参数，这个开发中需要注意。</p>\n"},{"title":"ios-stanford-1","date":"2017-12-31T13:44:56.000Z","_content":"\n# what‘s in iOS？\n\n## Core OS:\n\niOS基本就是一个基于Unix的操作系统，它大量借鉴了Mac OS X的内核部分。\n所以Core OS部分，包含了Sockets,Security,BSD,Mach 3.0,OSX Kernal, Power Management, Keychain Access, Certifications, File System Bonjour.这些实现一个操作系统的部分。\n\n## Core Services:\n\n这是一个能够让开发者使用大量的面向对象编程技术，但这层不包括ui，而是更多用于通过面向对象编程的方式访问硬件或者访问网络等等。我们需要耗费很多的时间，因为我们需要这些原始组件来建立更高的层。\n包括了Collections,Address Book,Networking,FileAccess, SQLite, CoreLocation,Net Services, Threading, Preferences, URL Utilities.\n\n## Media\n\nCore Audio, OpenAL, Audio Mixing, Audio Mixing, Audio Recording, Video Playback, JPEG/PNG/TIFF, PDF, Quartz(2D), Core Animation, OpenGL ES.\n\n## Cocoa Touch\n\nMulti-Touch, Alerts, Core Motion, Web View, View Hierarchy, Map kit, Localization, Image Picker, Controls, Camera\n使用这些与用户互动\n\n# MVC\n\nMVC是一种设计模式，更有利于阅读代码。而iOS从一开始就使用MVC设计，这是构建iOS的一种方法。\n\n# Demo\n\n","source":"_posts/ios-stanford-1.md","raw":"---\ntitle: ios-stanford-1\ndate: 2017-12-31 21:44:56\ntags: ios\n---\n\n# what‘s in iOS？\n\n## Core OS:\n\niOS基本就是一个基于Unix的操作系统，它大量借鉴了Mac OS X的内核部分。\n所以Core OS部分，包含了Sockets,Security,BSD,Mach 3.0,OSX Kernal, Power Management, Keychain Access, Certifications, File System Bonjour.这些实现一个操作系统的部分。\n\n## Core Services:\n\n这是一个能够让开发者使用大量的面向对象编程技术，但这层不包括ui，而是更多用于通过面向对象编程的方式访问硬件或者访问网络等等。我们需要耗费很多的时间，因为我们需要这些原始组件来建立更高的层。\n包括了Collections,Address Book,Networking,FileAccess, SQLite, CoreLocation,Net Services, Threading, Preferences, URL Utilities.\n\n## Media\n\nCore Audio, OpenAL, Audio Mixing, Audio Mixing, Audio Recording, Video Playback, JPEG/PNG/TIFF, PDF, Quartz(2D), Core Animation, OpenGL ES.\n\n## Cocoa Touch\n\nMulti-Touch, Alerts, Core Motion, Web View, View Hierarchy, Map kit, Localization, Image Picker, Controls, Camera\n使用这些与用户互动\n\n# MVC\n\nMVC是一种设计模式，更有利于阅读代码。而iOS从一开始就使用MVC设计，这是构建iOS的一种方法。\n\n# Demo\n\n","slug":"ios-stanford-1","published":1,"updated":"2019-03-12T09:26:33.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxx002y3a8kdwjfzv8l","content":"<h1 id=\"what‘s-in-iOS？\"><a href=\"#what‘s-in-iOS？\" class=\"headerlink\" title=\"what‘s in iOS？\"></a>what‘s in iOS？</h1><h2 id=\"Core-OS\"><a href=\"#Core-OS\" class=\"headerlink\" title=\"Core OS:\"></a>Core OS:</h2><p>iOS基本就是一个基于Unix的操作系统，它大量借鉴了Mac OS X的内核部分。<br>所以Core OS部分，包含了Sockets,Security,BSD,Mach 3.0,OSX Kernal, Power Management, Keychain Access, Certifications, File System Bonjour.这些实现一个操作系统的部分。</p>\n<h2 id=\"Core-Services\"><a href=\"#Core-Services\" class=\"headerlink\" title=\"Core Services:\"></a>Core Services:</h2><p>这是一个能够让开发者使用大量的面向对象编程技术，但这层不包括ui，而是更多用于通过面向对象编程的方式访问硬件或者访问网络等等。我们需要耗费很多的时间，因为我们需要这些原始组件来建立更高的层。<br>包括了Collections,Address Book,Networking,FileAccess, SQLite, CoreLocation,Net Services, Threading, Preferences, URL Utilities.</p>\n<h2 id=\"Media\"><a href=\"#Media\" class=\"headerlink\" title=\"Media\"></a>Media</h2><p>Core Audio, OpenAL, Audio Mixing, Audio Mixing, Audio Recording, Video Playback, JPEG/PNG/TIFF, PDF, Quartz(2D), Core Animation, OpenGL ES.</p>\n<h2 id=\"Cocoa-Touch\"><a href=\"#Cocoa-Touch\" class=\"headerlink\" title=\"Cocoa Touch\"></a>Cocoa Touch</h2><p>Multi-Touch, Alerts, Core Motion, Web View, View Hierarchy, Map kit, Localization, Image Picker, Controls, Camera<br>使用这些与用户互动</p>\n<h1 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h1><p>MVC是一种设计模式，更有利于阅读代码。而iOS从一开始就使用MVC设计，这是构建iOS的一种方法。</p>\n<h1 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"what‘s-in-iOS？\"><a href=\"#what‘s-in-iOS？\" class=\"headerlink\" title=\"what‘s in iOS？\"></a>what‘s in iOS？</h1><h2 id=\"Core-OS\"><a href=\"#Core-OS\" class=\"headerlink\" title=\"Core OS:\"></a>Core OS:</h2><p>iOS基本就是一个基于Unix的操作系统，它大量借鉴了Mac OS X的内核部分。<br>所以Core OS部分，包含了Sockets,Security,BSD,Mach 3.0,OSX Kernal, Power Management, Keychain Access, Certifications, File System Bonjour.这些实现一个操作系统的部分。</p>\n<h2 id=\"Core-Services\"><a href=\"#Core-Services\" class=\"headerlink\" title=\"Core Services:\"></a>Core Services:</h2><p>这是一个能够让开发者使用大量的面向对象编程技术，但这层不包括ui，而是更多用于通过面向对象编程的方式访问硬件或者访问网络等等。我们需要耗费很多的时间，因为我们需要这些原始组件来建立更高的层。<br>包括了Collections,Address Book,Networking,FileAccess, SQLite, CoreLocation,Net Services, Threading, Preferences, URL Utilities.</p>\n<h2 id=\"Media\"><a href=\"#Media\" class=\"headerlink\" title=\"Media\"></a>Media</h2><p>Core Audio, OpenAL, Audio Mixing, Audio Mixing, Audio Recording, Video Playback, JPEG/PNG/TIFF, PDF, Quartz(2D), Core Animation, OpenGL ES.</p>\n<h2 id=\"Cocoa-Touch\"><a href=\"#Cocoa-Touch\" class=\"headerlink\" title=\"Cocoa Touch\"></a>Cocoa Touch</h2><p>Multi-Touch, Alerts, Core Motion, Web View, View Hierarchy, Map kit, Localization, Image Picker, Controls, Camera<br>使用这些与用户互动</p>\n<h1 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h1><p>MVC是一种设计模式，更有利于阅读代码。而iOS从一开始就使用MVC设计，这是构建iOS的一种方法。</p>\n<h1 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h1>"},{"title":"java-uri拼接","date":"2018-03-26T12:31:44.000Z","_content":"\n项目中遇到一个问题，是关于uri拼接的。\n\nuri类似如下\nwww.baidu.com/d/j/fd%3fd\n\n我需要在后面加一个 ?xx/impg,wpeg/resize,h_40这样的\n\n这个涉及到解码编码的问题，前面由于具有%3这种符号，不可以解码，需要编码，而后缀由于具有?这种符号，不可以编码。\n\n这样可以直接前面的通过URI的buildupon来构建，而后面的可以通过直接相加避免编码的方法。\n\n事实上直接相加或许也可以，但是通过buildupon的path相加，会自动对path的内容进行编码，但是坑爹的是我的后缀也没变了。而encodepath则更坑，把前缀也给解码了。\n\n后来又试了一下直接相加，也可以？？\n\n这就好蛋疼了。\n","source":"_posts/java-uri拼接.md","raw":"---\ntitle: java-uri拼接\ndate: 2018-03-26 20:31:44\ntags: java\n---\n\n项目中遇到一个问题，是关于uri拼接的。\n\nuri类似如下\nwww.baidu.com/d/j/fd%3fd\n\n我需要在后面加一个 ?xx/impg,wpeg/resize,h_40这样的\n\n这个涉及到解码编码的问题，前面由于具有%3这种符号，不可以解码，需要编码，而后缀由于具有?这种符号，不可以编码。\n\n这样可以直接前面的通过URI的buildupon来构建，而后面的可以通过直接相加避免编码的方法。\n\n事实上直接相加或许也可以，但是通过buildupon的path相加，会自动对path的内容进行编码，但是坑爹的是我的后缀也没变了。而encodepath则更坑，把前缀也给解码了。\n\n后来又试了一下直接相加，也可以？？\n\n这就好蛋疼了。\n","slug":"java-uri拼接","published":1,"updated":"2019-03-12T09:26:33.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxz00303a8ki4qndu47","content":"<p>项目中遇到一个问题，是关于uri拼接的。</p>\n<p>uri类似如下<br><a href=\"http://www.baidu.com/d/j/fd%3fd\" target=\"_blank\" rel=\"noopener\">www.baidu.com/d/j/fd%3fd</a></p>\n<p>我需要在后面加一个 ?xx/impg,wpeg/resize,h_40这样的</p>\n<p>这个涉及到解码编码的问题，前面由于具有%3这种符号，不可以解码，需要编码，而后缀由于具有?这种符号，不可以编码。</p>\n<p>这样可以直接前面的通过URI的buildupon来构建，而后面的可以通过直接相加避免编码的方法。</p>\n<p>事实上直接相加或许也可以，但是通过buildupon的path相加，会自动对path的内容进行编码，但是坑爹的是我的后缀也没变了。而encodepath则更坑，把前缀也给解码了。</p>\n<p>后来又试了一下直接相加，也可以？？</p>\n<p>这就好蛋疼了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>项目中遇到一个问题，是关于uri拼接的。</p>\n<p>uri类似如下<br><a href=\"http://www.baidu.com/d/j/fd%3fd\" target=\"_blank\" rel=\"noopener\">www.baidu.com/d/j/fd%3fd</a></p>\n<p>我需要在后面加一个 ?xx/impg,wpeg/resize,h_40这样的</p>\n<p>这个涉及到解码编码的问题，前面由于具有%3这种符号，不可以解码，需要编码，而后缀由于具有?这种符号，不可以编码。</p>\n<p>这样可以直接前面的通过URI的buildupon来构建，而后面的可以通过直接相加避免编码的方法。</p>\n<p>事实上直接相加或许也可以，但是通过buildupon的path相加，会自动对path的内容进行编码，但是坑爹的是我的后缀也没变了。而encodepath则更坑，把前缀也给解码了。</p>\n<p>后来又试了一下直接相加，也可以？？</p>\n<p>这就好蛋疼了。</p>\n"},{"title":"java二分法查找","date":"2018-02-21T15:05:47.000Z","_content":"数据量很大的时候，且数据量有序不重复的情景下，可以使用二分查找法。\n\n# 算法思想\n\n假定在一串数组中，需要查找x，该数组升序，该数组长度为k，可以先比较x与中间位置及k/2-1处的值进行比对，相等则查找成功，不想等时，若x大于中间值，则从后半段进行相同操作。依次递归。\n\n# 空间复杂度\n\no（n）\n\n# 时间复杂度\n\n最坏情况，第一个元素或者最后一个元素是需要查找的元素，时间复杂度为O(log2n)\n最好情况，O(1)\n\n# 算法实现思想\n\n例：在有序的有N个元素的数组中查找用户输进去的数据x。\n算法如下：\n1.确定查找范围front=0，end=N-1，计算中项mid=（front+end）/2。\n2.若a[mid]=x或front>=end,则结束查找；否则，向下继续。\n3.若a[mid] < x,说明待查找的元素值只可能在比中项元素大的范围内，则把mid+1的值赋给front，并重新计算mid，转去执行步骤2；若a[mid]>x，说明待查找的元素值只可能在比中项元素小的范围内，则把mid-1的值赋给end，并重新计算mid，转去执行步骤2。\n\n\n# java实现\n\n```\npublic static int binary(int[] array, int value)\n    {\n        int low = 0;\n        int high = array.length - 1;\n        while(low <= high)\n        {\n            int middle = (low + high) / 2;\n            if(value == array[middle])\n            {\n                return middle;\n            }\n            if(value > array[middle])\n            {\n                low = middle + 1;\n            }\n            if(value < array[middle])\n            {\n                high = middle - 1;\n            }\n        }\n        return -1;\n    }\n```\n","source":"_posts/java二分法查找.md","raw":"---\ntitle: java二分法查找\ndate: 2018-02-21 23:05:47\ntags: 算法\n---\n数据量很大的时候，且数据量有序不重复的情景下，可以使用二分查找法。\n\n# 算法思想\n\n假定在一串数组中，需要查找x，该数组升序，该数组长度为k，可以先比较x与中间位置及k/2-1处的值进行比对，相等则查找成功，不想等时，若x大于中间值，则从后半段进行相同操作。依次递归。\n\n# 空间复杂度\n\no（n）\n\n# 时间复杂度\n\n最坏情况，第一个元素或者最后一个元素是需要查找的元素，时间复杂度为O(log2n)\n最好情况，O(1)\n\n# 算法实现思想\n\n例：在有序的有N个元素的数组中查找用户输进去的数据x。\n算法如下：\n1.确定查找范围front=0，end=N-1，计算中项mid=（front+end）/2。\n2.若a[mid]=x或front>=end,则结束查找；否则，向下继续。\n3.若a[mid] < x,说明待查找的元素值只可能在比中项元素大的范围内，则把mid+1的值赋给front，并重新计算mid，转去执行步骤2；若a[mid]>x，说明待查找的元素值只可能在比中项元素小的范围内，则把mid-1的值赋给end，并重新计算mid，转去执行步骤2。\n\n\n# java实现\n\n```\npublic static int binary(int[] array, int value)\n    {\n        int low = 0;\n        int high = array.length - 1;\n        while(low <= high)\n        {\n            int middle = (low + high) / 2;\n            if(value == array[middle])\n            {\n                return middle;\n            }\n            if(value > array[middle])\n            {\n                low = middle + 1;\n            }\n            if(value < array[middle])\n            {\n                high = middle - 1;\n            }\n        }\n        return -1;\n    }\n```\n","slug":"java二分法查找","published":1,"updated":"2019-03-12T09:26:33.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttxz00313a8kzqh4fqxn","content":"<p>数据量很大的时候，且数据量有序不重复的情景下，可以使用二分查找法。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>假定在一串数组中，需要查找x，该数组升序，该数组长度为k，可以先比较x与中间位置及k/2-1处的值进行比对，相等则查找成功，不想等时，若x大于中间值，则从后半段进行相同操作。依次递归。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>o（n）</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>最坏情况，第一个元素或者最后一个元素是需要查找的元素，时间复杂度为O(log2n)<br>最好情况，O(1)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>例：在有序的有N个元素的数组中查找用户输进去的数据x。<br>算法如下：<br>1.确定查找范围front=0，end=N-1，计算中项mid=（front+end）/2。<br>2.若a[mid]=x或front&gt;=end,则结束查找；否则，向下继续。<br>3.若a[mid] &lt; x,说明待查找的元素值只可能在比中项元素大的范围内，则把mid+1的值赋给front，并重新计算mid，转去执行步骤2；若a[mid]&gt;x，说明待查找的元素值只可能在比中项元素小的范围内，则把mid-1的值赋给end，并重新计算mid，转去执行步骤2。</p>\n<h1 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int binary(int[] array, int value)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int low = 0;</span><br><span class=\"line\">        int high = array.length - 1;</span><br><span class=\"line\">        while(low &lt;= high)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            int middle = (low + high) / 2;</span><br><span class=\"line\">            if(value == array[middle])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                return middle;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(value &gt; array[middle])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                low = middle + 1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(value &lt; array[middle])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                high = middle - 1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>数据量很大的时候，且数据量有序不重复的情景下，可以使用二分查找法。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>假定在一串数组中，需要查找x，该数组升序，该数组长度为k，可以先比较x与中间位置及k/2-1处的值进行比对，相等则查找成功，不想等时，若x大于中间值，则从后半段进行相同操作。依次递归。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>o（n）</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>最坏情况，第一个元素或者最后一个元素是需要查找的元素，时间复杂度为O(log2n)<br>最好情况，O(1)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>例：在有序的有N个元素的数组中查找用户输进去的数据x。<br>算法如下：<br>1.确定查找范围front=0，end=N-1，计算中项mid=（front+end）/2。<br>2.若a[mid]=x或front&gt;=end,则结束查找；否则，向下继续。<br>3.若a[mid] &lt; x,说明待查找的元素值只可能在比中项元素大的范围内，则把mid+1的值赋给front，并重新计算mid，转去执行步骤2；若a[mid]&gt;x，说明待查找的元素值只可能在比中项元素小的范围内，则把mid-1的值赋给end，并重新计算mid，转去执行步骤2。</p>\n<h1 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int binary(int[] array, int value)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int low = 0;</span><br><span class=\"line\">        int high = array.length - 1;</span><br><span class=\"line\">        while(low &lt;= high)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            int middle = (low + high) / 2;</span><br><span class=\"line\">            if(value == array[middle])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                return middle;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(value &gt; array[middle])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                low = middle + 1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(value &lt; array[middle])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                high = middle - 1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"java克隆、浅克隆、深克隆","date":"2018-04-04T06:29:51.000Z","_content":"\n# 克隆\n\n当我们需要有一个当前对象的克隆体，和当前对象完全相同的属性、功能，但又不想去仅仅创建一个对象的引用时，我们就需要对对象进行克隆。\n\n克隆clone，是创建了一个一摸一样的对象。该方法是object的方法，平时用不到是因为这个方法是protect属性的。\n\n需要用到clone方法的时候，直接覆盖父类的方法，定义成public，然后写super.clone()。或者直接自己写一个clone方法也可以。同时不要忘了记成clonable接口。\n\n# 浅克隆\n\n被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。\n\n继承自object的clone方法，就是浅克隆，除非对引用也使用clone的方法。\n\n没啥大用。\n\n# 深克隆\n\n被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。\n\n深克隆可以使用序列化的方法。\n\n精髓主要是将对象写入流中，然后在从流中都取出来。这样就实现了一个对象的深克隆。\n\n前提是对象都是序列化的，不论成员还是引用。\n\n```\npublic Object deepClone() throws IOException,OptionalDataException,ClassNotFoundException{//将对象写到流里\nByteArrayOutoutStream bo=new ByteArrayOutputStream();\nObjectOutputStream oo=new ObjectOutputStream(bo);\noo.writeObject(this);//从流里读出来\nByteArrayInputStream bi=new ByteArrayInputStream(bo.toByteArray());\nObjectInputStream oi=new ObjectInputStream(bi);\nreturn(oi.readObject());\n\n```\n\n\n\n","source":"_posts/java克隆、浅克隆、深克隆.md","raw":"---\ntitle: java克隆、浅克隆、深克隆\ndate: 2018-04-04 14:29:51\ntags: java\n---\n\n# 克隆\n\n当我们需要有一个当前对象的克隆体，和当前对象完全相同的属性、功能，但又不想去仅仅创建一个对象的引用时，我们就需要对对象进行克隆。\n\n克隆clone，是创建了一个一摸一样的对象。该方法是object的方法，平时用不到是因为这个方法是protect属性的。\n\n需要用到clone方法的时候，直接覆盖父类的方法，定义成public，然后写super.clone()。或者直接自己写一个clone方法也可以。同时不要忘了记成clonable接口。\n\n# 浅克隆\n\n被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。\n\n继承自object的clone方法，就是浅克隆，除非对引用也使用clone的方法。\n\n没啥大用。\n\n# 深克隆\n\n被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。\n\n深克隆可以使用序列化的方法。\n\n精髓主要是将对象写入流中，然后在从流中都取出来。这样就实现了一个对象的深克隆。\n\n前提是对象都是序列化的，不论成员还是引用。\n\n```\npublic Object deepClone() throws IOException,OptionalDataException,ClassNotFoundException{//将对象写到流里\nByteArrayOutoutStream bo=new ByteArrayOutputStream();\nObjectOutputStream oo=new ObjectOutputStream(bo);\noo.writeObject(this);//从流里读出来\nByteArrayInputStream bi=new ByteArrayInputStream(bo.toByteArray());\nObjectInputStream oi=new ObjectInputStream(bi);\nreturn(oi.readObject());\n\n```\n\n\n\n","slug":"java克隆、浅克隆、深克隆","published":1,"updated":"2019-03-12T09:26:33.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltty100343a8kum2psazj","content":"<h1 id=\"克隆\"><a href=\"#克隆\" class=\"headerlink\" title=\"克隆\"></a>克隆</h1><p>当我们需要有一个当前对象的克隆体，和当前对象完全相同的属性、功能，但又不想去仅仅创建一个对象的引用时，我们就需要对对象进行克隆。</p>\n<p>克隆clone，是创建了一个一摸一样的对象。该方法是object的方法，平时用不到是因为这个方法是protect属性的。</p>\n<p>需要用到clone方法的时候，直接覆盖父类的方法，定义成public，然后写super.clone()。或者直接自己写一个clone方法也可以。同时不要忘了记成clonable接口。</p>\n<h1 id=\"浅克隆\"><a href=\"#浅克隆\" class=\"headerlink\" title=\"浅克隆\"></a>浅克隆</h1><p>被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。</p>\n<p>继承自object的clone方法，就是浅克隆，除非对引用也使用clone的方法。</p>\n<p>没啥大用。</p>\n<h1 id=\"深克隆\"><a href=\"#深克隆\" class=\"headerlink\" title=\"深克隆\"></a>深克隆</h1><p>被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。</p>\n<p>深克隆可以使用序列化的方法。</p>\n<p>精髓主要是将对象写入流中，然后在从流中都取出来。这样就实现了一个对象的深克隆。</p>\n<p>前提是对象都是序列化的，不论成员还是引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Object deepClone() throws IOException,OptionalDataException,ClassNotFoundException&#123;//将对象写到流里</span><br><span class=\"line\">ByteArrayOutoutStream bo=new ByteArrayOutputStream();</span><br><span class=\"line\">ObjectOutputStream oo=new ObjectOutputStream(bo);</span><br><span class=\"line\">oo.writeObject(this);//从流里读出来</span><br><span class=\"line\">ByteArrayInputStream bi=new ByteArrayInputStream(bo.toByteArray());</span><br><span class=\"line\">ObjectInputStream oi=new ObjectInputStream(bi);</span><br><span class=\"line\">return(oi.readObject());</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"克隆\"><a href=\"#克隆\" class=\"headerlink\" title=\"克隆\"></a>克隆</h1><p>当我们需要有一个当前对象的克隆体，和当前对象完全相同的属性、功能，但又不想去仅仅创建一个对象的引用时，我们就需要对对象进行克隆。</p>\n<p>克隆clone，是创建了一个一摸一样的对象。该方法是object的方法，平时用不到是因为这个方法是protect属性的。</p>\n<p>需要用到clone方法的时候，直接覆盖父类的方法，定义成public，然后写super.clone()。或者直接自己写一个clone方法也可以。同时不要忘了记成clonable接口。</p>\n<h1 id=\"浅克隆\"><a href=\"#浅克隆\" class=\"headerlink\" title=\"浅克隆\"></a>浅克隆</h1><p>被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。</p>\n<p>继承自object的clone方法，就是浅克隆，除非对引用也使用clone的方法。</p>\n<p>没啥大用。</p>\n<h1 id=\"深克隆\"><a href=\"#深克隆\" class=\"headerlink\" title=\"深克隆\"></a>深克隆</h1><p>被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。</p>\n<p>深克隆可以使用序列化的方法。</p>\n<p>精髓主要是将对象写入流中，然后在从流中都取出来。这样就实现了一个对象的深克隆。</p>\n<p>前提是对象都是序列化的，不论成员还是引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Object deepClone() throws IOException,OptionalDataException,ClassNotFoundException&#123;//将对象写到流里</span><br><span class=\"line\">ByteArrayOutoutStream bo=new ByteArrayOutputStream();</span><br><span class=\"line\">ObjectOutputStream oo=new ObjectOutputStream(bo);</span><br><span class=\"line\">oo.writeObject(this);//从流里读出来</span><br><span class=\"line\">ByteArrayInputStream bi=new ByteArrayInputStream(bo.toByteArray());</span><br><span class=\"line\">ObjectInputStream oi=new ObjectInputStream(bi);</span><br><span class=\"line\">return(oi.readObject());</span><br></pre></td></tr></table></figure>\n"},{"title":"java动态编程","date":"2018-01-29T14:21:09.000Z","_content":"\n动态编程，常用到的是反射，但是反射开销性能大，上线的项目上面用反射不好。有另一种和反射功能相当的，但是比反射开销低的，就是javaassit\n\n# 什么是javaassit\n\njavaassit就是一个二方包，提供了运行时操作java字节码的方法。\n\n# 使用javaassit\n\n+ 更改某个类的父类\n\n```\n\tClassPool pool = ClassPool.getDefault();\n\tCtClass cc = pool.get(\"test.Rectangle\");\n\tcc.setSuperclass(pool.get(\"test.Point\"));\n\tcc.writeFile();\n```\n\n+ 获取字节码和加载字节码\n\n```\n\tbyte[] b = cc.toBytecode();\n\tClass clazz = cc.toClass();\n```\n\n+ 定义一个新类\n\n```\n\tClassPool pool = ClassPool.getDefault();\n\tCtClass cc = pool.makeClass(\"Point\");\n```\n\n+ 通过CtMethod和CtField构造方法和成员甚至Annotation。\n\n```\n\tClassPool pool = ClassPool.getDefault();\n\tCtClass cc = pool.makeClass(\"foo\");\n\tCtMethod mthd = CtNewMethod.make(\"public Integer getInteger() { return null; }\", cc);\n\tcc.addMethod(mthd);\n\tCtField f = new CtField(CtClass.intType, \"i\", cc);\n\tpoint.addField(f);\n\tclazz = cc.toClass(); Object instance = class.newInstance();\n```\n\n+ Javassist不仅可以生成类、变量和方法，还可以操作现有的方法，这在AOP上非常有用，比如做方法调用的埋点\n\n```\n\t// Point.java\n\tclass Point {\n    \tint x, y;\n    \tvoid move(int dx, int dy) { x += dx; y += dy; }\n\t}\n\n\t// 对已有代码每次move执行时做埋点\n\tClassPool pool = ClassPool.getDefault();\n\tCtClass cc = pool.get(\"Point\");\n\tCtMethod m = cc.getDeclaredMethod(\"move\");\n\tm.insertBefore(\"{ System.out.println($1); System.out.println($2); }\");\n\tcc.writeFile();\n```\n\n其中$1和$2表示调用栈中的第一和第二个参数，写到磁盘后的class定义类似：\n\n```\n\tclass Point {\n    \tint x, y;\n    \tvoid move(int dx, int dy) {\n        \t{ System.out.println(dx); System.out.println(dy); }\n        \tx += dx; y += dy;\n    \t}\n\t}\n```","source":"_posts/java动态编程.md","raw":"---\ntitle: java动态编程\ndate: 2018-01-29 22:21:09\ntags: java\n---\n\n动态编程，常用到的是反射，但是反射开销性能大，上线的项目上面用反射不好。有另一种和反射功能相当的，但是比反射开销低的，就是javaassit\n\n# 什么是javaassit\n\njavaassit就是一个二方包，提供了运行时操作java字节码的方法。\n\n# 使用javaassit\n\n+ 更改某个类的父类\n\n```\n\tClassPool pool = ClassPool.getDefault();\n\tCtClass cc = pool.get(\"test.Rectangle\");\n\tcc.setSuperclass(pool.get(\"test.Point\"));\n\tcc.writeFile();\n```\n\n+ 获取字节码和加载字节码\n\n```\n\tbyte[] b = cc.toBytecode();\n\tClass clazz = cc.toClass();\n```\n\n+ 定义一个新类\n\n```\n\tClassPool pool = ClassPool.getDefault();\n\tCtClass cc = pool.makeClass(\"Point\");\n```\n\n+ 通过CtMethod和CtField构造方法和成员甚至Annotation。\n\n```\n\tClassPool pool = ClassPool.getDefault();\n\tCtClass cc = pool.makeClass(\"foo\");\n\tCtMethod mthd = CtNewMethod.make(\"public Integer getInteger() { return null; }\", cc);\n\tcc.addMethod(mthd);\n\tCtField f = new CtField(CtClass.intType, \"i\", cc);\n\tpoint.addField(f);\n\tclazz = cc.toClass(); Object instance = class.newInstance();\n```\n\n+ Javassist不仅可以生成类、变量和方法，还可以操作现有的方法，这在AOP上非常有用，比如做方法调用的埋点\n\n```\n\t// Point.java\n\tclass Point {\n    \tint x, y;\n    \tvoid move(int dx, int dy) { x += dx; y += dy; }\n\t}\n\n\t// 对已有代码每次move执行时做埋点\n\tClassPool pool = ClassPool.getDefault();\n\tCtClass cc = pool.get(\"Point\");\n\tCtMethod m = cc.getDeclaredMethod(\"move\");\n\tm.insertBefore(\"{ System.out.println($1); System.out.println($2); }\");\n\tcc.writeFile();\n```\n\n其中$1和$2表示调用栈中的第一和第二个参数，写到磁盘后的class定义类似：\n\n```\n\tclass Point {\n    \tint x, y;\n    \tvoid move(int dx, int dy) {\n        \t{ System.out.println(dx); System.out.println(dy); }\n        \tx += dx; y += dy;\n    \t}\n\t}\n```","slug":"java动态编程","published":1,"updated":"2019-03-12T09:26:33.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltty200353a8kh94x118m","content":"<p>动态编程，常用到的是反射，但是反射开销性能大，上线的项目上面用反射不好。有另一种和反射功能相当的，但是比反射开销低的，就是javaassit</p>\n<h1 id=\"什么是javaassit\"><a href=\"#什么是javaassit\" class=\"headerlink\" title=\"什么是javaassit\"></a>什么是javaassit</h1><p>javaassit就是一个二方包，提供了运行时操作java字节码的方法。</p>\n<h1 id=\"使用javaassit\"><a href=\"#使用javaassit\" class=\"headerlink\" title=\"使用javaassit\"></a>使用javaassit</h1><ul>\n<li>更改某个类的父类</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.get(&quot;test.Rectangle&quot;);</span><br><span class=\"line\">cc.setSuperclass(pool.get(&quot;test.Point&quot;));</span><br><span class=\"line\">cc.writeFile();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取字节码和加载字节码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] b = cc.toBytecode();</span><br><span class=\"line\">Class clazz = cc.toClass();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>定义一个新类</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.makeClass(&quot;Point&quot;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过CtMethod和CtField构造方法和成员甚至Annotation。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.makeClass(&quot;foo&quot;);</span><br><span class=\"line\">CtMethod mthd = CtNewMethod.make(&quot;public Integer getInteger() &#123; return null; &#125;&quot;, cc);</span><br><span class=\"line\">cc.addMethod(mthd);</span><br><span class=\"line\">CtField f = new CtField(CtClass.intType, &quot;i&quot;, cc);</span><br><span class=\"line\">point.addField(f);</span><br><span class=\"line\">clazz = cc.toClass(); Object instance = class.newInstance();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Javassist不仅可以生成类、变量和方法，还可以操作现有的方法，这在AOP上非常有用，比如做方法调用的埋点</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Point.java</span><br><span class=\"line\">class Point &#123;</span><br><span class=\"line\">   \tint x, y;</span><br><span class=\"line\">   \tvoid move(int dx, int dy) &#123; x += dx; y += dy; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 对已有代码每次move执行时做埋点</span><br><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.get(&quot;Point&quot;);</span><br><span class=\"line\">CtMethod m = cc.getDeclaredMethod(&quot;move&quot;);</span><br><span class=\"line\">m.insertBefore(&quot;&#123; System.out.println($1); System.out.println($2); &#125;&quot;);</span><br><span class=\"line\">cc.writeFile();</span><br></pre></td></tr></table></figure>\n<p>其中$1和$2表示调用栈中的第一和第二个参数，写到磁盘后的class定义类似：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">   \tint x, y;</span><br><span class=\"line\">   \tvoid move(int dx, int dy) &#123;</span><br><span class=\"line\">       \t&#123; System.out.println(dx); System.out.println(dy); &#125;</span><br><span class=\"line\">       \tx += dx; y += dy;</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>动态编程，常用到的是反射，但是反射开销性能大，上线的项目上面用反射不好。有另一种和反射功能相当的，但是比反射开销低的，就是javaassit</p>\n<h1 id=\"什么是javaassit\"><a href=\"#什么是javaassit\" class=\"headerlink\" title=\"什么是javaassit\"></a>什么是javaassit</h1><p>javaassit就是一个二方包，提供了运行时操作java字节码的方法。</p>\n<h1 id=\"使用javaassit\"><a href=\"#使用javaassit\" class=\"headerlink\" title=\"使用javaassit\"></a>使用javaassit</h1><ul>\n<li>更改某个类的父类</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.get(&quot;test.Rectangle&quot;);</span><br><span class=\"line\">cc.setSuperclass(pool.get(&quot;test.Point&quot;));</span><br><span class=\"line\">cc.writeFile();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取字节码和加载字节码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] b = cc.toBytecode();</span><br><span class=\"line\">Class clazz = cc.toClass();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>定义一个新类</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.makeClass(&quot;Point&quot;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过CtMethod和CtField构造方法和成员甚至Annotation。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.makeClass(&quot;foo&quot;);</span><br><span class=\"line\">CtMethod mthd = CtNewMethod.make(&quot;public Integer getInteger() &#123; return null; &#125;&quot;, cc);</span><br><span class=\"line\">cc.addMethod(mthd);</span><br><span class=\"line\">CtField f = new CtField(CtClass.intType, &quot;i&quot;, cc);</span><br><span class=\"line\">point.addField(f);</span><br><span class=\"line\">clazz = cc.toClass(); Object instance = class.newInstance();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Javassist不仅可以生成类、变量和方法，还可以操作现有的方法，这在AOP上非常有用，比如做方法调用的埋点</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Point.java</span><br><span class=\"line\">class Point &#123;</span><br><span class=\"line\">   \tint x, y;</span><br><span class=\"line\">   \tvoid move(int dx, int dy) &#123; x += dx; y += dy; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 对已有代码每次move执行时做埋点</span><br><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.get(&quot;Point&quot;);</span><br><span class=\"line\">CtMethod m = cc.getDeclaredMethod(&quot;move&quot;);</span><br><span class=\"line\">m.insertBefore(&quot;&#123; System.out.println($1); System.out.println($2); &#125;&quot;);</span><br><span class=\"line\">cc.writeFile();</span><br></pre></td></tr></table></figure>\n<p>其中$1和$2表示调用栈中的第一和第二个参数，写到磁盘后的class定义类似：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">   \tint x, y;</span><br><span class=\"line\">   \tvoid move(int dx, int dy) &#123;</span><br><span class=\"line\">       \t&#123; System.out.println(dx); System.out.println(dy); &#125;</span><br><span class=\"line\">       \tx += dx; y += dy;</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"java反射","date":"2018-01-28T11:44:53.000Z","_content":"\n# 什么是反射\n\n反射是一种在程序运行时动态访问，修改某个类中任意属性(状态)和方法(行为)的机制\n\n+ 在运行时判断任意一个对象所属的类\n\n+ 在运行时构造任意一个类的对象\n\n+ 在运行时判断任意一个类所具有的成员变量和方法\n\n+ 在运行时调用任意一个对象的方法\n\n设计到的四个核心类\n\n+ java.lang.Class.java:类对象\n\n+ java.lang.reflect.Constructor.java:类的构造器对象\n\n+ java.lang.reflect.Method.java:类的方法对象\n\n+ java.lang.reflect.Field.java:类的属性对象\n\n# 反射有什么用？\n\n+ 操作因访问权限限制的属性和方法\n\n+ 实现自定义注解\n\n+ 动态加载第三方jar包，解决android中方法数不能超过65536个的问题\n\n+ 按需加载类，节省编译和初始化apk的时间\n\n# 反射工作原理\n\n当编完一个java项目之后，每个java文件都会被编译成一个.class文件，这些class对象继承了这个类的所有信息，包括父类、接口、构造函数、方法、属性等，这些class文件在程序运行时会被classloader加载到虚拟机中。当一类被加载以后，java虚拟机就会在内存中自动产生一个class对象。\n\n反射的原理就是借助class.java， constructor.java, method.java, field.java四个类在程序运行时动态访问和修改任何类的行为和状态。\n\n# 实例\n\n+ 获取父类\n\n```\n\tprivate void getSuperClass(){\n        ProgramMonkey programMonkey = new ProgramMonkey(\"小明\", \"男\", 12);\n        Class<?> superClass = programMonkey.getClass().getSuperclass();\n        while (superClass != null) {\n            LogE(\"programMonkey's super class is : \" + superClass.getName());\n            // 再获取父类的上一层父类，直到最后的 Object 类，Object 的父类为 null\n            superClass = superClass.getSuperclass();\n        }\n    }\n```\n\n+ 获取接口\n\n```\n\tprivate void getInterfaces() {\n        ProgramMonkey programMonkey = new ProgramMonkey(\"小明\", \"男\", 12);\n        Class<?>[] interfaceses = programMonkey.getClass().getInterfaces();\n        for (Class<?> class1 : interfaceses) {\n            LogE(\"programMonkey's interface is : \" + class1.getName());\n        }\n    }\n```\n\n+ 获取当前类的所有的方法\n\n```\n\tprivate void getCurrentClassMethods() {\n        ProgramMonkey programMonkey = new ProgramMonkey(\"小明\", \"男\", 12);\n        Method[] methods = programMonkey.getClass().getDeclaredMethods();\n        for (Method method : methods) {\n            LogE(\"declared method name : \" + method.getName());\n        }\n\n        try {\n            Method getSalaryPerMonthMethod = programMonkey.getClass().getDeclaredMethod(\"getSalaryPerMonth\");\n            getSalaryPerMonthMethod.setAccessible(true);\n            // 获取返回类型\n            Class<?> returnType = getSalaryPerMonthMethod.getReturnType();\n            LogE(\"getSalaryPerMonth 方法的返回类型 : \" + returnType.getName());\n\n            // 获取方法的参数类型列表\n            Class<?>[] paramClasses = getSalaryPerMonthMethod.getParameterTypes() ;\n            for (Class<?> class1 : paramClasses) {\n                LogE(\"getSalaryPerMonth 方法的参数类型 : \" + class1.getName());\n            }\n\n            // 是否是 private 函数，属性是否是 private 也可以使用这种方式判断\n            LogE(getSalaryPerMonthMethod.getName() + \" is private \" + Modifier.isPrivate(getSalaryPerMonthMethod.getModifiers()));\n\n            // 执行方法\n            Object result = getSalaryPerMonthMethod.invoke(programMonkey);\n            LogE(\"getSalaryPerMonth 方法的返回结果: \" + result);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n+ 获取当前类和父类的所有公有方法\n\n```\n\tprivate void getAllMethods() {\n        ProgramMonkey programMonkey = new ProgramMonkey(\"小明\", \"男\", 12);\n        // 获取当前类和父类的所有公有方法\n        Method[] methods = programMonkey.getClass().getMethods();\n        for (Method method : methods) {\n            LogE(\"method name : \" + method.getName());\n        }\n\n        try {\n            Method setmLanguageMethod = programMonkey.getClass().getMethod(\"setmLanguage\", String.class);\n            setmLanguageMethod.setAccessible(true);\n\n            // 获取返回类型\n            Class<?> returnType = setmLanguageMethod.getReturnType();\n            LogE(\"setmLanguage 方法的返回类型 : \" + returnType.getName());\n\n            // 获取方法的参数类型列表\n                        Class<?>[] paramClasses = setmLanguageMethod.getParameterTypes() ;\n            for (Class<?> class1 : paramClasses) {\n                LogE(\"setmLanguage 方法的参数类型 : \" + class1.getName());\n            }\n\n            // 是否是 private 函数，属性是否是 private 也可以使用这种方式判断\n            LogE(setmLanguageMethod.getName() + \" is private \" + Modifier.isPrivate(setmLanguageMethod.getModifiers()));\n\n            // 执行方法\n            Object result = setmLanguageMethod.invoke(programMonkey, \"Java\");\n            LogE(\"setmLanguage 方法的返回结果: \" + result);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n+ 获取当前类的所有实例\n\n```\n\tprivate void getCurrentClassFields() {\n        ProgramMonkey programMonkey = new ProgramMonkey(\"小明\", \"男\", 12);\n        // 获取当前类的所有属性\n        Field[] publicFields = programMonkey.getClass().getDeclaredFields();\n        for (Field field : publicFields) {\n            LogE(\"declared field name : \" + field.getName());\n        }\n\n        try {\n            // 获取当前类的某个属性\n            Field ageField = programMonkey.getClass().getDeclaredField(\"mAge\");\n            // 获取属性值\n            LogE(\" my age is : \" + ageField.getInt(programMonkey));\n            // 设置属性值\n            ageField.set(programMonkey, 10);\n            LogE(\" my age is : \" + ageField.getInt(programMonkey));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n+ 获取当前类和父类的所有公有属性\n\n```\n\tprivate void getAllFields() {\n        ProgramMonkey programMonkey = new ProgramMonkey(\"小明\", \"男\", 12);\n        // 得到当前类和父类的所有公有属性\n        Field[] publicFields = programMonkey.getClass().getFields();\n        for (Field field : publicFields) {\n            LogE(\"field name : \" + field.getName());\n        }\n\n        try {\n            // 获取当前类和父类的某个公有属性\n            Field ageField = programMonkey.getClass().getField(\"mAge\");\n            LogE(\" age is : \" + ageField.getInt(programMonkey));\n            ageField.set(programMonkey, 8);\n            LogE(\" my age is : \" + ageField.getInt(programMonkey));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```","source":"_posts/java反射.md","raw":"---\ntitle: java反射\ndate: 2018-01-28 19:44:53\ntags: java\n---\n\n# 什么是反射\n\n反射是一种在程序运行时动态访问，修改某个类中任意属性(状态)和方法(行为)的机制\n\n+ 在运行时判断任意一个对象所属的类\n\n+ 在运行时构造任意一个类的对象\n\n+ 在运行时判断任意一个类所具有的成员变量和方法\n\n+ 在运行时调用任意一个对象的方法\n\n设计到的四个核心类\n\n+ java.lang.Class.java:类对象\n\n+ java.lang.reflect.Constructor.java:类的构造器对象\n\n+ java.lang.reflect.Method.java:类的方法对象\n\n+ java.lang.reflect.Field.java:类的属性对象\n\n# 反射有什么用？\n\n+ 操作因访问权限限制的属性和方法\n\n+ 实现自定义注解\n\n+ 动态加载第三方jar包，解决android中方法数不能超过65536个的问题\n\n+ 按需加载类，节省编译和初始化apk的时间\n\n# 反射工作原理\n\n当编完一个java项目之后，每个java文件都会被编译成一个.class文件，这些class对象继承了这个类的所有信息，包括父类、接口、构造函数、方法、属性等，这些class文件在程序运行时会被classloader加载到虚拟机中。当一类被加载以后，java虚拟机就会在内存中自动产生一个class对象。\n\n反射的原理就是借助class.java， constructor.java, method.java, field.java四个类在程序运行时动态访问和修改任何类的行为和状态。\n\n# 实例\n\n+ 获取父类\n\n```\n\tprivate void getSuperClass(){\n        ProgramMonkey programMonkey = new ProgramMonkey(\"小明\", \"男\", 12);\n        Class<?> superClass = programMonkey.getClass().getSuperclass();\n        while (superClass != null) {\n            LogE(\"programMonkey's super class is : \" + superClass.getName());\n            // 再获取父类的上一层父类，直到最后的 Object 类，Object 的父类为 null\n            superClass = superClass.getSuperclass();\n        }\n    }\n```\n\n+ 获取接口\n\n```\n\tprivate void getInterfaces() {\n        ProgramMonkey programMonkey = new ProgramMonkey(\"小明\", \"男\", 12);\n        Class<?>[] interfaceses = programMonkey.getClass().getInterfaces();\n        for (Class<?> class1 : interfaceses) {\n            LogE(\"programMonkey's interface is : \" + class1.getName());\n        }\n    }\n```\n\n+ 获取当前类的所有的方法\n\n```\n\tprivate void getCurrentClassMethods() {\n        ProgramMonkey programMonkey = new ProgramMonkey(\"小明\", \"男\", 12);\n        Method[] methods = programMonkey.getClass().getDeclaredMethods();\n        for (Method method : methods) {\n            LogE(\"declared method name : \" + method.getName());\n        }\n\n        try {\n            Method getSalaryPerMonthMethod = programMonkey.getClass().getDeclaredMethod(\"getSalaryPerMonth\");\n            getSalaryPerMonthMethod.setAccessible(true);\n            // 获取返回类型\n            Class<?> returnType = getSalaryPerMonthMethod.getReturnType();\n            LogE(\"getSalaryPerMonth 方法的返回类型 : \" + returnType.getName());\n\n            // 获取方法的参数类型列表\n            Class<?>[] paramClasses = getSalaryPerMonthMethod.getParameterTypes() ;\n            for (Class<?> class1 : paramClasses) {\n                LogE(\"getSalaryPerMonth 方法的参数类型 : \" + class1.getName());\n            }\n\n            // 是否是 private 函数，属性是否是 private 也可以使用这种方式判断\n            LogE(getSalaryPerMonthMethod.getName() + \" is private \" + Modifier.isPrivate(getSalaryPerMonthMethod.getModifiers()));\n\n            // 执行方法\n            Object result = getSalaryPerMonthMethod.invoke(programMonkey);\n            LogE(\"getSalaryPerMonth 方法的返回结果: \" + result);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n+ 获取当前类和父类的所有公有方法\n\n```\n\tprivate void getAllMethods() {\n        ProgramMonkey programMonkey = new ProgramMonkey(\"小明\", \"男\", 12);\n        // 获取当前类和父类的所有公有方法\n        Method[] methods = programMonkey.getClass().getMethods();\n        for (Method method : methods) {\n            LogE(\"method name : \" + method.getName());\n        }\n\n        try {\n            Method setmLanguageMethod = programMonkey.getClass().getMethod(\"setmLanguage\", String.class);\n            setmLanguageMethod.setAccessible(true);\n\n            // 获取返回类型\n            Class<?> returnType = setmLanguageMethod.getReturnType();\n            LogE(\"setmLanguage 方法的返回类型 : \" + returnType.getName());\n\n            // 获取方法的参数类型列表\n                        Class<?>[] paramClasses = setmLanguageMethod.getParameterTypes() ;\n            for (Class<?> class1 : paramClasses) {\n                LogE(\"setmLanguage 方法的参数类型 : \" + class1.getName());\n            }\n\n            // 是否是 private 函数，属性是否是 private 也可以使用这种方式判断\n            LogE(setmLanguageMethod.getName() + \" is private \" + Modifier.isPrivate(setmLanguageMethod.getModifiers()));\n\n            // 执行方法\n            Object result = setmLanguageMethod.invoke(programMonkey, \"Java\");\n            LogE(\"setmLanguage 方法的返回结果: \" + result);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n+ 获取当前类的所有实例\n\n```\n\tprivate void getCurrentClassFields() {\n        ProgramMonkey programMonkey = new ProgramMonkey(\"小明\", \"男\", 12);\n        // 获取当前类的所有属性\n        Field[] publicFields = programMonkey.getClass().getDeclaredFields();\n        for (Field field : publicFields) {\n            LogE(\"declared field name : \" + field.getName());\n        }\n\n        try {\n            // 获取当前类的某个属性\n            Field ageField = programMonkey.getClass().getDeclaredField(\"mAge\");\n            // 获取属性值\n            LogE(\" my age is : \" + ageField.getInt(programMonkey));\n            // 设置属性值\n            ageField.set(programMonkey, 10);\n            LogE(\" my age is : \" + ageField.getInt(programMonkey));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n+ 获取当前类和父类的所有公有属性\n\n```\n\tprivate void getAllFields() {\n        ProgramMonkey programMonkey = new ProgramMonkey(\"小明\", \"男\", 12);\n        // 得到当前类和父类的所有公有属性\n        Field[] publicFields = programMonkey.getClass().getFields();\n        for (Field field : publicFields) {\n            LogE(\"field name : \" + field.getName());\n        }\n\n        try {\n            // 获取当前类和父类的某个公有属性\n            Field ageField = programMonkey.getClass().getField(\"mAge\");\n            LogE(\" age is : \" + ageField.getInt(programMonkey));\n            ageField.set(programMonkey, 8);\n            LogE(\" my age is : \" + ageField.getInt(programMonkey));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```","slug":"java反射","published":1,"updated":"2019-03-12T09:26:33.157Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltty300373a8kcbpeqr8f","content":"<h1 id=\"什么是反射\"><a href=\"#什么是反射\" class=\"headerlink\" title=\"什么是反射\"></a>什么是反射</h1><p>反射是一种在程序运行时动态访问，修改某个类中任意属性(状态)和方法(行为)的机制</p>\n<ul>\n<li><p>在运行时判断任意一个对象所属的类</p>\n</li>\n<li><p>在运行时构造任意一个类的对象</p>\n</li>\n<li><p>在运行时判断任意一个类所具有的成员变量和方法</p>\n</li>\n<li><p>在运行时调用任意一个对象的方法</p>\n</li>\n</ul>\n<p>设计到的四个核心类</p>\n<ul>\n<li><p>java.lang.Class.java:类对象</p>\n</li>\n<li><p>java.lang.reflect.Constructor.java:类的构造器对象</p>\n</li>\n<li><p>java.lang.reflect.Method.java:类的方法对象</p>\n</li>\n<li><p>java.lang.reflect.Field.java:类的属性对象</p>\n</li>\n</ul>\n<h1 id=\"反射有什么用？\"><a href=\"#反射有什么用？\" class=\"headerlink\" title=\"反射有什么用？\"></a>反射有什么用？</h1><ul>\n<li><p>操作因访问权限限制的属性和方法</p>\n</li>\n<li><p>实现自定义注解</p>\n</li>\n<li><p>动态加载第三方jar包，解决android中方法数不能超过65536个的问题</p>\n</li>\n<li><p>按需加载类，节省编译和初始化apk的时间</p>\n</li>\n</ul>\n<h1 id=\"反射工作原理\"><a href=\"#反射工作原理\" class=\"headerlink\" title=\"反射工作原理\"></a>反射工作原理</h1><p>当编完一个java项目之后，每个java文件都会被编译成一个.class文件，这些class对象继承了这个类的所有信息，包括父类、接口、构造函数、方法、属性等，这些class文件在程序运行时会被classloader加载到虚拟机中。当一类被加载以后，java虚拟机就会在内存中自动产生一个class对象。</p>\n<p>反射的原理就是借助class.java， constructor.java, method.java, field.java四个类在程序运行时动态访问和修改任何类的行为和状态。</p>\n<h1 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h1><ul>\n<li>获取父类</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void getSuperClass()&#123;</span><br><span class=\"line\">       ProgramMonkey programMonkey = new ProgramMonkey(&quot;小明&quot;, &quot;男&quot;, 12);</span><br><span class=\"line\">       Class&lt;?&gt; superClass = programMonkey.getClass().getSuperclass();</span><br><span class=\"line\">       while (superClass != null) &#123;</span><br><span class=\"line\">           LogE(&quot;programMonkey&apos;s super class is : &quot; + superClass.getName());</span><br><span class=\"line\">           // 再获取父类的上一层父类，直到最后的 Object 类，Object 的父类为 null</span><br><span class=\"line\">           superClass = superClass.getSuperclass();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取接口</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void getInterfaces() &#123;</span><br><span class=\"line\">       ProgramMonkey programMonkey = new ProgramMonkey(&quot;小明&quot;, &quot;男&quot;, 12);</span><br><span class=\"line\">       Class&lt;?&gt;[] interfaceses = programMonkey.getClass().getInterfaces();</span><br><span class=\"line\">       for (Class&lt;?&gt; class1 : interfaceses) &#123;</span><br><span class=\"line\">           LogE(&quot;programMonkey&apos;s interface is : &quot; + class1.getName());</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取当前类的所有的方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void getCurrentClassMethods() &#123;</span><br><span class=\"line\">       ProgramMonkey programMonkey = new ProgramMonkey(&quot;小明&quot;, &quot;男&quot;, 12);</span><br><span class=\"line\">       Method[] methods = programMonkey.getClass().getDeclaredMethods();</span><br><span class=\"line\">       for (Method method : methods) &#123;</span><br><span class=\"line\">           LogE(&quot;declared method name : &quot; + method.getName());</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">           Method getSalaryPerMonthMethod = programMonkey.getClass().getDeclaredMethod(&quot;getSalaryPerMonth&quot;);</span><br><span class=\"line\">           getSalaryPerMonthMethod.setAccessible(true);</span><br><span class=\"line\">           // 获取返回类型</span><br><span class=\"line\">           Class&lt;?&gt; returnType = getSalaryPerMonthMethod.getReturnType();</span><br><span class=\"line\">           LogE(&quot;getSalaryPerMonth 方法的返回类型 : &quot; + returnType.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">           // 获取方法的参数类型列表</span><br><span class=\"line\">           Class&lt;?&gt;[] paramClasses = getSalaryPerMonthMethod.getParameterTypes() ;</span><br><span class=\"line\">           for (Class&lt;?&gt; class1 : paramClasses) &#123;</span><br><span class=\"line\">               LogE(&quot;getSalaryPerMonth 方法的参数类型 : &quot; + class1.getName());</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           // 是否是 private 函数，属性是否是 private 也可以使用这种方式判断</span><br><span class=\"line\">           LogE(getSalaryPerMonthMethod.getName() + &quot; is private &quot; + Modifier.isPrivate(getSalaryPerMonthMethod.getModifiers()));</span><br><span class=\"line\"></span><br><span class=\"line\">           // 执行方法</span><br><span class=\"line\">           Object result = getSalaryPerMonthMethod.invoke(programMonkey);</span><br><span class=\"line\">           LogE(&quot;getSalaryPerMonth 方法的返回结果: &quot; + result);</span><br><span class=\"line\">       &#125; catch (Exception e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取当前类和父类的所有公有方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void getAllMethods() &#123;</span><br><span class=\"line\">       ProgramMonkey programMonkey = new ProgramMonkey(&quot;小明&quot;, &quot;男&quot;, 12);</span><br><span class=\"line\">       // 获取当前类和父类的所有公有方法</span><br><span class=\"line\">       Method[] methods = programMonkey.getClass().getMethods();</span><br><span class=\"line\">       for (Method method : methods) &#123;</span><br><span class=\"line\">           LogE(&quot;method name : &quot; + method.getName());</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">           Method setmLanguageMethod = programMonkey.getClass().getMethod(&quot;setmLanguage&quot;, String.class);</span><br><span class=\"line\">           setmLanguageMethod.setAccessible(true);</span><br><span class=\"line\"></span><br><span class=\"line\">           // 获取返回类型</span><br><span class=\"line\">           Class&lt;?&gt; returnType = setmLanguageMethod.getReturnType();</span><br><span class=\"line\">           LogE(&quot;setmLanguage 方法的返回类型 : &quot; + returnType.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">           // 获取方法的参数类型列表</span><br><span class=\"line\">                       Class&lt;?&gt;[] paramClasses = setmLanguageMethod.getParameterTypes() ;</span><br><span class=\"line\">           for (Class&lt;?&gt; class1 : paramClasses) &#123;</span><br><span class=\"line\">               LogE(&quot;setmLanguage 方法的参数类型 : &quot; + class1.getName());</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           // 是否是 private 函数，属性是否是 private 也可以使用这种方式判断</span><br><span class=\"line\">           LogE(setmLanguageMethod.getName() + &quot; is private &quot; + Modifier.isPrivate(setmLanguageMethod.getModifiers()));</span><br><span class=\"line\"></span><br><span class=\"line\">           // 执行方法</span><br><span class=\"line\">           Object result = setmLanguageMethod.invoke(programMonkey, &quot;Java&quot;);</span><br><span class=\"line\">           LogE(&quot;setmLanguage 方法的返回结果: &quot; + result);</span><br><span class=\"line\">       &#125; catch (Exception e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取当前类的所有实例</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void getCurrentClassFields() &#123;</span><br><span class=\"line\">       ProgramMonkey programMonkey = new ProgramMonkey(&quot;小明&quot;, &quot;男&quot;, 12);</span><br><span class=\"line\">       // 获取当前类的所有属性</span><br><span class=\"line\">       Field[] publicFields = programMonkey.getClass().getDeclaredFields();</span><br><span class=\"line\">       for (Field field : publicFields) &#123;</span><br><span class=\"line\">           LogE(&quot;declared field name : &quot; + field.getName());</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">           // 获取当前类的某个属性</span><br><span class=\"line\">           Field ageField = programMonkey.getClass().getDeclaredField(&quot;mAge&quot;);</span><br><span class=\"line\">           // 获取属性值</span><br><span class=\"line\">           LogE(&quot; my age is : &quot; + ageField.getInt(programMonkey));</span><br><span class=\"line\">           // 设置属性值</span><br><span class=\"line\">           ageField.set(programMonkey, 10);</span><br><span class=\"line\">           LogE(&quot; my age is : &quot; + ageField.getInt(programMonkey));</span><br><span class=\"line\">       &#125; catch (Exception e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取当前类和父类的所有公有属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void getAllFields() &#123;</span><br><span class=\"line\">       ProgramMonkey programMonkey = new ProgramMonkey(&quot;小明&quot;, &quot;男&quot;, 12);</span><br><span class=\"line\">       // 得到当前类和父类的所有公有属性</span><br><span class=\"line\">       Field[] publicFields = programMonkey.getClass().getFields();</span><br><span class=\"line\">       for (Field field : publicFields) &#123;</span><br><span class=\"line\">           LogE(&quot;field name : &quot; + field.getName());</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">           // 获取当前类和父类的某个公有属性</span><br><span class=\"line\">           Field ageField = programMonkey.getClass().getField(&quot;mAge&quot;);</span><br><span class=\"line\">           LogE(&quot; age is : &quot; + ageField.getInt(programMonkey));</span><br><span class=\"line\">           ageField.set(programMonkey, 8);</span><br><span class=\"line\">           LogE(&quot; my age is : &quot; + ageField.getInt(programMonkey));</span><br><span class=\"line\">       &#125; catch (Exception e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是反射\"><a href=\"#什么是反射\" class=\"headerlink\" title=\"什么是反射\"></a>什么是反射</h1><p>反射是一种在程序运行时动态访问，修改某个类中任意属性(状态)和方法(行为)的机制</p>\n<ul>\n<li><p>在运行时判断任意一个对象所属的类</p>\n</li>\n<li><p>在运行时构造任意一个类的对象</p>\n</li>\n<li><p>在运行时判断任意一个类所具有的成员变量和方法</p>\n</li>\n<li><p>在运行时调用任意一个对象的方法</p>\n</li>\n</ul>\n<p>设计到的四个核心类</p>\n<ul>\n<li><p>java.lang.Class.java:类对象</p>\n</li>\n<li><p>java.lang.reflect.Constructor.java:类的构造器对象</p>\n</li>\n<li><p>java.lang.reflect.Method.java:类的方法对象</p>\n</li>\n<li><p>java.lang.reflect.Field.java:类的属性对象</p>\n</li>\n</ul>\n<h1 id=\"反射有什么用？\"><a href=\"#反射有什么用？\" class=\"headerlink\" title=\"反射有什么用？\"></a>反射有什么用？</h1><ul>\n<li><p>操作因访问权限限制的属性和方法</p>\n</li>\n<li><p>实现自定义注解</p>\n</li>\n<li><p>动态加载第三方jar包，解决android中方法数不能超过65536个的问题</p>\n</li>\n<li><p>按需加载类，节省编译和初始化apk的时间</p>\n</li>\n</ul>\n<h1 id=\"反射工作原理\"><a href=\"#反射工作原理\" class=\"headerlink\" title=\"反射工作原理\"></a>反射工作原理</h1><p>当编完一个java项目之后，每个java文件都会被编译成一个.class文件，这些class对象继承了这个类的所有信息，包括父类、接口、构造函数、方法、属性等，这些class文件在程序运行时会被classloader加载到虚拟机中。当一类被加载以后，java虚拟机就会在内存中自动产生一个class对象。</p>\n<p>反射的原理就是借助class.java， constructor.java, method.java, field.java四个类在程序运行时动态访问和修改任何类的行为和状态。</p>\n<h1 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h1><ul>\n<li>获取父类</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void getSuperClass()&#123;</span><br><span class=\"line\">       ProgramMonkey programMonkey = new ProgramMonkey(&quot;小明&quot;, &quot;男&quot;, 12);</span><br><span class=\"line\">       Class&lt;?&gt; superClass = programMonkey.getClass().getSuperclass();</span><br><span class=\"line\">       while (superClass != null) &#123;</span><br><span class=\"line\">           LogE(&quot;programMonkey&apos;s super class is : &quot; + superClass.getName());</span><br><span class=\"line\">           // 再获取父类的上一层父类，直到最后的 Object 类，Object 的父类为 null</span><br><span class=\"line\">           superClass = superClass.getSuperclass();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取接口</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void getInterfaces() &#123;</span><br><span class=\"line\">       ProgramMonkey programMonkey = new ProgramMonkey(&quot;小明&quot;, &quot;男&quot;, 12);</span><br><span class=\"line\">       Class&lt;?&gt;[] interfaceses = programMonkey.getClass().getInterfaces();</span><br><span class=\"line\">       for (Class&lt;?&gt; class1 : interfaceses) &#123;</span><br><span class=\"line\">           LogE(&quot;programMonkey&apos;s interface is : &quot; + class1.getName());</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取当前类的所有的方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void getCurrentClassMethods() &#123;</span><br><span class=\"line\">       ProgramMonkey programMonkey = new ProgramMonkey(&quot;小明&quot;, &quot;男&quot;, 12);</span><br><span class=\"line\">       Method[] methods = programMonkey.getClass().getDeclaredMethods();</span><br><span class=\"line\">       for (Method method : methods) &#123;</span><br><span class=\"line\">           LogE(&quot;declared method name : &quot; + method.getName());</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">           Method getSalaryPerMonthMethod = programMonkey.getClass().getDeclaredMethod(&quot;getSalaryPerMonth&quot;);</span><br><span class=\"line\">           getSalaryPerMonthMethod.setAccessible(true);</span><br><span class=\"line\">           // 获取返回类型</span><br><span class=\"line\">           Class&lt;?&gt; returnType = getSalaryPerMonthMethod.getReturnType();</span><br><span class=\"line\">           LogE(&quot;getSalaryPerMonth 方法的返回类型 : &quot; + returnType.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">           // 获取方法的参数类型列表</span><br><span class=\"line\">           Class&lt;?&gt;[] paramClasses = getSalaryPerMonthMethod.getParameterTypes() ;</span><br><span class=\"line\">           for (Class&lt;?&gt; class1 : paramClasses) &#123;</span><br><span class=\"line\">               LogE(&quot;getSalaryPerMonth 方法的参数类型 : &quot; + class1.getName());</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           // 是否是 private 函数，属性是否是 private 也可以使用这种方式判断</span><br><span class=\"line\">           LogE(getSalaryPerMonthMethod.getName() + &quot; is private &quot; + Modifier.isPrivate(getSalaryPerMonthMethod.getModifiers()));</span><br><span class=\"line\"></span><br><span class=\"line\">           // 执行方法</span><br><span class=\"line\">           Object result = getSalaryPerMonthMethod.invoke(programMonkey);</span><br><span class=\"line\">           LogE(&quot;getSalaryPerMonth 方法的返回结果: &quot; + result);</span><br><span class=\"line\">       &#125; catch (Exception e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取当前类和父类的所有公有方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void getAllMethods() &#123;</span><br><span class=\"line\">       ProgramMonkey programMonkey = new ProgramMonkey(&quot;小明&quot;, &quot;男&quot;, 12);</span><br><span class=\"line\">       // 获取当前类和父类的所有公有方法</span><br><span class=\"line\">       Method[] methods = programMonkey.getClass().getMethods();</span><br><span class=\"line\">       for (Method method : methods) &#123;</span><br><span class=\"line\">           LogE(&quot;method name : &quot; + method.getName());</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">           Method setmLanguageMethod = programMonkey.getClass().getMethod(&quot;setmLanguage&quot;, String.class);</span><br><span class=\"line\">           setmLanguageMethod.setAccessible(true);</span><br><span class=\"line\"></span><br><span class=\"line\">           // 获取返回类型</span><br><span class=\"line\">           Class&lt;?&gt; returnType = setmLanguageMethod.getReturnType();</span><br><span class=\"line\">           LogE(&quot;setmLanguage 方法的返回类型 : &quot; + returnType.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">           // 获取方法的参数类型列表</span><br><span class=\"line\">                       Class&lt;?&gt;[] paramClasses = setmLanguageMethod.getParameterTypes() ;</span><br><span class=\"line\">           for (Class&lt;?&gt; class1 : paramClasses) &#123;</span><br><span class=\"line\">               LogE(&quot;setmLanguage 方法的参数类型 : &quot; + class1.getName());</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           // 是否是 private 函数，属性是否是 private 也可以使用这种方式判断</span><br><span class=\"line\">           LogE(setmLanguageMethod.getName() + &quot; is private &quot; + Modifier.isPrivate(setmLanguageMethod.getModifiers()));</span><br><span class=\"line\"></span><br><span class=\"line\">           // 执行方法</span><br><span class=\"line\">           Object result = setmLanguageMethod.invoke(programMonkey, &quot;Java&quot;);</span><br><span class=\"line\">           LogE(&quot;setmLanguage 方法的返回结果: &quot; + result);</span><br><span class=\"line\">       &#125; catch (Exception e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取当前类的所有实例</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void getCurrentClassFields() &#123;</span><br><span class=\"line\">       ProgramMonkey programMonkey = new ProgramMonkey(&quot;小明&quot;, &quot;男&quot;, 12);</span><br><span class=\"line\">       // 获取当前类的所有属性</span><br><span class=\"line\">       Field[] publicFields = programMonkey.getClass().getDeclaredFields();</span><br><span class=\"line\">       for (Field field : publicFields) &#123;</span><br><span class=\"line\">           LogE(&quot;declared field name : &quot; + field.getName());</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">           // 获取当前类的某个属性</span><br><span class=\"line\">           Field ageField = programMonkey.getClass().getDeclaredField(&quot;mAge&quot;);</span><br><span class=\"line\">           // 获取属性值</span><br><span class=\"line\">           LogE(&quot; my age is : &quot; + ageField.getInt(programMonkey));</span><br><span class=\"line\">           // 设置属性值</span><br><span class=\"line\">           ageField.set(programMonkey, 10);</span><br><span class=\"line\">           LogE(&quot; my age is : &quot; + ageField.getInt(programMonkey));</span><br><span class=\"line\">       &#125; catch (Exception e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取当前类和父类的所有公有属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void getAllFields() &#123;</span><br><span class=\"line\">       ProgramMonkey programMonkey = new ProgramMonkey(&quot;小明&quot;, &quot;男&quot;, 12);</span><br><span class=\"line\">       // 得到当前类和父类的所有公有属性</span><br><span class=\"line\">       Field[] publicFields = programMonkey.getClass().getFields();</span><br><span class=\"line\">       for (Field field : publicFields) &#123;</span><br><span class=\"line\">           LogE(&quot;field name : &quot; + field.getName());</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">           // 获取当前类和父类的某个公有属性</span><br><span class=\"line\">           Field ageField = programMonkey.getClass().getField(&quot;mAge&quot;);</span><br><span class=\"line\">           LogE(&quot; age is : &quot; + ageField.getInt(programMonkey));</span><br><span class=\"line\">           ageField.set(programMonkey, 8);</span><br><span class=\"line\">           LogE(&quot; my age is : &quot; + ageField.getInt(programMonkey));</span><br><span class=\"line\">       &#125; catch (Exception e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>"},{"title":"java各种锁学习","date":"2018-12-13T04:13:59.000Z","_content":"\n该片摘抄自慕课\n\n# 一. synchronized\n\n在 JDK 1.6 之前，synchronized 是重量级锁，效率低下。从 JDK 1.6 开始，synchronized 做了很多优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。synchronized 同步锁一共包含四种状态：无锁、偏向锁、轻量级锁、重量级锁，它会随着竞争情况逐渐升级。synchronized 同步锁可以升级但是不可以降级，目的是为了提高获取锁和释放锁的效率。\n\n## synchronized 修饰的代码块\n\n通过反编译.class文件，通过查看字节码可以得到：在代码块中使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令指明同步代码块的结束位置。\n\n## synchronized 修饰的方法\n\n同样查看字节码可以得到：在同步方法中会包含 ACC_SYNCHRONIZED 标记符。该标记符指明了该方法是一个同步方法，从而执行相应的同步调用。\n\n# 二. 对象锁、类锁、私有锁\n\n对象锁：使用 synchronized 修饰非静态的方法以及 synchronized(this) 同步代码块使用的锁是对象锁。\n\n类锁：使用 synchronized 修饰静态的方法以及 synchronized(class) 同步代码块使用的锁是类锁。\n\n私有锁：在类内部声明一个私有属性如private Object lock，在需要加锁的同步块使用 synchronized(lock）\n\n它们的特性：\n\n- 对象锁具有可重入性。\n- 当一个线程获得了某个对象的对象锁，则该线程仍然可以调用其他任何需要该对象锁的 synchronized 方法或 synchronized(this) 同步代码块。\n- 当一个线程访问某个对象的一个 synchronized(this) 同步代码块时，其他线程对该对象中所有其它 synchronized(this) 同步代码块的访问将被阻塞，因为访问的是同一个对象锁。\n- 每个类只有一个类锁，但是类可以实例化成对象，因此每一个对象对应一个对象锁。\n- 类锁和对象锁不会产生竞争。\n- 私有锁和对象锁也不会产生竞争。\n- 使用私有锁可以减小锁的细粒度，减少由锁产生的开销。\n\n由私有锁实现的等待/通知机制：\n\n```\nObject lock = new Object();// 由等待方线程实现\nsynchronized (lock) {\n    while (条件不满足) {\n       lock.wait();\n    }                         \n   }// 由通知方线程实现\n   synchronized (lock) {\n   条件发生改变\n   lock.notify();                    \n}\n```\n\n# 三. ReentrantLock\n\nReentrantLock 是一个独占/排他锁。相对于 synchronized，它更加灵活。但是需要自己写出加锁和解锁的过程。它的灵活性在于它拥有很多特性。\n\n>>ReentrantLock 需要显示地进行释放锁。特别是在程序异常时，synchronized 会自动释放锁，而 ReentrantLock 并不会自动释放锁，所以必须在 finally 中进行释放锁。\n\n它的特性：\n\n- 公平性：支持公平锁和非公平锁。默认使用了非公平锁。\n- 可重入\n- 可中断：相对于 synchronized，它是可中断的锁，能够对中断作出响应。\n- 超时机制：超时后不能获得锁，因此不会造成死锁。\n\nReentrantLock 是很多类的基础，例如 ConcurrentHashMap 内部使用的 Segment 就是继承 ReentrantLock，CopyOnWriteArrayList 也使用了 ReentrantLock。\n\n# 四. ReentrantReadWriteLock\n\n它拥有读锁(ReadLock)和写锁(WriteLock)，读锁是一个共享锁，写锁是一个排他锁。\n\n它的特性：\n- 公平性：支持公平锁和非公平锁。默认使用了非公平锁。\n- 可重入：读线程在获取读锁之后能够再次获取读锁。写线程在获取写锁之后能够再次获取写锁，同时也可以获取读锁（锁降级）。\n- 锁降级：先获取写锁，再获取读锁，然后再释放写锁的过程。锁降级是为了保证数据的可见性。\n\n# 五. CAS\n\n上面提到的 ReentrantLock、ReentrantReadWriteLock 都是基于 AbstractQueuedSynchronizer (AQS)，而 AQS 又是基于 CAS。CAS 的全称是 Compare And Swap（比较与交换），它是一种无锁算法。\n\nsynchronized、Lock 都采用了悲观锁的机制，而 CAS 是一种乐观锁的实现。\n\nCAS 的特性：\n\n- 通过调用 JNI 的代码实现\n- 非阻塞算法\n- 非独占锁\n\nCAS 存在的问题：\n\n- ABA\n- 循环时间长开销大\n- 只能保证一个共享变量的原子操作\n\n# 六. Condition\n\nCondition 用于替代传统的 Object 的 wait()、notify() 实现线程间的协作。\n\n>> 在 Condition 对象中，与 wait、notify、notifyAll 方法对应的分别是 await、signal 和 signalAll。\n\nCondition 必须要配合 Lock 一起使用，一个 Condition 的实例必须与一个 Lock 绑定。\n\n它的特性：\n\n- 一个 Lock 对象可以创建多个 Condition 实例，所以可以支持多个等待队列。\n- Condition 在使用 await、signal 或 signalAll 方法时，必须先获得 Lock 的 lock()\n- 支持响应中断\n- 支持的定时唤醒功能\n\n# 七. Semaphore\n\nSemaphore、CountDownLatch、CyclicBarrier 都是并发工具类。\n\nSemaphore 可以指定多个线程同时访问某个资源，而 synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源。由于 Semaphore 适用于限制访问某些资源的线程数目，因此可以使用它来做限流。\n\n>> Semaphore 并不会实现数据的同步，数据的同步还是需要使用 synchronized、Lock 等实现。\n\n它的特性：\n\n- 基于 AQS 的共享模式\n- 公平性：支持公平模式和非公平模式。默认使用了非公平模式。\n\n\n# 八. CountDownLatch\n\nCountDownLatch 可以看成是一个倒计数器，它允许一个或多个线程等待其他线程完成操作。因此，CountDownLatch 是共享锁。CountDownLatch 的 countDown() 方法将计数器减1，await() 方法会阻塞当前线程直到计数器变为0。\n\n# 九. 锁的分类\n\n![java锁图](/images/java/java锁图.png)","source":"_posts/java各种锁学习.md","raw":"---\ntitle: java各种锁学习\ndate: 2018-12-13 12:13:59\ntags: java\n---\n\n该片摘抄自慕课\n\n# 一. synchronized\n\n在 JDK 1.6 之前，synchronized 是重量级锁，效率低下。从 JDK 1.6 开始，synchronized 做了很多优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。synchronized 同步锁一共包含四种状态：无锁、偏向锁、轻量级锁、重量级锁，它会随着竞争情况逐渐升级。synchronized 同步锁可以升级但是不可以降级，目的是为了提高获取锁和释放锁的效率。\n\n## synchronized 修饰的代码块\n\n通过反编译.class文件，通过查看字节码可以得到：在代码块中使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令指明同步代码块的结束位置。\n\n## synchronized 修饰的方法\n\n同样查看字节码可以得到：在同步方法中会包含 ACC_SYNCHRONIZED 标记符。该标记符指明了该方法是一个同步方法，从而执行相应的同步调用。\n\n# 二. 对象锁、类锁、私有锁\n\n对象锁：使用 synchronized 修饰非静态的方法以及 synchronized(this) 同步代码块使用的锁是对象锁。\n\n类锁：使用 synchronized 修饰静态的方法以及 synchronized(class) 同步代码块使用的锁是类锁。\n\n私有锁：在类内部声明一个私有属性如private Object lock，在需要加锁的同步块使用 synchronized(lock）\n\n它们的特性：\n\n- 对象锁具有可重入性。\n- 当一个线程获得了某个对象的对象锁，则该线程仍然可以调用其他任何需要该对象锁的 synchronized 方法或 synchronized(this) 同步代码块。\n- 当一个线程访问某个对象的一个 synchronized(this) 同步代码块时，其他线程对该对象中所有其它 synchronized(this) 同步代码块的访问将被阻塞，因为访问的是同一个对象锁。\n- 每个类只有一个类锁，但是类可以实例化成对象，因此每一个对象对应一个对象锁。\n- 类锁和对象锁不会产生竞争。\n- 私有锁和对象锁也不会产生竞争。\n- 使用私有锁可以减小锁的细粒度，减少由锁产生的开销。\n\n由私有锁实现的等待/通知机制：\n\n```\nObject lock = new Object();// 由等待方线程实现\nsynchronized (lock) {\n    while (条件不满足) {\n       lock.wait();\n    }                         \n   }// 由通知方线程实现\n   synchronized (lock) {\n   条件发生改变\n   lock.notify();                    \n}\n```\n\n# 三. ReentrantLock\n\nReentrantLock 是一个独占/排他锁。相对于 synchronized，它更加灵活。但是需要自己写出加锁和解锁的过程。它的灵活性在于它拥有很多特性。\n\n>>ReentrantLock 需要显示地进行释放锁。特别是在程序异常时，synchronized 会自动释放锁，而 ReentrantLock 并不会自动释放锁，所以必须在 finally 中进行释放锁。\n\n它的特性：\n\n- 公平性：支持公平锁和非公平锁。默认使用了非公平锁。\n- 可重入\n- 可中断：相对于 synchronized，它是可中断的锁，能够对中断作出响应。\n- 超时机制：超时后不能获得锁，因此不会造成死锁。\n\nReentrantLock 是很多类的基础，例如 ConcurrentHashMap 内部使用的 Segment 就是继承 ReentrantLock，CopyOnWriteArrayList 也使用了 ReentrantLock。\n\n# 四. ReentrantReadWriteLock\n\n它拥有读锁(ReadLock)和写锁(WriteLock)，读锁是一个共享锁，写锁是一个排他锁。\n\n它的特性：\n- 公平性：支持公平锁和非公平锁。默认使用了非公平锁。\n- 可重入：读线程在获取读锁之后能够再次获取读锁。写线程在获取写锁之后能够再次获取写锁，同时也可以获取读锁（锁降级）。\n- 锁降级：先获取写锁，再获取读锁，然后再释放写锁的过程。锁降级是为了保证数据的可见性。\n\n# 五. CAS\n\n上面提到的 ReentrantLock、ReentrantReadWriteLock 都是基于 AbstractQueuedSynchronizer (AQS)，而 AQS 又是基于 CAS。CAS 的全称是 Compare And Swap（比较与交换），它是一种无锁算法。\n\nsynchronized、Lock 都采用了悲观锁的机制，而 CAS 是一种乐观锁的实现。\n\nCAS 的特性：\n\n- 通过调用 JNI 的代码实现\n- 非阻塞算法\n- 非独占锁\n\nCAS 存在的问题：\n\n- ABA\n- 循环时间长开销大\n- 只能保证一个共享变量的原子操作\n\n# 六. Condition\n\nCondition 用于替代传统的 Object 的 wait()、notify() 实现线程间的协作。\n\n>> 在 Condition 对象中，与 wait、notify、notifyAll 方法对应的分别是 await、signal 和 signalAll。\n\nCondition 必须要配合 Lock 一起使用，一个 Condition 的实例必须与一个 Lock 绑定。\n\n它的特性：\n\n- 一个 Lock 对象可以创建多个 Condition 实例，所以可以支持多个等待队列。\n- Condition 在使用 await、signal 或 signalAll 方法时，必须先获得 Lock 的 lock()\n- 支持响应中断\n- 支持的定时唤醒功能\n\n# 七. Semaphore\n\nSemaphore、CountDownLatch、CyclicBarrier 都是并发工具类。\n\nSemaphore 可以指定多个线程同时访问某个资源，而 synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源。由于 Semaphore 适用于限制访问某些资源的线程数目，因此可以使用它来做限流。\n\n>> Semaphore 并不会实现数据的同步，数据的同步还是需要使用 synchronized、Lock 等实现。\n\n它的特性：\n\n- 基于 AQS 的共享模式\n- 公平性：支持公平模式和非公平模式。默认使用了非公平模式。\n\n\n# 八. CountDownLatch\n\nCountDownLatch 可以看成是一个倒计数器，它允许一个或多个线程等待其他线程完成操作。因此，CountDownLatch 是共享锁。CountDownLatch 的 countDown() 方法将计数器减1，await() 方法会阻塞当前线程直到计数器变为0。\n\n# 九. 锁的分类\n\n![java锁图](/images/java/java锁图.png)","slug":"java各种锁学习","published":1,"updated":"2019-03-12T09:26:33.157Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltty500393a8kkvx047sx","content":"<p>该片摘抄自慕课</p>\n<h1 id=\"一-synchronized\"><a href=\"#一-synchronized\" class=\"headerlink\" title=\"一. synchronized\"></a>一. synchronized</h1><p>在 JDK 1.6 之前，synchronized 是重量级锁，效率低下。从 JDK 1.6 开始，synchronized 做了很多优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。synchronized 同步锁一共包含四种状态：无锁、偏向锁、轻量级锁、重量级锁，它会随着竞争情况逐渐升级。synchronized 同步锁可以升级但是不可以降级，目的是为了提高获取锁和释放锁的效率。</p>\n<h2 id=\"synchronized-修饰的代码块\"><a href=\"#synchronized-修饰的代码块\" class=\"headerlink\" title=\"synchronized 修饰的代码块\"></a>synchronized 修饰的代码块</h2><p>通过反编译.class文件，通过查看字节码可以得到：在代码块中使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令指明同步代码块的结束位置。</p>\n<h2 id=\"synchronized-修饰的方法\"><a href=\"#synchronized-修饰的方法\" class=\"headerlink\" title=\"synchronized 修饰的方法\"></a>synchronized 修饰的方法</h2><p>同样查看字节码可以得到：在同步方法中会包含 ACC_SYNCHRONIZED 标记符。该标记符指明了该方法是一个同步方法，从而执行相应的同步调用。</p>\n<h1 id=\"二-对象锁、类锁、私有锁\"><a href=\"#二-对象锁、类锁、私有锁\" class=\"headerlink\" title=\"二. 对象锁、类锁、私有锁\"></a>二. 对象锁、类锁、私有锁</h1><p>对象锁：使用 synchronized 修饰非静态的方法以及 synchronized(this) 同步代码块使用的锁是对象锁。</p>\n<p>类锁：使用 synchronized 修饰静态的方法以及 synchronized(class) 同步代码块使用的锁是类锁。</p>\n<p>私有锁：在类内部声明一个私有属性如private Object lock，在需要加锁的同步块使用 synchronized(lock）</p>\n<p>它们的特性：</p>\n<ul>\n<li>对象锁具有可重入性。</li>\n<li>当一个线程获得了某个对象的对象锁，则该线程仍然可以调用其他任何需要该对象锁的 synchronized 方法或 synchronized(this) 同步代码块。</li>\n<li>当一个线程访问某个对象的一个 synchronized(this) 同步代码块时，其他线程对该对象中所有其它 synchronized(this) 同步代码块的访问将被阻塞，因为访问的是同一个对象锁。</li>\n<li>每个类只有一个类锁，但是类可以实例化成对象，因此每一个对象对应一个对象锁。</li>\n<li>类锁和对象锁不会产生竞争。</li>\n<li>私有锁和对象锁也不会产生竞争。</li>\n<li>使用私有锁可以减小锁的细粒度，减少由锁产生的开销。</li>\n</ul>\n<p>由私有锁实现的等待/通知机制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object lock = new Object();// 由等待方线程实现</span><br><span class=\"line\">synchronized (lock) &#123;</span><br><span class=\"line\">    while (条件不满足) &#123;</span><br><span class=\"line\">       lock.wait();</span><br><span class=\"line\">    &#125;                         </span><br><span class=\"line\">   &#125;// 由通知方线程实现</span><br><span class=\"line\">   synchronized (lock) &#123;</span><br><span class=\"line\">   条件发生改变</span><br><span class=\"line\">   lock.notify();                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"三-ReentrantLock\"><a href=\"#三-ReentrantLock\" class=\"headerlink\" title=\"三. ReentrantLock\"></a>三. ReentrantLock</h1><p>ReentrantLock 是一个独占/排他锁。相对于 synchronized，它更加灵活。但是需要自己写出加锁和解锁的过程。它的灵活性在于它拥有很多特性。</p>\n<blockquote>\n<blockquote>\n<p>ReentrantLock 需要显示地进行释放锁。特别是在程序异常时，synchronized 会自动释放锁，而 ReentrantLock 并不会自动释放锁，所以必须在 finally 中进行释放锁。</p>\n</blockquote>\n</blockquote>\n<p>它的特性：</p>\n<ul>\n<li>公平性：支持公平锁和非公平锁。默认使用了非公平锁。</li>\n<li>可重入</li>\n<li>可中断：相对于 synchronized，它是可中断的锁，能够对中断作出响应。</li>\n<li>超时机制：超时后不能获得锁，因此不会造成死锁。</li>\n</ul>\n<p>ReentrantLock 是很多类的基础，例如 ConcurrentHashMap 内部使用的 Segment 就是继承 ReentrantLock，CopyOnWriteArrayList 也使用了 ReentrantLock。</p>\n<h1 id=\"四-ReentrantReadWriteLock\"><a href=\"#四-ReentrantReadWriteLock\" class=\"headerlink\" title=\"四. ReentrantReadWriteLock\"></a>四. ReentrantReadWriteLock</h1><p>它拥有读锁(ReadLock)和写锁(WriteLock)，读锁是一个共享锁，写锁是一个排他锁。</p>\n<p>它的特性：</p>\n<ul>\n<li>公平性：支持公平锁和非公平锁。默认使用了非公平锁。</li>\n<li>可重入：读线程在获取读锁之后能够再次获取读锁。写线程在获取写锁之后能够再次获取写锁，同时也可以获取读锁（锁降级）。</li>\n<li>锁降级：先获取写锁，再获取读锁，然后再释放写锁的过程。锁降级是为了保证数据的可见性。</li>\n</ul>\n<h1 id=\"五-CAS\"><a href=\"#五-CAS\" class=\"headerlink\" title=\"五. CAS\"></a>五. CAS</h1><p>上面提到的 ReentrantLock、ReentrantReadWriteLock 都是基于 AbstractQueuedSynchronizer (AQS)，而 AQS 又是基于 CAS。CAS 的全称是 Compare And Swap（比较与交换），它是一种无锁算法。</p>\n<p>synchronized、Lock 都采用了悲观锁的机制，而 CAS 是一种乐观锁的实现。</p>\n<p>CAS 的特性：</p>\n<ul>\n<li>通过调用 JNI 的代码实现</li>\n<li>非阻塞算法</li>\n<li>非独占锁</li>\n</ul>\n<p>CAS 存在的问题：</p>\n<ul>\n<li>ABA</li>\n<li>循环时间长开销大</li>\n<li>只能保证一个共享变量的原子操作</li>\n</ul>\n<h1 id=\"六-Condition\"><a href=\"#六-Condition\" class=\"headerlink\" title=\"六. Condition\"></a>六. Condition</h1><p>Condition 用于替代传统的 Object 的 wait()、notify() 实现线程间的协作。</p>\n<blockquote>\n<blockquote>\n<p>在 Condition 对象中，与 wait、notify、notifyAll 方法对应的分别是 await、signal 和 signalAll。</p>\n</blockquote>\n</blockquote>\n<p>Condition 必须要配合 Lock 一起使用，一个 Condition 的实例必须与一个 Lock 绑定。</p>\n<p>它的特性：</p>\n<ul>\n<li>一个 Lock 对象可以创建多个 Condition 实例，所以可以支持多个等待队列。</li>\n<li>Condition 在使用 await、signal 或 signalAll 方法时，必须先获得 Lock 的 lock()</li>\n<li>支持响应中断</li>\n<li>支持的定时唤醒功能</li>\n</ul>\n<h1 id=\"七-Semaphore\"><a href=\"#七-Semaphore\" class=\"headerlink\" title=\"七. Semaphore\"></a>七. Semaphore</h1><p>Semaphore、CountDownLatch、CyclicBarrier 都是并发工具类。</p>\n<p>Semaphore 可以指定多个线程同时访问某个资源，而 synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源。由于 Semaphore 适用于限制访问某些资源的线程数目，因此可以使用它来做限流。</p>\n<blockquote>\n<blockquote>\n<p>Semaphore 并不会实现数据的同步，数据的同步还是需要使用 synchronized、Lock 等实现。</p>\n</blockquote>\n</blockquote>\n<p>它的特性：</p>\n<ul>\n<li>基于 AQS 的共享模式</li>\n<li>公平性：支持公平模式和非公平模式。默认使用了非公平模式。</li>\n</ul>\n<h1 id=\"八-CountDownLatch\"><a href=\"#八-CountDownLatch\" class=\"headerlink\" title=\"八. CountDownLatch\"></a>八. CountDownLatch</h1><p>CountDownLatch 可以看成是一个倒计数器，它允许一个或多个线程等待其他线程完成操作。因此，CountDownLatch 是共享锁。CountDownLatch 的 countDown() 方法将计数器减1，await() 方法会阻塞当前线程直到计数器变为0。</p>\n<h1 id=\"九-锁的分类\"><a href=\"#九-锁的分类\" class=\"headerlink\" title=\"九. 锁的分类\"></a>九. 锁的分类</h1><p><img src=\"/images/java/java锁图.png\" alt=\"java锁图\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>该片摘抄自慕课</p>\n<h1 id=\"一-synchronized\"><a href=\"#一-synchronized\" class=\"headerlink\" title=\"一. synchronized\"></a>一. synchronized</h1><p>在 JDK 1.6 之前，synchronized 是重量级锁，效率低下。从 JDK 1.6 开始，synchronized 做了很多优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。synchronized 同步锁一共包含四种状态：无锁、偏向锁、轻量级锁、重量级锁，它会随着竞争情况逐渐升级。synchronized 同步锁可以升级但是不可以降级，目的是为了提高获取锁和释放锁的效率。</p>\n<h2 id=\"synchronized-修饰的代码块\"><a href=\"#synchronized-修饰的代码块\" class=\"headerlink\" title=\"synchronized 修饰的代码块\"></a>synchronized 修饰的代码块</h2><p>通过反编译.class文件，通过查看字节码可以得到：在代码块中使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令指明同步代码块的结束位置。</p>\n<h2 id=\"synchronized-修饰的方法\"><a href=\"#synchronized-修饰的方法\" class=\"headerlink\" title=\"synchronized 修饰的方法\"></a>synchronized 修饰的方法</h2><p>同样查看字节码可以得到：在同步方法中会包含 ACC_SYNCHRONIZED 标记符。该标记符指明了该方法是一个同步方法，从而执行相应的同步调用。</p>\n<h1 id=\"二-对象锁、类锁、私有锁\"><a href=\"#二-对象锁、类锁、私有锁\" class=\"headerlink\" title=\"二. 对象锁、类锁、私有锁\"></a>二. 对象锁、类锁、私有锁</h1><p>对象锁：使用 synchronized 修饰非静态的方法以及 synchronized(this) 同步代码块使用的锁是对象锁。</p>\n<p>类锁：使用 synchronized 修饰静态的方法以及 synchronized(class) 同步代码块使用的锁是类锁。</p>\n<p>私有锁：在类内部声明一个私有属性如private Object lock，在需要加锁的同步块使用 synchronized(lock）</p>\n<p>它们的特性：</p>\n<ul>\n<li>对象锁具有可重入性。</li>\n<li>当一个线程获得了某个对象的对象锁，则该线程仍然可以调用其他任何需要该对象锁的 synchronized 方法或 synchronized(this) 同步代码块。</li>\n<li>当一个线程访问某个对象的一个 synchronized(this) 同步代码块时，其他线程对该对象中所有其它 synchronized(this) 同步代码块的访问将被阻塞，因为访问的是同一个对象锁。</li>\n<li>每个类只有一个类锁，但是类可以实例化成对象，因此每一个对象对应一个对象锁。</li>\n<li>类锁和对象锁不会产生竞争。</li>\n<li>私有锁和对象锁也不会产生竞争。</li>\n<li>使用私有锁可以减小锁的细粒度，减少由锁产生的开销。</li>\n</ul>\n<p>由私有锁实现的等待/通知机制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object lock = new Object();// 由等待方线程实现</span><br><span class=\"line\">synchronized (lock) &#123;</span><br><span class=\"line\">    while (条件不满足) &#123;</span><br><span class=\"line\">       lock.wait();</span><br><span class=\"line\">    &#125;                         </span><br><span class=\"line\">   &#125;// 由通知方线程实现</span><br><span class=\"line\">   synchronized (lock) &#123;</span><br><span class=\"line\">   条件发生改变</span><br><span class=\"line\">   lock.notify();                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"三-ReentrantLock\"><a href=\"#三-ReentrantLock\" class=\"headerlink\" title=\"三. ReentrantLock\"></a>三. ReentrantLock</h1><p>ReentrantLock 是一个独占/排他锁。相对于 synchronized，它更加灵活。但是需要自己写出加锁和解锁的过程。它的灵活性在于它拥有很多特性。</p>\n<blockquote>\n<blockquote>\n<p>ReentrantLock 需要显示地进行释放锁。特别是在程序异常时，synchronized 会自动释放锁，而 ReentrantLock 并不会自动释放锁，所以必须在 finally 中进行释放锁。</p>\n</blockquote>\n</blockquote>\n<p>它的特性：</p>\n<ul>\n<li>公平性：支持公平锁和非公平锁。默认使用了非公平锁。</li>\n<li>可重入</li>\n<li>可中断：相对于 synchronized，它是可中断的锁，能够对中断作出响应。</li>\n<li>超时机制：超时后不能获得锁，因此不会造成死锁。</li>\n</ul>\n<p>ReentrantLock 是很多类的基础，例如 ConcurrentHashMap 内部使用的 Segment 就是继承 ReentrantLock，CopyOnWriteArrayList 也使用了 ReentrantLock。</p>\n<h1 id=\"四-ReentrantReadWriteLock\"><a href=\"#四-ReentrantReadWriteLock\" class=\"headerlink\" title=\"四. ReentrantReadWriteLock\"></a>四. ReentrantReadWriteLock</h1><p>它拥有读锁(ReadLock)和写锁(WriteLock)，读锁是一个共享锁，写锁是一个排他锁。</p>\n<p>它的特性：</p>\n<ul>\n<li>公平性：支持公平锁和非公平锁。默认使用了非公平锁。</li>\n<li>可重入：读线程在获取读锁之后能够再次获取读锁。写线程在获取写锁之后能够再次获取写锁，同时也可以获取读锁（锁降级）。</li>\n<li>锁降级：先获取写锁，再获取读锁，然后再释放写锁的过程。锁降级是为了保证数据的可见性。</li>\n</ul>\n<h1 id=\"五-CAS\"><a href=\"#五-CAS\" class=\"headerlink\" title=\"五. CAS\"></a>五. CAS</h1><p>上面提到的 ReentrantLock、ReentrantReadWriteLock 都是基于 AbstractQueuedSynchronizer (AQS)，而 AQS 又是基于 CAS。CAS 的全称是 Compare And Swap（比较与交换），它是一种无锁算法。</p>\n<p>synchronized、Lock 都采用了悲观锁的机制，而 CAS 是一种乐观锁的实现。</p>\n<p>CAS 的特性：</p>\n<ul>\n<li>通过调用 JNI 的代码实现</li>\n<li>非阻塞算法</li>\n<li>非独占锁</li>\n</ul>\n<p>CAS 存在的问题：</p>\n<ul>\n<li>ABA</li>\n<li>循环时间长开销大</li>\n<li>只能保证一个共享变量的原子操作</li>\n</ul>\n<h1 id=\"六-Condition\"><a href=\"#六-Condition\" class=\"headerlink\" title=\"六. Condition\"></a>六. Condition</h1><p>Condition 用于替代传统的 Object 的 wait()、notify() 实现线程间的协作。</p>\n<blockquote>\n<blockquote>\n<p>在 Condition 对象中，与 wait、notify、notifyAll 方法对应的分别是 await、signal 和 signalAll。</p>\n</blockquote>\n</blockquote>\n<p>Condition 必须要配合 Lock 一起使用，一个 Condition 的实例必须与一个 Lock 绑定。</p>\n<p>它的特性：</p>\n<ul>\n<li>一个 Lock 对象可以创建多个 Condition 实例，所以可以支持多个等待队列。</li>\n<li>Condition 在使用 await、signal 或 signalAll 方法时，必须先获得 Lock 的 lock()</li>\n<li>支持响应中断</li>\n<li>支持的定时唤醒功能</li>\n</ul>\n<h1 id=\"七-Semaphore\"><a href=\"#七-Semaphore\" class=\"headerlink\" title=\"七. Semaphore\"></a>七. Semaphore</h1><p>Semaphore、CountDownLatch、CyclicBarrier 都是并发工具类。</p>\n<p>Semaphore 可以指定多个线程同时访问某个资源，而 synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源。由于 Semaphore 适用于限制访问某些资源的线程数目，因此可以使用它来做限流。</p>\n<blockquote>\n<blockquote>\n<p>Semaphore 并不会实现数据的同步，数据的同步还是需要使用 synchronized、Lock 等实现。</p>\n</blockquote>\n</blockquote>\n<p>它的特性：</p>\n<ul>\n<li>基于 AQS 的共享模式</li>\n<li>公平性：支持公平模式和非公平模式。默认使用了非公平模式。</li>\n</ul>\n<h1 id=\"八-CountDownLatch\"><a href=\"#八-CountDownLatch\" class=\"headerlink\" title=\"八. CountDownLatch\"></a>八. CountDownLatch</h1><p>CountDownLatch 可以看成是一个倒计数器，它允许一个或多个线程等待其他线程完成操作。因此，CountDownLatch 是共享锁。CountDownLatch 的 countDown() 方法将计数器减1，await() 方法会阻塞当前线程直到计数器变为0。</p>\n<h1 id=\"九-锁的分类\"><a href=\"#九-锁的分类\" class=\"headerlink\" title=\"九. 锁的分类\"></a>九. 锁的分类</h1><p><img src=\"/images/java/java锁图.png\" alt=\"java锁图\"></p>\n"},{"title":"java对象的三种状态","date":"2019-01-13T14:13:03.000Z","_content":"\n最近被问到一个问题，java对象有几种状态？\n没有接触过这个，说实话被问到的时候连一点可说的都没有。\n\n因此总结一下网上对java对象的几种状态：可触及态、可复活态、不可触及态\n\n# 可触及态（可达状态）\n\n从根节点开始，可以搜索到这个状态，也就是可以访问到这个状态\n\n# 可复活态（可恢复态）\n\n从根节点开始，无论如何都不能访问到这个对象，也就是说这个对象的所有引用都被释放，没有任何变量引用该对象了，\n但是该对象有可能在finalize()方法中再次被引用，从而复活。\n\n垃圾回收器在准备回收垃圾时，调用finalize方法，在finalize方法中，系统有可能重新让一个或多个引用指向该对象，那么这个对象就由可恢复状态变为可达状态。 \n\n# 不可触及态（不可恢复态）\n\n在finalize()方法中没有复活，这样这个对象就消失在了内存堆中","source":"_posts/java对象的三种状态.md","raw":"---\ntitle: java对象的三种状态\ndate: 2019-01-13 22:13:03\ntags: java\n---\n\n最近被问到一个问题，java对象有几种状态？\n没有接触过这个，说实话被问到的时候连一点可说的都没有。\n\n因此总结一下网上对java对象的几种状态：可触及态、可复活态、不可触及态\n\n# 可触及态（可达状态）\n\n从根节点开始，可以搜索到这个状态，也就是可以访问到这个状态\n\n# 可复活态（可恢复态）\n\n从根节点开始，无论如何都不能访问到这个对象，也就是说这个对象的所有引用都被释放，没有任何变量引用该对象了，\n但是该对象有可能在finalize()方法中再次被引用，从而复活。\n\n垃圾回收器在准备回收垃圾时，调用finalize方法，在finalize方法中，系统有可能重新让一个或多个引用指向该对象，那么这个对象就由可恢复状态变为可达状态。 \n\n# 不可触及态（不可恢复态）\n\n在finalize()方法中没有复活，这样这个对象就消失在了内存堆中","slug":"java对象的三种状态","published":1,"updated":"2019-03-12T09:26:33.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltty6003b3a8kz9wdzooh","content":"<p>最近被问到一个问题，java对象有几种状态？<br>没有接触过这个，说实话被问到的时候连一点可说的都没有。</p>\n<p>因此总结一下网上对java对象的几种状态：可触及态、可复活态、不可触及态</p>\n<h1 id=\"可触及态（可达状态）\"><a href=\"#可触及态（可达状态）\" class=\"headerlink\" title=\"可触及态（可达状态）\"></a>可触及态（可达状态）</h1><p>从根节点开始，可以搜索到这个状态，也就是可以访问到这个状态</p>\n<h1 id=\"可复活态（可恢复态）\"><a href=\"#可复活态（可恢复态）\" class=\"headerlink\" title=\"可复活态（可恢复态）\"></a>可复活态（可恢复态）</h1><p>从根节点开始，无论如何都不能访问到这个对象，也就是说这个对象的所有引用都被释放，没有任何变量引用该对象了，<br>但是该对象有可能在finalize()方法中再次被引用，从而复活。</p>\n<p>垃圾回收器在准备回收垃圾时，调用finalize方法，在finalize方法中，系统有可能重新让一个或多个引用指向该对象，那么这个对象就由可恢复状态变为可达状态。 </p>\n<h1 id=\"不可触及态（不可恢复态）\"><a href=\"#不可触及态（不可恢复态）\" class=\"headerlink\" title=\"不可触及态（不可恢复态）\"></a>不可触及态（不可恢复态）</h1><p>在finalize()方法中没有复活，这样这个对象就消失在了内存堆中</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近被问到一个问题，java对象有几种状态？<br>没有接触过这个，说实话被问到的时候连一点可说的都没有。</p>\n<p>因此总结一下网上对java对象的几种状态：可触及态、可复活态、不可触及态</p>\n<h1 id=\"可触及态（可达状态）\"><a href=\"#可触及态（可达状态）\" class=\"headerlink\" title=\"可触及态（可达状态）\"></a>可触及态（可达状态）</h1><p>从根节点开始，可以搜索到这个状态，也就是可以访问到这个状态</p>\n<h1 id=\"可复活态（可恢复态）\"><a href=\"#可复活态（可恢复态）\" class=\"headerlink\" title=\"可复活态（可恢复态）\"></a>可复活态（可恢复态）</h1><p>从根节点开始，无论如何都不能访问到这个对象，也就是说这个对象的所有引用都被释放，没有任何变量引用该对象了，<br>但是该对象有可能在finalize()方法中再次被引用，从而复活。</p>\n<p>垃圾回收器在准备回收垃圾时，调用finalize方法，在finalize方法中，系统有可能重新让一个或多个引用指向该对象，那么这个对象就由可恢复状态变为可达状态。 </p>\n<h1 id=\"不可触及态（不可恢复态）\"><a href=\"#不可触及态（不可恢复态）\" class=\"headerlink\" title=\"不可触及态（不可恢复态）\"></a>不可触及态（不可恢复态）</h1><p>在finalize()方法中没有复活，这样这个对象就消失在了内存堆中</p>\n"},{"title":"java编程思想第一章《对象导论》学习笔记","date":"2018-05-06T17:05:26.000Z","_content":"\n1.1 抽象过程\n\n- 万物皆为对象：将对象是为奇特的变量，他可以存储数据，还可以在自身上执行操作。\n\n- 程序是对象的集合，它们通过发送消息来告知彼此所要做的：可以把消息想象为对某个特定对象的方法的调用请求。\n\n- 每个对象都有自己的由其他对象所构成的存储：通过创建包含现有的对象的包的方式来创建新类型的对象。\n\n- 每个对象都拥有其类型：每个类最重要的区别于其他类的特性就是可以发送什么样的消息给他。\n\n- 某一特定类型的所有对象都可以接收同样的消息：可替代性是oop中最强有力的概念之一。\n\n1.2 每个对象都有一个接口\n\n通过设计接口的形式，将对对象的每个请求定义下来。接口确定了对某一特定对象所能发出的请求。\n\n ","source":"_posts/java编程思想第一章《对象导论》学习笔记.md","raw":"---\ntitle: java编程思想第一章《对象导论》学习笔记\ndate: 2018-05-07 01:05:26\ntags: java\n---\n\n1.1 抽象过程\n\n- 万物皆为对象：将对象是为奇特的变量，他可以存储数据，还可以在自身上执行操作。\n\n- 程序是对象的集合，它们通过发送消息来告知彼此所要做的：可以把消息想象为对某个特定对象的方法的调用请求。\n\n- 每个对象都有自己的由其他对象所构成的存储：通过创建包含现有的对象的包的方式来创建新类型的对象。\n\n- 每个对象都拥有其类型：每个类最重要的区别于其他类的特性就是可以发送什么样的消息给他。\n\n- 某一特定类型的所有对象都可以接收同样的消息：可替代性是oop中最强有力的概念之一。\n\n1.2 每个对象都有一个接口\n\n通过设计接口的形式，将对对象的每个请求定义下来。接口确定了对某一特定对象所能发出的请求。\n\n ","slug":"java编程思想第一章《对象导论》学习笔记","published":1,"updated":"2019-03-12T09:26:33.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltty7003d3a8ko34mz2q6","content":"<p>1.1 抽象过程</p>\n<ul>\n<li><p>万物皆为对象：将对象是为奇特的变量，他可以存储数据，还可以在自身上执行操作。</p>\n</li>\n<li><p>程序是对象的集合，它们通过发送消息来告知彼此所要做的：可以把消息想象为对某个特定对象的方法的调用请求。</p>\n</li>\n<li><p>每个对象都有自己的由其他对象所构成的存储：通过创建包含现有的对象的包的方式来创建新类型的对象。</p>\n</li>\n<li><p>每个对象都拥有其类型：每个类最重要的区别于其他类的特性就是可以发送什么样的消息给他。</p>\n</li>\n<li><p>某一特定类型的所有对象都可以接收同样的消息：可替代性是oop中最强有力的概念之一。</p>\n</li>\n</ul>\n<p>1.2 每个对象都有一个接口</p>\n<p>通过设计接口的形式，将对对象的每个请求定义下来。接口确定了对某一特定对象所能发出的请求。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.1 抽象过程</p>\n<ul>\n<li><p>万物皆为对象：将对象是为奇特的变量，他可以存储数据，还可以在自身上执行操作。</p>\n</li>\n<li><p>程序是对象的集合，它们通过发送消息来告知彼此所要做的：可以把消息想象为对某个特定对象的方法的调用请求。</p>\n</li>\n<li><p>每个对象都有自己的由其他对象所构成的存储：通过创建包含现有的对象的包的方式来创建新类型的对象。</p>\n</li>\n<li><p>每个对象都拥有其类型：每个类最重要的区别于其他类的特性就是可以发送什么样的消息给他。</p>\n</li>\n<li><p>某一特定类型的所有对象都可以接收同样的消息：可替代性是oop中最强有力的概念之一。</p>\n</li>\n</ul>\n<p>1.2 每个对象都有一个接口</p>\n<p>通过设计接口的形式，将对对象的每个请求定义下来。接口确定了对某一特定对象所能发出的请求。</p>\n"},{"title":"js语法学习","date":"2018-02-08T02:50:54.000Z","_content":"\n今年过年一周时间需要用来充电，目前目标就是啃一下<JavaScript Dom编程艺术>这本书。\n\n#### 语法\n\n1. 语句\n\n```\n\tfirst statement\n\tsecond statement\n```\n\n```\n\tfirst statement; second statement;\n```\n\n```\n\tfirst statement;\n\tsecond statement;\n```\n\n以上三种都是可行的。\n\n2. 注释\n\n```\n\t// 这可以代表一行注释\n```\n\n```\n\t// 这可以代表多行注释第一行 \n\t// 这可代表多行注释第二行\n```\n\n```\n\t/* 多行注释\n\t\t第二种写法*/\n```\n\n```\n\t<!-- html风格注释，功能等同于//，不推荐使用，不需要使用html的-->结尾\n```\n\n3. 变量\n\njavascript是一个弱类型语言\n\n变量声明\n\n```\n\tvar mood;\n\tvar age;\n```\n\n```\n\tvar mood, age;\n```\n\n```\n\tvar mood = \"happy\";\n\tvar age = 33;\n```\n\n```\n\tvar mood = \"happy\", age = 33;\n```\n\n```\n\tvar mood, age;\n\tmood = \"happy\";\n\tage = 33;\n```\n\n以上声明都可以。js区分大小写。\n\n变量命名不允许包含空格或者标点符号，可以在适当的地方插入下划线。美元符号也可以。\n也可以使用驼峰格式\n\n4. 数据类型\n\njavascript是弱类型语言，可以在任何阶段改变变量的数据类型。\n\n+ 字符串\n\n字符串由0个或者多个字符构成，字符包括不限于字母、数字、标点符号和空格。字符必须包在引号里面，单引号或者双引号都可以。\n可以随意选用引号，单最好根据字符串所包含的字符来选择，如果字符串包含双引号，就将字符放入单引号里面。\n\n字符的转义也是和java一样的使用\\符号\n\n+ 数值\n\njavascript允许使用带小数点的数值，并且允许任意位小数，这样的数称为浮点数。\n\n```\n\tvar age = 33.35;\n```\n\n+ 布尔值\n\n```\n\tvar sleeping = true;\n```\n\n5. 数组\n\n可以声明带长度的数组\n```\n\tvar beatles = Array(4);\n```\n\n也可以声明不带长度的数组\n```\n\tvar beatles = Array();\n```\n\n数据填充方式如下\n```\n\tarray[index] = element;\n```\n\n也可以声明的时候赋值\n```\n\tvar beatles = Array(\"John\", \"Paul\", \"George\", \"Ringo\");\n```\n\n也可以不明确声明数组\n```\n\tvar beatles = ['John', 'Paul', 'George', 'Ringo'];\n```\n\n数组使用方式较为灵活，可以使用变量添加数组，数组数据类型可以不固定，还可以数组中包含其他数组。\n\n关联数组类似于key2value的pojo\n\n```\n\tvar lennon = Array();\n\tlennon[\"name\"] = \"John\";\n\tlennon[\"year\"] = 1940;\n\tlennon[\"living\"] = false;\n```\n\n并不推荐使用。可以直接使用object\n\n6. 对象\n\n对象也是使用一个名字表示一组值。对象的每个值都是对象的一个属性。\n\n```\n\tvar lennon = Object();\n\tlennon.name = \"John\";\n\tlennon.year = 1940;\n\tlennon.living = false;\n```\n\n或者使用一种更简洁的“花括号语法”\n\n```\n\tvar lennon = {name:\"John\", year:1940, living:false};\n```\n\n#### 函数\n\n需要多次使用同一段代码，可以把他们封装成一个函数，\n\n```\n\tfunction multiply(num1, num2){\n\t\tvar total = num1 * num2;\n\t\talert(total);\n\t}\n```\n\n```\n\tfunction convertToCelsius(temp){\n\t\tvar result = temp - 32;\n\t\tresult = result/1.8;\n\t\treturn result;\n\t}\n```\n\n\n#### 对象\n\njavascript里面，属性和方法都使用“点”语法来访问\n\n```\n\tvar jeremy = new Person;\n\talert(jeremy.age);\n\talert(jeremy.mood);\n```\n\n+ 内建对象\n\n内建对象是在new的时候就会自动创建的内在对象，比如说new出一个array，就自带了length对象。\n\n+ 宿主对象\n\njavascript脚本里面可以使用一些已经预先定义好的其他对象，这些对象不是由javascript语言本身而是由它的运行环境提供的。具体到web里面，这个环境就是浏览器，由浏览器提供的预定义对象被称为宿主对象。\n\n#### DOM\n\n+ getElementById\n\nDOM提供了一个名为getElementById的方法，这个方法将返回一个与那个有着给定id属性值的元素节点对应的对象\n\n+ getElementsByTagName\n\n该方法返回一个对象数组，每个对象分别对应着文档里有着给定标签的一个元素\n\n+ getElementsByClassName\n\n这个方法能够通过class来访问元素，返回一个具有相同类名的元素组。但是该方法需要较新的浏览器才可以使用，否则就要自己实现。\n\n```\n\tfunction getElementsByClassName(node, classname){\n\t\tif(node.getElementsByClassName){\n\t\t\treturn node.getElementsByClassName(classname);\n\t\t}else{\n\t\t\tvar results = new Array();\n\t\t\tvar elems = node.getElementsByTagName(\"*\");\n\t\t\tfor (var i = 0; i < elems.length; i++){\n\t\t\t\tif(elems[i].className.indexOf(classname) != -1){\n\t\t\t\t\tresults[results.length] = elems[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\t}\n```\n\n+ getAttribute\n\ngetAttribute是一个函数，它只有一个参数，打算查询的属性的姓名，getAttribute()方法不属于document对象，所以不能通过document对象调用，只能通过元素节点对象调用。\n\n```\n\tvar paras = document.getElementsByTagName(\"p\");\n\tfor(var i = 0; i < paras.length; i++){\n\t\talert(paras[i].getAttribute(\"title\"));\n\t}\n```\n\n+ setAttribute\n\nsetAttribute允许对节点值进行修改\n\n```\n\tvar shopping = document.getElementById(\"purchases\");\n\tshopping.setAttribute(\"title\", \"a list of goods\");\n```\n\n\n\n\n\n","source":"_posts/js语法学习.md","raw":"---\ntitle: js语法学习\ndate: 2018-02-08 10:50:54\ntags: javascript\n---\n\n今年过年一周时间需要用来充电，目前目标就是啃一下<JavaScript Dom编程艺术>这本书。\n\n#### 语法\n\n1. 语句\n\n```\n\tfirst statement\n\tsecond statement\n```\n\n```\n\tfirst statement; second statement;\n```\n\n```\n\tfirst statement;\n\tsecond statement;\n```\n\n以上三种都是可行的。\n\n2. 注释\n\n```\n\t// 这可以代表一行注释\n```\n\n```\n\t// 这可以代表多行注释第一行 \n\t// 这可代表多行注释第二行\n```\n\n```\n\t/* 多行注释\n\t\t第二种写法*/\n```\n\n```\n\t<!-- html风格注释，功能等同于//，不推荐使用，不需要使用html的-->结尾\n```\n\n3. 变量\n\njavascript是一个弱类型语言\n\n变量声明\n\n```\n\tvar mood;\n\tvar age;\n```\n\n```\n\tvar mood, age;\n```\n\n```\n\tvar mood = \"happy\";\n\tvar age = 33;\n```\n\n```\n\tvar mood = \"happy\", age = 33;\n```\n\n```\n\tvar mood, age;\n\tmood = \"happy\";\n\tage = 33;\n```\n\n以上声明都可以。js区分大小写。\n\n变量命名不允许包含空格或者标点符号，可以在适当的地方插入下划线。美元符号也可以。\n也可以使用驼峰格式\n\n4. 数据类型\n\njavascript是弱类型语言，可以在任何阶段改变变量的数据类型。\n\n+ 字符串\n\n字符串由0个或者多个字符构成，字符包括不限于字母、数字、标点符号和空格。字符必须包在引号里面，单引号或者双引号都可以。\n可以随意选用引号，单最好根据字符串所包含的字符来选择，如果字符串包含双引号，就将字符放入单引号里面。\n\n字符的转义也是和java一样的使用\\符号\n\n+ 数值\n\njavascript允许使用带小数点的数值，并且允许任意位小数，这样的数称为浮点数。\n\n```\n\tvar age = 33.35;\n```\n\n+ 布尔值\n\n```\n\tvar sleeping = true;\n```\n\n5. 数组\n\n可以声明带长度的数组\n```\n\tvar beatles = Array(4);\n```\n\n也可以声明不带长度的数组\n```\n\tvar beatles = Array();\n```\n\n数据填充方式如下\n```\n\tarray[index] = element;\n```\n\n也可以声明的时候赋值\n```\n\tvar beatles = Array(\"John\", \"Paul\", \"George\", \"Ringo\");\n```\n\n也可以不明确声明数组\n```\n\tvar beatles = ['John', 'Paul', 'George', 'Ringo'];\n```\n\n数组使用方式较为灵活，可以使用变量添加数组，数组数据类型可以不固定，还可以数组中包含其他数组。\n\n关联数组类似于key2value的pojo\n\n```\n\tvar lennon = Array();\n\tlennon[\"name\"] = \"John\";\n\tlennon[\"year\"] = 1940;\n\tlennon[\"living\"] = false;\n```\n\n并不推荐使用。可以直接使用object\n\n6. 对象\n\n对象也是使用一个名字表示一组值。对象的每个值都是对象的一个属性。\n\n```\n\tvar lennon = Object();\n\tlennon.name = \"John\";\n\tlennon.year = 1940;\n\tlennon.living = false;\n```\n\n或者使用一种更简洁的“花括号语法”\n\n```\n\tvar lennon = {name:\"John\", year:1940, living:false};\n```\n\n#### 函数\n\n需要多次使用同一段代码，可以把他们封装成一个函数，\n\n```\n\tfunction multiply(num1, num2){\n\t\tvar total = num1 * num2;\n\t\talert(total);\n\t}\n```\n\n```\n\tfunction convertToCelsius(temp){\n\t\tvar result = temp - 32;\n\t\tresult = result/1.8;\n\t\treturn result;\n\t}\n```\n\n\n#### 对象\n\njavascript里面，属性和方法都使用“点”语法来访问\n\n```\n\tvar jeremy = new Person;\n\talert(jeremy.age);\n\talert(jeremy.mood);\n```\n\n+ 内建对象\n\n内建对象是在new的时候就会自动创建的内在对象，比如说new出一个array，就自带了length对象。\n\n+ 宿主对象\n\njavascript脚本里面可以使用一些已经预先定义好的其他对象，这些对象不是由javascript语言本身而是由它的运行环境提供的。具体到web里面，这个环境就是浏览器，由浏览器提供的预定义对象被称为宿主对象。\n\n#### DOM\n\n+ getElementById\n\nDOM提供了一个名为getElementById的方法，这个方法将返回一个与那个有着给定id属性值的元素节点对应的对象\n\n+ getElementsByTagName\n\n该方法返回一个对象数组，每个对象分别对应着文档里有着给定标签的一个元素\n\n+ getElementsByClassName\n\n这个方法能够通过class来访问元素，返回一个具有相同类名的元素组。但是该方法需要较新的浏览器才可以使用，否则就要自己实现。\n\n```\n\tfunction getElementsByClassName(node, classname){\n\t\tif(node.getElementsByClassName){\n\t\t\treturn node.getElementsByClassName(classname);\n\t\t}else{\n\t\t\tvar results = new Array();\n\t\t\tvar elems = node.getElementsByTagName(\"*\");\n\t\t\tfor (var i = 0; i < elems.length; i++){\n\t\t\t\tif(elems[i].className.indexOf(classname) != -1){\n\t\t\t\t\tresults[results.length] = elems[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\t}\n```\n\n+ getAttribute\n\ngetAttribute是一个函数，它只有一个参数，打算查询的属性的姓名，getAttribute()方法不属于document对象，所以不能通过document对象调用，只能通过元素节点对象调用。\n\n```\n\tvar paras = document.getElementsByTagName(\"p\");\n\tfor(var i = 0; i < paras.length; i++){\n\t\talert(paras[i].getAttribute(\"title\"));\n\t}\n```\n\n+ setAttribute\n\nsetAttribute允许对节点值进行修改\n\n```\n\tvar shopping = document.getElementById(\"purchases\");\n\tshopping.setAttribute(\"title\", \"a list of goods\");\n```\n\n\n\n\n\n","slug":"js语法学习","published":1,"updated":"2019-03-12T09:26:33.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltty8003g3a8kerc0vzm4","content":"<p>今年过年一周时间需要用来充电，目前目标就是啃一下<javascript dom编程艺术>这本书。</javascript></p>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><ol>\n<li>语句</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">first statement</span><br><span class=\"line\">second statement</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">first statement; second statement;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">first statement;</span><br><span class=\"line\">second statement;</span><br></pre></td></tr></table></figure>\n<p>以上三种都是可行的。</p>\n<ol start=\"2\">\n<li>注释</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这可以代表一行注释</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这可以代表多行注释第一行 </span><br><span class=\"line\">// 这可代表多行注释第二行</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 多行注释</span><br><span class=\"line\">\t第二种写法*/</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- html风格注释，功能等同于//，不推荐使用，不需要使用html的--&gt;结尾</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>变量</li>\n</ol>\n<p>javascript是一个弱类型语言</p>\n<p>变量声明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mood;</span><br><span class=\"line\">var age;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mood, age;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mood = &quot;happy&quot;;</span><br><span class=\"line\">var age = 33;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mood = &quot;happy&quot;, age = 33;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mood, age;</span><br><span class=\"line\">mood = &quot;happy&quot;;</span><br><span class=\"line\">age = 33;</span><br></pre></td></tr></table></figure>\n<p>以上声明都可以。js区分大小写。</p>\n<p>变量命名不允许包含空格或者标点符号，可以在适当的地方插入下划线。美元符号也可以。<br>也可以使用驼峰格式</p>\n<ol start=\"4\">\n<li>数据类型</li>\n</ol>\n<p>javascript是弱类型语言，可以在任何阶段改变变量的数据类型。</p>\n<ul>\n<li>字符串</li>\n</ul>\n<p>字符串由0个或者多个字符构成，字符包括不限于字母、数字、标点符号和空格。字符必须包在引号里面，单引号或者双引号都可以。<br>可以随意选用引号，单最好根据字符串所包含的字符来选择，如果字符串包含双引号，就将字符放入单引号里面。</p>\n<p>字符的转义也是和java一样的使用\\符号</p>\n<ul>\n<li>数值</li>\n</ul>\n<p>javascript允许使用带小数点的数值，并且允许任意位小数，这样的数称为浮点数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var age = 33.35;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>布尔值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var sleeping = true;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>数组</li>\n</ol>\n<p>可以声明带长度的数组<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var beatles = Array(4);</span><br></pre></td></tr></table></figure></p>\n<p>也可以声明不带长度的数组<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var beatles = Array();</span><br></pre></td></tr></table></figure></p>\n<p>数据填充方式如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array[index] = element;</span><br></pre></td></tr></table></figure></p>\n<p>也可以声明的时候赋值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var beatles = Array(&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>也可以不明确声明数组<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var beatles = [&apos;John&apos;, &apos;Paul&apos;, &apos;George&apos;, &apos;Ringo&apos;];</span><br></pre></td></tr></table></figure></p>\n<p>数组使用方式较为灵活，可以使用变量添加数组，数组数据类型可以不固定，还可以数组中包含其他数组。</p>\n<p>关联数组类似于key2value的pojo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var lennon = Array();</span><br><span class=\"line\">lennon[&quot;name&quot;] = &quot;John&quot;;</span><br><span class=\"line\">lennon[&quot;year&quot;] = 1940;</span><br><span class=\"line\">lennon[&quot;living&quot;] = false;</span><br></pre></td></tr></table></figure>\n<p>并不推荐使用。可以直接使用object</p>\n<ol start=\"6\">\n<li>对象</li>\n</ol>\n<p>对象也是使用一个名字表示一组值。对象的每个值都是对象的一个属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var lennon = Object();</span><br><span class=\"line\">lennon.name = &quot;John&quot;;</span><br><span class=\"line\">lennon.year = 1940;</span><br><span class=\"line\">lennon.living = false;</span><br></pre></td></tr></table></figure>\n<p>或者使用一种更简洁的“花括号语法”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var lennon = &#123;name:&quot;John&quot;, year:1940, living:false&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h4><p>需要多次使用同一段代码，可以把他们封装成一个函数，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function multiply(num1, num2)&#123;</span><br><span class=\"line\">\tvar total = num1 * num2;</span><br><span class=\"line\">\talert(total);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function convertToCelsius(temp)&#123;</span><br><span class=\"line\">\tvar result = temp - 32;</span><br><span class=\"line\">\tresult = result/1.8;</span><br><span class=\"line\">\treturn result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h4><p>javascript里面，属性和方法都使用“点”语法来访问</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var jeremy = new Person;</span><br><span class=\"line\">alert(jeremy.age);</span><br><span class=\"line\">alert(jeremy.mood);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>内建对象</li>\n</ul>\n<p>内建对象是在new的时候就会自动创建的内在对象，比如说new出一个array，就自带了length对象。</p>\n<ul>\n<li>宿主对象</li>\n</ul>\n<p>javascript脚本里面可以使用一些已经预先定义好的其他对象，这些对象不是由javascript语言本身而是由它的运行环境提供的。具体到web里面，这个环境就是浏览器，由浏览器提供的预定义对象被称为宿主对象。</p>\n<h4 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h4><ul>\n<li>getElementById</li>\n</ul>\n<p>DOM提供了一个名为getElementById的方法，这个方法将返回一个与那个有着给定id属性值的元素节点对应的对象</p>\n<ul>\n<li>getElementsByTagName</li>\n</ul>\n<p>该方法返回一个对象数组，每个对象分别对应着文档里有着给定标签的一个元素</p>\n<ul>\n<li>getElementsByClassName</li>\n</ul>\n<p>这个方法能够通过class来访问元素，返回一个具有相同类名的元素组。但是该方法需要较新的浏览器才可以使用，否则就要自己实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getElementsByClassName(node, classname)&#123;</span><br><span class=\"line\">\tif(node.getElementsByClassName)&#123;</span><br><span class=\"line\">\t\treturn node.getElementsByClassName(classname);</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">\t\tvar results = new Array();</span><br><span class=\"line\">\t\tvar elems = node.getElementsByTagName(&quot;*&quot;);</span><br><span class=\"line\">\t\tfor (var i = 0; i &lt; elems.length; i++)&#123;</span><br><span class=\"line\">\t\t\tif(elems[i].className.indexOf(classname) != -1)&#123;</span><br><span class=\"line\">\t\t\t\tresults[results.length] = elems[i];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn results;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>getAttribute</li>\n</ul>\n<p>getAttribute是一个函数，它只有一个参数，打算查询的属性的姓名，getAttribute()方法不属于document对象，所以不能通过document对象调用，只能通过元素节点对象调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var paras = document.getElementsByTagName(&quot;p&quot;);</span><br><span class=\"line\">for(var i = 0; i &lt; paras.length; i++)&#123;</span><br><span class=\"line\">\talert(paras[i].getAttribute(&quot;title&quot;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>setAttribute</li>\n</ul>\n<p>setAttribute允许对节点值进行修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var shopping = document.getElementById(&quot;purchases&quot;);</span><br><span class=\"line\">shopping.setAttribute(&quot;title&quot;, &quot;a list of goods&quot;);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>今年过年一周时间需要用来充电，目前目标就是啃一下<javascript dom编程艺术>这本书。</javascript></p>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><ol>\n<li>语句</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">first statement</span><br><span class=\"line\">second statement</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">first statement; second statement;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">first statement;</span><br><span class=\"line\">second statement;</span><br></pre></td></tr></table></figure>\n<p>以上三种都是可行的。</p>\n<ol start=\"2\">\n<li>注释</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这可以代表一行注释</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这可以代表多行注释第一行 </span><br><span class=\"line\">// 这可代表多行注释第二行</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 多行注释</span><br><span class=\"line\">\t第二种写法*/</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- html风格注释，功能等同于//，不推荐使用，不需要使用html的--&gt;结尾</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>变量</li>\n</ol>\n<p>javascript是一个弱类型语言</p>\n<p>变量声明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mood;</span><br><span class=\"line\">var age;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mood, age;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mood = &quot;happy&quot;;</span><br><span class=\"line\">var age = 33;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mood = &quot;happy&quot;, age = 33;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mood, age;</span><br><span class=\"line\">mood = &quot;happy&quot;;</span><br><span class=\"line\">age = 33;</span><br></pre></td></tr></table></figure>\n<p>以上声明都可以。js区分大小写。</p>\n<p>变量命名不允许包含空格或者标点符号，可以在适当的地方插入下划线。美元符号也可以。<br>也可以使用驼峰格式</p>\n<ol start=\"4\">\n<li>数据类型</li>\n</ol>\n<p>javascript是弱类型语言，可以在任何阶段改变变量的数据类型。</p>\n<ul>\n<li>字符串</li>\n</ul>\n<p>字符串由0个或者多个字符构成，字符包括不限于字母、数字、标点符号和空格。字符必须包在引号里面，单引号或者双引号都可以。<br>可以随意选用引号，单最好根据字符串所包含的字符来选择，如果字符串包含双引号，就将字符放入单引号里面。</p>\n<p>字符的转义也是和java一样的使用\\符号</p>\n<ul>\n<li>数值</li>\n</ul>\n<p>javascript允许使用带小数点的数值，并且允许任意位小数，这样的数称为浮点数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var age = 33.35;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>布尔值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var sleeping = true;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>数组</li>\n</ol>\n<p>可以声明带长度的数组<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var beatles = Array(4);</span><br></pre></td></tr></table></figure></p>\n<p>也可以声明不带长度的数组<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var beatles = Array();</span><br></pre></td></tr></table></figure></p>\n<p>数据填充方式如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array[index] = element;</span><br></pre></td></tr></table></figure></p>\n<p>也可以声明的时候赋值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var beatles = Array(&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>也可以不明确声明数组<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var beatles = [&apos;John&apos;, &apos;Paul&apos;, &apos;George&apos;, &apos;Ringo&apos;];</span><br></pre></td></tr></table></figure></p>\n<p>数组使用方式较为灵活，可以使用变量添加数组，数组数据类型可以不固定，还可以数组中包含其他数组。</p>\n<p>关联数组类似于key2value的pojo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var lennon = Array();</span><br><span class=\"line\">lennon[&quot;name&quot;] = &quot;John&quot;;</span><br><span class=\"line\">lennon[&quot;year&quot;] = 1940;</span><br><span class=\"line\">lennon[&quot;living&quot;] = false;</span><br></pre></td></tr></table></figure>\n<p>并不推荐使用。可以直接使用object</p>\n<ol start=\"6\">\n<li>对象</li>\n</ol>\n<p>对象也是使用一个名字表示一组值。对象的每个值都是对象的一个属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var lennon = Object();</span><br><span class=\"line\">lennon.name = &quot;John&quot;;</span><br><span class=\"line\">lennon.year = 1940;</span><br><span class=\"line\">lennon.living = false;</span><br></pre></td></tr></table></figure>\n<p>或者使用一种更简洁的“花括号语法”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var lennon = &#123;name:&quot;John&quot;, year:1940, living:false&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h4><p>需要多次使用同一段代码，可以把他们封装成一个函数，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function multiply(num1, num2)&#123;</span><br><span class=\"line\">\tvar total = num1 * num2;</span><br><span class=\"line\">\talert(total);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function convertToCelsius(temp)&#123;</span><br><span class=\"line\">\tvar result = temp - 32;</span><br><span class=\"line\">\tresult = result/1.8;</span><br><span class=\"line\">\treturn result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h4><p>javascript里面，属性和方法都使用“点”语法来访问</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var jeremy = new Person;</span><br><span class=\"line\">alert(jeremy.age);</span><br><span class=\"line\">alert(jeremy.mood);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>内建对象</li>\n</ul>\n<p>内建对象是在new的时候就会自动创建的内在对象，比如说new出一个array，就自带了length对象。</p>\n<ul>\n<li>宿主对象</li>\n</ul>\n<p>javascript脚本里面可以使用一些已经预先定义好的其他对象，这些对象不是由javascript语言本身而是由它的运行环境提供的。具体到web里面，这个环境就是浏览器，由浏览器提供的预定义对象被称为宿主对象。</p>\n<h4 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h4><ul>\n<li>getElementById</li>\n</ul>\n<p>DOM提供了一个名为getElementById的方法，这个方法将返回一个与那个有着给定id属性值的元素节点对应的对象</p>\n<ul>\n<li>getElementsByTagName</li>\n</ul>\n<p>该方法返回一个对象数组，每个对象分别对应着文档里有着给定标签的一个元素</p>\n<ul>\n<li>getElementsByClassName</li>\n</ul>\n<p>这个方法能够通过class来访问元素，返回一个具有相同类名的元素组。但是该方法需要较新的浏览器才可以使用，否则就要自己实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getElementsByClassName(node, classname)&#123;</span><br><span class=\"line\">\tif(node.getElementsByClassName)&#123;</span><br><span class=\"line\">\t\treturn node.getElementsByClassName(classname);</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">\t\tvar results = new Array();</span><br><span class=\"line\">\t\tvar elems = node.getElementsByTagName(&quot;*&quot;);</span><br><span class=\"line\">\t\tfor (var i = 0; i &lt; elems.length; i++)&#123;</span><br><span class=\"line\">\t\t\tif(elems[i].className.indexOf(classname) != -1)&#123;</span><br><span class=\"line\">\t\t\t\tresults[results.length] = elems[i];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn results;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>getAttribute</li>\n</ul>\n<p>getAttribute是一个函数，它只有一个参数，打算查询的属性的姓名，getAttribute()方法不属于document对象，所以不能通过document对象调用，只能通过元素节点对象调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var paras = document.getElementsByTagName(&quot;p&quot;);</span><br><span class=\"line\">for(var i = 0; i &lt; paras.length; i++)&#123;</span><br><span class=\"line\">\talert(paras[i].getAttribute(&quot;title&quot;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>setAttribute</li>\n</ul>\n<p>setAttribute允许对节点值进行修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var shopping = document.getElementById(&quot;purchases&quot;);</span><br><span class=\"line\">shopping.setAttribute(&quot;title&quot;, &quot;a list of goods&quot;);</span><br></pre></td></tr></table></figure>\n"},{"title":"jvm方法调用机制","date":"2019-02-23T12:05:58.000Z","_content":"","source":"_posts/jvm方法调用机制.md","raw":"---\ntitle: jvm方法调用机制\ndate: 2019-02-23 20:05:58\ntags:\n---\n","slug":"jvm方法调用机制","published":1,"updated":"2019-03-12T09:26:33.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltty9003i3a8k2syg9fid","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"looper的message分发方式","date":"2019-01-16T10:47:19.000Z","_content":"\n前一阵遇到一个问题，就是looper在循环调用messageQueue中的message的时候，如何判断message的来源，并分发到对应的handler对象中的？\n\n当时认为是message中附带了对应的来源，或者说在发送message时使用了类似eventbus的方式进行了注册。\n\n直到今天看了源码...\n\n# loop()\n\n```\nfor (;;) {\n            Message msg = queue.next(); // might block\n            if (msg == null) {\n                // No message indicates that the message queue is quitting.\n                return;\n            }\n\n            // This must be in a local variable, in case a UI event sets the logger\n            final Printer logging = me.mLogging;\n            if (logging != null) {\n                logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +\n                        msg.callback + \": \" + msg.what);\n            }\n\n            final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;\n\n            final long traceTag = me.mTraceTag;\n            if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {\n                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));\n            }\n            final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();\n            final long end;\n            try {\n                msg.target.dispatchMessage(msg);\n                end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();\n            } finally {\n                if (traceTag != 0) {\n                    Trace.traceEnd(traceTag);\n                }\n            }\n            if (slowDispatchThresholdMs > 0) {\n                final long time = end - start;\n                if (time > slowDispatchThresholdMs) {\n                    Slog.w(TAG, \"Dispatch took \" + time + \"ms on \"\n                            + Thread.currentThread().getName() + \", h=\" +\n                            msg.target + \" cb=\" + msg.callback + \" msg=\" + msg.what);\n                }\n            }\n\n            if (logging != null) {\n                logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n            }\n\n            // Make sure that during the course of dispatching the\n            // identity of the thread wasn't corrupted.\n            final long newIdent = Binder.clearCallingIdentity();\n            if (ident != newIdent) {\n                Log.wtf(TAG, \"Thread identity changed from 0x\"\n                        + Long.toHexString(ident) + \" to 0x\"\n                        + Long.toHexString(newIdent) + \" while dispatching to \"\n                        + msg.target.getClass().getName() + \" \"\n                        + msg.callback + \" what=\" + msg.what);\n            }\n\n            msg.recycleUnchecked();\n        }\n```\nloop的过程看起来还是比较简单的，核心在于一个时延和分发。\n\n当检测到messagequeue中有消息的时候，会执行该消息的dispatchmessage()方法\n\n# msg.target\n\n该target对象是handler，也就是message中封了一个handler对像\n\n# dispatchmessage()\n\n```\npublic void dispatchMessage(Message msg) {\n        if (msg.callback != null) {\n            // 当 Message 存在回调方法，回调 msg.callback.run() 方法\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                // 当 Handler 存在 Callback 成员变量时，回调方法 handleMessage()\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            // Handler 自身的回调方法 handleMessage()\n            handleMessage(msg);\n        }\n    }\n```\n\n从这里可以看出，针对msg有三种处理方式\n\n## 单独处理callback\n\n当callback不为空的时候，会优先处理callback，这个callback的就是在post的时候的runnable对象\n\n## 构造处理msg\n\n当不是调用post方法进行的操作，会处理msg。如果构造的时候传入了callback，就会调用传入的callback方法的handlemessage方法\n\n## 自身处理msg\n\n如果没有传入callback，那么就会调用handler自身的hanldeMessage方法。\n\n该方法默认是一个空方法，需要重写handlemessage方法。\n\n## 总结\n\n如果是直接post一个runnable对象的话，当处理这个massage的时候，会直接调用该msg携带的runnable直接进行。\n\n如果是使用message方式来传递的话，需要处理该message，则需要两种方式\n\n1.向Hanlder的构造函数传入一个Handler.Callback对象，并实现Handler.Callback的handleMessage方法\n2.无需向Hanlder的构造函数传入Handler.Callback对象，但是需要重写Handler本身的handleMessage方法\n\n# 总结\n\nmessage分发判断是否传入到对应的handler中，其实是message自身携带的handler对象\n\n```\n private static Message getPostMessage(Runnable r) {\n        Message m = Message.obtain();\n        m.callback = r;\n        return m;\n    }\n```\n\npost的时候会通过这个方法对runnable对象进行封装，这样就顺利的将一个runnable与message联系起来，之后looper执行的时候仍然可以以message为对象进行处理。","source":"_posts/looper的message分发方式.md","raw":"---\ntitle: looper的message分发方式\ndate: 2019-01-16 18:47:19\ntags: android\n---\n\n前一阵遇到一个问题，就是looper在循环调用messageQueue中的message的时候，如何判断message的来源，并分发到对应的handler对象中的？\n\n当时认为是message中附带了对应的来源，或者说在发送message时使用了类似eventbus的方式进行了注册。\n\n直到今天看了源码...\n\n# loop()\n\n```\nfor (;;) {\n            Message msg = queue.next(); // might block\n            if (msg == null) {\n                // No message indicates that the message queue is quitting.\n                return;\n            }\n\n            // This must be in a local variable, in case a UI event sets the logger\n            final Printer logging = me.mLogging;\n            if (logging != null) {\n                logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +\n                        msg.callback + \": \" + msg.what);\n            }\n\n            final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;\n\n            final long traceTag = me.mTraceTag;\n            if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {\n                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));\n            }\n            final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();\n            final long end;\n            try {\n                msg.target.dispatchMessage(msg);\n                end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();\n            } finally {\n                if (traceTag != 0) {\n                    Trace.traceEnd(traceTag);\n                }\n            }\n            if (slowDispatchThresholdMs > 0) {\n                final long time = end - start;\n                if (time > slowDispatchThresholdMs) {\n                    Slog.w(TAG, \"Dispatch took \" + time + \"ms on \"\n                            + Thread.currentThread().getName() + \", h=\" +\n                            msg.target + \" cb=\" + msg.callback + \" msg=\" + msg.what);\n                }\n            }\n\n            if (logging != null) {\n                logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n            }\n\n            // Make sure that during the course of dispatching the\n            // identity of the thread wasn't corrupted.\n            final long newIdent = Binder.clearCallingIdentity();\n            if (ident != newIdent) {\n                Log.wtf(TAG, \"Thread identity changed from 0x\"\n                        + Long.toHexString(ident) + \" to 0x\"\n                        + Long.toHexString(newIdent) + \" while dispatching to \"\n                        + msg.target.getClass().getName() + \" \"\n                        + msg.callback + \" what=\" + msg.what);\n            }\n\n            msg.recycleUnchecked();\n        }\n```\nloop的过程看起来还是比较简单的，核心在于一个时延和分发。\n\n当检测到messagequeue中有消息的时候，会执行该消息的dispatchmessage()方法\n\n# msg.target\n\n该target对象是handler，也就是message中封了一个handler对像\n\n# dispatchmessage()\n\n```\npublic void dispatchMessage(Message msg) {\n        if (msg.callback != null) {\n            // 当 Message 存在回调方法，回调 msg.callback.run() 方法\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                // 当 Handler 存在 Callback 成员变量时，回调方法 handleMessage()\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            // Handler 自身的回调方法 handleMessage()\n            handleMessage(msg);\n        }\n    }\n```\n\n从这里可以看出，针对msg有三种处理方式\n\n## 单独处理callback\n\n当callback不为空的时候，会优先处理callback，这个callback的就是在post的时候的runnable对象\n\n## 构造处理msg\n\n当不是调用post方法进行的操作，会处理msg。如果构造的时候传入了callback，就会调用传入的callback方法的handlemessage方法\n\n## 自身处理msg\n\n如果没有传入callback，那么就会调用handler自身的hanldeMessage方法。\n\n该方法默认是一个空方法，需要重写handlemessage方法。\n\n## 总结\n\n如果是直接post一个runnable对象的话，当处理这个massage的时候，会直接调用该msg携带的runnable直接进行。\n\n如果是使用message方式来传递的话，需要处理该message，则需要两种方式\n\n1.向Hanlder的构造函数传入一个Handler.Callback对象，并实现Handler.Callback的handleMessage方法\n2.无需向Hanlder的构造函数传入Handler.Callback对象，但是需要重写Handler本身的handleMessage方法\n\n# 总结\n\nmessage分发判断是否传入到对应的handler中，其实是message自身携带的handler对象\n\n```\n private static Message getPostMessage(Runnable r) {\n        Message m = Message.obtain();\n        m.callback = r;\n        return m;\n    }\n```\n\npost的时候会通过这个方法对runnable对象进行封装，这样就顺利的将一个runnable与message联系起来，之后looper执行的时候仍然可以以message为对象进行处理。","slug":"looper的message分发方式","published":1,"updated":"2019-03-12T09:26:33.160Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttyb003k3a8kcdcotb3r","content":"<p>前一阵遇到一个问题，就是looper在循环调用messageQueue中的message的时候，如何判断message的来源，并分发到对应的handler对象中的？</p>\n<p>当时认为是message中附带了对应的来源，或者说在发送message时使用了类似eventbus的方式进行了注册。</p>\n<p>直到今天看了源码…</p>\n<h1 id=\"loop\"><a href=\"#loop\" class=\"headerlink\" title=\"loop()\"></a>loop()</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (;;) &#123;</span><br><span class=\"line\">            Message msg = queue.next(); // might block</span><br><span class=\"line\">            if (msg == null) &#123;</span><br><span class=\"line\">                // No message indicates that the message queue is quitting.</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            // This must be in a local variable, in case a UI event sets the logger</span><br><span class=\"line\">            final Printer logging = me.mLogging;</span><br><span class=\"line\">            if (logging != null) &#123;</span><br><span class=\"line\">                logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class=\"line\">                        msg.callback + &quot;: &quot; + msg.what);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class=\"line\"></span><br><span class=\"line\">            final long traceTag = me.mTraceTag;</span><br><span class=\"line\">            if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class=\"line\">                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class=\"line\">            final long end;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                msg.target.dispatchMessage(msg);</span><br><span class=\"line\">                end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                if (traceTag != 0) &#123;</span><br><span class=\"line\">                    Trace.traceEnd(traceTag);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (slowDispatchThresholdMs &gt; 0) &#123;</span><br><span class=\"line\">                final long time = end - start;</span><br><span class=\"line\">                if (time &gt; slowDispatchThresholdMs) &#123;</span><br><span class=\"line\">                    Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot;</span><br><span class=\"line\">                            + Thread.currentThread().getName() + &quot;, h=&quot; +</span><br><span class=\"line\">                            msg.target + &quot; cb=&quot; + msg.callback + &quot; msg=&quot; + msg.what);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (logging != null) &#123;</span><br><span class=\"line\">                logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            // Make sure that during the course of dispatching the</span><br><span class=\"line\">            // identity of the thread wasn&apos;t corrupted.</span><br><span class=\"line\">            final long newIdent = Binder.clearCallingIdentity();</span><br><span class=\"line\">            if (ident != newIdent) &#123;</span><br><span class=\"line\">                Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</span><br><span class=\"line\">                        + Long.toHexString(ident) + &quot; to 0x&quot;</span><br><span class=\"line\">                        + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</span><br><span class=\"line\">                        + msg.target.getClass().getName() + &quot; &quot;</span><br><span class=\"line\">                        + msg.callback + &quot; what=&quot; + msg.what);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            msg.recycleUnchecked();</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>loop的过程看起来还是比较简单的，核心在于一个时延和分发。</p>\n<p>当检测到messagequeue中有消息的时候，会执行该消息的dispatchmessage()方法</p>\n<h1 id=\"msg-target\"><a href=\"#msg-target\" class=\"headerlink\" title=\"msg.target\"></a>msg.target</h1><p>该target对象是handler，也就是message中封了一个handler对像</p>\n<h1 id=\"dispatchmessage\"><a href=\"#dispatchmessage\" class=\"headerlink\" title=\"dispatchmessage()\"></a>dispatchmessage()</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void dispatchMessage(Message msg) &#123;</span><br><span class=\"line\">        if (msg.callback != null) &#123;</span><br><span class=\"line\">            // 当 Message 存在回调方法，回调 msg.callback.run() 方法</span><br><span class=\"line\">            handleCallback(msg);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (mCallback != null) &#123;</span><br><span class=\"line\">                // 当 Handler 存在 Callback 成员变量时，回调方法 handleMessage()</span><br><span class=\"line\">                if (mCallback.handleMessage(msg)) &#123;</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // Handler 自身的回调方法 handleMessage()</span><br><span class=\"line\">            handleMessage(msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>从这里可以看出，针对msg有三种处理方式</p>\n<h2 id=\"单独处理callback\"><a href=\"#单独处理callback\" class=\"headerlink\" title=\"单独处理callback\"></a>单独处理callback</h2><p>当callback不为空的时候，会优先处理callback，这个callback的就是在post的时候的runnable对象</p>\n<h2 id=\"构造处理msg\"><a href=\"#构造处理msg\" class=\"headerlink\" title=\"构造处理msg\"></a>构造处理msg</h2><p>当不是调用post方法进行的操作，会处理msg。如果构造的时候传入了callback，就会调用传入的callback方法的handlemessage方法</p>\n<h2 id=\"自身处理msg\"><a href=\"#自身处理msg\" class=\"headerlink\" title=\"自身处理msg\"></a>自身处理msg</h2><p>如果没有传入callback，那么就会调用handler自身的hanldeMessage方法。</p>\n<p>该方法默认是一个空方法，需要重写handlemessage方法。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>如果是直接post一个runnable对象的话，当处理这个massage的时候，会直接调用该msg携带的runnable直接进行。</p>\n<p>如果是使用message方式来传递的话，需要处理该message，则需要两种方式</p>\n<p>1.向Hanlder的构造函数传入一个Handler.Callback对象，并实现Handler.Callback的handleMessage方法<br>2.无需向Hanlder的构造函数传入Handler.Callback对象，但是需要重写Handler本身的handleMessage方法</p>\n<h1 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>message分发判断是否传入到对应的handler中，其实是message自身携带的handler对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static Message getPostMessage(Runnable r) &#123;</span><br><span class=\"line\">       Message m = Message.obtain();</span><br><span class=\"line\">       m.callback = r;</span><br><span class=\"line\">       return m;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>post的时候会通过这个方法对runnable对象进行封装，这样就顺利的将一个runnable与message联系起来，之后looper执行的时候仍然可以以message为对象进行处理。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>前一阵遇到一个问题，就是looper在循环调用messageQueue中的message的时候，如何判断message的来源，并分发到对应的handler对象中的？</p>\n<p>当时认为是message中附带了对应的来源，或者说在发送message时使用了类似eventbus的方式进行了注册。</p>\n<p>直到今天看了源码…</p>\n<h1 id=\"loop\"><a href=\"#loop\" class=\"headerlink\" title=\"loop()\"></a>loop()</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (;;) &#123;</span><br><span class=\"line\">            Message msg = queue.next(); // might block</span><br><span class=\"line\">            if (msg == null) &#123;</span><br><span class=\"line\">                // No message indicates that the message queue is quitting.</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            // This must be in a local variable, in case a UI event sets the logger</span><br><span class=\"line\">            final Printer logging = me.mLogging;</span><br><span class=\"line\">            if (logging != null) &#123;</span><br><span class=\"line\">                logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class=\"line\">                        msg.callback + &quot;: &quot; + msg.what);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class=\"line\"></span><br><span class=\"line\">            final long traceTag = me.mTraceTag;</span><br><span class=\"line\">            if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class=\"line\">                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class=\"line\">            final long end;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                msg.target.dispatchMessage(msg);</span><br><span class=\"line\">                end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                if (traceTag != 0) &#123;</span><br><span class=\"line\">                    Trace.traceEnd(traceTag);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (slowDispatchThresholdMs &gt; 0) &#123;</span><br><span class=\"line\">                final long time = end - start;</span><br><span class=\"line\">                if (time &gt; slowDispatchThresholdMs) &#123;</span><br><span class=\"line\">                    Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot;</span><br><span class=\"line\">                            + Thread.currentThread().getName() + &quot;, h=&quot; +</span><br><span class=\"line\">                            msg.target + &quot; cb=&quot; + msg.callback + &quot; msg=&quot; + msg.what);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (logging != null) &#123;</span><br><span class=\"line\">                logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            // Make sure that during the course of dispatching the</span><br><span class=\"line\">            // identity of the thread wasn&apos;t corrupted.</span><br><span class=\"line\">            final long newIdent = Binder.clearCallingIdentity();</span><br><span class=\"line\">            if (ident != newIdent) &#123;</span><br><span class=\"line\">                Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</span><br><span class=\"line\">                        + Long.toHexString(ident) + &quot; to 0x&quot;</span><br><span class=\"line\">                        + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</span><br><span class=\"line\">                        + msg.target.getClass().getName() + &quot; &quot;</span><br><span class=\"line\">                        + msg.callback + &quot; what=&quot; + msg.what);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            msg.recycleUnchecked();</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>loop的过程看起来还是比较简单的，核心在于一个时延和分发。</p>\n<p>当检测到messagequeue中有消息的时候，会执行该消息的dispatchmessage()方法</p>\n<h1 id=\"msg-target\"><a href=\"#msg-target\" class=\"headerlink\" title=\"msg.target\"></a>msg.target</h1><p>该target对象是handler，也就是message中封了一个handler对像</p>\n<h1 id=\"dispatchmessage\"><a href=\"#dispatchmessage\" class=\"headerlink\" title=\"dispatchmessage()\"></a>dispatchmessage()</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void dispatchMessage(Message msg) &#123;</span><br><span class=\"line\">        if (msg.callback != null) &#123;</span><br><span class=\"line\">            // 当 Message 存在回调方法，回调 msg.callback.run() 方法</span><br><span class=\"line\">            handleCallback(msg);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (mCallback != null) &#123;</span><br><span class=\"line\">                // 当 Handler 存在 Callback 成员变量时，回调方法 handleMessage()</span><br><span class=\"line\">                if (mCallback.handleMessage(msg)) &#123;</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // Handler 自身的回调方法 handleMessage()</span><br><span class=\"line\">            handleMessage(msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>从这里可以看出，针对msg有三种处理方式</p>\n<h2 id=\"单独处理callback\"><a href=\"#单独处理callback\" class=\"headerlink\" title=\"单独处理callback\"></a>单独处理callback</h2><p>当callback不为空的时候，会优先处理callback，这个callback的就是在post的时候的runnable对象</p>\n<h2 id=\"构造处理msg\"><a href=\"#构造处理msg\" class=\"headerlink\" title=\"构造处理msg\"></a>构造处理msg</h2><p>当不是调用post方法进行的操作，会处理msg。如果构造的时候传入了callback，就会调用传入的callback方法的handlemessage方法</p>\n<h2 id=\"自身处理msg\"><a href=\"#自身处理msg\" class=\"headerlink\" title=\"自身处理msg\"></a>自身处理msg</h2><p>如果没有传入callback，那么就会调用handler自身的hanldeMessage方法。</p>\n<p>该方法默认是一个空方法，需要重写handlemessage方法。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>如果是直接post一个runnable对象的话，当处理这个massage的时候，会直接调用该msg携带的runnable直接进行。</p>\n<p>如果是使用message方式来传递的话，需要处理该message，则需要两种方式</p>\n<p>1.向Hanlder的构造函数传入一个Handler.Callback对象，并实现Handler.Callback的handleMessage方法<br>2.无需向Hanlder的构造函数传入Handler.Callback对象，但是需要重写Handler本身的handleMessage方法</p>\n<h1 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>message分发判断是否传入到对应的handler中，其实是message自身携带的handler对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static Message getPostMessage(Runnable r) &#123;</span><br><span class=\"line\">       Message m = Message.obtain();</span><br><span class=\"line\">       m.callback = r;</span><br><span class=\"line\">       return m;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>post的时候会通过这个方法对runnable对象进行封装，这样就顺利的将一个runnable与message联系起来，之后looper执行的时候仍然可以以message为对象进行处理。</p>\n"},{"title":"merge标签的作用","date":"2018-10-22T13:09:18.000Z","_content":"\nmerge标签的作用是用于减少一层布局的。\n\n事实上很多时候如果单控件的话，可以直接使用控件来当root使用。\n\n但是一旦控件比较多的话，那就没办法了，此时就需要使用merge标签来减少一层布局了。\n\nmerge标签一般的作用就是替代framelayout，当绘制绘制到他的时候，会主动跳过布局而直接绘制其包含的内容。但是缺点或者说局限就是只能使用framelayout的布局来布局。\n\n另外merge只能用作根布局，且如果想使用inflater来inflate的话，attachtoroot一定要写成true","source":"_posts/merge标签的作用.md","raw":"---\ntitle: merge标签的作用\ndate: 2018-10-22 21:09:18\ntags: android\n---\n\nmerge标签的作用是用于减少一层布局的。\n\n事实上很多时候如果单控件的话，可以直接使用控件来当root使用。\n\n但是一旦控件比较多的话，那就没办法了，此时就需要使用merge标签来减少一层布局了。\n\nmerge标签一般的作用就是替代framelayout，当绘制绘制到他的时候，会主动跳过布局而直接绘制其包含的内容。但是缺点或者说局限就是只能使用framelayout的布局来布局。\n\n另外merge只能用作根布局，且如果想使用inflater来inflate的话，attachtoroot一定要写成true","slug":"merge标签的作用","published":1,"updated":"2019-03-12T09:26:33.160Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttyd003n3a8k6r20sq65","content":"<p>merge标签的作用是用于减少一层布局的。</p>\n<p>事实上很多时候如果单控件的话，可以直接使用控件来当root使用。</p>\n<p>但是一旦控件比较多的话，那就没办法了，此时就需要使用merge标签来减少一层布局了。</p>\n<p>merge标签一般的作用就是替代framelayout，当绘制绘制到他的时候，会主动跳过布局而直接绘制其包含的内容。但是缺点或者说局限就是只能使用framelayout的布局来布局。</p>\n<p>另外merge只能用作根布局，且如果想使用inflater来inflate的话，attachtoroot一定要写成true</p>\n","site":{"data":{}},"excerpt":"","more":"<p>merge标签的作用是用于减少一层布局的。</p>\n<p>事实上很多时候如果单控件的话，可以直接使用控件来当root使用。</p>\n<p>但是一旦控件比较多的话，那就没办法了，此时就需要使用merge标签来减少一层布局了。</p>\n<p>merge标签一般的作用就是替代framelayout，当绘制绘制到他的时候，会主动跳过布局而直接绘制其包含的内容。但是缺点或者说局限就是只能使用framelayout的布局来布局。</p>\n<p>另外merge只能用作根布局，且如果想使用inflater来inflate的话，attachtoroot一定要写成true</p>\n"},{"title":"multidex错误小结","date":"2018-03-19T03:49:44.000Z","_content":"\n最近项目中遇到一个问题，是关于multidex的。\n\nmultidex是android提供的一个分包工具，将原来的一个dex分为一个主dex入口和很多子dex，然后让虚拟机进行加载。\n\n谷歌在L版本之前使用的dalvik虚拟机，这个虚拟机有一个坏处，他加载dex原本只设计了一个加载方式，就是只加载查询dex的第一个dex，因此假如使用了multidex分包策略时，必须设置编译的时候将什么放在主dex中，否则代码量一大，必然出现notfound，notdefined之类的找不到未命名未初始化的错误。\n\nL之后使用了art虚拟机，就不再有这方面的问题。\n\n这个问题很严重，导致了公司软件在android l以下的手机debug的时候打不开。\n\n后来发现了一个神奇的事情。debug的时候，混淆开关是关着的，release的时候，混淆开关是开着的。结果release的版本可以顺利运行。\n\n事实证明，虽然dalvik仍然只是加载一个主dex，这个主dex除了项目搭建的时候每个类都做了细致的标明，否则的确会出问题，但是若使用混淆，通过映射的方式，将代码映射开来，这样就有效避免了这个问题。\n\n因此在android 5.0以下的手机需要分包，可以使用该方法。\n","source":"_posts/multidex错误小结.md","raw":"---\ntitle: multidex错误小结\ndate: 2018-03-19 11:49:44\ntags: android\n---\n\n最近项目中遇到一个问题，是关于multidex的。\n\nmultidex是android提供的一个分包工具，将原来的一个dex分为一个主dex入口和很多子dex，然后让虚拟机进行加载。\n\n谷歌在L版本之前使用的dalvik虚拟机，这个虚拟机有一个坏处，他加载dex原本只设计了一个加载方式，就是只加载查询dex的第一个dex，因此假如使用了multidex分包策略时，必须设置编译的时候将什么放在主dex中，否则代码量一大，必然出现notfound，notdefined之类的找不到未命名未初始化的错误。\n\nL之后使用了art虚拟机，就不再有这方面的问题。\n\n这个问题很严重，导致了公司软件在android l以下的手机debug的时候打不开。\n\n后来发现了一个神奇的事情。debug的时候，混淆开关是关着的，release的时候，混淆开关是开着的。结果release的版本可以顺利运行。\n\n事实证明，虽然dalvik仍然只是加载一个主dex，这个主dex除了项目搭建的时候每个类都做了细致的标明，否则的确会出问题，但是若使用混淆，通过映射的方式，将代码映射开来，这样就有效避免了这个问题。\n\n因此在android 5.0以下的手机需要分包，可以使用该方法。\n","slug":"multidex错误小结","published":1,"updated":"2019-03-12T09:26:33.160Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttyh003p3a8kgql8wkat","content":"<p>最近项目中遇到一个问题，是关于multidex的。</p>\n<p>multidex是android提供的一个分包工具，将原来的一个dex分为一个主dex入口和很多子dex，然后让虚拟机进行加载。</p>\n<p>谷歌在L版本之前使用的dalvik虚拟机，这个虚拟机有一个坏处，他加载dex原本只设计了一个加载方式，就是只加载查询dex的第一个dex，因此假如使用了multidex分包策略时，必须设置编译的时候将什么放在主dex中，否则代码量一大，必然出现notfound，notdefined之类的找不到未命名未初始化的错误。</p>\n<p>L之后使用了art虚拟机，就不再有这方面的问题。</p>\n<p>这个问题很严重，导致了公司软件在android l以下的手机debug的时候打不开。</p>\n<p>后来发现了一个神奇的事情。debug的时候，混淆开关是关着的，release的时候，混淆开关是开着的。结果release的版本可以顺利运行。</p>\n<p>事实证明，虽然dalvik仍然只是加载一个主dex，这个主dex除了项目搭建的时候每个类都做了细致的标明，否则的确会出问题，但是若使用混淆，通过映射的方式，将代码映射开来，这样就有效避免了这个问题。</p>\n<p>因此在android 5.0以下的手机需要分包，可以使用该方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近项目中遇到一个问题，是关于multidex的。</p>\n<p>multidex是android提供的一个分包工具，将原来的一个dex分为一个主dex入口和很多子dex，然后让虚拟机进行加载。</p>\n<p>谷歌在L版本之前使用的dalvik虚拟机，这个虚拟机有一个坏处，他加载dex原本只设计了一个加载方式，就是只加载查询dex的第一个dex，因此假如使用了multidex分包策略时，必须设置编译的时候将什么放在主dex中，否则代码量一大，必然出现notfound，notdefined之类的找不到未命名未初始化的错误。</p>\n<p>L之后使用了art虚拟机，就不再有这方面的问题。</p>\n<p>这个问题很严重，导致了公司软件在android l以下的手机debug的时候打不开。</p>\n<p>后来发现了一个神奇的事情。debug的时候，混淆开关是关着的，release的时候，混淆开关是开着的。结果release的版本可以顺利运行。</p>\n<p>事实证明，虽然dalvik仍然只是加载一个主dex，这个主dex除了项目搭建的时候每个类都做了细致的标明，否则的确会出问题，但是若使用混淆，通过映射的方式，将代码映射开来，这样就有效避免了这个问题。</p>\n<p>因此在android 5.0以下的手机需要分包，可以使用该方法。</p>\n"},{"title":"mvc在android中的使用","date":"2018-02-10T05:50:25.000Z","_content":"\n以往只知mvc不知mvc所以然，今天来梳理一遍。\n\nm：即是model层，一般惯性是在model层做一些逻辑处理操作，比如说数据库存储、网络操作、复杂的算法操作、耗时任务等等\n\nv：即是view层，xml的布局就是android的view层，view层主要是显示model的结果\n\nc：即是controller层，例如在android中，fragment/activity可以操作view，与用户进行交流，用于显示model的结果，所以fragment/activity就是controller层\n\n光知道以上的还没用，需要了解一下为什么要分层。\n\n举个例子，现在有一个功能，是进行网络请求，我们知道，网络请求可以使用okhttp，可以使用volley，可以使用retrofit，但是假如我们直接构造一个getHttp()的方法，嵌入到activity里面，就会产生后续难以维护，假如将okhttp改成volley的话，就需要更改这个功能，由于接口的不同，会导致一系列难以想象的问题发生。\n\n因此我们可以定义一个interface，这个interface就是用于进行网络请求，里面只有2个功能，一个是请求，一个是返回结果。\n\n然后我们实现这个interface，实现完了，将这个interface作为一个model插入到activity里面，这样后续需要进行更改，使用别的框架的时候，可以直接更改这个impl，毕竟只需要两个接口的功能完全，也方便测试，同时插拔也十分方便。\n\nMVC的优点：\n\n(1)耦合性低。所谓耦合性就是模块代码之间的关联程度。利用MVC框架使得View（视图）层和Model（模型）层可以很好的分离，这样就达到了解耦的目的，所以耦合性低，减少模块代码之间的相互影响。\n\n(2)可扩展性好。由于耦合性低，添加需求，扩展代码就可以减少修改之前的代码，降低bug的出现率。\n\n(3)模块职责划分明确。主要划分层M,V,C三个模块，利于代码的维护。","source":"_posts/mvc在android中的使用.md","raw":"---\ntitle: mvc在android中的使用\ndate: 2018-02-10 13:50:25\ntags: 架构\n---\n\n以往只知mvc不知mvc所以然，今天来梳理一遍。\n\nm：即是model层，一般惯性是在model层做一些逻辑处理操作，比如说数据库存储、网络操作、复杂的算法操作、耗时任务等等\n\nv：即是view层，xml的布局就是android的view层，view层主要是显示model的结果\n\nc：即是controller层，例如在android中，fragment/activity可以操作view，与用户进行交流，用于显示model的结果，所以fragment/activity就是controller层\n\n光知道以上的还没用，需要了解一下为什么要分层。\n\n举个例子，现在有一个功能，是进行网络请求，我们知道，网络请求可以使用okhttp，可以使用volley，可以使用retrofit，但是假如我们直接构造一个getHttp()的方法，嵌入到activity里面，就会产生后续难以维护，假如将okhttp改成volley的话，就需要更改这个功能，由于接口的不同，会导致一系列难以想象的问题发生。\n\n因此我们可以定义一个interface，这个interface就是用于进行网络请求，里面只有2个功能，一个是请求，一个是返回结果。\n\n然后我们实现这个interface，实现完了，将这个interface作为一个model插入到activity里面，这样后续需要进行更改，使用别的框架的时候，可以直接更改这个impl，毕竟只需要两个接口的功能完全，也方便测试，同时插拔也十分方便。\n\nMVC的优点：\n\n(1)耦合性低。所谓耦合性就是模块代码之间的关联程度。利用MVC框架使得View（视图）层和Model（模型）层可以很好的分离，这样就达到了解耦的目的，所以耦合性低，减少模块代码之间的相互影响。\n\n(2)可扩展性好。由于耦合性低，添加需求，扩展代码就可以减少修改之前的代码，降低bug的出现率。\n\n(3)模块职责划分明确。主要划分层M,V,C三个模块，利于代码的维护。","slug":"mvc在android中的使用","published":1,"updated":"2019-03-12T09:26:33.160Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttyi003s3a8k0cfitxo1","content":"<p>以往只知mvc不知mvc所以然，今天来梳理一遍。</p>\n<p>m：即是model层，一般惯性是在model层做一些逻辑处理操作，比如说数据库存储、网络操作、复杂的算法操作、耗时任务等等</p>\n<p>v：即是view层，xml的布局就是android的view层，view层主要是显示model的结果</p>\n<p>c：即是controller层，例如在android中，fragment/activity可以操作view，与用户进行交流，用于显示model的结果，所以fragment/activity就是controller层</p>\n<p>光知道以上的还没用，需要了解一下为什么要分层。</p>\n<p>举个例子，现在有一个功能，是进行网络请求，我们知道，网络请求可以使用okhttp，可以使用volley，可以使用retrofit，但是假如我们直接构造一个getHttp()的方法，嵌入到activity里面，就会产生后续难以维护，假如将okhttp改成volley的话，就需要更改这个功能，由于接口的不同，会导致一系列难以想象的问题发生。</p>\n<p>因此我们可以定义一个interface，这个interface就是用于进行网络请求，里面只有2个功能，一个是请求，一个是返回结果。</p>\n<p>然后我们实现这个interface，实现完了，将这个interface作为一个model插入到activity里面，这样后续需要进行更改，使用别的框架的时候，可以直接更改这个impl，毕竟只需要两个接口的功能完全，也方便测试，同时插拔也十分方便。</p>\n<p>MVC的优点：</p>\n<p>(1)耦合性低。所谓耦合性就是模块代码之间的关联程度。利用MVC框架使得View（视图）层和Model（模型）层可以很好的分离，这样就达到了解耦的目的，所以耦合性低，减少模块代码之间的相互影响。</p>\n<p>(2)可扩展性好。由于耦合性低，添加需求，扩展代码就可以减少修改之前的代码，降低bug的出现率。</p>\n<p>(3)模块职责划分明确。主要划分层M,V,C三个模块，利于代码的维护。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>以往只知mvc不知mvc所以然，今天来梳理一遍。</p>\n<p>m：即是model层，一般惯性是在model层做一些逻辑处理操作，比如说数据库存储、网络操作、复杂的算法操作、耗时任务等等</p>\n<p>v：即是view层，xml的布局就是android的view层，view层主要是显示model的结果</p>\n<p>c：即是controller层，例如在android中，fragment/activity可以操作view，与用户进行交流，用于显示model的结果，所以fragment/activity就是controller层</p>\n<p>光知道以上的还没用，需要了解一下为什么要分层。</p>\n<p>举个例子，现在有一个功能，是进行网络请求，我们知道，网络请求可以使用okhttp，可以使用volley，可以使用retrofit，但是假如我们直接构造一个getHttp()的方法，嵌入到activity里面，就会产生后续难以维护，假如将okhttp改成volley的话，就需要更改这个功能，由于接口的不同，会导致一系列难以想象的问题发生。</p>\n<p>因此我们可以定义一个interface，这个interface就是用于进行网络请求，里面只有2个功能，一个是请求，一个是返回结果。</p>\n<p>然后我们实现这个interface，实现完了，将这个interface作为一个model插入到activity里面，这样后续需要进行更改，使用别的框架的时候，可以直接更改这个impl，毕竟只需要两个接口的功能完全，也方便测试，同时插拔也十分方便。</p>\n<p>MVC的优点：</p>\n<p>(1)耦合性低。所谓耦合性就是模块代码之间的关联程度。利用MVC框架使得View（视图）层和Model（模型）层可以很好的分离，这样就达到了解耦的目的，所以耦合性低，减少模块代码之间的相互影响。</p>\n<p>(2)可扩展性好。由于耦合性低，添加需求，扩展代码就可以减少修改之前的代码，降低bug的出现率。</p>\n<p>(3)模块职责划分明确。主要划分层M,V,C三个模块，利于代码的维护。</p>\n"},{"title":"python操作mongodb","date":"2018-06-06T03:35:26.000Z","_content":"\n# 连接mongodb\n\n```\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\nfrom pymongo import MongoClient\n\nconn = MongoClient('192.168.0.113', 27017)\ndb = conn.mydb  ##连接mydb数据库，没有则自动创建\nmy_set = db.test_set  # 使用test_set集合，没有则自动创建\n```\n\n# 插入数据\n\n```\nmy_set.insert({\"name\":\"zhangsan\",\"age\":18})\n\n# 或\n\nmy_set.save({\"name\":\"zhangsan\",\"age\",18})\n```\n\n#插入多条\n\n```\nusers=[{\"name\":\"zhangsan\",\"age\":18},{\"name\":\"lisi\",\"age\":18}]\nmy_set.insert(users)\n\n# 或\n\nmy_set.save(users)\n```\n\n# 查询数据\n\n```\n# 查询全部\nfor i in my_set.find():\n\tprint(i)\n\n# 查询name = zhangsan 的\n\nfor i in my_set.find({\"name\":\"zhangsan\"}):\n\tprint(i)\nprint(my_set.find_one({\"name\":\"zhangsan\"}))\n\n```\n\n# 更新数据\n\n```\nmy_set.update(\n\t<query>,  #查询条件\n\t<update>,  #update的对象和一些更新操作符\n\t{\n\t\tupsert: <boolean> # 如果不存在update的记录，是否插入\n\t\tmulti: <boolean> # 可选，mongodb默认是false，只更新找到的第一条记录\n\t\twriteConcern: <document> # 可选，抛出异常的级别\n\t}\n)\n```\n\n```\nmy_set.update({\"name\":\"zhangsan\"},{'$set':{\"age\":20}})\n```\n\n# 删除数据\n\n```\nmy_set.remove(\n\t<query>,  # 可选：删除的文档的条件\n\t{\n\t\tjustOne: <boolean>\n\t\twriteConcern: <document>\n\t}\n)\n```\n\n```\n# 删除name = lisi的全部记录\nmy_set.remove({'name':'zhangsan'})\n\n# 删除name=lisi的某个id的记录\nid = my_set.find_one({\"name\":\"zhangsan\"})[\"_id\"]\nmy_set.remove(id)\n\n# 删除集合里的所有记录\ndb.users.remove()\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/python操作mongodb.md","raw":"---\ntitle: python操作mongodb\ndate: 2018-06-06 11:35:26\ntags: python\n---\n\n# 连接mongodb\n\n```\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\nfrom pymongo import MongoClient\n\nconn = MongoClient('192.168.0.113', 27017)\ndb = conn.mydb  ##连接mydb数据库，没有则自动创建\nmy_set = db.test_set  # 使用test_set集合，没有则自动创建\n```\n\n# 插入数据\n\n```\nmy_set.insert({\"name\":\"zhangsan\",\"age\":18})\n\n# 或\n\nmy_set.save({\"name\":\"zhangsan\",\"age\",18})\n```\n\n#插入多条\n\n```\nusers=[{\"name\":\"zhangsan\",\"age\":18},{\"name\":\"lisi\",\"age\":18}]\nmy_set.insert(users)\n\n# 或\n\nmy_set.save(users)\n```\n\n# 查询数据\n\n```\n# 查询全部\nfor i in my_set.find():\n\tprint(i)\n\n# 查询name = zhangsan 的\n\nfor i in my_set.find({\"name\":\"zhangsan\"}):\n\tprint(i)\nprint(my_set.find_one({\"name\":\"zhangsan\"}))\n\n```\n\n# 更新数据\n\n```\nmy_set.update(\n\t<query>,  #查询条件\n\t<update>,  #update的对象和一些更新操作符\n\t{\n\t\tupsert: <boolean> # 如果不存在update的记录，是否插入\n\t\tmulti: <boolean> # 可选，mongodb默认是false，只更新找到的第一条记录\n\t\twriteConcern: <document> # 可选，抛出异常的级别\n\t}\n)\n```\n\n```\nmy_set.update({\"name\":\"zhangsan\"},{'$set':{\"age\":20}})\n```\n\n# 删除数据\n\n```\nmy_set.remove(\n\t<query>,  # 可选：删除的文档的条件\n\t{\n\t\tjustOne: <boolean>\n\t\twriteConcern: <document>\n\t}\n)\n```\n\n```\n# 删除name = lisi的全部记录\nmy_set.remove({'name':'zhangsan'})\n\n# 删除name=lisi的某个id的记录\nid = my_set.find_one({\"name\":\"zhangsan\"})[\"_id\"]\nmy_set.remove(id)\n\n# 删除集合里的所有记录\ndb.users.remove()\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"python操作mongodb","published":1,"updated":"2019-03-12T09:26:33.161Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttyj003u3a8k5sxmq4vk","content":"<h1 id=\"连接mongodb\"><a href=\"#连接mongodb\" class=\"headerlink\" title=\"连接mongodb\"></a>连接mongodb</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env python</span><br><span class=\"line\"># -*- coding:utf-8 -*-</span><br><span class=\"line\"></span><br><span class=\"line\">from pymongo import MongoClient</span><br><span class=\"line\"></span><br><span class=\"line\">conn = MongoClient(&apos;192.168.0.113&apos;, 27017)</span><br><span class=\"line\">db = conn.mydb  ##连接mydb数据库，没有则自动创建</span><br><span class=\"line\">my_set = db.test_set  # 使用test_set集合，没有则自动创建</span><br></pre></td></tr></table></figure>\n<h1 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_set.insert(&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"># 或</span><br><span class=\"line\"></span><br><span class=\"line\">my_set.save(&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;,18&#125;)</span><br></pre></td></tr></table></figure>\n<p>#插入多条</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">users=[&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18&#125;,&#123;&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:18&#125;]</span><br><span class=\"line\">my_set.insert(users)</span><br><span class=\"line\"></span><br><span class=\"line\"># 或</span><br><span class=\"line\"></span><br><span class=\"line\">my_set.save(users)</span><br></pre></td></tr></table></figure>\n<h1 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查询全部</span><br><span class=\"line\">for i in my_set.find():</span><br><span class=\"line\">\tprint(i)</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询name = zhangsan 的</span><br><span class=\"line\"></span><br><span class=\"line\">for i in my_set.find(&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;):</span><br><span class=\"line\">\tprint(i)</span><br><span class=\"line\">print(my_set.find_one(&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;))</span><br></pre></td></tr></table></figure>\n<h1 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_set.update(</span><br><span class=\"line\">\t&lt;query&gt;,  #查询条件</span><br><span class=\"line\">\t&lt;update&gt;,  #update的对象和一些更新操作符</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tupsert: &lt;boolean&gt; # 如果不存在update的记录，是否插入</span><br><span class=\"line\">\t\tmulti: &lt;boolean&gt; # 可选，mongodb默认是false，只更新找到的第一条记录</span><br><span class=\"line\">\t\twriteConcern: &lt;document&gt; # 可选，抛出异常的级别</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_set.update(&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;,&#123;&apos;$set&apos;:&#123;&quot;age&quot;:20&#125;&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_set.remove(</span><br><span class=\"line\">\t&lt;query&gt;,  # 可选：删除的文档的条件</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tjustOne: &lt;boolean&gt;</span><br><span class=\"line\">\t\twriteConcern: &lt;document&gt;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 删除name = lisi的全部记录</span><br><span class=\"line\">my_set.remove(&#123;&apos;name&apos;:&apos;zhangsan&apos;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除name=lisi的某个id的记录</span><br><span class=\"line\">id = my_set.find_one(&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;)[&quot;_id&quot;]</span><br><span class=\"line\">my_set.remove(id)</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除集合里的所有记录</span><br><span class=\"line\">db.users.remove()</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"连接mongodb\"><a href=\"#连接mongodb\" class=\"headerlink\" title=\"连接mongodb\"></a>连接mongodb</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env python</span><br><span class=\"line\"># -*- coding:utf-8 -*-</span><br><span class=\"line\"></span><br><span class=\"line\">from pymongo import MongoClient</span><br><span class=\"line\"></span><br><span class=\"line\">conn = MongoClient(&apos;192.168.0.113&apos;, 27017)</span><br><span class=\"line\">db = conn.mydb  ##连接mydb数据库，没有则自动创建</span><br><span class=\"line\">my_set = db.test_set  # 使用test_set集合，没有则自动创建</span><br></pre></td></tr></table></figure>\n<h1 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_set.insert(&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"># 或</span><br><span class=\"line\"></span><br><span class=\"line\">my_set.save(&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;,18&#125;)</span><br></pre></td></tr></table></figure>\n<p>#插入多条</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">users=[&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18&#125;,&#123;&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:18&#125;]</span><br><span class=\"line\">my_set.insert(users)</span><br><span class=\"line\"></span><br><span class=\"line\"># 或</span><br><span class=\"line\"></span><br><span class=\"line\">my_set.save(users)</span><br></pre></td></tr></table></figure>\n<h1 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查询全部</span><br><span class=\"line\">for i in my_set.find():</span><br><span class=\"line\">\tprint(i)</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询name = zhangsan 的</span><br><span class=\"line\"></span><br><span class=\"line\">for i in my_set.find(&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;):</span><br><span class=\"line\">\tprint(i)</span><br><span class=\"line\">print(my_set.find_one(&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;))</span><br></pre></td></tr></table></figure>\n<h1 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_set.update(</span><br><span class=\"line\">\t&lt;query&gt;,  #查询条件</span><br><span class=\"line\">\t&lt;update&gt;,  #update的对象和一些更新操作符</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tupsert: &lt;boolean&gt; # 如果不存在update的记录，是否插入</span><br><span class=\"line\">\t\tmulti: &lt;boolean&gt; # 可选，mongodb默认是false，只更新找到的第一条记录</span><br><span class=\"line\">\t\twriteConcern: &lt;document&gt; # 可选，抛出异常的级别</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_set.update(&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;,&#123;&apos;$set&apos;:&#123;&quot;age&quot;:20&#125;&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_set.remove(</span><br><span class=\"line\">\t&lt;query&gt;,  # 可选：删除的文档的条件</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tjustOne: &lt;boolean&gt;</span><br><span class=\"line\">\t\twriteConcern: &lt;document&gt;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 删除name = lisi的全部记录</span><br><span class=\"line\">my_set.remove(&#123;&apos;name&apos;:&apos;zhangsan&apos;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除name=lisi的某个id的记录</span><br><span class=\"line\">id = my_set.find_one(&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;)[&quot;_id&quot;]</span><br><span class=\"line\">my_set.remove(id)</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除集合里的所有记录</span><br><span class=\"line\">db.users.remove()</span><br></pre></td></tr></table></figure>\n"},{"title":"retrofit2 post","date":"2017-12-21T07:53:25.000Z","_content":"\n# retrofit的post方法\n\n## 简单的双参数上传，结果是ResponseBody\n```\n\t@FormUrlEncoded\n\t@POST(\"xxx.com\")\n\tObservable<ResponseBody> login(\n\t\t@Field(\"no\") String no,\n\t\t@Field(\"pass\") String pass);\n```\n\n## 文件上传 （ 多文件上传,使用 @PartMap Map<String, RequestBody> params 要注意在设置每一个RequestBody文件的时候，数组名不能一致，否则会覆 盖。）\n```\n\t@Multipart\n    @POST(\"xxx.com\")\n    Observable<ResponseBody> uploadFile(\n        @Part(\"file\\\"; filename=\\\"test.png\") RequestBody file\n     );\n\n```\n\n## 单文件上传\n```\n\t@Multipart\n    @POST(\"xxx.com\")\n    Observable<ResponseBody> uploadFile(\n            @Part MultipartBody.Part file );\n```\n\n## 多文件上传\n```\n\t@Multipart\n    @POST(\"xxx.com\")\n    Observable<ResponseBody> uploadFile(\n            @Part() List<MultipartBody.Part> files );\n```\n\n## 文件和参数共同上传  (参数也需要封装成MultipartBody.Part这样的类型，不然传递会出错，这个类型其实就是将这些数据封装成表单的类型，因为在这里不能使用FormUrlEncoded进行处理)\n```\n\t@Multipart\n    @POST(\"xxx.com\")\n    Observable<ResponseBody> uploadFile(\n         @Part() List<MultipartBody.Part > files );\n```","source":"_posts/retrofit2-post.md","raw":"---\ntitle: retrofit2 post\ndate: 2017-12-21 15:53:25\ntags: android\n---\n\n# retrofit的post方法\n\n## 简单的双参数上传，结果是ResponseBody\n```\n\t@FormUrlEncoded\n\t@POST(\"xxx.com\")\n\tObservable<ResponseBody> login(\n\t\t@Field(\"no\") String no,\n\t\t@Field(\"pass\") String pass);\n```\n\n## 文件上传 （ 多文件上传,使用 @PartMap Map<String, RequestBody> params 要注意在设置每一个RequestBody文件的时候，数组名不能一致，否则会覆 盖。）\n```\n\t@Multipart\n    @POST(\"xxx.com\")\n    Observable<ResponseBody> uploadFile(\n        @Part(\"file\\\"; filename=\\\"test.png\") RequestBody file\n     );\n\n```\n\n## 单文件上传\n```\n\t@Multipart\n    @POST(\"xxx.com\")\n    Observable<ResponseBody> uploadFile(\n            @Part MultipartBody.Part file );\n```\n\n## 多文件上传\n```\n\t@Multipart\n    @POST(\"xxx.com\")\n    Observable<ResponseBody> uploadFile(\n            @Part() List<MultipartBody.Part> files );\n```\n\n## 文件和参数共同上传  (参数也需要封装成MultipartBody.Part这样的类型，不然传递会出错，这个类型其实就是将这些数据封装成表单的类型，因为在这里不能使用FormUrlEncoded进行处理)\n```\n\t@Multipart\n    @POST(\"xxx.com\")\n    Observable<ResponseBody> uploadFile(\n         @Part() List<MultipartBody.Part > files );\n```","slug":"retrofit2-post","published":1,"updated":"2019-03-12T09:26:33.162Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttyk003x3a8k5ynigoae","content":"<h1 id=\"retrofit的post方法\"><a href=\"#retrofit的post方法\" class=\"headerlink\" title=\"retrofit的post方法\"></a>retrofit的post方法</h1><h2 id=\"简单的双参数上传，结果是ResponseBody\"><a href=\"#简单的双参数上传，结果是ResponseBody\" class=\"headerlink\" title=\"简单的双参数上传，结果是ResponseBody\"></a>简单的双参数上传，结果是ResponseBody</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FormUrlEncoded</span><br><span class=\"line\">@POST(&quot;xxx.com&quot;)</span><br><span class=\"line\">Observable&lt;ResponseBody&gt; login(</span><br><span class=\"line\">\t@Field(&quot;no&quot;) String no,</span><br><span class=\"line\">\t@Field(&quot;pass&quot;) String pass);</span><br></pre></td></tr></table></figure>\n<h2 id=\"文件上传-（-多文件上传-使用-PartMap-Map-lt-String-RequestBody-gt-params-要注意在设置每一个RequestBody文件的时候，数组名不能一致，否则会覆-盖。）\"><a href=\"#文件上传-（-多文件上传-使用-PartMap-Map-lt-String-RequestBody-gt-params-要注意在设置每一个RequestBody文件的时候，数组名不能一致，否则会覆-盖。）\" class=\"headerlink\" title=\"文件上传 （ 多文件上传,使用 @PartMap Map&lt;String, RequestBody&gt; params 要注意在设置每一个RequestBody文件的时候，数组名不能一致，否则会覆 盖。）\"></a>文件上传 （ 多文件上传,使用 @PartMap Map&lt;String, RequestBody&gt; params 要注意在设置每一个RequestBody文件的时候，数组名不能一致，否则会覆 盖。）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Multipart</span><br><span class=\"line\">   @POST(&quot;xxx.com&quot;)</span><br><span class=\"line\">   Observable&lt;ResponseBody&gt; uploadFile(</span><br><span class=\"line\">       @Part(&quot;file\\&quot;; filename=\\&quot;test.png&quot;) RequestBody file</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure>\n<h2 id=\"单文件上传\"><a href=\"#单文件上传\" class=\"headerlink\" title=\"单文件上传\"></a>单文件上传</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Multipart</span><br><span class=\"line\">   @POST(&quot;xxx.com&quot;)</span><br><span class=\"line\">   Observable&lt;ResponseBody&gt; uploadFile(</span><br><span class=\"line\">           @Part MultipartBody.Part file );</span><br></pre></td></tr></table></figure>\n<h2 id=\"多文件上传\"><a href=\"#多文件上传\" class=\"headerlink\" title=\"多文件上传\"></a>多文件上传</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Multipart</span><br><span class=\"line\">   @POST(&quot;xxx.com&quot;)</span><br><span class=\"line\">   Observable&lt;ResponseBody&gt; uploadFile(</span><br><span class=\"line\">           @Part() List&lt;MultipartBody.Part&gt; files );</span><br></pre></td></tr></table></figure>\n<h2 id=\"文件和参数共同上传-参数也需要封装成MultipartBody-Part这样的类型，不然传递会出错，这个类型其实就是将这些数据封装成表单的类型，因为在这里不能使用FormUrlEncoded进行处理\"><a href=\"#文件和参数共同上传-参数也需要封装成MultipartBody-Part这样的类型，不然传递会出错，这个类型其实就是将这些数据封装成表单的类型，因为在这里不能使用FormUrlEncoded进行处理\" class=\"headerlink\" title=\"文件和参数共同上传  (参数也需要封装成MultipartBody.Part这样的类型，不然传递会出错，这个类型其实就是将这些数据封装成表单的类型，因为在这里不能使用FormUrlEncoded进行处理)\"></a>文件和参数共同上传  (参数也需要封装成MultipartBody.Part这样的类型，不然传递会出错，这个类型其实就是将这些数据封装成表单的类型，因为在这里不能使用FormUrlEncoded进行处理)</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Multipart</span><br><span class=\"line\">   @POST(&quot;xxx.com&quot;)</span><br><span class=\"line\">   Observable&lt;ResponseBody&gt; uploadFile(</span><br><span class=\"line\">        @Part() List&lt;MultipartBody.Part &gt; files );</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"retrofit的post方法\"><a href=\"#retrofit的post方法\" class=\"headerlink\" title=\"retrofit的post方法\"></a>retrofit的post方法</h1><h2 id=\"简单的双参数上传，结果是ResponseBody\"><a href=\"#简单的双参数上传，结果是ResponseBody\" class=\"headerlink\" title=\"简单的双参数上传，结果是ResponseBody\"></a>简单的双参数上传，结果是ResponseBody</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FormUrlEncoded</span><br><span class=\"line\">@POST(&quot;xxx.com&quot;)</span><br><span class=\"line\">Observable&lt;ResponseBody&gt; login(</span><br><span class=\"line\">\t@Field(&quot;no&quot;) String no,</span><br><span class=\"line\">\t@Field(&quot;pass&quot;) String pass);</span><br></pre></td></tr></table></figure>\n<h2 id=\"文件上传-（-多文件上传-使用-PartMap-Map-lt-String-RequestBody-gt-params-要注意在设置每一个RequestBody文件的时候，数组名不能一致，否则会覆-盖。）\"><a href=\"#文件上传-（-多文件上传-使用-PartMap-Map-lt-String-RequestBody-gt-params-要注意在设置每一个RequestBody文件的时候，数组名不能一致，否则会覆-盖。）\" class=\"headerlink\" title=\"文件上传 （ 多文件上传,使用 @PartMap Map&lt;String, RequestBody&gt; params 要注意在设置每一个RequestBody文件的时候，数组名不能一致，否则会覆 盖。）\"></a>文件上传 （ 多文件上传,使用 @PartMap Map&lt;String, RequestBody&gt; params 要注意在设置每一个RequestBody文件的时候，数组名不能一致，否则会覆 盖。）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Multipart</span><br><span class=\"line\">   @POST(&quot;xxx.com&quot;)</span><br><span class=\"line\">   Observable&lt;ResponseBody&gt; uploadFile(</span><br><span class=\"line\">       @Part(&quot;file\\&quot;; filename=\\&quot;test.png&quot;) RequestBody file</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure>\n<h2 id=\"单文件上传\"><a href=\"#单文件上传\" class=\"headerlink\" title=\"单文件上传\"></a>单文件上传</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Multipart</span><br><span class=\"line\">   @POST(&quot;xxx.com&quot;)</span><br><span class=\"line\">   Observable&lt;ResponseBody&gt; uploadFile(</span><br><span class=\"line\">           @Part MultipartBody.Part file );</span><br></pre></td></tr></table></figure>\n<h2 id=\"多文件上传\"><a href=\"#多文件上传\" class=\"headerlink\" title=\"多文件上传\"></a>多文件上传</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Multipart</span><br><span class=\"line\">   @POST(&quot;xxx.com&quot;)</span><br><span class=\"line\">   Observable&lt;ResponseBody&gt; uploadFile(</span><br><span class=\"line\">           @Part() List&lt;MultipartBody.Part&gt; files );</span><br></pre></td></tr></table></figure>\n<h2 id=\"文件和参数共同上传-参数也需要封装成MultipartBody-Part这样的类型，不然传递会出错，这个类型其实就是将这些数据封装成表单的类型，因为在这里不能使用FormUrlEncoded进行处理\"><a href=\"#文件和参数共同上传-参数也需要封装成MultipartBody-Part这样的类型，不然传递会出错，这个类型其实就是将这些数据封装成表单的类型，因为在这里不能使用FormUrlEncoded进行处理\" class=\"headerlink\" title=\"文件和参数共同上传  (参数也需要封装成MultipartBody.Part这样的类型，不然传递会出错，这个类型其实就是将这些数据封装成表单的类型，因为在这里不能使用FormUrlEncoded进行处理)\"></a>文件和参数共同上传  (参数也需要封装成MultipartBody.Part这样的类型，不然传递会出错，这个类型其实就是将这些数据封装成表单的类型，因为在这里不能使用FormUrlEncoded进行处理)</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Multipart</span><br><span class=\"line\">   @POST(&quot;xxx.com&quot;)</span><br><span class=\"line\">   Observable&lt;ResponseBody&gt; uploadFile(</span><br><span class=\"line\">        @Part() List&lt;MultipartBody.Part &gt; files );</span><br></pre></td></tr></table></figure>"},{"title":"test appveyor","date":"2017-12-21T03:25:39.000Z","_content":"","source":"_posts/test-appveyor.md","raw":"---\ntitle: test appveyor\ndate: 2017-12-21 11:25:39\ntags: hexo\n---\n","slug":"test-appveyor","published":1,"updated":"2019-03-12T09:26:33.162Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttyk003z3a8kd3gxdvev","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"viewgroup测量","date":"2018-01-02T15:07:40.000Z","_content":"ViewGroup会去管理子view，当ViewGroup的大小为wrap_content时，ViewGroup就需要对子View进行遍历，以便获得所有的子View的大小，从而决定自己的大小。在其他模式下则会通过具体的制定值来设置自身的大小。\nViewGroup在测量时通过遍历所有的子view，从而调用子view的measure方法来获得每个子view的测量结果。\n当子view测量结束时，就会将子view放到合适的位置，这个过程就是子view的layout过程。viewgroup在执行layout过程时，也同样是使用遍历的方法来调用子view的layout方法，并指定其具体显示的位置，从而来决定其布局位置。\n在自定义viewgroup中，通常会重写layout方法来控制子view显示位置的逻辑。同样如果是wrap_content，也必须重写onmeasure方法，这点与view是相同的。\n\n# viewgroup的绘制\n\nviewgroup通常不需要绘制，因为本身没有什么值得绘制的东西，如果不是需要指定viewgroup的颜色，甚至连ondraw方法都不会调用。但是viewgroup会使用dispatchDraw()方法来绘制子view","source":"_posts/viewgroup测量.md","raw":"---\ntitle: viewgroup测量\ndate: 2018-01-02 23:07:40\ntags: android\n---\nViewGroup会去管理子view，当ViewGroup的大小为wrap_content时，ViewGroup就需要对子View进行遍历，以便获得所有的子View的大小，从而决定自己的大小。在其他模式下则会通过具体的制定值来设置自身的大小。\nViewGroup在测量时通过遍历所有的子view，从而调用子view的measure方法来获得每个子view的测量结果。\n当子view测量结束时，就会将子view放到合适的位置，这个过程就是子view的layout过程。viewgroup在执行layout过程时，也同样是使用遍历的方法来调用子view的layout方法，并指定其具体显示的位置，从而来决定其布局位置。\n在自定义viewgroup中，通常会重写layout方法来控制子view显示位置的逻辑。同样如果是wrap_content，也必须重写onmeasure方法，这点与view是相同的。\n\n# viewgroup的绘制\n\nviewgroup通常不需要绘制，因为本身没有什么值得绘制的东西，如果不是需要指定viewgroup的颜色，甚至连ondraw方法都不会调用。但是viewgroup会使用dispatchDraw()方法来绘制子view","slug":"viewgroup测量","published":1,"updated":"2019-03-12T09:26:33.163Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttyl00423a8kac4b8xra","content":"<p>ViewGroup会去管理子view，当ViewGroup的大小为wrap_content时，ViewGroup就需要对子View进行遍历，以便获得所有的子View的大小，从而决定自己的大小。在其他模式下则会通过具体的制定值来设置自身的大小。<br>ViewGroup在测量时通过遍历所有的子view，从而调用子view的measure方法来获得每个子view的测量结果。<br>当子view测量结束时，就会将子view放到合适的位置，这个过程就是子view的layout过程。viewgroup在执行layout过程时，也同样是使用遍历的方法来调用子view的layout方法，并指定其具体显示的位置，从而来决定其布局位置。<br>在自定义viewgroup中，通常会重写layout方法来控制子view显示位置的逻辑。同样如果是wrap_content，也必须重写onmeasure方法，这点与view是相同的。</p>\n<h1 id=\"viewgroup的绘制\"><a href=\"#viewgroup的绘制\" class=\"headerlink\" title=\"viewgroup的绘制\"></a>viewgroup的绘制</h1><p>viewgroup通常不需要绘制，因为本身没有什么值得绘制的东西，如果不是需要指定viewgroup的颜色，甚至连ondraw方法都不会调用。但是viewgroup会使用dispatchDraw()方法来绘制子view</p>\n","site":{"data":{}},"excerpt":"","more":"<p>ViewGroup会去管理子view，当ViewGroup的大小为wrap_content时，ViewGroup就需要对子View进行遍历，以便获得所有的子View的大小，从而决定自己的大小。在其他模式下则会通过具体的制定值来设置自身的大小。<br>ViewGroup在测量时通过遍历所有的子view，从而调用子view的measure方法来获得每个子view的测量结果。<br>当子view测量结束时，就会将子view放到合适的位置，这个过程就是子view的layout过程。viewgroup在执行layout过程时，也同样是使用遍历的方法来调用子view的layout方法，并指定其具体显示的位置，从而来决定其布局位置。<br>在自定义viewgroup中，通常会重写layout方法来控制子view显示位置的逻辑。同样如果是wrap_content，也必须重写onmeasure方法，这点与view是相同的。</p>\n<h1 id=\"viewgroup的绘制\"><a href=\"#viewgroup的绘制\" class=\"headerlink\" title=\"viewgroup的绘制\"></a>viewgroup的绘制</h1><p>viewgroup通常不需要绘制，因为本身没有什么值得绘制的东西，如果不是需要指定viewgroup的颜色，甚至连ondraw方法都不会调用。但是viewgroup会使用dispatchDraw()方法来绘制子view</p>\n"},{"title":"viewstub的作用","date":"2018-10-22T15:53:18.000Z","_content":"\nviewstub和merge标签基本上都属于android开发强求优化的时候需要注意的事情。\n\nviewstub的大致作用是用于替换布局。与include这种将布局模块化的不同，viewstub主要的场景是用于分布加载，或者说延迟加载。\n\n```\n<ViewStub\n        android:id=\"@+id/map_stub\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"fill_parent\"\n        android:inflatedId=\"@+id/map_view\"\n        android:layout=\"@layout/map\" />\n```\n\n一般来讲viewstub就是这样，包含一个inflatedid，和一个layout，当viewstub被inflate时或者被设置为visiable时，viewstub属性就会消失，取而代之的是layout，并且此时viewstub的id也会消失，新的布局的id就是inflatedid，之后如果在要使用viewstub的布局的话，就需要直接调inflatedid了。viewstub老的id寻找的布局将为null\n","source":"_posts/viewstub的作用.md","raw":"---\ntitle: viewstub的作用\ndate: 2018-10-22 23:53:18\ntags: android\n---\n\nviewstub和merge标签基本上都属于android开发强求优化的时候需要注意的事情。\n\nviewstub的大致作用是用于替换布局。与include这种将布局模块化的不同，viewstub主要的场景是用于分布加载，或者说延迟加载。\n\n```\n<ViewStub\n        android:id=\"@+id/map_stub\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"fill_parent\"\n        android:inflatedId=\"@+id/map_view\"\n        android:layout=\"@layout/map\" />\n```\n\n一般来讲viewstub就是这样，包含一个inflatedid，和一个layout，当viewstub被inflate时或者被设置为visiable时，viewstub属性就会消失，取而代之的是layout，并且此时viewstub的id也会消失，新的布局的id就是inflatedid，之后如果在要使用viewstub的布局的话，就需要直接调inflatedid了。viewstub老的id寻找的布局将为null\n","slug":"viewstub的作用","published":1,"updated":"2019-03-12T09:26:33.163Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttym00443a8kooguyrgm","content":"<p>viewstub和merge标签基本上都属于android开发强求优化的时候需要注意的事情。</p>\n<p>viewstub的大致作用是用于替换布局。与include这种将布局模块化的不同，viewstub主要的场景是用于分布加载，或者说延迟加载。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ViewStub</span><br><span class=\"line\">        android:id=&quot;@+id/map_stub&quot;</span><br><span class=\"line\">        android:layout_width=&quot;fill_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;fill_parent&quot;</span><br><span class=\"line\">        android:inflatedId=&quot;@+id/map_view&quot;</span><br><span class=\"line\">        android:layout=&quot;@layout/map&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>一般来讲viewstub就是这样，包含一个inflatedid，和一个layout，当viewstub被inflate时或者被设置为visiable时，viewstub属性就会消失，取而代之的是layout，并且此时viewstub的id也会消失，新的布局的id就是inflatedid，之后如果在要使用viewstub的布局的话，就需要直接调inflatedid了。viewstub老的id寻找的布局将为null</p>\n","site":{"data":{}},"excerpt":"","more":"<p>viewstub和merge标签基本上都属于android开发强求优化的时候需要注意的事情。</p>\n<p>viewstub的大致作用是用于替换布局。与include这种将布局模块化的不同，viewstub主要的场景是用于分布加载，或者说延迟加载。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ViewStub</span><br><span class=\"line\">        android:id=&quot;@+id/map_stub&quot;</span><br><span class=\"line\">        android:layout_width=&quot;fill_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;fill_parent&quot;</span><br><span class=\"line\">        android:inflatedId=&quot;@+id/map_view&quot;</span><br><span class=\"line\">        android:layout=&quot;@layout/map&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>一般来讲viewstub就是这样，包含一个inflatedid，和一个layout，当viewstub被inflate时或者被设置为visiable时，viewstub属性就会消失，取而代之的是layout，并且此时viewstub的id也会消失，新的布局的id就是inflatedid，之后如果在要使用viewstub的布局的话，就需要直接调inflatedid了。viewstub老的id寻找的布局将为null</p>\n"},{"title":"view的测量和绘制","date":"2018-01-02T04:38:03.000Z","_content":"系统绘制一个view，如同蒙着眼睛的小孩拿着笔在画板上画出一个指定的图案。因此需要一个人在旁边指导他如何去画。\nAndroid就是那个蒙着眼睛画画的人，开发者需要告诉它如何去画。\n\n# View的测量\n\n去画一个图形，就必须知道它的大小和位置。\nAndroid系统在绘制view之前，也必须对view进行测量，告诉系统该画一个多大的view。这个过程在onMeasure()中进行。\n\n## MeasureSpec\n\nmeasurespec是一个协助测量view的类。它是一个32位的int值，其中高2位为测量的模式，低30位为测量的大小。使用位运算是为了提高并优化效率。\n测量的模式分为以下三种：\n\n1. EXACTLY\n精确模式，当我们将控件的layout_width属性或者layout_height属性指定为具体数值时，比如android:layout_height=\"100dp\",或者指定为match_parent属性时，系统使用的是EXACTLY模式。\n\n2. AT_MOST\n最大值模式，当控件的layout_width属性或者layout_height属性指定为wrap_content时，控件的大小一般随着子控件或内容的变化而变化，此时控件的尺寸只要不超过父控件的最大尺寸即可。\n\n3. UNSPECIFIED\n不指定大小测量模式。view想多大就多大，通常在绘制自定义view时才使用。\n\nView类默认的onMeasure()方法只能支持EXACTLY模式。如果要让自定义view支持wrap_content属性，必须重写onMeasure方法来指定wrap_content时的大小。\n\n## 测量的步骤\n\n1. 从MeasureSpec对象中提取具体的测量模式和大小\n\n```\n\tint specMode = MeasureSpec.getMode(measureSpec);\n\tint specSize = MeasureSpec.getSize(measureSpec);\n\n```\n\n2. 通过判断测量的模式，给出不同的判断值。当specMode为EXACTLY时，直接使用指定的specSize即可；当specMode为其他两种模式时，需要给它一个默认的大小。特别的，如果指定wrap_content属性，即AT_MOST模式，需要取出我们制定的大小与specSize中最小的一个来作为最后的测量值。\n\n```\nprivate int measureWidth(int measureSpec){\n\tint result = 0;\n\tint specMode = MeasureSpec.getMode(measureSpec);\n\tint specSize = MeasureSpec.getSize(measureSpec);\n\n\tif(specMode == MeasureSpec.EXACTLY){\n\t\tresult = specSize;\n\t}else{\n\t\tresult = 200;\n\t\tif(specMpde == MeasureSpec.AT_MOST){\n\t\t\tresult = Math.min(result, specSize);\n\t\t}\n\t}\n\treturn result;\n}\n```\n\n","source":"_posts/view的测量和绘制.md","raw":"---\ntitle: view的测量和绘制\ndate: 2018-01-02 12:38:03\ntags: android\n---\n系统绘制一个view，如同蒙着眼睛的小孩拿着笔在画板上画出一个指定的图案。因此需要一个人在旁边指导他如何去画。\nAndroid就是那个蒙着眼睛画画的人，开发者需要告诉它如何去画。\n\n# View的测量\n\n去画一个图形，就必须知道它的大小和位置。\nAndroid系统在绘制view之前，也必须对view进行测量，告诉系统该画一个多大的view。这个过程在onMeasure()中进行。\n\n## MeasureSpec\n\nmeasurespec是一个协助测量view的类。它是一个32位的int值，其中高2位为测量的模式，低30位为测量的大小。使用位运算是为了提高并优化效率。\n测量的模式分为以下三种：\n\n1. EXACTLY\n精确模式，当我们将控件的layout_width属性或者layout_height属性指定为具体数值时，比如android:layout_height=\"100dp\",或者指定为match_parent属性时，系统使用的是EXACTLY模式。\n\n2. AT_MOST\n最大值模式，当控件的layout_width属性或者layout_height属性指定为wrap_content时，控件的大小一般随着子控件或内容的变化而变化，此时控件的尺寸只要不超过父控件的最大尺寸即可。\n\n3. UNSPECIFIED\n不指定大小测量模式。view想多大就多大，通常在绘制自定义view时才使用。\n\nView类默认的onMeasure()方法只能支持EXACTLY模式。如果要让自定义view支持wrap_content属性，必须重写onMeasure方法来指定wrap_content时的大小。\n\n## 测量的步骤\n\n1. 从MeasureSpec对象中提取具体的测量模式和大小\n\n```\n\tint specMode = MeasureSpec.getMode(measureSpec);\n\tint specSize = MeasureSpec.getSize(measureSpec);\n\n```\n\n2. 通过判断测量的模式，给出不同的判断值。当specMode为EXACTLY时，直接使用指定的specSize即可；当specMode为其他两种模式时，需要给它一个默认的大小。特别的，如果指定wrap_content属性，即AT_MOST模式，需要取出我们制定的大小与specSize中最小的一个来作为最后的测量值。\n\n```\nprivate int measureWidth(int measureSpec){\n\tint result = 0;\n\tint specMode = MeasureSpec.getMode(measureSpec);\n\tint specSize = MeasureSpec.getSize(measureSpec);\n\n\tif(specMode == MeasureSpec.EXACTLY){\n\t\tresult = specSize;\n\t}else{\n\t\tresult = 200;\n\t\tif(specMpde == MeasureSpec.AT_MOST){\n\t\t\tresult = Math.min(result, specSize);\n\t\t}\n\t}\n\treturn result;\n}\n```\n\n","slug":"view的测量和绘制","published":1,"updated":"2019-03-12T09:26:33.163Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttyn00473a8kxhib95f0","content":"<p>系统绘制一个view，如同蒙着眼睛的小孩拿着笔在画板上画出一个指定的图案。因此需要一个人在旁边指导他如何去画。<br>Android就是那个蒙着眼睛画画的人，开发者需要告诉它如何去画。</p>\n<h1 id=\"View的测量\"><a href=\"#View的测量\" class=\"headerlink\" title=\"View的测量\"></a>View的测量</h1><p>去画一个图形，就必须知道它的大小和位置。<br>Android系统在绘制view之前，也必须对view进行测量，告诉系统该画一个多大的view。这个过程在onMeasure()中进行。</p>\n<h2 id=\"MeasureSpec\"><a href=\"#MeasureSpec\" class=\"headerlink\" title=\"MeasureSpec\"></a>MeasureSpec</h2><p>measurespec是一个协助测量view的类。它是一个32位的int值，其中高2位为测量的模式，低30位为测量的大小。使用位运算是为了提高并优化效率。<br>测量的模式分为以下三种：</p>\n<ol>\n<li><p>EXACTLY<br>精确模式，当我们将控件的layout_width属性或者layout_height属性指定为具体数值时，比如android:layout_height=”100dp”,或者指定为match_parent属性时，系统使用的是EXACTLY模式。</p>\n</li>\n<li><p>AT_MOST<br>最大值模式，当控件的layout_width属性或者layout_height属性指定为wrap_content时，控件的大小一般随着子控件或内容的变化而变化，此时控件的尺寸只要不超过父控件的最大尺寸即可。</p>\n</li>\n<li><p>UNSPECIFIED<br>不指定大小测量模式。view想多大就多大，通常在绘制自定义view时才使用。</p>\n</li>\n</ol>\n<p>View类默认的onMeasure()方法只能支持EXACTLY模式。如果要让自定义view支持wrap_content属性，必须重写onMeasure方法来指定wrap_content时的大小。</p>\n<h2 id=\"测量的步骤\"><a href=\"#测量的步骤\" class=\"headerlink\" title=\"测量的步骤\"></a>测量的步骤</h2><ol>\n<li>从MeasureSpec对象中提取具体的测量模式和大小</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int specMode = MeasureSpec.getMode(measureSpec);</span><br><span class=\"line\">int specSize = MeasureSpec.getSize(measureSpec);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>通过判断测量的模式，给出不同的判断值。当specMode为EXACTLY时，直接使用指定的specSize即可；当specMode为其他两种模式时，需要给它一个默认的大小。特别的，如果指定wrap_content属性，即AT_MOST模式，需要取出我们制定的大小与specSize中最小的一个来作为最后的测量值。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int measureWidth(int measureSpec)&#123;</span><br><span class=\"line\">\tint result = 0;</span><br><span class=\"line\">\tint specMode = MeasureSpec.getMode(measureSpec);</span><br><span class=\"line\">\tint specSize = MeasureSpec.getSize(measureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">\tif(specMode == MeasureSpec.EXACTLY)&#123;</span><br><span class=\"line\">\t\tresult = specSize;</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">\t\tresult = 200;</span><br><span class=\"line\">\t\tif(specMpde == MeasureSpec.AT_MOST)&#123;</span><br><span class=\"line\">\t\t\tresult = Math.min(result, specSize);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>系统绘制一个view，如同蒙着眼睛的小孩拿着笔在画板上画出一个指定的图案。因此需要一个人在旁边指导他如何去画。<br>Android就是那个蒙着眼睛画画的人，开发者需要告诉它如何去画。</p>\n<h1 id=\"View的测量\"><a href=\"#View的测量\" class=\"headerlink\" title=\"View的测量\"></a>View的测量</h1><p>去画一个图形，就必须知道它的大小和位置。<br>Android系统在绘制view之前，也必须对view进行测量，告诉系统该画一个多大的view。这个过程在onMeasure()中进行。</p>\n<h2 id=\"MeasureSpec\"><a href=\"#MeasureSpec\" class=\"headerlink\" title=\"MeasureSpec\"></a>MeasureSpec</h2><p>measurespec是一个协助测量view的类。它是一个32位的int值，其中高2位为测量的模式，低30位为测量的大小。使用位运算是为了提高并优化效率。<br>测量的模式分为以下三种：</p>\n<ol>\n<li><p>EXACTLY<br>精确模式，当我们将控件的layout_width属性或者layout_height属性指定为具体数值时，比如android:layout_height=”100dp”,或者指定为match_parent属性时，系统使用的是EXACTLY模式。</p>\n</li>\n<li><p>AT_MOST<br>最大值模式，当控件的layout_width属性或者layout_height属性指定为wrap_content时，控件的大小一般随着子控件或内容的变化而变化，此时控件的尺寸只要不超过父控件的最大尺寸即可。</p>\n</li>\n<li><p>UNSPECIFIED<br>不指定大小测量模式。view想多大就多大，通常在绘制自定义view时才使用。</p>\n</li>\n</ol>\n<p>View类默认的onMeasure()方法只能支持EXACTLY模式。如果要让自定义view支持wrap_content属性，必须重写onMeasure方法来指定wrap_content时的大小。</p>\n<h2 id=\"测量的步骤\"><a href=\"#测量的步骤\" class=\"headerlink\" title=\"测量的步骤\"></a>测量的步骤</h2><ol>\n<li>从MeasureSpec对象中提取具体的测量模式和大小</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int specMode = MeasureSpec.getMode(measureSpec);</span><br><span class=\"line\">int specSize = MeasureSpec.getSize(measureSpec);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>通过判断测量的模式，给出不同的判断值。当specMode为EXACTLY时，直接使用指定的specSize即可；当specMode为其他两种模式时，需要给它一个默认的大小。特别的，如果指定wrap_content属性，即AT_MOST模式，需要取出我们制定的大小与specSize中最小的一个来作为最后的测量值。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int measureWidth(int measureSpec)&#123;</span><br><span class=\"line\">\tint result = 0;</span><br><span class=\"line\">\tint specMode = MeasureSpec.getMode(measureSpec);</span><br><span class=\"line\">\tint specSize = MeasureSpec.getSize(measureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">\tif(specMode == MeasureSpec.EXACTLY)&#123;</span><br><span class=\"line\">\t\tresult = specSize;</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">\t\tresult = 200;</span><br><span class=\"line\">\t\tif(specMpde == MeasureSpec.AT_MOST)&#123;</span><br><span class=\"line\">\t\t\tresult = Math.min(result, specSize);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"virtual-app学习","date":"2019-02-21T14:12:08.000Z","_content":"","source":"_posts/virtual-app学习.md","raw":"---\ntitle: virtual-app学习\ndate: 2019-02-21 22:12:08\ntags:\n---\n","slug":"virtual-app学习","published":1,"updated":"2019-03-12T09:26:33.163Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttyo00493a8kp6b17zjq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"为什么在activity触发ondestroy的时候内部类可能产生泄露","date":"2018-10-21T10:41:36.000Z","_content":"基于内部类的泄露是android泄露的一个很常见的问题。\n\n这方面自从使用了rxjava之后有很多好转，凡是内部类的我都会转换成为observable然后bindtolifecycle，这样通过生命周期的强制绑定，能够一定程度上面减少泄露发生的问题。\n\n在lifecycle中，一般如果不指明的话，在start时订阅的事件将会在stop的时候dispose，在resume时订阅的事件将会在pause的时候dispose。\n\n```\nswitch (lastEvent) {\n                case CREATE:\n                    return ActivityEvent.DESTROY;\n                case START:\n                    return ActivityEvent.STOP;\n                case RESUME:\n                    return ActivityEvent.PAUSE;\n                case PAUSE:\n                    return ActivityEvent.STOP;\n                case STOP:\n                    return ActivityEvent.DESTROY;\n                case DESTROY:\n                    throw new OutsideLifecycleException(\"Cannot bind to Activity lifecycle when outside of it.\");\n                default:\n                    throw new UnsupportedOperationException(\"Binding to \" + lastEvent + \" not yet implemented\");\n            }\n```\n\n生命周期就是上面这种，lifecycle在必要的地方做了很详细的处理，通过lifecyclesubject来根据绑定的生命周期来不断的发送接下来的activityevent（生命周期事件）。直到当发送下来一个取消的通知，之后就会取消订阅。\n\nlifecycle的确很好用，但是没有办法所有的地方都使用到rxjava。因此关于内部类的泄露还是要明确讨论一下。\n\n\n# 内部类泄露\n\n\n回到内部类泄露的地方。android的内部类分为静态内部类和非静态内部类，内部类又分一些匿名的，成员的等等。非静态内部类会潜在的持有外部类的引用，因此当有耗时操作的时候，就会导致外部类的泄露。\n\nactivity在ondestroy的时候，凡是引用到他的内部类，假如没有结束的话，就会导致activity被泄露，因为activity是被强引用。\n\n解决的方法其实看来很简单，1.在activity结束的时候强制释放掉2.将对activity的引用改为弱引用。\n\n# 引用细分\n\n引用只有四种：强引用（内存泄露罪魁祸首），软引用，弱引用，虚引用。\n\n一般将强引用转化为弱引用即可避免强制引用带来的锅。\n\n\n# loginChecker优化\n\n代码中为了方便做登录的检查，同时为了防止包过大，没有使用切片，而是写了一个loginchecker辅助类\n\n```\npackage com.haomaiyi.base.util;\n\nimport android.annotation.SuppressLint;\nimport android.app.Activity;\nimport android.text.TextUtils;\n\nimport com.haomaiyi.base.updatemanager.Logger;\nimport com.haomaiyi.fittingroom.AppApplication;\nimport com.haomaiyi.fittingroom.domain.interactor.account.GetCurrentAccount;\nimport com.haomaiyi.fittingroom.domain.model.account.Account;\nimport com.haomaiyi.fittingroom.domain.model.account.AnonymousAccount;\nimport com.haomaiyi.fittingroom.ui.LoginActivity;\nimport com.orhanobut.hawk.Hawk;\nimport com.trello.rxlifecycle2.LifecycleProvider;\n\nimport javax.inject.Inject;\n\nimport io.reactivex.Observable;\nimport io.reactivex.android.schedulers.AndroidSchedulers;\nimport io.reactivex.schedulers.Schedulers;\n\n@SuppressLint(\"CheckResult\")\npublic class LoginChecker {\n\n    private static LoginChecker instance;\n    public LoginProceed proceed;\n    @Inject\n    GetCurrentAccount getCurrentAccount;\n    //    private boolean loginStat = false;\n    private int uid = -1;\n    private boolean logSuccess = false;\n\n    public LoginChecker() {\n        AppApplication.getInstance().getUserComponent().inject(this);\n    }\n\n    public static LoginChecker getInstance() {\n        if (instance == null) {\n            synchronized (LoginChecker.class) {\n                if (instance == null) {\n                    instance = new LoginChecker();\n                }\n            }\n        }\n        return instance;\n    }\n\n    public void onLoginStart() {\n        logSuccess = false;\n    }\n\n    public void onLoginFinish() {\n        // TODO: 2018/9/30\n    }\n\n    public LgnStat getLoginStat() {\n        Account ac = getCurrentAccount.executeSync();\n        LgnStat stat;\n        if (ac instanceof AnonymousAccount) {\n            stat = LgnStat.ANONYMOUS;\n        } else if (TextUtils.isEmpty(ac.getPhonenumber())) {\n            stat = LgnStat.NEED_NUMBER;\n        } else {\n            stat = LgnStat.COMPLETE;\n        }\n        return stat;\n    }\n\n    public int getUid() {\n        uid = getCurrentAccount.executeSync().getId();\n        return uid;\n    }\n\n    public void setUid(int uid) {\n        this.uid = uid;\n    }\n\n    public void check(LifecycleProvider lifecycle, LoginCallback callback) {\n\n        final Observable<Account> ob = getCurrentAccount.getObservable()\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread());\n\n        if (lifecycle != null)\n            ob.compose(lifecycle.bindToLifecycle());\n\n        ob.subscribe(ac -> {\n            uid = ac.getId();\n            LgnStat stat;\n            if (ac instanceof AnonymousAccount) {\n                stat = LgnStat.ANONYMOUS;\n            } else if (TextUtils.isEmpty(ac.getPhonenumber())) {\n                stat = LgnStat.NEED_NUMBER;\n            } else {\n                stat = LgnStat.COMPLETE;\n            }\n            callback.onLogin(stat);\n        });\n    }\n\n    public void loginAndproceed(Activity src, LifecycleProvider lifecycleProvider, LoginProceed proceed) {\n        Logger.i(\"check=\" + this);\n        check(lifecycleProvider, new LoginCallback() {\n            @Override\n            public void onLogin(LgnStat stat) {\n                switch (stat) {\n                    case ANONYMOUS:\n                        LoginChecker.this.proceed = proceed;\n                        LoginActivity.start(src);\n                        break;\n                    case NEED_NUMBER:\n                        LoginChecker.this.proceed = proceed;\n                        LoginActivity.start(src, LgnStat.NEED_NUMBER);\n                        break;\n                    case COMPLETE:\n                        proceed.onProceed();\n                        break;\n                }\n            }\n        });\n    }\n\n    /**\n     * Must be called after cancel login behavior.\n     */\n    public void clear() {\n        proceed = null;\n    }\n\n    /**\n     * Must be called after login success.\n     */\n    public boolean consume(int id, LoginActivity act) {\n        uid = id;\n        Hawk.put(\"SHOW_GIFT\", true);\n        if (proceed == null)\n            return false;\n        proceed.onLoginAndProceed(id, act);\n        proceed = null;\n        return true;\n    }\n\n    public enum LgnStat {\n        // 匿名用户\n        ANONYMOUS,\n        // 有手机号\n        COMPLETE,\n        // 无手机号\n        NEED_NUMBER\n    }\n\n    public interface LoginProceed {\n        void onProceed();\n\n        void onLoginAndProceed(int id, LoginActivity act);\n    }\n\n    public interface LoginCallback {\n        void onLogin(LgnStat loginStat);\n    }\n}\n```\n\n这个类虽然不是内部类，但是其携带的内部类以接口形式获取了activity，以activity作为实例，做了一些别的事情。而且有个最重要的问题，就是启动loginactivity的时候使用的是获取的实例。同时整个类又绑定了lifecycle。这就导致了一个很有趣的问题，就是当使用实例来启动的时候触发了onpause和onstop，此时刚好gc，导致无法回收。\n\n因此此时需要更改几个地方，一是不在使用原来传过来的activity，改用application的context，这样就不会再出现强制捆绑的地方。其次是将该类中使用到的任何引用的地方改成weakreference。atu","source":"_posts/为什么在activity触发ondestroy的时候内部类可能产生泄露.md","raw":"---\ntitle: 为什么在activity触发ondestroy的时候内部类可能产生泄露\ndate: 2018-10-21 18:41:36\ntags:\n---\n基于内部类的泄露是android泄露的一个很常见的问题。\n\n这方面自从使用了rxjava之后有很多好转，凡是内部类的我都会转换成为observable然后bindtolifecycle，这样通过生命周期的强制绑定，能够一定程度上面减少泄露发生的问题。\n\n在lifecycle中，一般如果不指明的话，在start时订阅的事件将会在stop的时候dispose，在resume时订阅的事件将会在pause的时候dispose。\n\n```\nswitch (lastEvent) {\n                case CREATE:\n                    return ActivityEvent.DESTROY;\n                case START:\n                    return ActivityEvent.STOP;\n                case RESUME:\n                    return ActivityEvent.PAUSE;\n                case PAUSE:\n                    return ActivityEvent.STOP;\n                case STOP:\n                    return ActivityEvent.DESTROY;\n                case DESTROY:\n                    throw new OutsideLifecycleException(\"Cannot bind to Activity lifecycle when outside of it.\");\n                default:\n                    throw new UnsupportedOperationException(\"Binding to \" + lastEvent + \" not yet implemented\");\n            }\n```\n\n生命周期就是上面这种，lifecycle在必要的地方做了很详细的处理，通过lifecyclesubject来根据绑定的生命周期来不断的发送接下来的activityevent（生命周期事件）。直到当发送下来一个取消的通知，之后就会取消订阅。\n\nlifecycle的确很好用，但是没有办法所有的地方都使用到rxjava。因此关于内部类的泄露还是要明确讨论一下。\n\n\n# 内部类泄露\n\n\n回到内部类泄露的地方。android的内部类分为静态内部类和非静态内部类，内部类又分一些匿名的，成员的等等。非静态内部类会潜在的持有外部类的引用，因此当有耗时操作的时候，就会导致外部类的泄露。\n\nactivity在ondestroy的时候，凡是引用到他的内部类，假如没有结束的话，就会导致activity被泄露，因为activity是被强引用。\n\n解决的方法其实看来很简单，1.在activity结束的时候强制释放掉2.将对activity的引用改为弱引用。\n\n# 引用细分\n\n引用只有四种：强引用（内存泄露罪魁祸首），软引用，弱引用，虚引用。\n\n一般将强引用转化为弱引用即可避免强制引用带来的锅。\n\n\n# loginChecker优化\n\n代码中为了方便做登录的检查，同时为了防止包过大，没有使用切片，而是写了一个loginchecker辅助类\n\n```\npackage com.haomaiyi.base.util;\n\nimport android.annotation.SuppressLint;\nimport android.app.Activity;\nimport android.text.TextUtils;\n\nimport com.haomaiyi.base.updatemanager.Logger;\nimport com.haomaiyi.fittingroom.AppApplication;\nimport com.haomaiyi.fittingroom.domain.interactor.account.GetCurrentAccount;\nimport com.haomaiyi.fittingroom.domain.model.account.Account;\nimport com.haomaiyi.fittingroom.domain.model.account.AnonymousAccount;\nimport com.haomaiyi.fittingroom.ui.LoginActivity;\nimport com.orhanobut.hawk.Hawk;\nimport com.trello.rxlifecycle2.LifecycleProvider;\n\nimport javax.inject.Inject;\n\nimport io.reactivex.Observable;\nimport io.reactivex.android.schedulers.AndroidSchedulers;\nimport io.reactivex.schedulers.Schedulers;\n\n@SuppressLint(\"CheckResult\")\npublic class LoginChecker {\n\n    private static LoginChecker instance;\n    public LoginProceed proceed;\n    @Inject\n    GetCurrentAccount getCurrentAccount;\n    //    private boolean loginStat = false;\n    private int uid = -1;\n    private boolean logSuccess = false;\n\n    public LoginChecker() {\n        AppApplication.getInstance().getUserComponent().inject(this);\n    }\n\n    public static LoginChecker getInstance() {\n        if (instance == null) {\n            synchronized (LoginChecker.class) {\n                if (instance == null) {\n                    instance = new LoginChecker();\n                }\n            }\n        }\n        return instance;\n    }\n\n    public void onLoginStart() {\n        logSuccess = false;\n    }\n\n    public void onLoginFinish() {\n        // TODO: 2018/9/30\n    }\n\n    public LgnStat getLoginStat() {\n        Account ac = getCurrentAccount.executeSync();\n        LgnStat stat;\n        if (ac instanceof AnonymousAccount) {\n            stat = LgnStat.ANONYMOUS;\n        } else if (TextUtils.isEmpty(ac.getPhonenumber())) {\n            stat = LgnStat.NEED_NUMBER;\n        } else {\n            stat = LgnStat.COMPLETE;\n        }\n        return stat;\n    }\n\n    public int getUid() {\n        uid = getCurrentAccount.executeSync().getId();\n        return uid;\n    }\n\n    public void setUid(int uid) {\n        this.uid = uid;\n    }\n\n    public void check(LifecycleProvider lifecycle, LoginCallback callback) {\n\n        final Observable<Account> ob = getCurrentAccount.getObservable()\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread());\n\n        if (lifecycle != null)\n            ob.compose(lifecycle.bindToLifecycle());\n\n        ob.subscribe(ac -> {\n            uid = ac.getId();\n            LgnStat stat;\n            if (ac instanceof AnonymousAccount) {\n                stat = LgnStat.ANONYMOUS;\n            } else if (TextUtils.isEmpty(ac.getPhonenumber())) {\n                stat = LgnStat.NEED_NUMBER;\n            } else {\n                stat = LgnStat.COMPLETE;\n            }\n            callback.onLogin(stat);\n        });\n    }\n\n    public void loginAndproceed(Activity src, LifecycleProvider lifecycleProvider, LoginProceed proceed) {\n        Logger.i(\"check=\" + this);\n        check(lifecycleProvider, new LoginCallback() {\n            @Override\n            public void onLogin(LgnStat stat) {\n                switch (stat) {\n                    case ANONYMOUS:\n                        LoginChecker.this.proceed = proceed;\n                        LoginActivity.start(src);\n                        break;\n                    case NEED_NUMBER:\n                        LoginChecker.this.proceed = proceed;\n                        LoginActivity.start(src, LgnStat.NEED_NUMBER);\n                        break;\n                    case COMPLETE:\n                        proceed.onProceed();\n                        break;\n                }\n            }\n        });\n    }\n\n    /**\n     * Must be called after cancel login behavior.\n     */\n    public void clear() {\n        proceed = null;\n    }\n\n    /**\n     * Must be called after login success.\n     */\n    public boolean consume(int id, LoginActivity act) {\n        uid = id;\n        Hawk.put(\"SHOW_GIFT\", true);\n        if (proceed == null)\n            return false;\n        proceed.onLoginAndProceed(id, act);\n        proceed = null;\n        return true;\n    }\n\n    public enum LgnStat {\n        // 匿名用户\n        ANONYMOUS,\n        // 有手机号\n        COMPLETE,\n        // 无手机号\n        NEED_NUMBER\n    }\n\n    public interface LoginProceed {\n        void onProceed();\n\n        void onLoginAndProceed(int id, LoginActivity act);\n    }\n\n    public interface LoginCallback {\n        void onLogin(LgnStat loginStat);\n    }\n}\n```\n\n这个类虽然不是内部类，但是其携带的内部类以接口形式获取了activity，以activity作为实例，做了一些别的事情。而且有个最重要的问题，就是启动loginactivity的时候使用的是获取的实例。同时整个类又绑定了lifecycle。这就导致了一个很有趣的问题，就是当使用实例来启动的时候触发了onpause和onstop，此时刚好gc，导致无法回收。\n\n因此此时需要更改几个地方，一是不在使用原来传过来的activity，改用application的context，这样就不会再出现强制捆绑的地方。其次是将该类中使用到的任何引用的地方改成weakreference。atu","slug":"为什么在activity触发ondestroy的时候内部类可能产生泄露","published":1,"updated":"2019-03-12T09:26:33.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttyp004c3a8ke1lhmdn2","content":"<p>基于内部类的泄露是android泄露的一个很常见的问题。</p>\n<p>这方面自从使用了rxjava之后有很多好转，凡是内部类的我都会转换成为observable然后bindtolifecycle，这样通过生命周期的强制绑定，能够一定程度上面减少泄露发生的问题。</p>\n<p>在lifecycle中，一般如果不指明的话，在start时订阅的事件将会在stop的时候dispose，在resume时订阅的事件将会在pause的时候dispose。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch (lastEvent) &#123;</span><br><span class=\"line\">                case CREATE:</span><br><span class=\"line\">                    return ActivityEvent.DESTROY;</span><br><span class=\"line\">                case START:</span><br><span class=\"line\">                    return ActivityEvent.STOP;</span><br><span class=\"line\">                case RESUME:</span><br><span class=\"line\">                    return ActivityEvent.PAUSE;</span><br><span class=\"line\">                case PAUSE:</span><br><span class=\"line\">                    return ActivityEvent.STOP;</span><br><span class=\"line\">                case STOP:</span><br><span class=\"line\">                    return ActivityEvent.DESTROY;</span><br><span class=\"line\">                case DESTROY:</span><br><span class=\"line\">                    throw new OutsideLifecycleException(&quot;Cannot bind to Activity lifecycle when outside of it.&quot;);</span><br><span class=\"line\">                default:</span><br><span class=\"line\">                    throw new UnsupportedOperationException(&quot;Binding to &quot; + lastEvent + &quot; not yet implemented&quot;);</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<p>生命周期就是上面这种，lifecycle在必要的地方做了很详细的处理，通过lifecyclesubject来根据绑定的生命周期来不断的发送接下来的activityevent（生命周期事件）。直到当发送下来一个取消的通知，之后就会取消订阅。</p>\n<p>lifecycle的确很好用，但是没有办法所有的地方都使用到rxjava。因此关于内部类的泄露还是要明确讨论一下。</p>\n<h1 id=\"内部类泄露\"><a href=\"#内部类泄露\" class=\"headerlink\" title=\"内部类泄露\"></a>内部类泄露</h1><p>回到内部类泄露的地方。android的内部类分为静态内部类和非静态内部类，内部类又分一些匿名的，成员的等等。非静态内部类会潜在的持有外部类的引用，因此当有耗时操作的时候，就会导致外部类的泄露。</p>\n<p>activity在ondestroy的时候，凡是引用到他的内部类，假如没有结束的话，就会导致activity被泄露，因为activity是被强引用。</p>\n<p>解决的方法其实看来很简单，1.在activity结束的时候强制释放掉2.将对activity的引用改为弱引用。</p>\n<h1 id=\"引用细分\"><a href=\"#引用细分\" class=\"headerlink\" title=\"引用细分\"></a>引用细分</h1><p>引用只有四种：强引用（内存泄露罪魁祸首），软引用，弱引用，虚引用。</p>\n<p>一般将强引用转化为弱引用即可避免强制引用带来的锅。</p>\n<h1 id=\"loginChecker优化\"><a href=\"#loginChecker优化\" class=\"headerlink\" title=\"loginChecker优化\"></a>loginChecker优化</h1><p>代码中为了方便做登录的检查，同时为了防止包过大，没有使用切片，而是写了一个loginchecker辅助类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.haomaiyi.base.util;</span><br><span class=\"line\"></span><br><span class=\"line\">import android.annotation.SuppressLint;</span><br><span class=\"line\">import android.app.Activity;</span><br><span class=\"line\">import android.text.TextUtils;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.haomaiyi.base.updatemanager.Logger;</span><br><span class=\"line\">import com.haomaiyi.fittingroom.AppApplication;</span><br><span class=\"line\">import com.haomaiyi.fittingroom.domain.interactor.account.GetCurrentAccount;</span><br><span class=\"line\">import com.haomaiyi.fittingroom.domain.model.account.Account;</span><br><span class=\"line\">import com.haomaiyi.fittingroom.domain.model.account.AnonymousAccount;</span><br><span class=\"line\">import com.haomaiyi.fittingroom.ui.LoginActivity;</span><br><span class=\"line\">import com.orhanobut.hawk.Hawk;</span><br><span class=\"line\">import com.trello.rxlifecycle2.LifecycleProvider;</span><br><span class=\"line\"></span><br><span class=\"line\">import javax.inject.Inject;</span><br><span class=\"line\"></span><br><span class=\"line\">import io.reactivex.Observable;</span><br><span class=\"line\">import io.reactivex.android.schedulers.AndroidSchedulers;</span><br><span class=\"line\">import io.reactivex.schedulers.Schedulers;</span><br><span class=\"line\"></span><br><span class=\"line\">@SuppressLint(&quot;CheckResult&quot;)</span><br><span class=\"line\">public class LoginChecker &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static LoginChecker instance;</span><br><span class=\"line\">    public LoginProceed proceed;</span><br><span class=\"line\">    @Inject</span><br><span class=\"line\">    GetCurrentAccount getCurrentAccount;</span><br><span class=\"line\">    //    private boolean loginStat = false;</span><br><span class=\"line\">    private int uid = -1;</span><br><span class=\"line\">    private boolean logSuccess = false;</span><br><span class=\"line\"></span><br><span class=\"line\">    public LoginChecker() &#123;</span><br><span class=\"line\">        AppApplication.getInstance().getUserComponent().inject(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static LoginChecker getInstance() &#123;</span><br><span class=\"line\">        if (instance == null) &#123;</span><br><span class=\"line\">            synchronized (LoginChecker.class) &#123;</span><br><span class=\"line\">                if (instance == null) &#123;</span><br><span class=\"line\">                    instance = new LoginChecker();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void onLoginStart() &#123;</span><br><span class=\"line\">        logSuccess = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void onLoginFinish() &#123;</span><br><span class=\"line\">        // TODO: 2018/9/30</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public LgnStat getLoginStat() &#123;</span><br><span class=\"line\">        Account ac = getCurrentAccount.executeSync();</span><br><span class=\"line\">        LgnStat stat;</span><br><span class=\"line\">        if (ac instanceof AnonymousAccount) &#123;</span><br><span class=\"line\">            stat = LgnStat.ANONYMOUS;</span><br><span class=\"line\">        &#125; else if (TextUtils.isEmpty(ac.getPhonenumber())) &#123;</span><br><span class=\"line\">            stat = LgnStat.NEED_NUMBER;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            stat = LgnStat.COMPLETE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return stat;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getUid() &#123;</span><br><span class=\"line\">        uid = getCurrentAccount.executeSync().getId();</span><br><span class=\"line\">        return uid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUid(int uid) &#123;</span><br><span class=\"line\">        this.uid = uid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void check(LifecycleProvider lifecycle, LoginCallback callback) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        final Observable&lt;Account&gt; ob = getCurrentAccount.getObservable()</span><br><span class=\"line\">                .subscribeOn(Schedulers.io())</span><br><span class=\"line\">                .observeOn(AndroidSchedulers.mainThread());</span><br><span class=\"line\"></span><br><span class=\"line\">        if (lifecycle != null)</span><br><span class=\"line\">            ob.compose(lifecycle.bindToLifecycle());</span><br><span class=\"line\"></span><br><span class=\"line\">        ob.subscribe(ac -&gt; &#123;</span><br><span class=\"line\">            uid = ac.getId();</span><br><span class=\"line\">            LgnStat stat;</span><br><span class=\"line\">            if (ac instanceof AnonymousAccount) &#123;</span><br><span class=\"line\">                stat = LgnStat.ANONYMOUS;</span><br><span class=\"line\">            &#125; else if (TextUtils.isEmpty(ac.getPhonenumber())) &#123;</span><br><span class=\"line\">                stat = LgnStat.NEED_NUMBER;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                stat = LgnStat.COMPLETE;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            callback.onLogin(stat);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void loginAndproceed(Activity src, LifecycleProvider lifecycleProvider, LoginProceed proceed) &#123;</span><br><span class=\"line\">        Logger.i(&quot;check=&quot; + this);</span><br><span class=\"line\">        check(lifecycleProvider, new LoginCallback() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onLogin(LgnStat stat) &#123;</span><br><span class=\"line\">                switch (stat) &#123;</span><br><span class=\"line\">                    case ANONYMOUS:</span><br><span class=\"line\">                        LoginChecker.this.proceed = proceed;</span><br><span class=\"line\">                        LoginActivity.start(src);</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case NEED_NUMBER:</span><br><span class=\"line\">                        LoginChecker.this.proceed = proceed;</span><br><span class=\"line\">                        LoginActivity.start(src, LgnStat.NEED_NUMBER);</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case COMPLETE:</span><br><span class=\"line\">                        proceed.onProceed();</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Must be called after cancel login behavior.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void clear() &#123;</span><br><span class=\"line\">        proceed = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Must be called after login success.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public boolean consume(int id, LoginActivity act) &#123;</span><br><span class=\"line\">        uid = id;</span><br><span class=\"line\">        Hawk.put(&quot;SHOW_GIFT&quot;, true);</span><br><span class=\"line\">        if (proceed == null)</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        proceed.onLoginAndProceed(id, act);</span><br><span class=\"line\">        proceed = null;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public enum LgnStat &#123;</span><br><span class=\"line\">        // 匿名用户</span><br><span class=\"line\">        ANONYMOUS,</span><br><span class=\"line\">        // 有手机号</span><br><span class=\"line\">        COMPLETE,</span><br><span class=\"line\">        // 无手机号</span><br><span class=\"line\">        NEED_NUMBER</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public interface LoginProceed &#123;</span><br><span class=\"line\">        void onProceed();</span><br><span class=\"line\"></span><br><span class=\"line\">        void onLoginAndProceed(int id, LoginActivity act);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public interface LoginCallback &#123;</span><br><span class=\"line\">        void onLogin(LgnStat loginStat);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个类虽然不是内部类，但是其携带的内部类以接口形式获取了activity，以activity作为实例，做了一些别的事情。而且有个最重要的问题，就是启动loginactivity的时候使用的是获取的实例。同时整个类又绑定了lifecycle。这就导致了一个很有趣的问题，就是当使用实例来启动的时候触发了onpause和onstop，此时刚好gc，导致无法回收。</p>\n<p>因此此时需要更改几个地方，一是不在使用原来传过来的activity，改用application的context，这样就不会再出现强制捆绑的地方。其次是将该类中使用到的任何引用的地方改成weakreference。atu</p>\n","site":{"data":{}},"excerpt":"","more":"<p>基于内部类的泄露是android泄露的一个很常见的问题。</p>\n<p>这方面自从使用了rxjava之后有很多好转，凡是内部类的我都会转换成为observable然后bindtolifecycle，这样通过生命周期的强制绑定，能够一定程度上面减少泄露发生的问题。</p>\n<p>在lifecycle中，一般如果不指明的话，在start时订阅的事件将会在stop的时候dispose，在resume时订阅的事件将会在pause的时候dispose。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch (lastEvent) &#123;</span><br><span class=\"line\">                case CREATE:</span><br><span class=\"line\">                    return ActivityEvent.DESTROY;</span><br><span class=\"line\">                case START:</span><br><span class=\"line\">                    return ActivityEvent.STOP;</span><br><span class=\"line\">                case RESUME:</span><br><span class=\"line\">                    return ActivityEvent.PAUSE;</span><br><span class=\"line\">                case PAUSE:</span><br><span class=\"line\">                    return ActivityEvent.STOP;</span><br><span class=\"line\">                case STOP:</span><br><span class=\"line\">                    return ActivityEvent.DESTROY;</span><br><span class=\"line\">                case DESTROY:</span><br><span class=\"line\">                    throw new OutsideLifecycleException(&quot;Cannot bind to Activity lifecycle when outside of it.&quot;);</span><br><span class=\"line\">                default:</span><br><span class=\"line\">                    throw new UnsupportedOperationException(&quot;Binding to &quot; + lastEvent + &quot; not yet implemented&quot;);</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<p>生命周期就是上面这种，lifecycle在必要的地方做了很详细的处理，通过lifecyclesubject来根据绑定的生命周期来不断的发送接下来的activityevent（生命周期事件）。直到当发送下来一个取消的通知，之后就会取消订阅。</p>\n<p>lifecycle的确很好用，但是没有办法所有的地方都使用到rxjava。因此关于内部类的泄露还是要明确讨论一下。</p>\n<h1 id=\"内部类泄露\"><a href=\"#内部类泄露\" class=\"headerlink\" title=\"内部类泄露\"></a>内部类泄露</h1><p>回到内部类泄露的地方。android的内部类分为静态内部类和非静态内部类，内部类又分一些匿名的，成员的等等。非静态内部类会潜在的持有外部类的引用，因此当有耗时操作的时候，就会导致外部类的泄露。</p>\n<p>activity在ondestroy的时候，凡是引用到他的内部类，假如没有结束的话，就会导致activity被泄露，因为activity是被强引用。</p>\n<p>解决的方法其实看来很简单，1.在activity结束的时候强制释放掉2.将对activity的引用改为弱引用。</p>\n<h1 id=\"引用细分\"><a href=\"#引用细分\" class=\"headerlink\" title=\"引用细分\"></a>引用细分</h1><p>引用只有四种：强引用（内存泄露罪魁祸首），软引用，弱引用，虚引用。</p>\n<p>一般将强引用转化为弱引用即可避免强制引用带来的锅。</p>\n<h1 id=\"loginChecker优化\"><a href=\"#loginChecker优化\" class=\"headerlink\" title=\"loginChecker优化\"></a>loginChecker优化</h1><p>代码中为了方便做登录的检查，同时为了防止包过大，没有使用切片，而是写了一个loginchecker辅助类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.haomaiyi.base.util;</span><br><span class=\"line\"></span><br><span class=\"line\">import android.annotation.SuppressLint;</span><br><span class=\"line\">import android.app.Activity;</span><br><span class=\"line\">import android.text.TextUtils;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.haomaiyi.base.updatemanager.Logger;</span><br><span class=\"line\">import com.haomaiyi.fittingroom.AppApplication;</span><br><span class=\"line\">import com.haomaiyi.fittingroom.domain.interactor.account.GetCurrentAccount;</span><br><span class=\"line\">import com.haomaiyi.fittingroom.domain.model.account.Account;</span><br><span class=\"line\">import com.haomaiyi.fittingroom.domain.model.account.AnonymousAccount;</span><br><span class=\"line\">import com.haomaiyi.fittingroom.ui.LoginActivity;</span><br><span class=\"line\">import com.orhanobut.hawk.Hawk;</span><br><span class=\"line\">import com.trello.rxlifecycle2.LifecycleProvider;</span><br><span class=\"line\"></span><br><span class=\"line\">import javax.inject.Inject;</span><br><span class=\"line\"></span><br><span class=\"line\">import io.reactivex.Observable;</span><br><span class=\"line\">import io.reactivex.android.schedulers.AndroidSchedulers;</span><br><span class=\"line\">import io.reactivex.schedulers.Schedulers;</span><br><span class=\"line\"></span><br><span class=\"line\">@SuppressLint(&quot;CheckResult&quot;)</span><br><span class=\"line\">public class LoginChecker &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static LoginChecker instance;</span><br><span class=\"line\">    public LoginProceed proceed;</span><br><span class=\"line\">    @Inject</span><br><span class=\"line\">    GetCurrentAccount getCurrentAccount;</span><br><span class=\"line\">    //    private boolean loginStat = false;</span><br><span class=\"line\">    private int uid = -1;</span><br><span class=\"line\">    private boolean logSuccess = false;</span><br><span class=\"line\"></span><br><span class=\"line\">    public LoginChecker() &#123;</span><br><span class=\"line\">        AppApplication.getInstance().getUserComponent().inject(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static LoginChecker getInstance() &#123;</span><br><span class=\"line\">        if (instance == null) &#123;</span><br><span class=\"line\">            synchronized (LoginChecker.class) &#123;</span><br><span class=\"line\">                if (instance == null) &#123;</span><br><span class=\"line\">                    instance = new LoginChecker();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void onLoginStart() &#123;</span><br><span class=\"line\">        logSuccess = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void onLoginFinish() &#123;</span><br><span class=\"line\">        // TODO: 2018/9/30</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public LgnStat getLoginStat() &#123;</span><br><span class=\"line\">        Account ac = getCurrentAccount.executeSync();</span><br><span class=\"line\">        LgnStat stat;</span><br><span class=\"line\">        if (ac instanceof AnonymousAccount) &#123;</span><br><span class=\"line\">            stat = LgnStat.ANONYMOUS;</span><br><span class=\"line\">        &#125; else if (TextUtils.isEmpty(ac.getPhonenumber())) &#123;</span><br><span class=\"line\">            stat = LgnStat.NEED_NUMBER;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            stat = LgnStat.COMPLETE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return stat;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getUid() &#123;</span><br><span class=\"line\">        uid = getCurrentAccount.executeSync().getId();</span><br><span class=\"line\">        return uid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUid(int uid) &#123;</span><br><span class=\"line\">        this.uid = uid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void check(LifecycleProvider lifecycle, LoginCallback callback) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        final Observable&lt;Account&gt; ob = getCurrentAccount.getObservable()</span><br><span class=\"line\">                .subscribeOn(Schedulers.io())</span><br><span class=\"line\">                .observeOn(AndroidSchedulers.mainThread());</span><br><span class=\"line\"></span><br><span class=\"line\">        if (lifecycle != null)</span><br><span class=\"line\">            ob.compose(lifecycle.bindToLifecycle());</span><br><span class=\"line\"></span><br><span class=\"line\">        ob.subscribe(ac -&gt; &#123;</span><br><span class=\"line\">            uid = ac.getId();</span><br><span class=\"line\">            LgnStat stat;</span><br><span class=\"line\">            if (ac instanceof AnonymousAccount) &#123;</span><br><span class=\"line\">                stat = LgnStat.ANONYMOUS;</span><br><span class=\"line\">            &#125; else if (TextUtils.isEmpty(ac.getPhonenumber())) &#123;</span><br><span class=\"line\">                stat = LgnStat.NEED_NUMBER;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                stat = LgnStat.COMPLETE;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            callback.onLogin(stat);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void loginAndproceed(Activity src, LifecycleProvider lifecycleProvider, LoginProceed proceed) &#123;</span><br><span class=\"line\">        Logger.i(&quot;check=&quot; + this);</span><br><span class=\"line\">        check(lifecycleProvider, new LoginCallback() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onLogin(LgnStat stat) &#123;</span><br><span class=\"line\">                switch (stat) &#123;</span><br><span class=\"line\">                    case ANONYMOUS:</span><br><span class=\"line\">                        LoginChecker.this.proceed = proceed;</span><br><span class=\"line\">                        LoginActivity.start(src);</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case NEED_NUMBER:</span><br><span class=\"line\">                        LoginChecker.this.proceed = proceed;</span><br><span class=\"line\">                        LoginActivity.start(src, LgnStat.NEED_NUMBER);</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case COMPLETE:</span><br><span class=\"line\">                        proceed.onProceed();</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Must be called after cancel login behavior.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void clear() &#123;</span><br><span class=\"line\">        proceed = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Must be called after login success.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public boolean consume(int id, LoginActivity act) &#123;</span><br><span class=\"line\">        uid = id;</span><br><span class=\"line\">        Hawk.put(&quot;SHOW_GIFT&quot;, true);</span><br><span class=\"line\">        if (proceed == null)</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        proceed.onLoginAndProceed(id, act);</span><br><span class=\"line\">        proceed = null;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public enum LgnStat &#123;</span><br><span class=\"line\">        // 匿名用户</span><br><span class=\"line\">        ANONYMOUS,</span><br><span class=\"line\">        // 有手机号</span><br><span class=\"line\">        COMPLETE,</span><br><span class=\"line\">        // 无手机号</span><br><span class=\"line\">        NEED_NUMBER</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public interface LoginProceed &#123;</span><br><span class=\"line\">        void onProceed();</span><br><span class=\"line\"></span><br><span class=\"line\">        void onLoginAndProceed(int id, LoginActivity act);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public interface LoginCallback &#123;</span><br><span class=\"line\">        void onLogin(LgnStat loginStat);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个类虽然不是内部类，但是其携带的内部类以接口形式获取了activity，以activity作为实例，做了一些别的事情。而且有个最重要的问题，就是启动loginactivity的时候使用的是获取的实例。同时整个类又绑定了lifecycle。这就导致了一个很有趣的问题，就是当使用实例来启动的时候触发了onpause和onstop，此时刚好gc，导致无法回收。</p>\n<p>因此此时需要更改几个地方，一是不在使用原来传过来的activity，改用application的context，这样就不会再出现强制捆绑的地方。其次是将该类中使用到的任何引用的地方改成weakreference。atu</p>\n"},{"title":"二路归并排序","date":"2018-12-30T08:30:42.000Z","_content":"\n# 算法思想\n\n利用递归，将原始序列不断两两分块，直到每块剩下一个元素，这个元素肯定是有序的。然后利用递归的原理合并即可\n\n# 空间复杂度\n\n空间复杂度应该从拆分上面来看，第一次拆分是1块拆成2快，第二次是2块拆成4块，第三次是4块拆成8块...第n次就是2^(n-1)拆成2^(n)块，总和应该是2^0+2^1+2^2...+2^n为O(n)\n\n# 时间复杂度\n\nO(nlgn)\n\n每层需要合并的总数为n，一共有logn层，故为nlogn\n\n\n# 算法实现思想\n\n首先使用类似于后序遍历的方式，将数组不断的分割，最后在进行归并。\n\n归并的过程是：使用三根指针，第一根指向第一个子表首位元素，第二根指向第一个子表末尾元素，最后一根指向第二个子表末尾元素元素。\n在确保第一根位置小于第二根，第二根+1小于第三根的情况下，不断比较第一根和第二根的大小并做相应的替换，替换完毕之后2根指针同时++,直到第一根指针到达左侧最末尾或者第二根指针到达第三根指针位置，即可中断。\n\n\n# java实现\n\n```\n\tprivate static void mergeSort(int[] arr) {\n        mergeSort(arr, new int[arr.length], 0, arr.length - 1);\n    }\n\n    private static void mergeSort(int[] arr, int[] temp, int left, int right) {\n        if (left < right) {\n            int center = (left + right) / 2;\n            mergeSort(arr, temp, left, center); // 左边\n            mergeSort(arr, temp, center + 1, right); // 右边\n            merge(arr, temp, left, center + 1, right); // 合并两个有序 ett\n        }\n    }\n\n    private static void merge(int[] arr, int[] temp, int leftPos, int rightPos, int rightEnd) {\n        int leftEnd = rightPos - 1; // 左边结束下标\n        int tempPos = leftPos; // 从左边开始算\n        int numEle = rightEnd - leftPos + 1; // 元素个数\n        while (leftPos <= leftEnd && rightPos <= rightEnd) {\n            if (arr[leftPos] <= arr[rightPos])\n            \t//通过一个临时数组做存储，这样不需要使用temp对象做临时存储做转换，而是直接从最小的区块开始拷贝进去\n                temp[tempPos++] = arr[leftPos++];\n            else\n                temp[tempPos++] = arr[rightPos++];\n        }\n        while (leftPos <= leftEnd) {  // 左边如果有剩余\n            temp[tempPos++] = arr[leftPos++];\n        }\n        while (rightPos <= rightEnd) { // 右边如果有剩余\n            temp[tempPos++] = arr[rightPos++];\n        }\n        // 最后一步进行复制，复制的只有更改的几个数字\n        for (int i = 0; i < numEle; i++) {\n            arr[rightEnd] = temp[rightEnd];\n            rightEnd--;\n        }\n    }\n```\n\n\n# c实现\n\n# python实现","source":"_posts/二路归并排序.md","raw":"---\ntitle: 二路归并排序\ndate: 2018-12-30 16:30:42\ntags:\n---\n\n# 算法思想\n\n利用递归，将原始序列不断两两分块，直到每块剩下一个元素，这个元素肯定是有序的。然后利用递归的原理合并即可\n\n# 空间复杂度\n\n空间复杂度应该从拆分上面来看，第一次拆分是1块拆成2快，第二次是2块拆成4块，第三次是4块拆成8块...第n次就是2^(n-1)拆成2^(n)块，总和应该是2^0+2^1+2^2...+2^n为O(n)\n\n# 时间复杂度\n\nO(nlgn)\n\n每层需要合并的总数为n，一共有logn层，故为nlogn\n\n\n# 算法实现思想\n\n首先使用类似于后序遍历的方式，将数组不断的分割，最后在进行归并。\n\n归并的过程是：使用三根指针，第一根指向第一个子表首位元素，第二根指向第一个子表末尾元素，最后一根指向第二个子表末尾元素元素。\n在确保第一根位置小于第二根，第二根+1小于第三根的情况下，不断比较第一根和第二根的大小并做相应的替换，替换完毕之后2根指针同时++,直到第一根指针到达左侧最末尾或者第二根指针到达第三根指针位置，即可中断。\n\n\n# java实现\n\n```\n\tprivate static void mergeSort(int[] arr) {\n        mergeSort(arr, new int[arr.length], 0, arr.length - 1);\n    }\n\n    private static void mergeSort(int[] arr, int[] temp, int left, int right) {\n        if (left < right) {\n            int center = (left + right) / 2;\n            mergeSort(arr, temp, left, center); // 左边\n            mergeSort(arr, temp, center + 1, right); // 右边\n            merge(arr, temp, left, center + 1, right); // 合并两个有序 ett\n        }\n    }\n\n    private static void merge(int[] arr, int[] temp, int leftPos, int rightPos, int rightEnd) {\n        int leftEnd = rightPos - 1; // 左边结束下标\n        int tempPos = leftPos; // 从左边开始算\n        int numEle = rightEnd - leftPos + 1; // 元素个数\n        while (leftPos <= leftEnd && rightPos <= rightEnd) {\n            if (arr[leftPos] <= arr[rightPos])\n            \t//通过一个临时数组做存储，这样不需要使用temp对象做临时存储做转换，而是直接从最小的区块开始拷贝进去\n                temp[tempPos++] = arr[leftPos++];\n            else\n                temp[tempPos++] = arr[rightPos++];\n        }\n        while (leftPos <= leftEnd) {  // 左边如果有剩余\n            temp[tempPos++] = arr[leftPos++];\n        }\n        while (rightPos <= rightEnd) { // 右边如果有剩余\n            temp[tempPos++] = arr[rightPos++];\n        }\n        // 最后一步进行复制，复制的只有更改的几个数字\n        for (int i = 0; i < numEle; i++) {\n            arr[rightEnd] = temp[rightEnd];\n            rightEnd--;\n        }\n    }\n```\n\n\n# c实现\n\n# python实现","slug":"二路归并排序","published":1,"updated":"2019-03-12T09:26:33.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttyq004e3a8ksip1v26h","content":"<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>利用递归，将原始序列不断两两分块，直到每块剩下一个元素，这个元素肯定是有序的。然后利用递归的原理合并即可</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>空间复杂度应该从拆分上面来看，第一次拆分是1块拆成2快，第二次是2块拆成4块，第三次是4块拆成8块…第n次就是2^(n-1)拆成2^(n)块，总和应该是2^0+2^1+2^2…+2^n为O(n)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>O(nlgn)</p>\n<p>每层需要合并的总数为n，一共有logn层，故为nlogn</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>首先使用类似于后序遍历的方式，将数组不断的分割，最后在进行归并。</p>\n<p>归并的过程是：使用三根指针，第一根指向第一个子表首位元素，第二根指向第一个子表末尾元素，最后一根指向第二个子表末尾元素元素。<br>在确保第一根位置小于第二根，第二根+1小于第三根的情况下，不断比较第一根和第二根的大小并做相应的替换，替换完毕之后2根指针同时++,直到第一根指针到达左侧最末尾或者第二根指针到达第三根指针位置，即可中断。</p>\n<h1 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static void mergeSort(int[] arr) &#123;</span><br><span class=\"line\">       mergeSort(arr, new int[arr.length], 0, arr.length - 1);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   private static void mergeSort(int[] arr, int[] temp, int left, int right) &#123;</span><br><span class=\"line\">       if (left &lt; right) &#123;</span><br><span class=\"line\">           int center = (left + right) / 2;</span><br><span class=\"line\">           mergeSort(arr, temp, left, center); // 左边</span><br><span class=\"line\">           mergeSort(arr, temp, center + 1, right); // 右边</span><br><span class=\"line\">           merge(arr, temp, left, center + 1, right); // 合并两个有序 ett</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   private static void merge(int[] arr, int[] temp, int leftPos, int rightPos, int rightEnd) &#123;</span><br><span class=\"line\">       int leftEnd = rightPos - 1; // 左边结束下标</span><br><span class=\"line\">       int tempPos = leftPos; // 从左边开始算</span><br><span class=\"line\">       int numEle = rightEnd - leftPos + 1; // 元素个数</span><br><span class=\"line\">       while (leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd) &#123;</span><br><span class=\"line\">           if (arr[leftPos] &lt;= arr[rightPos])</span><br><span class=\"line\">           \t//通过一个临时数组做存储，这样不需要使用temp对象做临时存储做转换，而是直接从最小的区块开始拷贝进去</span><br><span class=\"line\">               temp[tempPos++] = arr[leftPos++];</span><br><span class=\"line\">           else</span><br><span class=\"line\">               temp[tempPos++] = arr[rightPos++];</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       while (leftPos &lt;= leftEnd) &#123;  // 左边如果有剩余</span><br><span class=\"line\">           temp[tempPos++] = arr[leftPos++];</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       while (rightPos &lt;= rightEnd) &#123; // 右边如果有剩余</span><br><span class=\"line\">           temp[tempPos++] = arr[rightPos++];</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       // 最后一步进行复制，复制的只有更改的几个数字</span><br><span class=\"line\">       for (int i = 0; i &lt; numEle; i++) &#123;</span><br><span class=\"line\">           arr[rightEnd] = temp[rightEnd];</span><br><span class=\"line\">           rightEnd--;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h1><h1 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>利用递归，将原始序列不断两两分块，直到每块剩下一个元素，这个元素肯定是有序的。然后利用递归的原理合并即可</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>空间复杂度应该从拆分上面来看，第一次拆分是1块拆成2快，第二次是2块拆成4块，第三次是4块拆成8块…第n次就是2^(n-1)拆成2^(n)块，总和应该是2^0+2^1+2^2…+2^n为O(n)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>O(nlgn)</p>\n<p>每层需要合并的总数为n，一共有logn层，故为nlogn</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>首先使用类似于后序遍历的方式，将数组不断的分割，最后在进行归并。</p>\n<p>归并的过程是：使用三根指针，第一根指向第一个子表首位元素，第二根指向第一个子表末尾元素，最后一根指向第二个子表末尾元素元素。<br>在确保第一根位置小于第二根，第二根+1小于第三根的情况下，不断比较第一根和第二根的大小并做相应的替换，替换完毕之后2根指针同时++,直到第一根指针到达左侧最末尾或者第二根指针到达第三根指针位置，即可中断。</p>\n<h1 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static void mergeSort(int[] arr) &#123;</span><br><span class=\"line\">       mergeSort(arr, new int[arr.length], 0, arr.length - 1);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   private static void mergeSort(int[] arr, int[] temp, int left, int right) &#123;</span><br><span class=\"line\">       if (left &lt; right) &#123;</span><br><span class=\"line\">           int center = (left + right) / 2;</span><br><span class=\"line\">           mergeSort(arr, temp, left, center); // 左边</span><br><span class=\"line\">           mergeSort(arr, temp, center + 1, right); // 右边</span><br><span class=\"line\">           merge(arr, temp, left, center + 1, right); // 合并两个有序 ett</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   private static void merge(int[] arr, int[] temp, int leftPos, int rightPos, int rightEnd) &#123;</span><br><span class=\"line\">       int leftEnd = rightPos - 1; // 左边结束下标</span><br><span class=\"line\">       int tempPos = leftPos; // 从左边开始算</span><br><span class=\"line\">       int numEle = rightEnd - leftPos + 1; // 元素个数</span><br><span class=\"line\">       while (leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd) &#123;</span><br><span class=\"line\">           if (arr[leftPos] &lt;= arr[rightPos])</span><br><span class=\"line\">           \t//通过一个临时数组做存储，这样不需要使用temp对象做临时存储做转换，而是直接从最小的区块开始拷贝进去</span><br><span class=\"line\">               temp[tempPos++] = arr[leftPos++];</span><br><span class=\"line\">           else</span><br><span class=\"line\">               temp[tempPos++] = arr[rightPos++];</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       while (leftPos &lt;= leftEnd) &#123;  // 左边如果有剩余</span><br><span class=\"line\">           temp[tempPos++] = arr[leftPos++];</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       while (rightPos &lt;= rightEnd) &#123; // 右边如果有剩余</span><br><span class=\"line\">           temp[tempPos++] = arr[rightPos++];</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       // 最后一步进行复制，复制的只有更改的几个数字</span><br><span class=\"line\">       for (int i = 0; i &lt; numEle; i++) &#123;</span><br><span class=\"line\">           arr[rightEnd] = temp[rightEnd];</span><br><span class=\"line\">           rightEnd--;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h1><h1 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h1>"},{"title":"使用appveyor.xml 进行双端部署hexo","date":"2017-12-21T03:12:17.000Z","_content":"\n\n# 注册并登录AppVeyor\n\n> 访问 [AppVeyor](https://ci.appveyor.com/login),使用github登录即可。\n\n# 添加project\n\n> 在 [project页面](https://ci.appveyor.com/projects/new),添加相应的source repo\n\n# 添加appveyor.yml到source repo\n\n> appveyor如[appveyor样例](https://github.com/formulahendry/formulahendry.github.io.source/blob/master/appveyor.yml),只需要更改 [Your Github Access Token]即可。\n\n# 在repo/settings/Environment中添加四个变量\n\n> GIT_USER_EMAIL: github email\n> GIT_USER_NAME: github username\n> STATIC_SITE_REPO: blog repo site\n> TARGET_BRANCH: blog repo main branch (default is master)\n\n# 完成\n\n> 背后的过程如下\n> Git push to Source Repo -> AppVeyor CI -> Update GitHub Pages Content Repo -> Generate your Hexo blog site\n\n# [出处](https://formulahendry.github.io/2016/12/04/hexo-ci/)\n","source":"_posts/使用appveyor-xml-进行双端部署hexo.md","raw":"---\ntitle: 使用appveyor.xml 进行双端部署hexo\ndate: 2017-12-21 11:12:17\ntags: hexo\n---\n\n\n# 注册并登录AppVeyor\n\n> 访问 [AppVeyor](https://ci.appveyor.com/login),使用github登录即可。\n\n# 添加project\n\n> 在 [project页面](https://ci.appveyor.com/projects/new),添加相应的source repo\n\n# 添加appveyor.yml到source repo\n\n> appveyor如[appveyor样例](https://github.com/formulahendry/formulahendry.github.io.source/blob/master/appveyor.yml),只需要更改 [Your Github Access Token]即可。\n\n# 在repo/settings/Environment中添加四个变量\n\n> GIT_USER_EMAIL: github email\n> GIT_USER_NAME: github username\n> STATIC_SITE_REPO: blog repo site\n> TARGET_BRANCH: blog repo main branch (default is master)\n\n# 完成\n\n> 背后的过程如下\n> Git push to Source Repo -> AppVeyor CI -> Update GitHub Pages Content Repo -> Generate your Hexo blog site\n\n# [出处](https://formulahendry.github.io/2016/12/04/hexo-ci/)\n","slug":"使用appveyor-xml-进行双端部署hexo","published":1,"updated":"2019-03-12T09:26:33.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttyr004h3a8kic7xn9n0","content":"<h1 id=\"注册并登录AppVeyor\"><a href=\"#注册并登录AppVeyor\" class=\"headerlink\" title=\"注册并登录AppVeyor\"></a>注册并登录AppVeyor</h1><blockquote>\n<p>访问 <a href=\"https://ci.appveyor.com/login\" target=\"_blank\" rel=\"noopener\">AppVeyor</a>,使用github登录即可。</p>\n</blockquote>\n<h1 id=\"添加project\"><a href=\"#添加project\" class=\"headerlink\" title=\"添加project\"></a>添加project</h1><blockquote>\n<p>在 <a href=\"https://ci.appveyor.com/projects/new\" target=\"_blank\" rel=\"noopener\">project页面</a>,添加相应的source repo</p>\n</blockquote>\n<h1 id=\"添加appveyor-yml到source-repo\"><a href=\"#添加appveyor-yml到source-repo\" class=\"headerlink\" title=\"添加appveyor.yml到source repo\"></a>添加appveyor.yml到source repo</h1><blockquote>\n<p>appveyor如<a href=\"https://github.com/formulahendry/formulahendry.github.io.source/blob/master/appveyor.yml\" target=\"_blank\" rel=\"noopener\">appveyor样例</a>,只需要更改 [Your Github Access Token]即可。</p>\n</blockquote>\n<h1 id=\"在repo-settings-Environment中添加四个变量\"><a href=\"#在repo-settings-Environment中添加四个变量\" class=\"headerlink\" title=\"在repo/settings/Environment中添加四个变量\"></a>在repo/settings/Environment中添加四个变量</h1><blockquote>\n<p>GIT_USER_EMAIL: github email<br>GIT_USER_NAME: github username<br>STATIC_SITE_REPO: blog repo site<br>TARGET_BRANCH: blog repo main branch (default is master)</p>\n</blockquote>\n<h1 id=\"完成\"><a href=\"#完成\" class=\"headerlink\" title=\"完成\"></a>完成</h1><blockquote>\n<p>背后的过程如下<br>Git push to Source Repo -&gt; AppVeyor CI -&gt; Update GitHub Pages Content Repo -&gt; Generate your Hexo blog site</p>\n</blockquote>\n<h1 id=\"出处\"><a href=\"#出处\" class=\"headerlink\" title=\"出处\"></a><a href=\"https://formulahendry.github.io/2016/12/04/hexo-ci/\" target=\"_blank\" rel=\"noopener\">出处</a></h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"注册并登录AppVeyor\"><a href=\"#注册并登录AppVeyor\" class=\"headerlink\" title=\"注册并登录AppVeyor\"></a>注册并登录AppVeyor</h1><blockquote>\n<p>访问 <a href=\"https://ci.appveyor.com/login\" target=\"_blank\" rel=\"noopener\">AppVeyor</a>,使用github登录即可。</p>\n</blockquote>\n<h1 id=\"添加project\"><a href=\"#添加project\" class=\"headerlink\" title=\"添加project\"></a>添加project</h1><blockquote>\n<p>在 <a href=\"https://ci.appveyor.com/projects/new\" target=\"_blank\" rel=\"noopener\">project页面</a>,添加相应的source repo</p>\n</blockquote>\n<h1 id=\"添加appveyor-yml到source-repo\"><a href=\"#添加appveyor-yml到source-repo\" class=\"headerlink\" title=\"添加appveyor.yml到source repo\"></a>添加appveyor.yml到source repo</h1><blockquote>\n<p>appveyor如<a href=\"https://github.com/formulahendry/formulahendry.github.io.source/blob/master/appveyor.yml\" target=\"_blank\" rel=\"noopener\">appveyor样例</a>,只需要更改 [Your Github Access Token]即可。</p>\n</blockquote>\n<h1 id=\"在repo-settings-Environment中添加四个变量\"><a href=\"#在repo-settings-Environment中添加四个变量\" class=\"headerlink\" title=\"在repo/settings/Environment中添加四个变量\"></a>在repo/settings/Environment中添加四个变量</h1><blockquote>\n<p>GIT_USER_EMAIL: github email<br>GIT_USER_NAME: github username<br>STATIC_SITE_REPO: blog repo site<br>TARGET_BRANCH: blog repo main branch (default is master)</p>\n</blockquote>\n<h1 id=\"完成\"><a href=\"#完成\" class=\"headerlink\" title=\"完成\"></a>完成</h1><blockquote>\n<p>背后的过程如下<br>Git push to Source Repo -&gt; AppVeyor CI -&gt; Update GitHub Pages Content Repo -&gt; Generate your Hexo blog site</p>\n</blockquote>\n<h1 id=\"出处\"><a href=\"#出处\" class=\"headerlink\" title=\"出处\"></a><a href=\"https://formulahendry.github.io/2016/12/04/hexo-ci/\" target=\"_blank\" rel=\"noopener\">出处</a></h1>"},{"title":"使用python抓取网页内容","date":"2018-01-26T14:54:51.000Z","_content":"\n进行爬虫抓取，有一个大致的思路。\n首先是抓取当前页的关键内容，也就是我们需要的内容。\n其次是抓取下一页的网址信息，也就是用于下一轮进行抓取的对象。\n\n因此使用一个queue去存储抓取的网址信息，当queue不为空的时候执行轮次抓取关键信息的操作。\n同时还有一个set去存储以抓取的网址的信息，确保不会重复查询某个网址。\n\n```\nqueue Q\nset S\nStartPoint = \"http://jecvay.com\"\nQ.push(StartPoint)  # 经典的BFS开头\nS.insert(StartPoint)  # 访问一个页面之前先标记他为已访问\nwhile (Q.empty() == false)  # BFS循环体\n  T = Q.top()  # 并且pop\n  for point in PageUrl(T)  # PageUrl(T)是指页面T中所有url的集合, point是这个集合中的一个元素.\n    if (point not in S)\n      Q.push(point)\n      S.insert(point)\n```\n\n大致如这个伪代码。\n\nqueue初始化：\n```\n\tqueue = deque()\n```\nqueue添加：\n```\n\tqueue.append(url)\n```\nqueue出栈：\n```\n\tqueue.popleft()\n```\n\n\nset初始化：\n```\n\tvisited = set()\n```\nset添加：\n```\n\tvisited |= {url}\n```\n\nurl抓取：\n```\n\turlop = urllib.requests.urlopen(url)\n```\n\n数据解析:\n```\n\tdata = urlop.read().decode('utf-8')\n```\n","source":"_posts/使用python抓取网页内容.md","raw":"---\ntitle: 使用python抓取网页内容\ndate: 2018-01-26 22:54:51\ntags: python\n---\n\n进行爬虫抓取，有一个大致的思路。\n首先是抓取当前页的关键内容，也就是我们需要的内容。\n其次是抓取下一页的网址信息，也就是用于下一轮进行抓取的对象。\n\n因此使用一个queue去存储抓取的网址信息，当queue不为空的时候执行轮次抓取关键信息的操作。\n同时还有一个set去存储以抓取的网址的信息，确保不会重复查询某个网址。\n\n```\nqueue Q\nset S\nStartPoint = \"http://jecvay.com\"\nQ.push(StartPoint)  # 经典的BFS开头\nS.insert(StartPoint)  # 访问一个页面之前先标记他为已访问\nwhile (Q.empty() == false)  # BFS循环体\n  T = Q.top()  # 并且pop\n  for point in PageUrl(T)  # PageUrl(T)是指页面T中所有url的集合, point是这个集合中的一个元素.\n    if (point not in S)\n      Q.push(point)\n      S.insert(point)\n```\n\n大致如这个伪代码。\n\nqueue初始化：\n```\n\tqueue = deque()\n```\nqueue添加：\n```\n\tqueue.append(url)\n```\nqueue出栈：\n```\n\tqueue.popleft()\n```\n\n\nset初始化：\n```\n\tvisited = set()\n```\nset添加：\n```\n\tvisited |= {url}\n```\n\nurl抓取：\n```\n\turlop = urllib.requests.urlopen(url)\n```\n\n数据解析:\n```\n\tdata = urlop.read().decode('utf-8')\n```\n","slug":"使用python抓取网页内容","published":1,"updated":"2019-03-12T09:26:33.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttyt004j3a8kqvrt3i55","content":"<p>进行爬虫抓取，有一个大致的思路。<br>首先是抓取当前页的关键内容，也就是我们需要的内容。<br>其次是抓取下一页的网址信息，也就是用于下一轮进行抓取的对象。</p>\n<p>因此使用一个queue去存储抓取的网址信息，当queue不为空的时候执行轮次抓取关键信息的操作。<br>同时还有一个set去存储以抓取的网址的信息，确保不会重复查询某个网址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">queue Q</span><br><span class=\"line\">set S</span><br><span class=\"line\">StartPoint = &quot;http://jecvay.com&quot;</span><br><span class=\"line\">Q.push(StartPoint)  # 经典的BFS开头</span><br><span class=\"line\">S.insert(StartPoint)  # 访问一个页面之前先标记他为已访问</span><br><span class=\"line\">while (Q.empty() == false)  # BFS循环体</span><br><span class=\"line\">  T = Q.top()  # 并且pop</span><br><span class=\"line\">  for point in PageUrl(T)  # PageUrl(T)是指页面T中所有url的集合, point是这个集合中的一个元素.</span><br><span class=\"line\">    if (point not in S)</span><br><span class=\"line\">      Q.push(point)</span><br><span class=\"line\">      S.insert(point)</span><br></pre></td></tr></table></figure>\n<p>大致如这个伪代码。</p>\n<p>queue初始化：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">queue = deque()</span><br></pre></td></tr></table></figure></p>\n<p>queue添加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">queue.append(url)</span><br></pre></td></tr></table></figure></p>\n<p>queue出栈：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">queue.popleft()</span><br></pre></td></tr></table></figure></p>\n<p>set初始化：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">visited = set()</span><br></pre></td></tr></table></figure></p>\n<p>set添加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">visited |= &#123;url&#125;</span><br></pre></td></tr></table></figure></p>\n<p>url抓取：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">urlop = urllib.requests.urlopen(url)</span><br></pre></td></tr></table></figure></p>\n<p>数据解析:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = urlop.read().decode(&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>进行爬虫抓取，有一个大致的思路。<br>首先是抓取当前页的关键内容，也就是我们需要的内容。<br>其次是抓取下一页的网址信息，也就是用于下一轮进行抓取的对象。</p>\n<p>因此使用一个queue去存储抓取的网址信息，当queue不为空的时候执行轮次抓取关键信息的操作。<br>同时还有一个set去存储以抓取的网址的信息，确保不会重复查询某个网址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">queue Q</span><br><span class=\"line\">set S</span><br><span class=\"line\">StartPoint = &quot;http://jecvay.com&quot;</span><br><span class=\"line\">Q.push(StartPoint)  # 经典的BFS开头</span><br><span class=\"line\">S.insert(StartPoint)  # 访问一个页面之前先标记他为已访问</span><br><span class=\"line\">while (Q.empty() == false)  # BFS循环体</span><br><span class=\"line\">  T = Q.top()  # 并且pop</span><br><span class=\"line\">  for point in PageUrl(T)  # PageUrl(T)是指页面T中所有url的集合, point是这个集合中的一个元素.</span><br><span class=\"line\">    if (point not in S)</span><br><span class=\"line\">      Q.push(point)</span><br><span class=\"line\">      S.insert(point)</span><br></pre></td></tr></table></figure>\n<p>大致如这个伪代码。</p>\n<p>queue初始化：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">queue = deque()</span><br></pre></td></tr></table></figure></p>\n<p>queue添加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">queue.append(url)</span><br></pre></td></tr></table></figure></p>\n<p>queue出栈：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">queue.popleft()</span><br></pre></td></tr></table></figure></p>\n<p>set初始化：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">visited = set()</span><br></pre></td></tr></table></figure></p>\n<p>set添加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">visited |= &#123;url&#125;</span><br></pre></td></tr></table></figure></p>\n<p>url抓取：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">urlop = urllib.requests.urlopen(url)</span><br></pre></td></tr></table></figure></p>\n<p>数据解析:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = urlop.read().decode(&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure></p>\n"},{"title":"使用浏览器唤起app","date":"2018-01-06T10:38:38.000Z","_content":"浏览器唤起app，其实很简单，是使用manifest中注册scheme的方式来设置。\n\nmanifest中注册如下\n\n```\n<intent-filter>\n    <action android:name=\"android.intent.action.VIEW\"/>\n    <category android:name=\"android.intent.category.DEFAULT\" />\n    <category android:name=\"android.intent.category.BROWSABLE\" />\n    <data android:scheme=\"myapp\" android:host=\"jp.app\" android:pathPrefix=\"/openwith\"/>\n</intent-filter>\n```\n\n这段代表了唤起方式可以由浏览器唤起，data方面重要的是写scheme，之后的host和pathprefix都是无关紧要的。\n\nassets文件夹里面放静态html页面，使用webview来load。\n\n```\n<a href=\"myapp://jp.app/openwith?name=zhangsan&age=26\">启动应用程序</a>\n```\n\n启动的activity里面接受intent\n```\nif(Intent.ACTION_VIEW.equals(action)){\n    Uri uri = i_getvalue.getData();\n    if(uri != null){\n        String name = uri.getQueryParameter(\"name\");\n        String age= uri.getQueryParameter(\"age\");\n        Log.d(getClass().getName(),name+age);\n\t}\n}\n```\n\n可以接收到intent里面包含的信息。\n\n针对昨天的问题，如何从html中get一个接口的数据，然后返回吊起activity，可以直接使用script来fetch（url），针对内容对唤起的activity后缀加内容。\n\n目前关于这个问题还是涉及到跨域的情况，张凯说使用301转发，周宇说跨域需要接口支持。我也不知道该怎么办了。周一去公司的时候查一下接口能不能跨域再说。","source":"_posts/使用浏览器唤起app.md","raw":"---\ntitle: 使用浏览器唤起app\ndate: 2018-01-06 18:38:38\ntags: android\n---\n浏览器唤起app，其实很简单，是使用manifest中注册scheme的方式来设置。\n\nmanifest中注册如下\n\n```\n<intent-filter>\n    <action android:name=\"android.intent.action.VIEW\"/>\n    <category android:name=\"android.intent.category.DEFAULT\" />\n    <category android:name=\"android.intent.category.BROWSABLE\" />\n    <data android:scheme=\"myapp\" android:host=\"jp.app\" android:pathPrefix=\"/openwith\"/>\n</intent-filter>\n```\n\n这段代表了唤起方式可以由浏览器唤起，data方面重要的是写scheme，之后的host和pathprefix都是无关紧要的。\n\nassets文件夹里面放静态html页面，使用webview来load。\n\n```\n<a href=\"myapp://jp.app/openwith?name=zhangsan&age=26\">启动应用程序</a>\n```\n\n启动的activity里面接受intent\n```\nif(Intent.ACTION_VIEW.equals(action)){\n    Uri uri = i_getvalue.getData();\n    if(uri != null){\n        String name = uri.getQueryParameter(\"name\");\n        String age= uri.getQueryParameter(\"age\");\n        Log.d(getClass().getName(),name+age);\n\t}\n}\n```\n\n可以接收到intent里面包含的信息。\n\n针对昨天的问题，如何从html中get一个接口的数据，然后返回吊起activity，可以直接使用script来fetch（url），针对内容对唤起的activity后缀加内容。\n\n目前关于这个问题还是涉及到跨域的情况，张凯说使用301转发，周宇说跨域需要接口支持。我也不知道该怎么办了。周一去公司的时候查一下接口能不能跨域再说。","slug":"使用浏览器唤起app","published":1,"updated":"2019-03-12T09:26:33.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttyu004l3a8k76d0k3gr","content":"<p>浏览器唤起app，其实很简单，是使用manifest中注册scheme的方式来设置。</p>\n<p>manifest中注册如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;intent-filter&gt;</span><br><span class=\"line\">    &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;</span><br><span class=\"line\">    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class=\"line\">    &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;</span><br><span class=\"line\">    &lt;data android:scheme=&quot;myapp&quot; android:host=&quot;jp.app&quot; android:pathPrefix=&quot;/openwith&quot;/&gt;</span><br><span class=\"line\">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>\n<p>这段代表了唤起方式可以由浏览器唤起，data方面重要的是写scheme，之后的host和pathprefix都是无关紧要的。</p>\n<p>assets文件夹里面放静态html页面，使用webview来load。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;myapp://jp.app/openwith?name=zhangsan&amp;age=26&quot;&gt;启动应用程序&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<p>启动的activity里面接受intent<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(Intent.ACTION_VIEW.equals(action))&#123;</span><br><span class=\"line\">    Uri uri = i_getvalue.getData();</span><br><span class=\"line\">    if(uri != null)&#123;</span><br><span class=\"line\">        String name = uri.getQueryParameter(&quot;name&quot;);</span><br><span class=\"line\">        String age= uri.getQueryParameter(&quot;age&quot;);</span><br><span class=\"line\">        Log.d(getClass().getName(),name+age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以接收到intent里面包含的信息。</p>\n<p>针对昨天的问题，如何从html中get一个接口的数据，然后返回吊起activity，可以直接使用script来fetch（url），针对内容对唤起的activity后缀加内容。</p>\n<p>目前关于这个问题还是涉及到跨域的情况，张凯说使用301转发，周宇说跨域需要接口支持。我也不知道该怎么办了。周一去公司的时候查一下接口能不能跨域再说。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>浏览器唤起app，其实很简单，是使用manifest中注册scheme的方式来设置。</p>\n<p>manifest中注册如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;intent-filter&gt;</span><br><span class=\"line\">    &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;</span><br><span class=\"line\">    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class=\"line\">    &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;</span><br><span class=\"line\">    &lt;data android:scheme=&quot;myapp&quot; android:host=&quot;jp.app&quot; android:pathPrefix=&quot;/openwith&quot;/&gt;</span><br><span class=\"line\">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>\n<p>这段代表了唤起方式可以由浏览器唤起，data方面重要的是写scheme，之后的host和pathprefix都是无关紧要的。</p>\n<p>assets文件夹里面放静态html页面，使用webview来load。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;myapp://jp.app/openwith?name=zhangsan&amp;age=26&quot;&gt;启动应用程序&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<p>启动的activity里面接受intent<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(Intent.ACTION_VIEW.equals(action))&#123;</span><br><span class=\"line\">    Uri uri = i_getvalue.getData();</span><br><span class=\"line\">    if(uri != null)&#123;</span><br><span class=\"line\">        String name = uri.getQueryParameter(&quot;name&quot;);</span><br><span class=\"line\">        String age= uri.getQueryParameter(&quot;age&quot;);</span><br><span class=\"line\">        Log.d(getClass().getName(),name+age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以接收到intent里面包含的信息。</p>\n<p>针对昨天的问题，如何从html中get一个接口的数据，然后返回吊起activity，可以直接使用script来fetch（url），针对内容对唤起的activity后缀加内容。</p>\n<p>目前关于这个问题还是涉及到跨域的情况，张凯说使用301转发，周宇说跨域需要接口支持。我也不知道该怎么办了。周一去公司的时候查一下接口能不能跨域再说。</p>\n"},{"title":"关于后台改接口之后前端应该做的事情","date":"2018-03-30T13:45:26.000Z","_content":"\n新到公司，一切都是新鲜的，然而很快问题就来了。\n\n公司后台重构了后台的接口，将原先多层级的接口，改成了扁平化的接口。\n\n这对我是完全没有接触过的挑战。\n\n刚开始我觉得，既然后台改了接口，我就应该把接口部分删了重构，然后将得到的数据结构也重构。但是后来发现，基于原来数据结构上的接口衍生的代码十分庞大，层级比较深，这样重构数据结构基本上等于重构项目了，时间上面不可行。\n\n因此我后来想到一个办法，将原来的数据结构设为set和get，然后将现在获取的数据结构扭成之前的数据结构，需要原先参数的地方，我改成get的方式，将现有的数据结构组合来返回，这样衍生的代码就可以基于之前的数据结构上来运行，可以保证数据结构之上的代码不需要改变。\n\n但是又遇到一个问题，就是项目中很多地方是直接使用数据结构里面的值来进行操作的，而不是set和get，这样我改成set和get，就需要更改使用到该值的地方。当时采取了这种方式，的确代码可运行，而且较为稳定了。\n\n后来在和别人的交流中，得知可以使用一层封装，封装现有的数据结构，变成原来的数据结构，这样也可以。\n\n例如我使用retrofit获取的数据，在rxjava中对observable的执行过程中，直接将原先的数据进行转换，写一个wrapper，然后onnext中返回这个wrapper，这样使用这个接口的部分仍然可以直接使用原来的数据，甚至都不需要使用get和set。\n\n所以当以后遇到这种情况，可以直接使用上述方法，将数据扭合成原先的结构，来进行更改。这样每次更改接口，仅仅需要更改这个wrapper即可。\n","source":"_posts/关于后台改接口之后前端应该做的事情.md","raw":"---\ntitle: 关于后台改接口之后前端应该做的事情\ndate: 2018-03-30 21:45:26\ntags: android\n---\n\n新到公司，一切都是新鲜的，然而很快问题就来了。\n\n公司后台重构了后台的接口，将原先多层级的接口，改成了扁平化的接口。\n\n这对我是完全没有接触过的挑战。\n\n刚开始我觉得，既然后台改了接口，我就应该把接口部分删了重构，然后将得到的数据结构也重构。但是后来发现，基于原来数据结构上的接口衍生的代码十分庞大，层级比较深，这样重构数据结构基本上等于重构项目了，时间上面不可行。\n\n因此我后来想到一个办法，将原来的数据结构设为set和get，然后将现在获取的数据结构扭成之前的数据结构，需要原先参数的地方，我改成get的方式，将现有的数据结构组合来返回，这样衍生的代码就可以基于之前的数据结构上来运行，可以保证数据结构之上的代码不需要改变。\n\n但是又遇到一个问题，就是项目中很多地方是直接使用数据结构里面的值来进行操作的，而不是set和get，这样我改成set和get，就需要更改使用到该值的地方。当时采取了这种方式，的确代码可运行，而且较为稳定了。\n\n后来在和别人的交流中，得知可以使用一层封装，封装现有的数据结构，变成原来的数据结构，这样也可以。\n\n例如我使用retrofit获取的数据，在rxjava中对observable的执行过程中，直接将原先的数据进行转换，写一个wrapper，然后onnext中返回这个wrapper，这样使用这个接口的部分仍然可以直接使用原来的数据，甚至都不需要使用get和set。\n\n所以当以后遇到这种情况，可以直接使用上述方法，将数据扭合成原先的结构，来进行更改。这样每次更改接口，仅仅需要更改这个wrapper即可。\n","slug":"关于后台改接口之后前端应该做的事情","published":1,"updated":"2019-03-12T09:26:33.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttyv004n3a8kbhpd985y","content":"<p>新到公司，一切都是新鲜的，然而很快问题就来了。</p>\n<p>公司后台重构了后台的接口，将原先多层级的接口，改成了扁平化的接口。</p>\n<p>这对我是完全没有接触过的挑战。</p>\n<p>刚开始我觉得，既然后台改了接口，我就应该把接口部分删了重构，然后将得到的数据结构也重构。但是后来发现，基于原来数据结构上的接口衍生的代码十分庞大，层级比较深，这样重构数据结构基本上等于重构项目了，时间上面不可行。</p>\n<p>因此我后来想到一个办法，将原来的数据结构设为set和get，然后将现在获取的数据结构扭成之前的数据结构，需要原先参数的地方，我改成get的方式，将现有的数据结构组合来返回，这样衍生的代码就可以基于之前的数据结构上来运行，可以保证数据结构之上的代码不需要改变。</p>\n<p>但是又遇到一个问题，就是项目中很多地方是直接使用数据结构里面的值来进行操作的，而不是set和get，这样我改成set和get，就需要更改使用到该值的地方。当时采取了这种方式，的确代码可运行，而且较为稳定了。</p>\n<p>后来在和别人的交流中，得知可以使用一层封装，封装现有的数据结构，变成原来的数据结构，这样也可以。</p>\n<p>例如我使用retrofit获取的数据，在rxjava中对observable的执行过程中，直接将原先的数据进行转换，写一个wrapper，然后onnext中返回这个wrapper，这样使用这个接口的部分仍然可以直接使用原来的数据，甚至都不需要使用get和set。</p>\n<p>所以当以后遇到这种情况，可以直接使用上述方法，将数据扭合成原先的结构，来进行更改。这样每次更改接口，仅仅需要更改这个wrapper即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>新到公司，一切都是新鲜的，然而很快问题就来了。</p>\n<p>公司后台重构了后台的接口，将原先多层级的接口，改成了扁平化的接口。</p>\n<p>这对我是完全没有接触过的挑战。</p>\n<p>刚开始我觉得，既然后台改了接口，我就应该把接口部分删了重构，然后将得到的数据结构也重构。但是后来发现，基于原来数据结构上的接口衍生的代码十分庞大，层级比较深，这样重构数据结构基本上等于重构项目了，时间上面不可行。</p>\n<p>因此我后来想到一个办法，将原来的数据结构设为set和get，然后将现在获取的数据结构扭成之前的数据结构，需要原先参数的地方，我改成get的方式，将现有的数据结构组合来返回，这样衍生的代码就可以基于之前的数据结构上来运行，可以保证数据结构之上的代码不需要改变。</p>\n<p>但是又遇到一个问题，就是项目中很多地方是直接使用数据结构里面的值来进行操作的，而不是set和get，这样我改成set和get，就需要更改使用到该值的地方。当时采取了这种方式，的确代码可运行，而且较为稳定了。</p>\n<p>后来在和别人的交流中，得知可以使用一层封装，封装现有的数据结构，变成原来的数据结构，这样也可以。</p>\n<p>例如我使用retrofit获取的数据，在rxjava中对observable的执行过程中，直接将原先的数据进行转换，写一个wrapper，然后onnext中返回这个wrapper，这样使用这个接口的部分仍然可以直接使用原来的数据，甚至都不需要使用get和set。</p>\n<p>所以当以后遇到这种情况，可以直接使用上述方法，将数据扭合成原先的结构，来进行更改。这样每次更改接口，仅仅需要更改这个wrapper即可。</p>\n"},{"title":"关于面向对象","date":"2018-03-31T15:22:59.000Z","_content":"\n写java也这么多年了，从一开始就知道面向对象的三大特征：封装多态和继承。然而在工作这么久之后，突然回头看看，才一下子意识到这三大特征的重要性。\n\n知其然容易，知其所以然则太难了。如今希望能在突然一瞬间的理解出现时，将其记录下来。\n\n# 封装\n\n封装是将对象使用一系列方法包裹起来，仅仅对外提供一系列功能接口，而屏蔽内在的属性。\n\n为什么这么做呢？\n\n首先，我们将对象定义为一系列的属性，这一系列的属性决定了这个对象能够表达出什么样的信息。但是其实我们并不关心他真正的属性，并不关心他某个值的含义，关心的仅仅是他能够做什么。\n\n所以我们需要将他的功能列出来，这些功能并不是说他们只能这样，而是我们处于项目的需求，只需要这些功能。\n\n因此在我们眼前，对象不是一系列的数据组合的，而是一系列功能组合的。\n\n这样其实就已经从普通的物理层面抽象出来了对象的本质，换言之，我们仅仅需要功能，而不再是属性。\n\n从代码层面，这样有一个好处，就是我们将一个对象可以做的事情，限制在他的类中，直观的操作，而不再是通过在不同条件下拼装其属性来展现功能。\n\n对象可以是变的，可能是后端接口导致的映射改变，也可能是某个属性不在起作用，但是我们仅仅需要关心的功能是否能够再次实现。\n\n对内，对象是一个系统。对外，对象却只是一个小模块。\n\n# 多态\n\n多态是对一个方法的展开。\n\n我们将一个个的对象封装起来的意义，就是为了只观功能。\n\n而多态恰巧给功能的健壮性提供了面对多场合的稳定。\n\n没有了多态，我们需要实现一个相同功能，却命名为一个不同的名字。在不同的场景下会产生很多的误解。\n\n封装是为了将对象进行功能的抽象，而多态，是对功能的抽象进行一个整合，让这个抽象不需要太离谱。\n\n# 继承\n\n继承，或者说实现，就是一个完全的面向功能的操作。\n\n继承是子类对父类的角色实现一种扩展，每个子类都需要有父类的特征，但同时也可以拥有自己的特征。\n\n接口在我眼里也是一种继承，不过接口在高度上高于直接继承，接口是完完全全为了功能实现的。\n\n有了接口，我们可以直接在功能的角度上面来设计代码，之后只需要对这些功能来实现即可。这是自上而下，而之前的封装，则是自下而上，实际操作没有这么隔离，但是大致意义这样。\n\n# 对架构的关系\n\n总是从低到高的实现，就如同从底层开始构筑，很容易出现越垒越歪，越垒越庞大。而由于基于底层，所以一旦对底层有一些更改，很容易出现大规模的重构。十分不利于代码的健壮性。\n\n而从高到低的实现，很大程度避免了这个问题的发生。\n\n将一个项目拆分成几个子模块，然后将子模块的功能定下来，之后无论下层如何实现，如何更改，从高层来看，仍然是原来的模样。\n\n架构的魅力很大，单纯写代码会让人觉得疲惫，庸于在代码中翻找。而架构，让人一瞬间高屋建瓴，一眼看透了需要做什么。之后连工期都很容易预估。\n\n\n\n\n\n\n\n\n","source":"_posts/关于面向对象.md","raw":"---\ntitle: 关于面向对象\ndate: 2018-03-31 23:22:59\ntags: android\n---\n\n写java也这么多年了，从一开始就知道面向对象的三大特征：封装多态和继承。然而在工作这么久之后，突然回头看看，才一下子意识到这三大特征的重要性。\n\n知其然容易，知其所以然则太难了。如今希望能在突然一瞬间的理解出现时，将其记录下来。\n\n# 封装\n\n封装是将对象使用一系列方法包裹起来，仅仅对外提供一系列功能接口，而屏蔽内在的属性。\n\n为什么这么做呢？\n\n首先，我们将对象定义为一系列的属性，这一系列的属性决定了这个对象能够表达出什么样的信息。但是其实我们并不关心他真正的属性，并不关心他某个值的含义，关心的仅仅是他能够做什么。\n\n所以我们需要将他的功能列出来，这些功能并不是说他们只能这样，而是我们处于项目的需求，只需要这些功能。\n\n因此在我们眼前，对象不是一系列的数据组合的，而是一系列功能组合的。\n\n这样其实就已经从普通的物理层面抽象出来了对象的本质，换言之，我们仅仅需要功能，而不再是属性。\n\n从代码层面，这样有一个好处，就是我们将一个对象可以做的事情，限制在他的类中，直观的操作，而不再是通过在不同条件下拼装其属性来展现功能。\n\n对象可以是变的，可能是后端接口导致的映射改变，也可能是某个属性不在起作用，但是我们仅仅需要关心的功能是否能够再次实现。\n\n对内，对象是一个系统。对外，对象却只是一个小模块。\n\n# 多态\n\n多态是对一个方法的展开。\n\n我们将一个个的对象封装起来的意义，就是为了只观功能。\n\n而多态恰巧给功能的健壮性提供了面对多场合的稳定。\n\n没有了多态，我们需要实现一个相同功能，却命名为一个不同的名字。在不同的场景下会产生很多的误解。\n\n封装是为了将对象进行功能的抽象，而多态，是对功能的抽象进行一个整合，让这个抽象不需要太离谱。\n\n# 继承\n\n继承，或者说实现，就是一个完全的面向功能的操作。\n\n继承是子类对父类的角色实现一种扩展，每个子类都需要有父类的特征，但同时也可以拥有自己的特征。\n\n接口在我眼里也是一种继承，不过接口在高度上高于直接继承，接口是完完全全为了功能实现的。\n\n有了接口，我们可以直接在功能的角度上面来设计代码，之后只需要对这些功能来实现即可。这是自上而下，而之前的封装，则是自下而上，实际操作没有这么隔离，但是大致意义这样。\n\n# 对架构的关系\n\n总是从低到高的实现，就如同从底层开始构筑，很容易出现越垒越歪，越垒越庞大。而由于基于底层，所以一旦对底层有一些更改，很容易出现大规模的重构。十分不利于代码的健壮性。\n\n而从高到低的实现，很大程度避免了这个问题的发生。\n\n将一个项目拆分成几个子模块，然后将子模块的功能定下来，之后无论下层如何实现，如何更改，从高层来看，仍然是原来的模样。\n\n架构的魅力很大，单纯写代码会让人觉得疲惫，庸于在代码中翻找。而架构，让人一瞬间高屋建瓴，一眼看透了需要做什么。之后连工期都很容易预估。\n\n\n\n\n\n\n\n\n","slug":"关于面向对象","published":1,"updated":"2019-03-12T09:26:33.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttyw004p3a8khau06tjk","content":"<p>写java也这么多年了，从一开始就知道面向对象的三大特征：封装多态和继承。然而在工作这么久之后，突然回头看看，才一下子意识到这三大特征的重要性。</p>\n<p>知其然容易，知其所以然则太难了。如今希望能在突然一瞬间的理解出现时，将其记录下来。</p>\n<h1 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h1><p>封装是将对象使用一系列方法包裹起来，仅仅对外提供一系列功能接口，而屏蔽内在的属性。</p>\n<p>为什么这么做呢？</p>\n<p>首先，我们将对象定义为一系列的属性，这一系列的属性决定了这个对象能够表达出什么样的信息。但是其实我们并不关心他真正的属性，并不关心他某个值的含义，关心的仅仅是他能够做什么。</p>\n<p>所以我们需要将他的功能列出来，这些功能并不是说他们只能这样，而是我们处于项目的需求，只需要这些功能。</p>\n<p>因此在我们眼前，对象不是一系列的数据组合的，而是一系列功能组合的。</p>\n<p>这样其实就已经从普通的物理层面抽象出来了对象的本质，换言之，我们仅仅需要功能，而不再是属性。</p>\n<p>从代码层面，这样有一个好处，就是我们将一个对象可以做的事情，限制在他的类中，直观的操作，而不再是通过在不同条件下拼装其属性来展现功能。</p>\n<p>对象可以是变的，可能是后端接口导致的映射改变，也可能是某个属性不在起作用，但是我们仅仅需要关心的功能是否能够再次实现。</p>\n<p>对内，对象是一个系统。对外，对象却只是一个小模块。</p>\n<h1 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h1><p>多态是对一个方法的展开。</p>\n<p>我们将一个个的对象封装起来的意义，就是为了只观功能。</p>\n<p>而多态恰巧给功能的健壮性提供了面对多场合的稳定。</p>\n<p>没有了多态，我们需要实现一个相同功能，却命名为一个不同的名字。在不同的场景下会产生很多的误解。</p>\n<p>封装是为了将对象进行功能的抽象，而多态，是对功能的抽象进行一个整合，让这个抽象不需要太离谱。</p>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><p>继承，或者说实现，就是一个完全的面向功能的操作。</p>\n<p>继承是子类对父类的角色实现一种扩展，每个子类都需要有父类的特征，但同时也可以拥有自己的特征。</p>\n<p>接口在我眼里也是一种继承，不过接口在高度上高于直接继承，接口是完完全全为了功能实现的。</p>\n<p>有了接口，我们可以直接在功能的角度上面来设计代码，之后只需要对这些功能来实现即可。这是自上而下，而之前的封装，则是自下而上，实际操作没有这么隔离，但是大致意义这样。</p>\n<h1 id=\"对架构的关系\"><a href=\"#对架构的关系\" class=\"headerlink\" title=\"对架构的关系\"></a>对架构的关系</h1><p>总是从低到高的实现，就如同从底层开始构筑，很容易出现越垒越歪，越垒越庞大。而由于基于底层，所以一旦对底层有一些更改，很容易出现大规模的重构。十分不利于代码的健壮性。</p>\n<p>而从高到低的实现，很大程度避免了这个问题的发生。</p>\n<p>将一个项目拆分成几个子模块，然后将子模块的功能定下来，之后无论下层如何实现，如何更改，从高层来看，仍然是原来的模样。</p>\n<p>架构的魅力很大，单纯写代码会让人觉得疲惫，庸于在代码中翻找。而架构，让人一瞬间高屋建瓴，一眼看透了需要做什么。之后连工期都很容易预估。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>写java也这么多年了，从一开始就知道面向对象的三大特征：封装多态和继承。然而在工作这么久之后，突然回头看看，才一下子意识到这三大特征的重要性。</p>\n<p>知其然容易，知其所以然则太难了。如今希望能在突然一瞬间的理解出现时，将其记录下来。</p>\n<h1 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h1><p>封装是将对象使用一系列方法包裹起来，仅仅对外提供一系列功能接口，而屏蔽内在的属性。</p>\n<p>为什么这么做呢？</p>\n<p>首先，我们将对象定义为一系列的属性，这一系列的属性决定了这个对象能够表达出什么样的信息。但是其实我们并不关心他真正的属性，并不关心他某个值的含义，关心的仅仅是他能够做什么。</p>\n<p>所以我们需要将他的功能列出来，这些功能并不是说他们只能这样，而是我们处于项目的需求，只需要这些功能。</p>\n<p>因此在我们眼前，对象不是一系列的数据组合的，而是一系列功能组合的。</p>\n<p>这样其实就已经从普通的物理层面抽象出来了对象的本质，换言之，我们仅仅需要功能，而不再是属性。</p>\n<p>从代码层面，这样有一个好处，就是我们将一个对象可以做的事情，限制在他的类中，直观的操作，而不再是通过在不同条件下拼装其属性来展现功能。</p>\n<p>对象可以是变的，可能是后端接口导致的映射改变，也可能是某个属性不在起作用，但是我们仅仅需要关心的功能是否能够再次实现。</p>\n<p>对内，对象是一个系统。对外，对象却只是一个小模块。</p>\n<h1 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h1><p>多态是对一个方法的展开。</p>\n<p>我们将一个个的对象封装起来的意义，就是为了只观功能。</p>\n<p>而多态恰巧给功能的健壮性提供了面对多场合的稳定。</p>\n<p>没有了多态，我们需要实现一个相同功能，却命名为一个不同的名字。在不同的场景下会产生很多的误解。</p>\n<p>封装是为了将对象进行功能的抽象，而多态，是对功能的抽象进行一个整合，让这个抽象不需要太离谱。</p>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><p>继承，或者说实现，就是一个完全的面向功能的操作。</p>\n<p>继承是子类对父类的角色实现一种扩展，每个子类都需要有父类的特征，但同时也可以拥有自己的特征。</p>\n<p>接口在我眼里也是一种继承，不过接口在高度上高于直接继承，接口是完完全全为了功能实现的。</p>\n<p>有了接口，我们可以直接在功能的角度上面来设计代码，之后只需要对这些功能来实现即可。这是自上而下，而之前的封装，则是自下而上，实际操作没有这么隔离，但是大致意义这样。</p>\n<h1 id=\"对架构的关系\"><a href=\"#对架构的关系\" class=\"headerlink\" title=\"对架构的关系\"></a>对架构的关系</h1><p>总是从低到高的实现，就如同从底层开始构筑，很容易出现越垒越歪，越垒越庞大。而由于基于底层，所以一旦对底层有一些更改，很容易出现大规模的重构。十分不利于代码的健壮性。</p>\n<p>而从高到低的实现，很大程度避免了这个问题的发生。</p>\n<p>将一个项目拆分成几个子模块，然后将子模块的功能定下来，之后无论下层如何实现，如何更改，从高层来看，仍然是原来的模样。</p>\n<p>架构的魅力很大，单纯写代码会让人觉得疲惫，庸于在代码中翻找。而架构，让人一瞬间高屋建瓴，一眼看透了需要做什么。之后连工期都很容易预估。</p>\n"},{"title":"冒泡排序","date":"2018-01-11T13:52:24.000Z","_content":"\n冒泡排序是内部排序中交换排序的一种。\n\n# 算法思想\n\n对当前还未排序好的范围内的全部数，自上而下对相邻的两个数进行比较和调整，大的下沉，小的上浮。\n\n# 空间复杂度\n\n只是互换，为O(1)\n\n# 时间复杂度\n\n两次循环，故为O(n^2)\n\n# 算法实现思想\n\n每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。\n\n# java实现\n\n```\npublic int[] bubbleSort(int[] array){\n\tint[] arr = array;\n\tfor(int i = 0; i < array.length - 1; i ++){\n\t\tfor(int j = 0; j < array.length - i - 1; j ++){\n\t\t\tif(arr[j] > arr[j+1]){\n\t\t\t\tint temp = arr[j];\n\t\t\t\tarr[j] = arr[j+1];\n\t\t\t\tarr[j+1] = temp;\n\t\t\t}\n\t\t}\n\t}\n\treturn arr;\n}\n\n```\n\n# c实现\n\n# python实现","source":"_posts/冒泡排序.md","raw":"---\ntitle: 冒泡排序\ndate: 2018-01-11 21:52:24\ntags:\n---\n\n冒泡排序是内部排序中交换排序的一种。\n\n# 算法思想\n\n对当前还未排序好的范围内的全部数，自上而下对相邻的两个数进行比较和调整，大的下沉，小的上浮。\n\n# 空间复杂度\n\n只是互换，为O(1)\n\n# 时间复杂度\n\n两次循环，故为O(n^2)\n\n# 算法实现思想\n\n每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。\n\n# java实现\n\n```\npublic int[] bubbleSort(int[] array){\n\tint[] arr = array;\n\tfor(int i = 0; i < array.length - 1; i ++){\n\t\tfor(int j = 0; j < array.length - i - 1; j ++){\n\t\t\tif(arr[j] > arr[j+1]){\n\t\t\t\tint temp = arr[j];\n\t\t\t\tarr[j] = arr[j+1];\n\t\t\t\tarr[j+1] = temp;\n\t\t\t}\n\t\t}\n\t}\n\treturn arr;\n}\n\n```\n\n# c实现\n\n# python实现","slug":"冒泡排序","published":1,"updated":"2019-03-12T09:26:33.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttyz004r3a8kn3voq7av","content":"<p>冒泡排序是内部排序中交换排序的一种。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>对当前还未排序好的范围内的全部数，自上而下对相邻的两个数进行比较和调整，大的下沉，小的上浮。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>只是互换，为O(1)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>两次循环，故为O(n^2)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p>\n<h1 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int[] bubbleSort(int[] array)&#123;</span><br><span class=\"line\">\tint[] arr = array;</span><br><span class=\"line\">\tfor(int i = 0; i &lt; array.length - 1; i ++)&#123;</span><br><span class=\"line\">\t\tfor(int j = 0; j &lt; array.length - i - 1; j ++)&#123;</span><br><span class=\"line\">\t\t\tif(arr[j] &gt; arr[j+1])&#123;</span><br><span class=\"line\">\t\t\t\tint temp = arr[j];</span><br><span class=\"line\">\t\t\t\tarr[j] = arr[j+1];</span><br><span class=\"line\">\t\t\t\tarr[j+1] = temp;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h1><h1 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h1>","site":{"data":{}},"excerpt":"","more":"<p>冒泡排序是内部排序中交换排序的一种。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>对当前还未排序好的范围内的全部数，自上而下对相邻的两个数进行比较和调整，大的下沉，小的上浮。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>只是互换，为O(1)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>两次循环，故为O(n^2)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p>\n<h1 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int[] bubbleSort(int[] array)&#123;</span><br><span class=\"line\">\tint[] arr = array;</span><br><span class=\"line\">\tfor(int i = 0; i &lt; array.length - 1; i ++)&#123;</span><br><span class=\"line\">\t\tfor(int j = 0; j &lt; array.length - i - 1; j ++)&#123;</span><br><span class=\"line\">\t\t\tif(arr[j] &gt; arr[j+1])&#123;</span><br><span class=\"line\">\t\t\t\tint temp = arr[j];</span><br><span class=\"line\">\t\t\t\tarr[j] = arr[j+1];</span><br><span class=\"line\">\t\t\t\tarr[j+1] = temp;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h1><h1 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h1>"},{"title":"动态规划","date":"2018-12-27T14:57:33.000Z","_content":"\n# 基本思想\n\n- 将多阶段决策过程划分阶段，恰当的选取状态变量、决策变量及定义最优指标函数，从而把问题化成同一族同类型的子问题，然后逐个求解。\n- 求解时从边界条件开始，逆（或顺）过程进行方向，逐段递推寻优。在每一个子问题的求解时，都要使用它前面求出的子问题最优结果，最后一个子问题的最优解，就是真个问题的最优解。\n- 动态规划方法是既把当前一段与未来各段分开，又把当前效益和未来效益结合起来考虑的一种最优化方法，因此每段的最优决策选取是从全局考虑的，与该段的最优选择一般是不同的。\n\n# 建立动态规划模型的要点\n\n- 识别问题的多阶段特性，按时间或空间的先后顺序适当的划分为满足递推关系的若干阶段，对非时序的静态问题要认为的赋予“时段”概念\n- 正确的选择状态变量，使其具备两个必要特征：\n1. 可知性：过程演变的各阶段状态变量的取值，能直接或间接的确定\n2. 能够确切的描述过程的演变且满足无后效性。即由第k阶段的状态Sk出发的后部子过程，可以看作是一个以Sk为初始状态的独立过程。这一点不是很容易满足，需要尝试把握。\n- 根据状态变量与决策变量的含义，正确写出状态转移方程S(k+1) = Tk(Sk, Uk)或转移规则\n- 根据题意明确指标函数V(k,n),最优指标函数Fk(Sk)以及k阶段指标Vk(Sk,Uk)的含义，并正确列出最优指标函数的递推关系及边界条件\n","source":"_posts/动态规划.md","raw":"---\ntitle: 动态规划\ndate: 2018-12-27 22:57:33\ntags: 算法\n---\n\n# 基本思想\n\n- 将多阶段决策过程划分阶段，恰当的选取状态变量、决策变量及定义最优指标函数，从而把问题化成同一族同类型的子问题，然后逐个求解。\n- 求解时从边界条件开始，逆（或顺）过程进行方向，逐段递推寻优。在每一个子问题的求解时，都要使用它前面求出的子问题最优结果，最后一个子问题的最优解，就是真个问题的最优解。\n- 动态规划方法是既把当前一段与未来各段分开，又把当前效益和未来效益结合起来考虑的一种最优化方法，因此每段的最优决策选取是从全局考虑的，与该段的最优选择一般是不同的。\n\n# 建立动态规划模型的要点\n\n- 识别问题的多阶段特性，按时间或空间的先后顺序适当的划分为满足递推关系的若干阶段，对非时序的静态问题要认为的赋予“时段”概念\n- 正确的选择状态变量，使其具备两个必要特征：\n1. 可知性：过程演变的各阶段状态变量的取值，能直接或间接的确定\n2. 能够确切的描述过程的演变且满足无后效性。即由第k阶段的状态Sk出发的后部子过程，可以看作是一个以Sk为初始状态的独立过程。这一点不是很容易满足，需要尝试把握。\n- 根据状态变量与决策变量的含义，正确写出状态转移方程S(k+1) = Tk(Sk, Uk)或转移规则\n- 根据题意明确指标函数V(k,n),最优指标函数Fk(Sk)以及k阶段指标Vk(Sk,Uk)的含义，并正确列出最优指标函数的递推关系及边界条件\n","slug":"动态规划","published":1,"updated":"2019-03-12T09:26:33.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttz0004t3a8keo32ofoe","content":"<h1 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h1><ul>\n<li>将多阶段决策过程划分阶段，恰当的选取状态变量、决策变量及定义最优指标函数，从而把问题化成同一族同类型的子问题，然后逐个求解。</li>\n<li>求解时从边界条件开始，逆（或顺）过程进行方向，逐段递推寻优。在每一个子问题的求解时，都要使用它前面求出的子问题最优结果，最后一个子问题的最优解，就是真个问题的最优解。</li>\n<li>动态规划方法是既把当前一段与未来各段分开，又把当前效益和未来效益结合起来考虑的一种最优化方法，因此每段的最优决策选取是从全局考虑的，与该段的最优选择一般是不同的。</li>\n</ul>\n<h1 id=\"建立动态规划模型的要点\"><a href=\"#建立动态规划模型的要点\" class=\"headerlink\" title=\"建立动态规划模型的要点\"></a>建立动态规划模型的要点</h1><ul>\n<li>识别问题的多阶段特性，按时间或空间的先后顺序适当的划分为满足递推关系的若干阶段，对非时序的静态问题要认为的赋予“时段”概念</li>\n<li>正确的选择状态变量，使其具备两个必要特征：</li>\n</ul>\n<ol>\n<li>可知性：过程演变的各阶段状态变量的取值，能直接或间接的确定</li>\n<li>能够确切的描述过程的演变且满足无后效性。即由第k阶段的状态Sk出发的后部子过程，可以看作是一个以Sk为初始状态的独立过程。这一点不是很容易满足，需要尝试把握。</li>\n</ol>\n<ul>\n<li>根据状态变量与决策变量的含义，正确写出状态转移方程S(k+1) = Tk(Sk, Uk)或转移规则</li>\n<li>根据题意明确指标函数V(k,n),最优指标函数Fk(Sk)以及k阶段指标Vk(Sk,Uk)的含义，并正确列出最优指标函数的递推关系及边界条件</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h1><ul>\n<li>将多阶段决策过程划分阶段，恰当的选取状态变量、决策变量及定义最优指标函数，从而把问题化成同一族同类型的子问题，然后逐个求解。</li>\n<li>求解时从边界条件开始，逆（或顺）过程进行方向，逐段递推寻优。在每一个子问题的求解时，都要使用它前面求出的子问题最优结果，最后一个子问题的最优解，就是真个问题的最优解。</li>\n<li>动态规划方法是既把当前一段与未来各段分开，又把当前效益和未来效益结合起来考虑的一种最优化方法，因此每段的最优决策选取是从全局考虑的，与该段的最优选择一般是不同的。</li>\n</ul>\n<h1 id=\"建立动态规划模型的要点\"><a href=\"#建立动态规划模型的要点\" class=\"headerlink\" title=\"建立动态规划模型的要点\"></a>建立动态规划模型的要点</h1><ul>\n<li>识别问题的多阶段特性，按时间或空间的先后顺序适当的划分为满足递推关系的若干阶段，对非时序的静态问题要认为的赋予“时段”概念</li>\n<li>正确的选择状态变量，使其具备两个必要特征：</li>\n</ul>\n<ol>\n<li>可知性：过程演变的各阶段状态变量的取值，能直接或间接的确定</li>\n<li>能够确切的描述过程的演变且满足无后效性。即由第k阶段的状态Sk出发的后部子过程，可以看作是一个以Sk为初始状态的独立过程。这一点不是很容易满足，需要尝试把握。</li>\n</ol>\n<ul>\n<li>根据状态变量与决策变量的含义，正确写出状态转移方程S(k+1) = Tk(Sk, Uk)或转移规则</li>\n<li>根据题意明确指标函数V(k,n),最优指标函数Fk(Sk)以及k阶段指标Vk(Sk,Uk)的含义，并正确列出最优指标函数的递推关系及边界条件</li>\n</ul>\n"},{"title":"堆排序","date":"2018-01-09T15:27:02.000Z","_content":"堆排序是内部排序中选择排序的一种。堆排序是一种树形选择排序，是对选择排序的有效改进。\n\n堆是一种具有n个元素的序列，当且仅当满足 ki<=k2i, ki<= k2i+1，或者反过来。\n若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。\n\n初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。\n然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大的元素。\n依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。\n\n1. 调整小堆顶的方法\n\n1）设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。\n\n2）将根结点与左、右子树中较小元素的进行交换。\n\n3）若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）.\n\n4）若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）.\n\n5）继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。\n\n2. 建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。\n\n1）n 个结点的完全二叉树，则最后一个结点是第个结点的子树。\n\n2）筛选从第个结点为根的子树开始，该子树成为堆。\n\n3）之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。\n\n\n# 算法思想\n\n初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。\n然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大的元素。\n依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。\n\n\n# 空间复杂度\n\n因为堆排序是就地排序，空间复杂度为常数：O(1)\n\n# 时间复杂度\n\n堆排序的时间复杂度，主要在初始化堆过程和每次选取最大数后重新建堆的过程；\n\n初始化建堆过程时间：O(n)\n\n推算过程：\n\n首先要理解怎么计算这个堆化过程所消耗的时间，可以直接画图去理解；\n\n假设高度为k，则从倒数第二层右边的节点开始，这一层的节点都要执行子节点比较然后交换（如果顺序是对的就不用交换）；倒数第三层呢，则会选择其子节点进行比较和交换，如果没交换就可以不用再执行下去了。如果交换了，那么又要选择一支子树进行比较和交换；\n\n那么总的时间计算为：s = 2^( i - 1 )  *  ( k - i )；其中 i 表示第几层，2^( i - 1) 表示该层上有多少个元素，( k - i) 表示子树上要比较的次数，如果在最差的条件下，就是比较次数后还要交换；因为这个是常数，所以提出来后可以忽略；\n\nS = 2^(k-2) * 1 + 2^(k-3)*2.....+2*(k-2)+2^(0)*(k-1)  ===> 因为叶子层不用交换，所以i从 k-1 开始到 1；\n这个等式求解，我想高中已经会了：等式左右乘上2，然后和原来的等式相减，就变成了：\nS = 2^(k - 1) + 2^(k - 2) + 2^(k - 3) ..... + 2 - (k-1)\n除最后一项外，就是一个等比数列了，直接用求和公式：S = {  a1[ 1-  (q^n) ] }  / (1-q)；\nS = 2^k -k -1；又因为k为完全二叉树的深度，所以 (2^k) <=  n < (2^k  -1 )，总之可以认为：k = logn （实际计算得到应该是 log(n+1) < k <= logn ）;\n综上所述得到：S = n - longn -1，所以时间复杂度为：O(n)\n更改堆元素后重建堆时间：O(nlogn)\n推算过程：\n1、循环  n -1 次，每次都是从根节点往下循环查找，所以每一次时间是 logn，总时间：logn(n-1) = nlogn  - logn ；\n综上所述：堆排序的时间复杂度为：O(nlogn)\n\n# 算法实现思想\n\n堆排序的大概步骤如下:\n\n1. 构建最大堆。\n2. 选择顶，并与第0位置元素交换\n3. 由于步骤2的的交换可能破环了最大堆的性质，第0不再是最大元素，需要调用maxHeap调整堆(沉降法)，如果需要重复步骤2\n\n# java实现\n\n```\npublic static void heapSort(int[] array) {  \n    if (array == null || array.length <= 1) {  \n        return;  \n    }  \n  \n    buildMaxHeap(array);  \n  \n    for (int i = array.length - 1; i >= 1; i--) {  \n    \tArrayUtils.exchangeElements(array, 0, i);  \n\n    \tmaxHeap(array, i, 0);  \n    }  \n}  \n  \nprivate static void buildMaxHeap(int[] array) {  \n\tif (array == null || array.length <= 1) {  \n\t\treturn;  \n\t}  \n\n\tint half = array.length / 2;  \n\tfor (int i = half; i >= 0; i--) {  \n\t\tmaxHeap(array, array.length, i);  \n\t}  \n}\nprivate static void maxHeap(int[] array, int heapSize, int index) {  \n\tint left = index * 2 + 1;  \n\tint right = index * 2 + 2;  \n\n\tint largest = index;  \n\tif (left < heapSize && array[left] > array[index]) {  \n\t\tlargest = left;  \n\t}  \n\n\tif (right < heapSize && array[right] > array[largest]) {  \n\t\tlargest = right;  \n\t}  \n\n\tif (index != largest) {  \n\t\tArrayUtils.exchangeElements(array, index, largest);  \n\n\t\tmaxHeap(array, heapSize, largest);  \n\t}  \n}  \npublic static void exchangeElements(int[] array, int index1, int index2) {  \n\tint temp = array[index1];  \n\tarray[index1] = array[index2];  \n\tarray[index2] = temp;  \n}  \n```\n\n# c实现\n\n# python实现","source":"_posts/堆排序.md","raw":"---\ntitle: 堆排序\ndate: 2018-01-09 23:27:02\ntags: 算法\n---\n堆排序是内部排序中选择排序的一种。堆排序是一种树形选择排序，是对选择排序的有效改进。\n\n堆是一种具有n个元素的序列，当且仅当满足 ki<=k2i, ki<= k2i+1，或者反过来。\n若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。\n\n初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。\n然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大的元素。\n依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。\n\n1. 调整小堆顶的方法\n\n1）设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。\n\n2）将根结点与左、右子树中较小元素的进行交换。\n\n3）若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）.\n\n4）若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）.\n\n5）继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。\n\n2. 建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。\n\n1）n 个结点的完全二叉树，则最后一个结点是第个结点的子树。\n\n2）筛选从第个结点为根的子树开始，该子树成为堆。\n\n3）之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。\n\n\n# 算法思想\n\n初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。\n然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大的元素。\n依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。\n\n\n# 空间复杂度\n\n因为堆排序是就地排序，空间复杂度为常数：O(1)\n\n# 时间复杂度\n\n堆排序的时间复杂度，主要在初始化堆过程和每次选取最大数后重新建堆的过程；\n\n初始化建堆过程时间：O(n)\n\n推算过程：\n\n首先要理解怎么计算这个堆化过程所消耗的时间，可以直接画图去理解；\n\n假设高度为k，则从倒数第二层右边的节点开始，这一层的节点都要执行子节点比较然后交换（如果顺序是对的就不用交换）；倒数第三层呢，则会选择其子节点进行比较和交换，如果没交换就可以不用再执行下去了。如果交换了，那么又要选择一支子树进行比较和交换；\n\n那么总的时间计算为：s = 2^( i - 1 )  *  ( k - i )；其中 i 表示第几层，2^( i - 1) 表示该层上有多少个元素，( k - i) 表示子树上要比较的次数，如果在最差的条件下，就是比较次数后还要交换；因为这个是常数，所以提出来后可以忽略；\n\nS = 2^(k-2) * 1 + 2^(k-3)*2.....+2*(k-2)+2^(0)*(k-1)  ===> 因为叶子层不用交换，所以i从 k-1 开始到 1；\n这个等式求解，我想高中已经会了：等式左右乘上2，然后和原来的等式相减，就变成了：\nS = 2^(k - 1) + 2^(k - 2) + 2^(k - 3) ..... + 2 - (k-1)\n除最后一项外，就是一个等比数列了，直接用求和公式：S = {  a1[ 1-  (q^n) ] }  / (1-q)；\nS = 2^k -k -1；又因为k为完全二叉树的深度，所以 (2^k) <=  n < (2^k  -1 )，总之可以认为：k = logn （实际计算得到应该是 log(n+1) < k <= logn ）;\n综上所述得到：S = n - longn -1，所以时间复杂度为：O(n)\n更改堆元素后重建堆时间：O(nlogn)\n推算过程：\n1、循环  n -1 次，每次都是从根节点往下循环查找，所以每一次时间是 logn，总时间：logn(n-1) = nlogn  - logn ；\n综上所述：堆排序的时间复杂度为：O(nlogn)\n\n# 算法实现思想\n\n堆排序的大概步骤如下:\n\n1. 构建最大堆。\n2. 选择顶，并与第0位置元素交换\n3. 由于步骤2的的交换可能破环了最大堆的性质，第0不再是最大元素，需要调用maxHeap调整堆(沉降法)，如果需要重复步骤2\n\n# java实现\n\n```\npublic static void heapSort(int[] array) {  \n    if (array == null || array.length <= 1) {  \n        return;  \n    }  \n  \n    buildMaxHeap(array);  \n  \n    for (int i = array.length - 1; i >= 1; i--) {  \n    \tArrayUtils.exchangeElements(array, 0, i);  \n\n    \tmaxHeap(array, i, 0);  \n    }  \n}  \n  \nprivate static void buildMaxHeap(int[] array) {  \n\tif (array == null || array.length <= 1) {  \n\t\treturn;  \n\t}  \n\n\tint half = array.length / 2;  \n\tfor (int i = half; i >= 0; i--) {  \n\t\tmaxHeap(array, array.length, i);  \n\t}  \n}\nprivate static void maxHeap(int[] array, int heapSize, int index) {  \n\tint left = index * 2 + 1;  \n\tint right = index * 2 + 2;  \n\n\tint largest = index;  \n\tif (left < heapSize && array[left] > array[index]) {  \n\t\tlargest = left;  \n\t}  \n\n\tif (right < heapSize && array[right] > array[largest]) {  \n\t\tlargest = right;  \n\t}  \n\n\tif (index != largest) {  \n\t\tArrayUtils.exchangeElements(array, index, largest);  \n\n\t\tmaxHeap(array, heapSize, largest);  \n\t}  \n}  \npublic static void exchangeElements(int[] array, int index1, int index2) {  \n\tint temp = array[index1];  \n\tarray[index1] = array[index2];  \n\tarray[index2] = temp;  \n}  \n```\n\n# c实现\n\n# python实现","slug":"堆排序","published":1,"updated":"2019-03-12T09:26:33.167Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttz1004v3a8kxao7zi99","content":"<p>堆排序是内部排序中选择排序的一种。堆排序是一种树形选择排序，是对选择排序的有效改进。</p>\n<p>堆是一种具有n个元素的序列，当且仅当满足 ki&lt;=k2i, ki&lt;= k2i+1，或者反过来。<br>若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。</p>\n<p>初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。<br>然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大的元素。<br>依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。</p>\n<ol>\n<li>调整小堆顶的方法</li>\n</ol>\n<p>1）设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。</p>\n<p>2）将根结点与左、右子树中较小元素的进行交换。</p>\n<p>3）若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）.</p>\n<p>4）若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）.</p>\n<p>5）继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。</p>\n<ol start=\"2\">\n<li>建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。</li>\n</ol>\n<p>1）n 个结点的完全二叉树，则最后一个结点是第个结点的子树。</p>\n<p>2）筛选从第个结点为根的子树开始，该子树成为堆。</p>\n<p>3）之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。<br>然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大的元素。<br>依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>因为堆排序是就地排序，空间复杂度为常数：O(1)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>堆排序的时间复杂度，主要在初始化堆过程和每次选取最大数后重新建堆的过程；</p>\n<p>初始化建堆过程时间：O(n)</p>\n<p>推算过程：</p>\n<p>首先要理解怎么计算这个堆化过程所消耗的时间，可以直接画图去理解；</p>\n<p>假设高度为k，则从倒数第二层右边的节点开始，这一层的节点都要执行子节点比较然后交换（如果顺序是对的就不用交换）；倒数第三层呢，则会选择其子节点进行比较和交换，如果没交换就可以不用再执行下去了。如果交换了，那么又要选择一支子树进行比较和交换；</p>\n<p>那么总的时间计算为：s = 2^( i - 1 )  *  ( k - i )；其中 i 表示第几层，2^( i - 1) 表示该层上有多少个元素，( k - i) 表示子树上要比较的次数，如果在最差的条件下，就是比较次数后还要交换；因为这个是常数，所以提出来后可以忽略；</p>\n<p>S = 2^(k-2) <em> 1 + 2^(k-3)</em>2…..+2<em>(k-2)+2^(0)</em>(k-1)  ===&gt; 因为叶子层不用交换，所以i从 k-1 开始到 1；<br>这个等式求解，我想高中已经会了：等式左右乘上2，然后和原来的等式相减，就变成了：<br>S = 2^(k - 1) + 2^(k - 2) + 2^(k - 3) ….. + 2 - (k-1)<br>除最后一项外，就是一个等比数列了，直接用求和公式：S = {  a1[ 1-  (q^n) ] }  / (1-q)；<br>S = 2^k -k -1；又因为k为完全二叉树的深度，所以 (2^k) &lt;=  n &lt; (2^k  -1 )，总之可以认为：k = logn （实际计算得到应该是 log(n+1) &lt; k &lt;= logn ）;<br>综上所述得到：S = n - longn -1，所以时间复杂度为：O(n)<br>更改堆元素后重建堆时间：O(nlogn)<br>推算过程：<br>1、循环  n -1 次，每次都是从根节点往下循环查找，所以每一次时间是 logn，总时间：logn(n-1) = nlogn  - logn ；<br>综上所述：堆排序的时间复杂度为：O(nlogn)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>堆排序的大概步骤如下:</p>\n<ol>\n<li>构建最大堆。</li>\n<li>选择顶，并与第0位置元素交换</li>\n<li>由于步骤2的的交换可能破环了最大堆的性质，第0不再是最大元素，需要调用maxHeap调整堆(沉降法)，如果需要重复步骤2</li>\n</ol>\n<h1 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void heapSort(int[] array) &#123;  </span><br><span class=\"line\">    if (array == null || array.length &lt;= 1) &#123;  </span><br><span class=\"line\">        return;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    buildMaxHeap(array);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    for (int i = array.length - 1; i &gt;= 1; i--) &#123;  </span><br><span class=\"line\">    \tArrayUtils.exchangeElements(array, 0, i);  </span><br><span class=\"line\"></span><br><span class=\"line\">    \tmaxHeap(array, i, 0);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">private static void buildMaxHeap(int[] array) &#123;  </span><br><span class=\"line\">\tif (array == null || array.length &lt;= 1) &#123;  </span><br><span class=\"line\">\t\treturn;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">\tint half = array.length / 2;  </span><br><span class=\"line\">\tfor (int i = half; i &gt;= 0; i--) &#123;  </span><br><span class=\"line\">\t\tmaxHeap(array, array.length, i);  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private static void maxHeap(int[] array, int heapSize, int index) &#123;  </span><br><span class=\"line\">\tint left = index * 2 + 1;  </span><br><span class=\"line\">\tint right = index * 2 + 2;  </span><br><span class=\"line\"></span><br><span class=\"line\">\tint largest = index;  </span><br><span class=\"line\">\tif (left &lt; heapSize &amp;&amp; array[left] &gt; array[index]) &#123;  </span><br><span class=\"line\">\t\tlargest = left;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">\tif (right &lt; heapSize &amp;&amp; array[right] &gt; array[largest]) &#123;  </span><br><span class=\"line\">\t\tlargest = right;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">\tif (index != largest) &#123;  </span><br><span class=\"line\">\t\tArrayUtils.exchangeElements(array, index, largest);  </span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmaxHeap(array, heapSize, largest);  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">public static void exchangeElements(int[] array, int index1, int index2) &#123;  </span><br><span class=\"line\">\tint temp = array[index1];  </span><br><span class=\"line\">\tarray[index1] = array[index2];  </span><br><span class=\"line\">\tarray[index2] = temp;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h1><h1 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h1>","site":{"data":{}},"excerpt":"","more":"<p>堆排序是内部排序中选择排序的一种。堆排序是一种树形选择排序，是对选择排序的有效改进。</p>\n<p>堆是一种具有n个元素的序列，当且仅当满足 ki&lt;=k2i, ki&lt;= k2i+1，或者反过来。<br>若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。</p>\n<p>初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。<br>然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大的元素。<br>依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。</p>\n<ol>\n<li>调整小堆顶的方法</li>\n</ol>\n<p>1）设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。</p>\n<p>2）将根结点与左、右子树中较小元素的进行交换。</p>\n<p>3）若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）.</p>\n<p>4）若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）.</p>\n<p>5）继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。</p>\n<ol start=\"2\">\n<li>建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。</li>\n</ol>\n<p>1）n 个结点的完全二叉树，则最后一个结点是第个结点的子树。</p>\n<p>2）筛选从第个结点为根的子树开始，该子树成为堆。</p>\n<p>3）之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。<br>然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大的元素。<br>依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>因为堆排序是就地排序，空间复杂度为常数：O(1)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>堆排序的时间复杂度，主要在初始化堆过程和每次选取最大数后重新建堆的过程；</p>\n<p>初始化建堆过程时间：O(n)</p>\n<p>推算过程：</p>\n<p>首先要理解怎么计算这个堆化过程所消耗的时间，可以直接画图去理解；</p>\n<p>假设高度为k，则从倒数第二层右边的节点开始，这一层的节点都要执行子节点比较然后交换（如果顺序是对的就不用交换）；倒数第三层呢，则会选择其子节点进行比较和交换，如果没交换就可以不用再执行下去了。如果交换了，那么又要选择一支子树进行比较和交换；</p>\n<p>那么总的时间计算为：s = 2^( i - 1 )  *  ( k - i )；其中 i 表示第几层，2^( i - 1) 表示该层上有多少个元素，( k - i) 表示子树上要比较的次数，如果在最差的条件下，就是比较次数后还要交换；因为这个是常数，所以提出来后可以忽略；</p>\n<p>S = 2^(k-2) <em> 1 + 2^(k-3)</em>2…..+2<em>(k-2)+2^(0)</em>(k-1)  ===&gt; 因为叶子层不用交换，所以i从 k-1 开始到 1；<br>这个等式求解，我想高中已经会了：等式左右乘上2，然后和原来的等式相减，就变成了：<br>S = 2^(k - 1) + 2^(k - 2) + 2^(k - 3) ….. + 2 - (k-1)<br>除最后一项外，就是一个等比数列了，直接用求和公式：S = {  a1[ 1-  (q^n) ] }  / (1-q)；<br>S = 2^k -k -1；又因为k为完全二叉树的深度，所以 (2^k) &lt;=  n &lt; (2^k  -1 )，总之可以认为：k = logn （实际计算得到应该是 log(n+1) &lt; k &lt;= logn ）;<br>综上所述得到：S = n - longn -1，所以时间复杂度为：O(n)<br>更改堆元素后重建堆时间：O(nlogn)<br>推算过程：<br>1、循环  n -1 次，每次都是从根节点往下循环查找，所以每一次时间是 logn，总时间：logn(n-1) = nlogn  - logn ；<br>综上所述：堆排序的时间复杂度为：O(nlogn)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>堆排序的大概步骤如下:</p>\n<ol>\n<li>构建最大堆。</li>\n<li>选择顶，并与第0位置元素交换</li>\n<li>由于步骤2的的交换可能破环了最大堆的性质，第0不再是最大元素，需要调用maxHeap调整堆(沉降法)，如果需要重复步骤2</li>\n</ol>\n<h1 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void heapSort(int[] array) &#123;  </span><br><span class=\"line\">    if (array == null || array.length &lt;= 1) &#123;  </span><br><span class=\"line\">        return;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    buildMaxHeap(array);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    for (int i = array.length - 1; i &gt;= 1; i--) &#123;  </span><br><span class=\"line\">    \tArrayUtils.exchangeElements(array, 0, i);  </span><br><span class=\"line\"></span><br><span class=\"line\">    \tmaxHeap(array, i, 0);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">private static void buildMaxHeap(int[] array) &#123;  </span><br><span class=\"line\">\tif (array == null || array.length &lt;= 1) &#123;  </span><br><span class=\"line\">\t\treturn;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">\tint half = array.length / 2;  </span><br><span class=\"line\">\tfor (int i = half; i &gt;= 0; i--) &#123;  </span><br><span class=\"line\">\t\tmaxHeap(array, array.length, i);  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private static void maxHeap(int[] array, int heapSize, int index) &#123;  </span><br><span class=\"line\">\tint left = index * 2 + 1;  </span><br><span class=\"line\">\tint right = index * 2 + 2;  </span><br><span class=\"line\"></span><br><span class=\"line\">\tint largest = index;  </span><br><span class=\"line\">\tif (left &lt; heapSize &amp;&amp; array[left] &gt; array[index]) &#123;  </span><br><span class=\"line\">\t\tlargest = left;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">\tif (right &lt; heapSize &amp;&amp; array[right] &gt; array[largest]) &#123;  </span><br><span class=\"line\">\t\tlargest = right;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">\tif (index != largest) &#123;  </span><br><span class=\"line\">\t\tArrayUtils.exchangeElements(array, index, largest);  </span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmaxHeap(array, heapSize, largest);  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">public static void exchangeElements(int[] array, int index1, int index2) &#123;  </span><br><span class=\"line\">\tint temp = array[index1];  </span><br><span class=\"line\">\tarray[index1] = array[index2];  </span><br><span class=\"line\">\tarray[index2] = temp;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h1><h1 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h1>"},{"title":"希尔排序","date":"2018-01-08T15:43:42.000Z","_content":"希尔排序又叫缩小增量排序，是排序中的内部排序的插入排序的一种\n\n# 算法思想\n\n先将整个待排序的记录数组分割为若干个子数组，对各个子数组进行直接插入排序，待整个数组中的元素“基本有序”时，在对全体数组进行依次直接插入排序。\n所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，例如｛2,1,3,6,4,7,5,8,9,｝就可以称为基本有序了。但像｛1,5,9,3,7,8,2,4,6｝这样，9在第三位，2在倒数第三位就谈不上基本有序。\n\n# 空间复杂度\n\n每次只比较一个单元，所以空间复杂度为O(1)\n\n# 时间复杂度\n\n希尔排序是不稳定排序，时间复杂度最好和平均都是O(nlogn),最坏复杂度是O(n^2)\n\n# 算法实现思想\n\n以数组{26, 53, 67, 48, 57, 13, 48, 32, 60, 50 }为例，步长序列为{5,3,1} \n初始化关键字： [26, 53, 67, 48, 57, 13, 48, 32, 60, 50 ]\n\n![排序过程](/images/算法/希尔排序.png)\n\n最后的排序结果： \n13 26 32 48 48 50 53 57 60 67\n\n## java实现\n\n```\npublic static int[] shellSort(int[] array){\n\tint i = 0;\n\tint temp = 0;\n\tint[] arr = array;\n\tfor (int increment = arr.length; increment > 0; increment /= 2){\n\t\tfor (i = increment; i < arr.length; i++){\n\t\t\ttemp = arr[i];\n\t\t\tfor (j = i - increment; j >= 0; j -= increment){\n\t\t\t\tif (temp < data[j]){\n\t\t\t\t\tdata[j + increment] = data[j];\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn arr;\n}\n```\n\n## c实现\n\n```\nvoid shell_sort(int array[], int length){  \n    int i;  \n    int j;  \n    int k;  \n    int gap;    //gap是分组的步长  \n    int temp;   //希尔排序是在直接插入排序的基础上实现的,所以仍然需要哨兵  \n    for(gap=length/2; gap>0; gap=gap/2){  \n        for(i=0; i<gap; i++){  \n            for(j=i+gap; j<length; j=j+gap){ //单独一次的插入排序  \n                if(array[j] < array[j - gap]){  \n                    temp = array[j];    //哨兵  \n                    k = j - gap;  \n                    while(k>=0 && array[k]>temp){  \n                        array[k + gap] = array[k];  \n                        k = k - gap;  \n                    }  \n                    array[k + gap] = temp;  \n                }  \n            }  \n        }  \n    }  \n} \n```\n\n## python实现\n\n```\ndef shell_sort(A):\n    N = len(A)\n    increment = N//2\n    while increment > 0:\n        i = increment\n        while i < N:\n            j = i - increment\n            tmp = A[i]\n            while j >= 0 and A[j] > tmp:\n                A[j + increment] = A[j]\n                j -= increment\n            A[j + increment] = tmp\n            i += 1\n        increment //= 2\n    return None\n```\n","source":"_posts/希尔排序.md","raw":"---\ntitle: 希尔排序\ndate: 2018-01-08 23:43:42\ntags: 算法\n---\n希尔排序又叫缩小增量排序，是排序中的内部排序的插入排序的一种\n\n# 算法思想\n\n先将整个待排序的记录数组分割为若干个子数组，对各个子数组进行直接插入排序，待整个数组中的元素“基本有序”时，在对全体数组进行依次直接插入排序。\n所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，例如｛2,1,3,6,4,7,5,8,9,｝就可以称为基本有序了。但像｛1,5,9,3,7,8,2,4,6｝这样，9在第三位，2在倒数第三位就谈不上基本有序。\n\n# 空间复杂度\n\n每次只比较一个单元，所以空间复杂度为O(1)\n\n# 时间复杂度\n\n希尔排序是不稳定排序，时间复杂度最好和平均都是O(nlogn),最坏复杂度是O(n^2)\n\n# 算法实现思想\n\n以数组{26, 53, 67, 48, 57, 13, 48, 32, 60, 50 }为例，步长序列为{5,3,1} \n初始化关键字： [26, 53, 67, 48, 57, 13, 48, 32, 60, 50 ]\n\n![排序过程](/images/算法/希尔排序.png)\n\n最后的排序结果： \n13 26 32 48 48 50 53 57 60 67\n\n## java实现\n\n```\npublic static int[] shellSort(int[] array){\n\tint i = 0;\n\tint temp = 0;\n\tint[] arr = array;\n\tfor (int increment = arr.length; increment > 0; increment /= 2){\n\t\tfor (i = increment; i < arr.length; i++){\n\t\t\ttemp = arr[i];\n\t\t\tfor (j = i - increment; j >= 0; j -= increment){\n\t\t\t\tif (temp < data[j]){\n\t\t\t\t\tdata[j + increment] = data[j];\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn arr;\n}\n```\n\n## c实现\n\n```\nvoid shell_sort(int array[], int length){  \n    int i;  \n    int j;  \n    int k;  \n    int gap;    //gap是分组的步长  \n    int temp;   //希尔排序是在直接插入排序的基础上实现的,所以仍然需要哨兵  \n    for(gap=length/2; gap>0; gap=gap/2){  \n        for(i=0; i<gap; i++){  \n            for(j=i+gap; j<length; j=j+gap){ //单独一次的插入排序  \n                if(array[j] < array[j - gap]){  \n                    temp = array[j];    //哨兵  \n                    k = j - gap;  \n                    while(k>=0 && array[k]>temp){  \n                        array[k + gap] = array[k];  \n                        k = k - gap;  \n                    }  \n                    array[k + gap] = temp;  \n                }  \n            }  \n        }  \n    }  \n} \n```\n\n## python实现\n\n```\ndef shell_sort(A):\n    N = len(A)\n    increment = N//2\n    while increment > 0:\n        i = increment\n        while i < N:\n            j = i - increment\n            tmp = A[i]\n            while j >= 0 and A[j] > tmp:\n                A[j + increment] = A[j]\n                j -= increment\n            A[j + increment] = tmp\n            i += 1\n        increment //= 2\n    return None\n```\n","slug":"希尔排序","published":1,"updated":"2019-03-12T09:26:33.167Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttz3004x3a8k1gxow6z1","content":"<p>希尔排序又叫缩小增量排序，是排序中的内部排序的插入排序的一种</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>先将整个待排序的记录数组分割为若干个子数组，对各个子数组进行直接插入排序，待整个数组中的元素“基本有序”时，在对全体数组进行依次直接插入排序。<br>所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，例如｛2,1,3,6,4,7,5,8,9,｝就可以称为基本有序了。但像｛1,5,9,3,7,8,2,4,6｝这样，9在第三位，2在倒数第三位就谈不上基本有序。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>每次只比较一个单元，所以空间复杂度为O(1)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>希尔排序是不稳定排序，时间复杂度最好和平均都是O(nlogn),最坏复杂度是O(n^2)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>以数组{26, 53, 67, 48, 57, 13, 48, 32, 60, 50 }为例，步长序列为{5,3,1}<br>初始化关键字： [26, 53, 67, 48, 57, 13, 48, 32, 60, 50 ]</p>\n<p><img src=\"/images/算法/希尔排序.png\" alt=\"排序过程\"></p>\n<p>最后的排序结果：<br>13 26 32 48 48 50 53 57 60 67</p>\n<h2 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int[] shellSort(int[] array)&#123;</span><br><span class=\"line\">\tint i = 0;</span><br><span class=\"line\">\tint temp = 0;</span><br><span class=\"line\">\tint[] arr = array;</span><br><span class=\"line\">\tfor (int increment = arr.length; increment &gt; 0; increment /= 2)&#123;</span><br><span class=\"line\">\t\tfor (i = increment; i &lt; arr.length; i++)&#123;</span><br><span class=\"line\">\t\t\ttemp = arr[i];</span><br><span class=\"line\">\t\t\tfor (j = i - increment; j &gt;= 0; j -= increment)&#123;</span><br><span class=\"line\">\t\t\t\tif (temp &lt; data[j])&#123;</span><br><span class=\"line\">\t\t\t\t\tdata[j + increment] = data[j];</span><br><span class=\"line\">\t\t\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void shell_sort(int array[], int length)&#123;  </span><br><span class=\"line\">    int i;  </span><br><span class=\"line\">    int j;  </span><br><span class=\"line\">    int k;  </span><br><span class=\"line\">    int gap;    //gap是分组的步长  </span><br><span class=\"line\">    int temp;   //希尔排序是在直接插入排序的基础上实现的,所以仍然需要哨兵  </span><br><span class=\"line\">    for(gap=length/2; gap&gt;0; gap=gap/2)&#123;  </span><br><span class=\"line\">        for(i=0; i&lt;gap; i++)&#123;  </span><br><span class=\"line\">            for(j=i+gap; j&lt;length; j=j+gap)&#123; //单独一次的插入排序  </span><br><span class=\"line\">                if(array[j] &lt; array[j - gap])&#123;  </span><br><span class=\"line\">                    temp = array[j];    //哨兵  </span><br><span class=\"line\">                    k = j - gap;  </span><br><span class=\"line\">                    while(k&gt;=0 &amp;&amp; array[k]&gt;temp)&#123;  </span><br><span class=\"line\">                        array[k + gap] = array[k];  </span><br><span class=\"line\">                        k = k - gap;  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    array[k + gap] = temp;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def shell_sort(A):</span><br><span class=\"line\">    N = len(A)</span><br><span class=\"line\">    increment = N//2</span><br><span class=\"line\">    while increment &gt; 0:</span><br><span class=\"line\">        i = increment</span><br><span class=\"line\">        while i &lt; N:</span><br><span class=\"line\">            j = i - increment</span><br><span class=\"line\">            tmp = A[i]</span><br><span class=\"line\">            while j &gt;= 0 and A[j] &gt; tmp:</span><br><span class=\"line\">                A[j + increment] = A[j]</span><br><span class=\"line\">                j -= increment</span><br><span class=\"line\">            A[j + increment] = tmp</span><br><span class=\"line\">            i += 1</span><br><span class=\"line\">        increment //= 2</span><br><span class=\"line\">    return None</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>希尔排序又叫缩小增量排序，是排序中的内部排序的插入排序的一种</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>先将整个待排序的记录数组分割为若干个子数组，对各个子数组进行直接插入排序，待整个数组中的元素“基本有序”时，在对全体数组进行依次直接插入排序。<br>所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，例如｛2,1,3,6,4,7,5,8,9,｝就可以称为基本有序了。但像｛1,5,9,3,7,8,2,4,6｝这样，9在第三位，2在倒数第三位就谈不上基本有序。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>每次只比较一个单元，所以空间复杂度为O(1)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>希尔排序是不稳定排序，时间复杂度最好和平均都是O(nlogn),最坏复杂度是O(n^2)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>以数组{26, 53, 67, 48, 57, 13, 48, 32, 60, 50 }为例，步长序列为{5,3,1}<br>初始化关键字： [26, 53, 67, 48, 57, 13, 48, 32, 60, 50 ]</p>\n<p><img src=\"/images/算法/希尔排序.png\" alt=\"排序过程\"></p>\n<p>最后的排序结果：<br>13 26 32 48 48 50 53 57 60 67</p>\n<h2 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int[] shellSort(int[] array)&#123;</span><br><span class=\"line\">\tint i = 0;</span><br><span class=\"line\">\tint temp = 0;</span><br><span class=\"line\">\tint[] arr = array;</span><br><span class=\"line\">\tfor (int increment = arr.length; increment &gt; 0; increment /= 2)&#123;</span><br><span class=\"line\">\t\tfor (i = increment; i &lt; arr.length; i++)&#123;</span><br><span class=\"line\">\t\t\ttemp = arr[i];</span><br><span class=\"line\">\t\t\tfor (j = i - increment; j &gt;= 0; j -= increment)&#123;</span><br><span class=\"line\">\t\t\t\tif (temp &lt; data[j])&#123;</span><br><span class=\"line\">\t\t\t\t\tdata[j + increment] = data[j];</span><br><span class=\"line\">\t\t\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void shell_sort(int array[], int length)&#123;  </span><br><span class=\"line\">    int i;  </span><br><span class=\"line\">    int j;  </span><br><span class=\"line\">    int k;  </span><br><span class=\"line\">    int gap;    //gap是分组的步长  </span><br><span class=\"line\">    int temp;   //希尔排序是在直接插入排序的基础上实现的,所以仍然需要哨兵  </span><br><span class=\"line\">    for(gap=length/2; gap&gt;0; gap=gap/2)&#123;  </span><br><span class=\"line\">        for(i=0; i&lt;gap; i++)&#123;  </span><br><span class=\"line\">            for(j=i+gap; j&lt;length; j=j+gap)&#123; //单独一次的插入排序  </span><br><span class=\"line\">                if(array[j] &lt; array[j - gap])&#123;  </span><br><span class=\"line\">                    temp = array[j];    //哨兵  </span><br><span class=\"line\">                    k = j - gap;  </span><br><span class=\"line\">                    while(k&gt;=0 &amp;&amp; array[k]&gt;temp)&#123;  </span><br><span class=\"line\">                        array[k + gap] = array[k];  </span><br><span class=\"line\">                        k = k - gap;  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    array[k + gap] = temp;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def shell_sort(A):</span><br><span class=\"line\">    N = len(A)</span><br><span class=\"line\">    increment = N//2</span><br><span class=\"line\">    while increment &gt; 0:</span><br><span class=\"line\">        i = increment</span><br><span class=\"line\">        while i &lt; N:</span><br><span class=\"line\">            j = i - increment</span><br><span class=\"line\">            tmp = A[i]</span><br><span class=\"line\">            while j &gt;= 0 and A[j] &gt; tmp:</span><br><span class=\"line\">                A[j + increment] = A[j]</span><br><span class=\"line\">                j -= increment</span><br><span class=\"line\">            A[j + increment] = tmp</span><br><span class=\"line\">            i += 1</span><br><span class=\"line\">        increment //= 2</span><br><span class=\"line\">    return None</span><br></pre></td></tr></table></figure>\n"},{"title":"快速排序","date":"2018-01-11T14:32:16.000Z","_content":"快速排序是内部排序中交换排序的一种。\n\n# 算法思想\n\n1）选择一个基准元素,通常选择第一个元素或者最后一个元素,\n\n2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。\n\n3）此时基准元素在其排好序后的正确位置\n\n4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。\n\n# 空间复杂度\n\nO(1)\n\n# 时间复杂度\n\n最理想 O(nlogn) 最差时间O(n^2)\n\n# 算法实现思想\n\n# java实现\n\n```\nclass quick_sort {\n    /**\n     * 前后指针快排法\n     */\n    public static void quickSortByTwoPointer(int[] a,int startIndex, int endIndex){\n        if (startIndex >= endIndex){\n            return;\n        }\n        int partitionIndex = getPartitionIndexByTwoPointer(a,startIndex,endIndex);\n        quickSortByTwoPointer(a, startIndex, partitionIndex-1);\n        quickSortByTwoPointer(a, partitionIndex + 1, endIndex);\n    }\n\n    private static int getPartitionIndexByTwoPointer(int[] a, int startIndex, int endIndex){\n        int left = startIndex;\n        int right = endIndex;\n        int pivot = a[startIndex];\n        while (left != right){\n            while (left < right && a[right] > pivot){\n                right --;\n            }\n            while (left < right && a[left] <= pivot){\n                left ++;\n            }\n            if (left < right){\n                a[left] = a[left] + a[right];\n                a[right] = a[left] - a[right];\n                a[left] = a[left] - a[right];\n            }\n            System.out.println(\"after replace \"+Arrays.toString(a));\n        }\n        System.out.println(\"before change \"+ Arrays.toString(a));\n        a[startIndex] = a[left];\n        a[left] = pivot;\n        System.out.println(\"after change \"+Arrays.toString(a));\n        return left;\n    }\n\n    public static void quickSortByFillEmpty(int[] a, int startIndex, int endIndex){\n        if (startIndex > endIndex){\n            return;\n        }\n        int partitionIndex = getPartitionIndexByFillEmpty(a, startIndex,endIndex);\n        quickSortByFillEmpty(a, startIndex, partitionIndex-1);\n        quickSortByFillEmpty(a, partitionIndex +1, endIndex);\n    }\n\n    private static int getPartitionIndexByFillEmpty(int[] a, int startIndex, int endIndex){\n        int index = startIndex;\n        int left = startIndex;\n        int right = endIndex;\n        int pivot = a[startIndex];\n\n        while (left < right){\n            while (left < right){\n                if (a[right] < pivot){\n                    a[index] = a[right];\n                    index = right;\n                    left ++;\n                    break;\n                }\n                right --;\n            }\n            while (left < right){\n                if (a[left] > pivot){\n                    a[index] = a[left];\n                    index = left;\n                    right --;\n                    break;\n                }\n                left ++;\n            }\n        }\n        a[index] = pivot;\n        return index;\n    }\n\n    public static void main(String[] args) {\n        int[] a = new int[]{3,4,9,1,2,6,5,2,1};\n        System.out.println(Arrays.toString(a));\n        quickSortByTwoPointer(a,0, a.length-1);\n        System.out.println(Arrays.toString(a));\n//        int a = 1;\n//        int b = 2;\n//        a = a + b;\n//        b = a - b;\n//        a = a - b;\n//        System.out.println(a);\n//        System.out.println(b);\n    }\n}\n```\n\n# c实现\n\n# python实现","source":"_posts/快速排序.md","raw":"---\ntitle: 快速排序\ndate: 2018-01-11 22:32:16\ntags:\n---\n快速排序是内部排序中交换排序的一种。\n\n# 算法思想\n\n1）选择一个基准元素,通常选择第一个元素或者最后一个元素,\n\n2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。\n\n3）此时基准元素在其排好序后的正确位置\n\n4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。\n\n# 空间复杂度\n\nO(1)\n\n# 时间复杂度\n\n最理想 O(nlogn) 最差时间O(n^2)\n\n# 算法实现思想\n\n# java实现\n\n```\nclass quick_sort {\n    /**\n     * 前后指针快排法\n     */\n    public static void quickSortByTwoPointer(int[] a,int startIndex, int endIndex){\n        if (startIndex >= endIndex){\n            return;\n        }\n        int partitionIndex = getPartitionIndexByTwoPointer(a,startIndex,endIndex);\n        quickSortByTwoPointer(a, startIndex, partitionIndex-1);\n        quickSortByTwoPointer(a, partitionIndex + 1, endIndex);\n    }\n\n    private static int getPartitionIndexByTwoPointer(int[] a, int startIndex, int endIndex){\n        int left = startIndex;\n        int right = endIndex;\n        int pivot = a[startIndex];\n        while (left != right){\n            while (left < right && a[right] > pivot){\n                right --;\n            }\n            while (left < right && a[left] <= pivot){\n                left ++;\n            }\n            if (left < right){\n                a[left] = a[left] + a[right];\n                a[right] = a[left] - a[right];\n                a[left] = a[left] - a[right];\n            }\n            System.out.println(\"after replace \"+Arrays.toString(a));\n        }\n        System.out.println(\"before change \"+ Arrays.toString(a));\n        a[startIndex] = a[left];\n        a[left] = pivot;\n        System.out.println(\"after change \"+Arrays.toString(a));\n        return left;\n    }\n\n    public static void quickSortByFillEmpty(int[] a, int startIndex, int endIndex){\n        if (startIndex > endIndex){\n            return;\n        }\n        int partitionIndex = getPartitionIndexByFillEmpty(a, startIndex,endIndex);\n        quickSortByFillEmpty(a, startIndex, partitionIndex-1);\n        quickSortByFillEmpty(a, partitionIndex +1, endIndex);\n    }\n\n    private static int getPartitionIndexByFillEmpty(int[] a, int startIndex, int endIndex){\n        int index = startIndex;\n        int left = startIndex;\n        int right = endIndex;\n        int pivot = a[startIndex];\n\n        while (left < right){\n            while (left < right){\n                if (a[right] < pivot){\n                    a[index] = a[right];\n                    index = right;\n                    left ++;\n                    break;\n                }\n                right --;\n            }\n            while (left < right){\n                if (a[left] > pivot){\n                    a[index] = a[left];\n                    index = left;\n                    right --;\n                    break;\n                }\n                left ++;\n            }\n        }\n        a[index] = pivot;\n        return index;\n    }\n\n    public static void main(String[] args) {\n        int[] a = new int[]{3,4,9,1,2,6,5,2,1};\n        System.out.println(Arrays.toString(a));\n        quickSortByTwoPointer(a,0, a.length-1);\n        System.out.println(Arrays.toString(a));\n//        int a = 1;\n//        int b = 2;\n//        a = a + b;\n//        b = a - b;\n//        a = a - b;\n//        System.out.println(a);\n//        System.out.println(b);\n    }\n}\n```\n\n# c实现\n\n# python实现","slug":"快速排序","published":1,"updated":"2019-03-12T09:26:33.167Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttz4004z3a8kqsw1t5jt","content":"<p>快速排序是内部排序中交换排序的一种。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>1）选择一个基准元素,通常选择第一个元素或者最后一个元素,</p>\n<p>2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。</p>\n<p>3）此时基准元素在其排好序后的正确位置</p>\n<p>4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>O(1)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>最理想 O(nlogn) 最差时间O(n^2)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><h1 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class quick_sort &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 前后指针快排法</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void quickSortByTwoPointer(int[] a,int startIndex, int endIndex)&#123;</span><br><span class=\"line\">        if (startIndex &gt;= endIndex)&#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int partitionIndex = getPartitionIndexByTwoPointer(a,startIndex,endIndex);</span><br><span class=\"line\">        quickSortByTwoPointer(a, startIndex, partitionIndex-1);</span><br><span class=\"line\">        quickSortByTwoPointer(a, partitionIndex + 1, endIndex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static int getPartitionIndexByTwoPointer(int[] a, int startIndex, int endIndex)&#123;</span><br><span class=\"line\">        int left = startIndex;</span><br><span class=\"line\">        int right = endIndex;</span><br><span class=\"line\">        int pivot = a[startIndex];</span><br><span class=\"line\">        while (left != right)&#123;</span><br><span class=\"line\">            while (left &lt; right &amp;&amp; a[right] &gt; pivot)&#123;</span><br><span class=\"line\">                right --;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            while (left &lt; right &amp;&amp; a[left] &lt;= pivot)&#123;</span><br><span class=\"line\">                left ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (left &lt; right)&#123;</span><br><span class=\"line\">                a[left] = a[left] + a[right];</span><br><span class=\"line\">                a[right] = a[left] - a[right];</span><br><span class=\"line\">                a[left] = a[left] - a[right];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(&quot;after replace &quot;+Arrays.toString(a));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;before change &quot;+ Arrays.toString(a));</span><br><span class=\"line\">        a[startIndex] = a[left];</span><br><span class=\"line\">        a[left] = pivot;</span><br><span class=\"line\">        System.out.println(&quot;after change &quot;+Arrays.toString(a));</span><br><span class=\"line\">        return left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void quickSortByFillEmpty(int[] a, int startIndex, int endIndex)&#123;</span><br><span class=\"line\">        if (startIndex &gt; endIndex)&#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int partitionIndex = getPartitionIndexByFillEmpty(a, startIndex,endIndex);</span><br><span class=\"line\">        quickSortByFillEmpty(a, startIndex, partitionIndex-1);</span><br><span class=\"line\">        quickSortByFillEmpty(a, partitionIndex +1, endIndex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static int getPartitionIndexByFillEmpty(int[] a, int startIndex, int endIndex)&#123;</span><br><span class=\"line\">        int index = startIndex;</span><br><span class=\"line\">        int left = startIndex;</span><br><span class=\"line\">        int right = endIndex;</span><br><span class=\"line\">        int pivot = a[startIndex];</span><br><span class=\"line\"></span><br><span class=\"line\">        while (left &lt; right)&#123;</span><br><span class=\"line\">            while (left &lt; right)&#123;</span><br><span class=\"line\">                if (a[right] &lt; pivot)&#123;</span><br><span class=\"line\">                    a[index] = a[right];</span><br><span class=\"line\">                    index = right;</span><br><span class=\"line\">                    left ++;</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                right --;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            while (left &lt; right)&#123;</span><br><span class=\"line\">                if (a[left] &gt; pivot)&#123;</span><br><span class=\"line\">                    a[index] = a[left];</span><br><span class=\"line\">                    index = left;</span><br><span class=\"line\">                    right --;</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                left ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a[index] = pivot;</span><br><span class=\"line\">        return index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] a = new int[]&#123;3,4,9,1,2,6,5,2,1&#125;;</span><br><span class=\"line\">        System.out.println(Arrays.toString(a));</span><br><span class=\"line\">        quickSortByTwoPointer(a,0, a.length-1);</span><br><span class=\"line\">        System.out.println(Arrays.toString(a));</span><br><span class=\"line\">//        int a = 1;</span><br><span class=\"line\">//        int b = 2;</span><br><span class=\"line\">//        a = a + b;</span><br><span class=\"line\">//        b = a - b;</span><br><span class=\"line\">//        a = a - b;</span><br><span class=\"line\">//        System.out.println(a);</span><br><span class=\"line\">//        System.out.println(b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h1><h1 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h1>","site":{"data":{}},"excerpt":"","more":"<p>快速排序是内部排序中交换排序的一种。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>1）选择一个基准元素,通常选择第一个元素或者最后一个元素,</p>\n<p>2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。</p>\n<p>3）此时基准元素在其排好序后的正确位置</p>\n<p>4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>O(1)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>最理想 O(nlogn) 最差时间O(n^2)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><h1 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class quick_sort &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 前后指针快排法</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void quickSortByTwoPointer(int[] a,int startIndex, int endIndex)&#123;</span><br><span class=\"line\">        if (startIndex &gt;= endIndex)&#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int partitionIndex = getPartitionIndexByTwoPointer(a,startIndex,endIndex);</span><br><span class=\"line\">        quickSortByTwoPointer(a, startIndex, partitionIndex-1);</span><br><span class=\"line\">        quickSortByTwoPointer(a, partitionIndex + 1, endIndex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static int getPartitionIndexByTwoPointer(int[] a, int startIndex, int endIndex)&#123;</span><br><span class=\"line\">        int left = startIndex;</span><br><span class=\"line\">        int right = endIndex;</span><br><span class=\"line\">        int pivot = a[startIndex];</span><br><span class=\"line\">        while (left != right)&#123;</span><br><span class=\"line\">            while (left &lt; right &amp;&amp; a[right] &gt; pivot)&#123;</span><br><span class=\"line\">                right --;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            while (left &lt; right &amp;&amp; a[left] &lt;= pivot)&#123;</span><br><span class=\"line\">                left ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (left &lt; right)&#123;</span><br><span class=\"line\">                a[left] = a[left] + a[right];</span><br><span class=\"line\">                a[right] = a[left] - a[right];</span><br><span class=\"line\">                a[left] = a[left] - a[right];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(&quot;after replace &quot;+Arrays.toString(a));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;before change &quot;+ Arrays.toString(a));</span><br><span class=\"line\">        a[startIndex] = a[left];</span><br><span class=\"line\">        a[left] = pivot;</span><br><span class=\"line\">        System.out.println(&quot;after change &quot;+Arrays.toString(a));</span><br><span class=\"line\">        return left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void quickSortByFillEmpty(int[] a, int startIndex, int endIndex)&#123;</span><br><span class=\"line\">        if (startIndex &gt; endIndex)&#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int partitionIndex = getPartitionIndexByFillEmpty(a, startIndex,endIndex);</span><br><span class=\"line\">        quickSortByFillEmpty(a, startIndex, partitionIndex-1);</span><br><span class=\"line\">        quickSortByFillEmpty(a, partitionIndex +1, endIndex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static int getPartitionIndexByFillEmpty(int[] a, int startIndex, int endIndex)&#123;</span><br><span class=\"line\">        int index = startIndex;</span><br><span class=\"line\">        int left = startIndex;</span><br><span class=\"line\">        int right = endIndex;</span><br><span class=\"line\">        int pivot = a[startIndex];</span><br><span class=\"line\"></span><br><span class=\"line\">        while (left &lt; right)&#123;</span><br><span class=\"line\">            while (left &lt; right)&#123;</span><br><span class=\"line\">                if (a[right] &lt; pivot)&#123;</span><br><span class=\"line\">                    a[index] = a[right];</span><br><span class=\"line\">                    index = right;</span><br><span class=\"line\">                    left ++;</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                right --;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            while (left &lt; right)&#123;</span><br><span class=\"line\">                if (a[left] &gt; pivot)&#123;</span><br><span class=\"line\">                    a[index] = a[left];</span><br><span class=\"line\">                    index = left;</span><br><span class=\"line\">                    right --;</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                left ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a[index] = pivot;</span><br><span class=\"line\">        return index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] a = new int[]&#123;3,4,9,1,2,6,5,2,1&#125;;</span><br><span class=\"line\">        System.out.println(Arrays.toString(a));</span><br><span class=\"line\">        quickSortByTwoPointer(a,0, a.length-1);</span><br><span class=\"line\">        System.out.println(Arrays.toString(a));</span><br><span class=\"line\">//        int a = 1;</span><br><span class=\"line\">//        int b = 2;</span><br><span class=\"line\">//        a = a + b;</span><br><span class=\"line\">//        b = a - b;</span><br><span class=\"line\">//        a = a - b;</span><br><span class=\"line\">//        System.out.println(a);</span><br><span class=\"line\">//        System.out.println(b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h1><h1 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h1>"},{"title":"某金融公司面试小记","date":"2018-01-12T12:38:32.000Z","_content":"\n前几天在boss直聘上面接到了一个面试邀请，hr蛮真诚的，今天下午请了半天年假去试试。\n\n# 笔试\n\n首先是笔试，笔试第一题是Math.round(11.5)和Math.round(-11.5)的值,我居然没用过，当时猜的12和-11，还猜对了。\n\n挑有印象的写。\n\n之后是问intent能传送哪些内容，serizable，parcel，bundle，charsquence,当时忘了，就写了个parcel和bundle，回来一看其实都能..\n\n之后的一些字符串处理的\nStringBuffer str = new StringBuffer(\"hello\");\nstr.append(\"world\");\n当然输出hello world了\n\nList<Integer> listA = new ArrayList<>();\nlistA.add(1);\nlistA.add(2);\nList<Integer> listB = new ArrayList<>(listA);\nCollections.copy(listA, listB);\n这时候listb还是1，2\n\nfragment在activity中使用和fragment中使用的差别：\n记得就是fragmentmanager的差别，context的差别。\n\n解释一下DVM中的线程和linux中线程的区别：\nDVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。 \n这题不会。\n\n笔试大概就这么多了。\n\n# 一面\n\n一面是个android的leader，刚开始还不是很打开话夹子，问我为啥走，问我做了哪些工作。居然还把我app开发说成只有6个月，丫的。\n这个leader感觉没问啥高深的问题，我居然都想不起来了。但我的确有几个没回答的上来..汗怎么忘了。\n\n感觉好像对大学学java的比较歧视，以为我没有多深的java功底。\n\n后来问我kotlin的一些相关的，高阶编程，我以为是函数式编程，拿python的高阶函数去说，还居然蒙对了。\n还问我h5会不会，我说只会一丁点，node会不会，只会搭博客，python会不会，这个有。没问c我有点诧异。\n\n问了我一个问题，关于activity的启动模式的，四种我都熟了，后来问我假如这四种同时添加，栈内什么情况，我说正确的，后来问我怎么从a回退到c，我真不知道这个，只能从activitymanager获取stack这个角度来说，这样获取了实例可以直接启动。\n\n\n# 二面\n\n二面是项目经理，这是大神，上来就是一系列由浅入深的题目，让我用mvp设计一个架构，保证耦合度低和热插拔，这部分是接口分离的原则来设计，这部分真不了解。\n之后问我一些别的内容，数据结构方面的，set vector的区别，我居然说vector是线程安全的，但是好像不止这些，其内部指责都不同。\n还问了我一些内容，可是好多我都忘了- -汗。\n\n# 三面\n\n三面是个证券经理，既然是证券经理，为啥揪着我简历上面的技术栈问..蛋疼\n\n# 四面\n\n四面是个妹子，和我讲了一些公司的发展，薪酬方面的，大概扣多少钱五险之类的。\n\n# 五面\n\n五面是联系我去公司的hr，他和我讲了好久公司发展的内容，其实我写的预期薪资并不高啊，最后成功的从税前13扯到了税后11-12，其实还不错。不过明显的他有点慌，他的意思是希望我接到offer能早点去，不要太拖，不要被别的公司高不到5k的offer挖走。汗，加5k是他妈18k了，我哪里值这么多钱。\n\n# 心得\n\n安卓开发自己还是投入了不少心血的，虽然一年半的从业经验，还是收获了不少东西，这次面试也证明了自己的能力。不再是当年在传音的时候任人宰割的那个我了。\n\n# 期望\n\n希望能拿到offer吧，税后12我就去，11以内我就放弃。","source":"_posts/某金融公司面试小记.md","raw":"---\ntitle: 某金融公司面试小记\ndate: 2018-01-12 20:38:32\ntags: 生活\n---\n\n前几天在boss直聘上面接到了一个面试邀请，hr蛮真诚的，今天下午请了半天年假去试试。\n\n# 笔试\n\n首先是笔试，笔试第一题是Math.round(11.5)和Math.round(-11.5)的值,我居然没用过，当时猜的12和-11，还猜对了。\n\n挑有印象的写。\n\n之后是问intent能传送哪些内容，serizable，parcel，bundle，charsquence,当时忘了，就写了个parcel和bundle，回来一看其实都能..\n\n之后的一些字符串处理的\nStringBuffer str = new StringBuffer(\"hello\");\nstr.append(\"world\");\n当然输出hello world了\n\nList<Integer> listA = new ArrayList<>();\nlistA.add(1);\nlistA.add(2);\nList<Integer> listB = new ArrayList<>(listA);\nCollections.copy(listA, listB);\n这时候listb还是1，2\n\nfragment在activity中使用和fragment中使用的差别：\n记得就是fragmentmanager的差别，context的差别。\n\n解释一下DVM中的线程和linux中线程的区别：\nDVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。 \n这题不会。\n\n笔试大概就这么多了。\n\n# 一面\n\n一面是个android的leader，刚开始还不是很打开话夹子，问我为啥走，问我做了哪些工作。居然还把我app开发说成只有6个月，丫的。\n这个leader感觉没问啥高深的问题，我居然都想不起来了。但我的确有几个没回答的上来..汗怎么忘了。\n\n感觉好像对大学学java的比较歧视，以为我没有多深的java功底。\n\n后来问我kotlin的一些相关的，高阶编程，我以为是函数式编程，拿python的高阶函数去说，还居然蒙对了。\n还问我h5会不会，我说只会一丁点，node会不会，只会搭博客，python会不会，这个有。没问c我有点诧异。\n\n问了我一个问题，关于activity的启动模式的，四种我都熟了，后来问我假如这四种同时添加，栈内什么情况，我说正确的，后来问我怎么从a回退到c，我真不知道这个，只能从activitymanager获取stack这个角度来说，这样获取了实例可以直接启动。\n\n\n# 二面\n\n二面是项目经理，这是大神，上来就是一系列由浅入深的题目，让我用mvp设计一个架构，保证耦合度低和热插拔，这部分是接口分离的原则来设计，这部分真不了解。\n之后问我一些别的内容，数据结构方面的，set vector的区别，我居然说vector是线程安全的，但是好像不止这些，其内部指责都不同。\n还问了我一些内容，可是好多我都忘了- -汗。\n\n# 三面\n\n三面是个证券经理，既然是证券经理，为啥揪着我简历上面的技术栈问..蛋疼\n\n# 四面\n\n四面是个妹子，和我讲了一些公司的发展，薪酬方面的，大概扣多少钱五险之类的。\n\n# 五面\n\n五面是联系我去公司的hr，他和我讲了好久公司发展的内容，其实我写的预期薪资并不高啊，最后成功的从税前13扯到了税后11-12，其实还不错。不过明显的他有点慌，他的意思是希望我接到offer能早点去，不要太拖，不要被别的公司高不到5k的offer挖走。汗，加5k是他妈18k了，我哪里值这么多钱。\n\n# 心得\n\n安卓开发自己还是投入了不少心血的，虽然一年半的从业经验，还是收获了不少东西，这次面试也证明了自己的能力。不再是当年在传音的时候任人宰割的那个我了。\n\n# 期望\n\n希望能拿到offer吧，税后12我就去，11以内我就放弃。","slug":"某金融公司面试小记","published":1,"updated":"2019-03-12T09:26:33.168Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttz500513a8ki14e2pq4","content":"<p>前几天在boss直聘上面接到了一个面试邀请，hr蛮真诚的，今天下午请了半天年假去试试。</p>\n<h1 id=\"笔试\"><a href=\"#笔试\" class=\"headerlink\" title=\"笔试\"></a>笔试</h1><p>首先是笔试，笔试第一题是Math.round(11.5)和Math.round(-11.5)的值,我居然没用过，当时猜的12和-11，还猜对了。</p>\n<p>挑有印象的写。</p>\n<p>之后是问intent能传送哪些内容，serizable，parcel，bundle，charsquence,当时忘了，就写了个parcel和bundle，回来一看其实都能..</p>\n<p>之后的一些字符串处理的<br>StringBuffer str = new StringBuffer(“hello”);<br>str.append(“world”);<br>当然输出hello world了</p>\n<p>List<integer> listA = new ArrayList&lt;&gt;();<br>listA.add(1);<br>listA.add(2);<br>List<integer> listB = new ArrayList&lt;&gt;(listA);<br>Collections.copy(listA, listB);<br>这时候listb还是1，2</integer></integer></p>\n<p>fragment在activity中使用和fragment中使用的差别：<br>记得就是fragmentmanager的差别，context的差别。</p>\n<p>解释一下DVM中的线程和linux中线程的区别：<br>DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。<br>这题不会。</p>\n<p>笔试大概就这么多了。</p>\n<h1 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h1><p>一面是个android的leader，刚开始还不是很打开话夹子，问我为啥走，问我做了哪些工作。居然还把我app开发说成只有6个月，丫的。<br>这个leader感觉没问啥高深的问题，我居然都想不起来了。但我的确有几个没回答的上来..汗怎么忘了。</p>\n<p>感觉好像对大学学java的比较歧视，以为我没有多深的java功底。</p>\n<p>后来问我kotlin的一些相关的，高阶编程，我以为是函数式编程，拿python的高阶函数去说，还居然蒙对了。<br>还问我h5会不会，我说只会一丁点，node会不会，只会搭博客，python会不会，这个有。没问c我有点诧异。</p>\n<p>问了我一个问题，关于activity的启动模式的，四种我都熟了，后来问我假如这四种同时添加，栈内什么情况，我说正确的，后来问我怎么从a回退到c，我真不知道这个，只能从activitymanager获取stack这个角度来说，这样获取了实例可以直接启动。</p>\n<h1 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h1><p>二面是项目经理，这是大神，上来就是一系列由浅入深的题目，让我用mvp设计一个架构，保证耦合度低和热插拔，这部分是接口分离的原则来设计，这部分真不了解。<br>之后问我一些别的内容，数据结构方面的，set vector的区别，我居然说vector是线程安全的，但是好像不止这些，其内部指责都不同。<br>还问了我一些内容，可是好多我都忘了- -汗。</p>\n<h1 id=\"三面\"><a href=\"#三面\" class=\"headerlink\" title=\"三面\"></a>三面</h1><p>三面是个证券经理，既然是证券经理，为啥揪着我简历上面的技术栈问..蛋疼</p>\n<h1 id=\"四面\"><a href=\"#四面\" class=\"headerlink\" title=\"四面\"></a>四面</h1><p>四面是个妹子，和我讲了一些公司的发展，薪酬方面的，大概扣多少钱五险之类的。</p>\n<h1 id=\"五面\"><a href=\"#五面\" class=\"headerlink\" title=\"五面\"></a>五面</h1><p>五面是联系我去公司的hr，他和我讲了好久公司发展的内容，其实我写的预期薪资并不高啊，最后成功的从税前13扯到了税后11-12，其实还不错。不过明显的他有点慌，他的意思是希望我接到offer能早点去，不要太拖，不要被别的公司高不到5k的offer挖走。汗，加5k是他妈18k了，我哪里值这么多钱。</p>\n<h1 id=\"心得\"><a href=\"#心得\" class=\"headerlink\" title=\"心得\"></a>心得</h1><p>安卓开发自己还是投入了不少心血的，虽然一年半的从业经验，还是收获了不少东西，这次面试也证明了自己的能力。不再是当年在传音的时候任人宰割的那个我了。</p>\n<h1 id=\"期望\"><a href=\"#期望\" class=\"headerlink\" title=\"期望\"></a>期望</h1><p>希望能拿到offer吧，税后12我就去，11以内我就放弃。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>前几天在boss直聘上面接到了一个面试邀请，hr蛮真诚的，今天下午请了半天年假去试试。</p>\n<h1 id=\"笔试\"><a href=\"#笔试\" class=\"headerlink\" title=\"笔试\"></a>笔试</h1><p>首先是笔试，笔试第一题是Math.round(11.5)和Math.round(-11.5)的值,我居然没用过，当时猜的12和-11，还猜对了。</p>\n<p>挑有印象的写。</p>\n<p>之后是问intent能传送哪些内容，serizable，parcel，bundle，charsquence,当时忘了，就写了个parcel和bundle，回来一看其实都能..</p>\n<p>之后的一些字符串处理的<br>StringBuffer str = new StringBuffer(“hello”);<br>str.append(“world”);<br>当然输出hello world了</p>\n<p>List<integer> listA = new ArrayList&lt;&gt;();<br>listA.add(1);<br>listA.add(2);<br>List<integer> listB = new ArrayList&lt;&gt;(listA);<br>Collections.copy(listA, listB);<br>这时候listb还是1，2</integer></integer></p>\n<p>fragment在activity中使用和fragment中使用的差别：<br>记得就是fragmentmanager的差别，context的差别。</p>\n<p>解释一下DVM中的线程和linux中线程的区别：<br>DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。<br>这题不会。</p>\n<p>笔试大概就这么多了。</p>\n<h1 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h1><p>一面是个android的leader，刚开始还不是很打开话夹子，问我为啥走，问我做了哪些工作。居然还把我app开发说成只有6个月，丫的。<br>这个leader感觉没问啥高深的问题，我居然都想不起来了。但我的确有几个没回答的上来..汗怎么忘了。</p>\n<p>感觉好像对大学学java的比较歧视，以为我没有多深的java功底。</p>\n<p>后来问我kotlin的一些相关的，高阶编程，我以为是函数式编程，拿python的高阶函数去说，还居然蒙对了。<br>还问我h5会不会，我说只会一丁点，node会不会，只会搭博客，python会不会，这个有。没问c我有点诧异。</p>\n<p>问了我一个问题，关于activity的启动模式的，四种我都熟了，后来问我假如这四种同时添加，栈内什么情况，我说正确的，后来问我怎么从a回退到c，我真不知道这个，只能从activitymanager获取stack这个角度来说，这样获取了实例可以直接启动。</p>\n<h1 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h1><p>二面是项目经理，这是大神，上来就是一系列由浅入深的题目，让我用mvp设计一个架构，保证耦合度低和热插拔，这部分是接口分离的原则来设计，这部分真不了解。<br>之后问我一些别的内容，数据结构方面的，set vector的区别，我居然说vector是线程安全的，但是好像不止这些，其内部指责都不同。<br>还问了我一些内容，可是好多我都忘了- -汗。</p>\n<h1 id=\"三面\"><a href=\"#三面\" class=\"headerlink\" title=\"三面\"></a>三面</h1><p>三面是个证券经理，既然是证券经理，为啥揪着我简历上面的技术栈问..蛋疼</p>\n<h1 id=\"四面\"><a href=\"#四面\" class=\"headerlink\" title=\"四面\"></a>四面</h1><p>四面是个妹子，和我讲了一些公司的发展，薪酬方面的，大概扣多少钱五险之类的。</p>\n<h1 id=\"五面\"><a href=\"#五面\" class=\"headerlink\" title=\"五面\"></a>五面</h1><p>五面是联系我去公司的hr，他和我讲了好久公司发展的内容，其实我写的预期薪资并不高啊，最后成功的从税前13扯到了税后11-12，其实还不错。不过明显的他有点慌，他的意思是希望我接到offer能早点去，不要太拖，不要被别的公司高不到5k的offer挖走。汗，加5k是他妈18k了，我哪里值这么多钱。</p>\n<h1 id=\"心得\"><a href=\"#心得\" class=\"headerlink\" title=\"心得\"></a>心得</h1><p>安卓开发自己还是投入了不少心血的，虽然一年半的从业经验，还是收获了不少东西，这次面试也证明了自己的能力。不再是当年在传音的时候任人宰割的那个我了。</p>\n<h1 id=\"期望\"><a href=\"#期望\" class=\"headerlink\" title=\"期望\"></a>期望</h1><p>希望能拿到offer吧，税后12我就去，11以内我就放弃。</p>\n"},{"title":"混淆学习","date":"2018-03-14T01:59:35.000Z","_content":"\n# 混淆文件生成\n\n每次构建时 ProGuard 都会输出下列文件：\n\ndump.txt\n说明 APK 中所有类文件的内部结构。\n\nmapping.txt\n提供原始与混淆过的类、方法和字段名称之间的转换。\n\nseeds.txt\n列出未进行混淆的类和成员。\n\nusage.txt\n列出从 APK 移除的代码。\n\n这些文件保存在 <module-name>/build/outputs/mapping/release/ 中。\n\n\n# 解码混淆过的堆叠追踪\n\n在 ProGuard 压缩代码后，读取堆叠追踪变得困难（即使并非不可行），因为方法名称经过了混淆处理。幸运的是，ProGuard 每次运行时都会创建一个 mapping.txt 文件，其中显示了与混淆过的名称对应的原始类名称、方法名称和字段名称。ProGuard 将该文件保存在应用的 <module-name>/build/outputs/mapping/release/ 目录中。\n\n请注意，您每次使用 ProGuard 创建发布构建时都会覆盖 mapping.txt 文件，因此您每次发布新版本时都必须小心地保存一个副本。通过为每个发布构建保留一个 mapping.txt 文件副本，您就可以在用户提交的已混淆堆叠追踪来自旧版本应用时对问题进行调试。\n\n在 Google Play 上发布应用时，您可以上传每个 APK 版本的 mapping.txt 文件。Google Play 将根据用户报告的问题对收到的堆叠追踪进行去混淆处理，以便您在 Google Play Developer Console 中进行检查。如需了解详细信息，请参阅帮助中心有关如何对崩溃堆叠追踪进行去混淆处理的文章。\n\n要自行将混淆过的堆叠追踪转换成可读的堆叠追踪，请使用 retrace 脚本（在 Windows 上为 retrace.bat；在 Mac/Linux 上为 retrace.sh）。它位于 <sdk-root>/tools/proguard/ 目录中。该脚本利用 mapping.txt 文件和您的堆叠追踪生成新的可读堆叠追踪。使用 retrace 工具的语法如下：\n```\nretrace.bat|retrace.sh [-verbose] mapping.txt [<stacktrace_file>]\n```\n\n例如：\n```\nretrace.bat -verbose mapping.txt obfuscated_trace.txt\n```\n如果您不指定堆叠追踪文件，retrace 工具会从标准输入读取。\n\n","source":"_posts/混淆学习.md","raw":"---\ntitle: 混淆学习\ndate: 2018-03-14 09:59:35\ntags: android\n---\n\n# 混淆文件生成\n\n每次构建时 ProGuard 都会输出下列文件：\n\ndump.txt\n说明 APK 中所有类文件的内部结构。\n\nmapping.txt\n提供原始与混淆过的类、方法和字段名称之间的转换。\n\nseeds.txt\n列出未进行混淆的类和成员。\n\nusage.txt\n列出从 APK 移除的代码。\n\n这些文件保存在 <module-name>/build/outputs/mapping/release/ 中。\n\n\n# 解码混淆过的堆叠追踪\n\n在 ProGuard 压缩代码后，读取堆叠追踪变得困难（即使并非不可行），因为方法名称经过了混淆处理。幸运的是，ProGuard 每次运行时都会创建一个 mapping.txt 文件，其中显示了与混淆过的名称对应的原始类名称、方法名称和字段名称。ProGuard 将该文件保存在应用的 <module-name>/build/outputs/mapping/release/ 目录中。\n\n请注意，您每次使用 ProGuard 创建发布构建时都会覆盖 mapping.txt 文件，因此您每次发布新版本时都必须小心地保存一个副本。通过为每个发布构建保留一个 mapping.txt 文件副本，您就可以在用户提交的已混淆堆叠追踪来自旧版本应用时对问题进行调试。\n\n在 Google Play 上发布应用时，您可以上传每个 APK 版本的 mapping.txt 文件。Google Play 将根据用户报告的问题对收到的堆叠追踪进行去混淆处理，以便您在 Google Play Developer Console 中进行检查。如需了解详细信息，请参阅帮助中心有关如何对崩溃堆叠追踪进行去混淆处理的文章。\n\n要自行将混淆过的堆叠追踪转换成可读的堆叠追踪，请使用 retrace 脚本（在 Windows 上为 retrace.bat；在 Mac/Linux 上为 retrace.sh）。它位于 <sdk-root>/tools/proguard/ 目录中。该脚本利用 mapping.txt 文件和您的堆叠追踪生成新的可读堆叠追踪。使用 retrace 工具的语法如下：\n```\nretrace.bat|retrace.sh [-verbose] mapping.txt [<stacktrace_file>]\n```\n\n例如：\n```\nretrace.bat -verbose mapping.txt obfuscated_trace.txt\n```\n如果您不指定堆叠追踪文件，retrace 工具会从标准输入读取。\n\n","slug":"混淆学习","published":1,"updated":"2019-03-12T09:26:33.168Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttz600533a8koumvm7ty","content":"<h1 id=\"混淆文件生成\"><a href=\"#混淆文件生成\" class=\"headerlink\" title=\"混淆文件生成\"></a>混淆文件生成</h1><p>每次构建时 ProGuard 都会输出下列文件：</p>\n<p>dump.txt<br>说明 APK 中所有类文件的内部结构。</p>\n<p>mapping.txt<br>提供原始与混淆过的类、方法和字段名称之间的转换。</p>\n<p>seeds.txt<br>列出未进行混淆的类和成员。</p>\n<p>usage.txt<br>列出从 APK 移除的代码。</p>\n<p>这些文件保存在 <module-name>/build/outputs/mapping/release/ 中。</module-name></p>\n<h1 id=\"解码混淆过的堆叠追踪\"><a href=\"#解码混淆过的堆叠追踪\" class=\"headerlink\" title=\"解码混淆过的堆叠追踪\"></a>解码混淆过的堆叠追踪</h1><p>在 ProGuard 压缩代码后，读取堆叠追踪变得困难（即使并非不可行），因为方法名称经过了混淆处理。幸运的是，ProGuard 每次运行时都会创建一个 mapping.txt 文件，其中显示了与混淆过的名称对应的原始类名称、方法名称和字段名称。ProGuard 将该文件保存在应用的 <module-name>/build/outputs/mapping/release/ 目录中。</module-name></p>\n<p>请注意，您每次使用 ProGuard 创建发布构建时都会覆盖 mapping.txt 文件，因此您每次发布新版本时都必须小心地保存一个副本。通过为每个发布构建保留一个 mapping.txt 文件副本，您就可以在用户提交的已混淆堆叠追踪来自旧版本应用时对问题进行调试。</p>\n<p>在 Google Play 上发布应用时，您可以上传每个 APK 版本的 mapping.txt 文件。Google Play 将根据用户报告的问题对收到的堆叠追踪进行去混淆处理，以便您在 Google Play Developer Console 中进行检查。如需了解详细信息，请参阅帮助中心有关如何对崩溃堆叠追踪进行去混淆处理的文章。</p>\n<p>要自行将混淆过的堆叠追踪转换成可读的堆叠追踪，请使用 retrace 脚本（在 Windows 上为 retrace.bat；在 Mac/Linux 上为 retrace.sh）。它位于 <sdk-root>/tools/proguard/ 目录中。该脚本利用 mapping.txt 文件和您的堆叠追踪生成新的可读堆叠追踪。使用 retrace 工具的语法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">retrace.bat|retrace.sh [-verbose] mapping.txt [&lt;stacktrace_file&gt;]</span><br></pre></td></tr></table></figure></sdk-root></p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">retrace.bat -verbose mapping.txt obfuscated_trace.txt</span><br></pre></td></tr></table></figure></p>\n<p>如果您不指定堆叠追踪文件，retrace 工具会从标准输入读取。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"混淆文件生成\"><a href=\"#混淆文件生成\" class=\"headerlink\" title=\"混淆文件生成\"></a>混淆文件生成</h1><p>每次构建时 ProGuard 都会输出下列文件：</p>\n<p>dump.txt<br>说明 APK 中所有类文件的内部结构。</p>\n<p>mapping.txt<br>提供原始与混淆过的类、方法和字段名称之间的转换。</p>\n<p>seeds.txt<br>列出未进行混淆的类和成员。</p>\n<p>usage.txt<br>列出从 APK 移除的代码。</p>\n<p>这些文件保存在 <module-name>/build/outputs/mapping/release/ 中。</module-name></p>\n<h1 id=\"解码混淆过的堆叠追踪\"><a href=\"#解码混淆过的堆叠追踪\" class=\"headerlink\" title=\"解码混淆过的堆叠追踪\"></a>解码混淆过的堆叠追踪</h1><p>在 ProGuard 压缩代码后，读取堆叠追踪变得困难（即使并非不可行），因为方法名称经过了混淆处理。幸运的是，ProGuard 每次运行时都会创建一个 mapping.txt 文件，其中显示了与混淆过的名称对应的原始类名称、方法名称和字段名称。ProGuard 将该文件保存在应用的 <module-name>/build/outputs/mapping/release/ 目录中。</module-name></p>\n<p>请注意，您每次使用 ProGuard 创建发布构建时都会覆盖 mapping.txt 文件，因此您每次发布新版本时都必须小心地保存一个副本。通过为每个发布构建保留一个 mapping.txt 文件副本，您就可以在用户提交的已混淆堆叠追踪来自旧版本应用时对问题进行调试。</p>\n<p>在 Google Play 上发布应用时，您可以上传每个 APK 版本的 mapping.txt 文件。Google Play 将根据用户报告的问题对收到的堆叠追踪进行去混淆处理，以便您在 Google Play Developer Console 中进行检查。如需了解详细信息，请参阅帮助中心有关如何对崩溃堆叠追踪进行去混淆处理的文章。</p>\n<p>要自行将混淆过的堆叠追踪转换成可读的堆叠追踪，请使用 retrace 脚本（在 Windows 上为 retrace.bat；在 Mac/Linux 上为 retrace.sh）。它位于 <sdk-root>/tools/proguard/ 目录中。该脚本利用 mapping.txt 文件和您的堆叠追踪生成新的可读堆叠追踪。使用 retrace 工具的语法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">retrace.bat|retrace.sh [-verbose] mapping.txt [&lt;stacktrace_file&gt;]</span><br></pre></td></tr></table></figure></sdk-root></p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">retrace.bat -verbose mapping.txt obfuscated_trace.txt</span><br></pre></td></tr></table></figure></p>\n<p>如果您不指定堆叠追踪文件，retrace 工具会从标准输入读取。</p>\n"},{"title":"焦虑感的排解方式","date":"2018-12-25T16:27:45.000Z","_content":"\n# 焦虑感的由来\n\n当一个人希望掌控自己的生活，他就会自主的创建一系列的计划和安排，希望依靠这些计划和安排来带来目标的靠近。\n\n但是计划和安排并不一定会和期望的一样，一来是不一定生活一下子迈上了正轨，计划执行的不一定完全，二来是变化大于计划，安排的不够仔细，没有考虑到的细节，决定了计划无法实施，三是计划的过程中产生了新的计划，堆积在老的计划上面，形成了过多的计划。三方面都很有可能导致计划的流产。流产就会造成目前情况并不会有任何好转，没有好转，就会带来挫折感，失败感，这些感觉在平时不会有任何反馈，但是到了deadline，新的周期开始或者老的周期结束时，会突然涌现，成堆的失败感形成了巨大的压迫力，衍生成为了焦虑。\n\n# 焦虑感的坏处\n\n焦虑一定程度上能促进人思想的转变，但是过多焦虑，会引发焦虑症，忧郁症，抑郁症，情节程度由低至高。\n\n## 焦虑症\n\n焦虑症是神经过多沉浸在焦虑中引起的一种神经疾病，分为急性焦虑症和广泛性焦虑症。\n\n### 广泛性焦虑症\n\n```\n没有明显诱因的情况下，会出现与现实情境不符的过分担心，并且这种担心没有任何明显的对象和来由。表现为头晕、心慌、呼吸急促、尿频等。\n```\n\n### 急性焦虑症\n\n```\n突然出现极度恐惧的心理，对自己产生严重的失控感和濒死感。\n```\n\n## 忧郁症\n\n忧郁症是轻度抑郁症，主要表现是持久的心情低落\n\n## 抑郁症\n\n对生活失去了希望，觉得很痛苦，觉得自己毫无用处。\n\n# 焦虑感的排解方式\n\n## 订踏实靠谱的目标\n\n对目标进行量化操作，不能订泛泛而谈的目标，比如说我现在要想成为一个全栈大牛，我需要先把android弄好，然后在在别的地方慢慢开花。另外把android弄好也需要对\"好\"有个界定，比如说能完整的单挑一个项目等等。\n\n## 良好的生活作息\n\n每天晚上很晚睡，就会导致第二天很晚起，这样就会错过早上的时间。早上其实思想比较光明，不会像晚上一样接受了太多信息而聚不了神。反而是晚上很容易就想现在，一下子弄到了凌晨。以后要定个时间，超过一定时间就不搞了，准时洗洗睡了。\n\n先定11点半吧，大学熄灯时间。\n\n## 良好的沟通\n\n产生焦虑感的人群，大多都是单身工作者，或者夫妻关系不和谐的成年人，还有就是学业重的青少年。目前对于我来讲，是第一种，将来可能是第二种，所以要增加切实有效的沟通对象。\n其实这个很难，人生在世，太多事情是自己不得不做，每个人在不同的位置并不能理解对方。甚至自己的烦恼在别人眼里可能是炫耀。这一方面只能说是锦上添花的事情。\n如果焦虑感发展成为焦虑症，需要增加心理医生为沟通对象。\n\n## 删除/精简计划\n\n这个地方需要做的比较多，以往订计划，往往是以季度，以月，甚至以周为时间单位来做计划，这样太散乱了，而且对职场规划没有任何作为，我需要做一个以人生10年为单位的大计划，不过这个计划的谋划很难，而且需要思考的事情太多，目前的水平很难说能思考仔细。这个需要仔细考虑。\n\n## 不要接触负面事物/情绪/人\n\n屏蔽关键词。\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/焦虑感的排解方式.md","raw":"---\ntitle: 焦虑感的排解方式\ndate: 2018-12-26 00:27:45\ntags: 自我提升\n---\n\n# 焦虑感的由来\n\n当一个人希望掌控自己的生活，他就会自主的创建一系列的计划和安排，希望依靠这些计划和安排来带来目标的靠近。\n\n但是计划和安排并不一定会和期望的一样，一来是不一定生活一下子迈上了正轨，计划执行的不一定完全，二来是变化大于计划，安排的不够仔细，没有考虑到的细节，决定了计划无法实施，三是计划的过程中产生了新的计划，堆积在老的计划上面，形成了过多的计划。三方面都很有可能导致计划的流产。流产就会造成目前情况并不会有任何好转，没有好转，就会带来挫折感，失败感，这些感觉在平时不会有任何反馈，但是到了deadline，新的周期开始或者老的周期结束时，会突然涌现，成堆的失败感形成了巨大的压迫力，衍生成为了焦虑。\n\n# 焦虑感的坏处\n\n焦虑一定程度上能促进人思想的转变，但是过多焦虑，会引发焦虑症，忧郁症，抑郁症，情节程度由低至高。\n\n## 焦虑症\n\n焦虑症是神经过多沉浸在焦虑中引起的一种神经疾病，分为急性焦虑症和广泛性焦虑症。\n\n### 广泛性焦虑症\n\n```\n没有明显诱因的情况下，会出现与现实情境不符的过分担心，并且这种担心没有任何明显的对象和来由。表现为头晕、心慌、呼吸急促、尿频等。\n```\n\n### 急性焦虑症\n\n```\n突然出现极度恐惧的心理，对自己产生严重的失控感和濒死感。\n```\n\n## 忧郁症\n\n忧郁症是轻度抑郁症，主要表现是持久的心情低落\n\n## 抑郁症\n\n对生活失去了希望，觉得很痛苦，觉得自己毫无用处。\n\n# 焦虑感的排解方式\n\n## 订踏实靠谱的目标\n\n对目标进行量化操作，不能订泛泛而谈的目标，比如说我现在要想成为一个全栈大牛，我需要先把android弄好，然后在在别的地方慢慢开花。另外把android弄好也需要对\"好\"有个界定，比如说能完整的单挑一个项目等等。\n\n## 良好的生活作息\n\n每天晚上很晚睡，就会导致第二天很晚起，这样就会错过早上的时间。早上其实思想比较光明，不会像晚上一样接受了太多信息而聚不了神。反而是晚上很容易就想现在，一下子弄到了凌晨。以后要定个时间，超过一定时间就不搞了，准时洗洗睡了。\n\n先定11点半吧，大学熄灯时间。\n\n## 良好的沟通\n\n产生焦虑感的人群，大多都是单身工作者，或者夫妻关系不和谐的成年人，还有就是学业重的青少年。目前对于我来讲，是第一种，将来可能是第二种，所以要增加切实有效的沟通对象。\n其实这个很难，人生在世，太多事情是自己不得不做，每个人在不同的位置并不能理解对方。甚至自己的烦恼在别人眼里可能是炫耀。这一方面只能说是锦上添花的事情。\n如果焦虑感发展成为焦虑症，需要增加心理医生为沟通对象。\n\n## 删除/精简计划\n\n这个地方需要做的比较多，以往订计划，往往是以季度，以月，甚至以周为时间单位来做计划，这样太散乱了，而且对职场规划没有任何作为，我需要做一个以人生10年为单位的大计划，不过这个计划的谋划很难，而且需要思考的事情太多，目前的水平很难说能思考仔细。这个需要仔细考虑。\n\n## 不要接触负面事物/情绪/人\n\n屏蔽关键词。\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"焦虑感的排解方式","published":1,"updated":"2019-03-12T09:26:33.168Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttz600553a8kqfepnl8g","content":"<h1 id=\"焦虑感的由来\"><a href=\"#焦虑感的由来\" class=\"headerlink\" title=\"焦虑感的由来\"></a>焦虑感的由来</h1><p>当一个人希望掌控自己的生活，他就会自主的创建一系列的计划和安排，希望依靠这些计划和安排来带来目标的靠近。</p>\n<p>但是计划和安排并不一定会和期望的一样，一来是不一定生活一下子迈上了正轨，计划执行的不一定完全，二来是变化大于计划，安排的不够仔细，没有考虑到的细节，决定了计划无法实施，三是计划的过程中产生了新的计划，堆积在老的计划上面，形成了过多的计划。三方面都很有可能导致计划的流产。流产就会造成目前情况并不会有任何好转，没有好转，就会带来挫折感，失败感，这些感觉在平时不会有任何反馈，但是到了deadline，新的周期开始或者老的周期结束时，会突然涌现，成堆的失败感形成了巨大的压迫力，衍生成为了焦虑。</p>\n<h1 id=\"焦虑感的坏处\"><a href=\"#焦虑感的坏处\" class=\"headerlink\" title=\"焦虑感的坏处\"></a>焦虑感的坏处</h1><p>焦虑一定程度上能促进人思想的转变，但是过多焦虑，会引发焦虑症，忧郁症，抑郁症，情节程度由低至高。</p>\n<h2 id=\"焦虑症\"><a href=\"#焦虑症\" class=\"headerlink\" title=\"焦虑症\"></a>焦虑症</h2><p>焦虑症是神经过多沉浸在焦虑中引起的一种神经疾病，分为急性焦虑症和广泛性焦虑症。</p>\n<h3 id=\"广泛性焦虑症\"><a href=\"#广泛性焦虑症\" class=\"headerlink\" title=\"广泛性焦虑症\"></a>广泛性焦虑症</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">没有明显诱因的情况下，会出现与现实情境不符的过分担心，并且这种担心没有任何明显的对象和来由。表现为头晕、心慌、呼吸急促、尿频等。</span><br></pre></td></tr></table></figure>\n<h3 id=\"急性焦虑症\"><a href=\"#急性焦虑症\" class=\"headerlink\" title=\"急性焦虑症\"></a>急性焦虑症</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">突然出现极度恐惧的心理，对自己产生严重的失控感和濒死感。</span><br></pre></td></tr></table></figure>\n<h2 id=\"忧郁症\"><a href=\"#忧郁症\" class=\"headerlink\" title=\"忧郁症\"></a>忧郁症</h2><p>忧郁症是轻度抑郁症，主要表现是持久的心情低落</p>\n<h2 id=\"抑郁症\"><a href=\"#抑郁症\" class=\"headerlink\" title=\"抑郁症\"></a>抑郁症</h2><p>对生活失去了希望，觉得很痛苦，觉得自己毫无用处。</p>\n<h1 id=\"焦虑感的排解方式\"><a href=\"#焦虑感的排解方式\" class=\"headerlink\" title=\"焦虑感的排解方式\"></a>焦虑感的排解方式</h1><h2 id=\"订踏实靠谱的目标\"><a href=\"#订踏实靠谱的目标\" class=\"headerlink\" title=\"订踏实靠谱的目标\"></a>订踏实靠谱的目标</h2><p>对目标进行量化操作，不能订泛泛而谈的目标，比如说我现在要想成为一个全栈大牛，我需要先把android弄好，然后在在别的地方慢慢开花。另外把android弄好也需要对”好”有个界定，比如说能完整的单挑一个项目等等。</p>\n<h2 id=\"良好的生活作息\"><a href=\"#良好的生活作息\" class=\"headerlink\" title=\"良好的生活作息\"></a>良好的生活作息</h2><p>每天晚上很晚睡，就会导致第二天很晚起，这样就会错过早上的时间。早上其实思想比较光明，不会像晚上一样接受了太多信息而聚不了神。反而是晚上很容易就想现在，一下子弄到了凌晨。以后要定个时间，超过一定时间就不搞了，准时洗洗睡了。</p>\n<p>先定11点半吧，大学熄灯时间。</p>\n<h2 id=\"良好的沟通\"><a href=\"#良好的沟通\" class=\"headerlink\" title=\"良好的沟通\"></a>良好的沟通</h2><p>产生焦虑感的人群，大多都是单身工作者，或者夫妻关系不和谐的成年人，还有就是学业重的青少年。目前对于我来讲，是第一种，将来可能是第二种，所以要增加切实有效的沟通对象。<br>其实这个很难，人生在世，太多事情是自己不得不做，每个人在不同的位置并不能理解对方。甚至自己的烦恼在别人眼里可能是炫耀。这一方面只能说是锦上添花的事情。<br>如果焦虑感发展成为焦虑症，需要增加心理医生为沟通对象。</p>\n<h2 id=\"删除-精简计划\"><a href=\"#删除-精简计划\" class=\"headerlink\" title=\"删除/精简计划\"></a>删除/精简计划</h2><p>这个地方需要做的比较多，以往订计划，往往是以季度，以月，甚至以周为时间单位来做计划，这样太散乱了，而且对职场规划没有任何作为，我需要做一个以人生10年为单位的大计划，不过这个计划的谋划很难，而且需要思考的事情太多，目前的水平很难说能思考仔细。这个需要仔细考虑。</p>\n<h2 id=\"不要接触负面事物-情绪-人\"><a href=\"#不要接触负面事物-情绪-人\" class=\"headerlink\" title=\"不要接触负面事物/情绪/人\"></a>不要接触负面事物/情绪/人</h2><p>屏蔽关键词。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"焦虑感的由来\"><a href=\"#焦虑感的由来\" class=\"headerlink\" title=\"焦虑感的由来\"></a>焦虑感的由来</h1><p>当一个人希望掌控自己的生活，他就会自主的创建一系列的计划和安排，希望依靠这些计划和安排来带来目标的靠近。</p>\n<p>但是计划和安排并不一定会和期望的一样，一来是不一定生活一下子迈上了正轨，计划执行的不一定完全，二来是变化大于计划，安排的不够仔细，没有考虑到的细节，决定了计划无法实施，三是计划的过程中产生了新的计划，堆积在老的计划上面，形成了过多的计划。三方面都很有可能导致计划的流产。流产就会造成目前情况并不会有任何好转，没有好转，就会带来挫折感，失败感，这些感觉在平时不会有任何反馈，但是到了deadline，新的周期开始或者老的周期结束时，会突然涌现，成堆的失败感形成了巨大的压迫力，衍生成为了焦虑。</p>\n<h1 id=\"焦虑感的坏处\"><a href=\"#焦虑感的坏处\" class=\"headerlink\" title=\"焦虑感的坏处\"></a>焦虑感的坏处</h1><p>焦虑一定程度上能促进人思想的转变，但是过多焦虑，会引发焦虑症，忧郁症，抑郁症，情节程度由低至高。</p>\n<h2 id=\"焦虑症\"><a href=\"#焦虑症\" class=\"headerlink\" title=\"焦虑症\"></a>焦虑症</h2><p>焦虑症是神经过多沉浸在焦虑中引起的一种神经疾病，分为急性焦虑症和广泛性焦虑症。</p>\n<h3 id=\"广泛性焦虑症\"><a href=\"#广泛性焦虑症\" class=\"headerlink\" title=\"广泛性焦虑症\"></a>广泛性焦虑症</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">没有明显诱因的情况下，会出现与现实情境不符的过分担心，并且这种担心没有任何明显的对象和来由。表现为头晕、心慌、呼吸急促、尿频等。</span><br></pre></td></tr></table></figure>\n<h3 id=\"急性焦虑症\"><a href=\"#急性焦虑症\" class=\"headerlink\" title=\"急性焦虑症\"></a>急性焦虑症</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">突然出现极度恐惧的心理，对自己产生严重的失控感和濒死感。</span><br></pre></td></tr></table></figure>\n<h2 id=\"忧郁症\"><a href=\"#忧郁症\" class=\"headerlink\" title=\"忧郁症\"></a>忧郁症</h2><p>忧郁症是轻度抑郁症，主要表现是持久的心情低落</p>\n<h2 id=\"抑郁症\"><a href=\"#抑郁症\" class=\"headerlink\" title=\"抑郁症\"></a>抑郁症</h2><p>对生活失去了希望，觉得很痛苦，觉得自己毫无用处。</p>\n<h1 id=\"焦虑感的排解方式\"><a href=\"#焦虑感的排解方式\" class=\"headerlink\" title=\"焦虑感的排解方式\"></a>焦虑感的排解方式</h1><h2 id=\"订踏实靠谱的目标\"><a href=\"#订踏实靠谱的目标\" class=\"headerlink\" title=\"订踏实靠谱的目标\"></a>订踏实靠谱的目标</h2><p>对目标进行量化操作，不能订泛泛而谈的目标，比如说我现在要想成为一个全栈大牛，我需要先把android弄好，然后在在别的地方慢慢开花。另外把android弄好也需要对”好”有个界定，比如说能完整的单挑一个项目等等。</p>\n<h2 id=\"良好的生活作息\"><a href=\"#良好的生活作息\" class=\"headerlink\" title=\"良好的生活作息\"></a>良好的生活作息</h2><p>每天晚上很晚睡，就会导致第二天很晚起，这样就会错过早上的时间。早上其实思想比较光明，不会像晚上一样接受了太多信息而聚不了神。反而是晚上很容易就想现在，一下子弄到了凌晨。以后要定个时间，超过一定时间就不搞了，准时洗洗睡了。</p>\n<p>先定11点半吧，大学熄灯时间。</p>\n<h2 id=\"良好的沟通\"><a href=\"#良好的沟通\" class=\"headerlink\" title=\"良好的沟通\"></a>良好的沟通</h2><p>产生焦虑感的人群，大多都是单身工作者，或者夫妻关系不和谐的成年人，还有就是学业重的青少年。目前对于我来讲，是第一种，将来可能是第二种，所以要增加切实有效的沟通对象。<br>其实这个很难，人生在世，太多事情是自己不得不做，每个人在不同的位置并不能理解对方。甚至自己的烦恼在别人眼里可能是炫耀。这一方面只能说是锦上添花的事情。<br>如果焦虑感发展成为焦虑症，需要增加心理医生为沟通对象。</p>\n<h2 id=\"删除-精简计划\"><a href=\"#删除-精简计划\" class=\"headerlink\" title=\"删除/精简计划\"></a>删除/精简计划</h2><p>这个地方需要做的比较多，以往订计划，往往是以季度，以月，甚至以周为时间单位来做计划，这样太散乱了，而且对职场规划没有任何作为，我需要做一个以人生10年为单位的大计划，不过这个计划的谋划很难，而且需要思考的事情太多，目前的水平很难说能思考仔细。这个需要仔细考虑。</p>\n<h2 id=\"不要接触负面事物-情绪-人\"><a href=\"#不要接触负面事物-情绪-人\" class=\"headerlink\" title=\"不要接触负面事物/情绪/人\"></a>不要接触负面事物/情绪/人</h2><p>屏蔽关键词。</p>\n"},{"title":"爬虫相关","date":"2017-12-23T09:21:18.000Z","_content":"\n# 概念相关：\n\n## 所有网站皆可爬\n\n互联网的内容都是人写出来的，而且都是偷懒写出来的（不会第一页是a，下一页是8），所以肯定有规律，这就给人有了爬取的可能，可以说，天下没有不能爬的网站\n\n## 框架不变\n\n网站不同，但是原理都类似，大部分爬虫都是从 发送请求——获得页面——解析页面——下载内容——储存内容 这样的流程来进行，只是用的工具不同\n\n# 基础相关\n\n## python 基础\n\nlist，dict：用来序列化你爬的东西\n切片：用来对爬取的内容进行分割，生成\n条件判断（if等）：用来解决爬虫过程中哪些要哪些不要的问题\n循环和迭代（for while ）：用来循环，重复爬虫动作\n文件读写操作：用来读取参数、保存爬下来的内容等\n\n## 网页基本知识\n\n基本的HTML语言知识（知道href等大学计算机一级内容即可）\n理解网站的发包和收包的概念（POST GET）\n稍微一点点的js知识，用于理解动态网页（当然如果本身就懂当然更好啦）\n\n## 分析语言相关\n\n### 正则表达式：扛把子技术，总得会最基础的\n\n![正则表达式](/images/爬虫相关/正则.jpg)\n\n### [xpath](http://www.w3school.com.cn/xpath/)：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则\n\n### [BeautifulSoup](http://beautifulsoup.readthedocs.io/zh_CN/latest/)：美丽汤模块解析网页神器,一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本\n\n## 辅助工具相关\n\n### F12开发者工具\n\n1. 看源代码：快速定位元素\n2. 分析xpath：1、此处建议谷歌系浏览器,可以在源码界面直接右键看\n\n### 抓包工具\n\n推荐httpfox，火狐浏览器下的插件,比谷歌火狐系自带的F12工具都要好，可以方便查看网站收包发包的信息\n\n### XPATH CHECKER (火狐插件）\n\n非常不错的xpath测试工具，但是有几个坑，都是个人踩过的，，在此告诫大家：     1、xpath checker生成的是绝对路径，遇到一些动态生成的图标（常见的有列表翻页按钮等），飘忽不定的绝对路径很有可能造成错误，所以这里建议在真正分析的时候，只是作为参考     2、记得把如下图xpath框里的“x:”去掉，貌似这个是早期版本xpath的语法，目前已经和一些模块不兼容（比如scrapy），还是删去避免报错\n\n### 正则表达式测试工具\n\n[在线正则表达式测试](http://tool.oschina.net/regex/)\n拿来多练练手，也辅助分析！里面有很多现成的正则表达式可以用，也可以进行参考！\n\n## 爬虫模块相关\n\nurllib urllib2 requests \n\n### 现成模块 scrapy\n\n### 动态页面解决 selenium phantomJS\n\n### 反爬虫策略验证码 \n\nPIL opencv pybrain 打码平台\n\n## 数据库相关\n\nmysql， mongodb， sqlite\n\n## 数据处理\n\nnumpy 数据分析，类似matlab的模块\npandas（基于numpy的数据分析模块，相信我，如果你不是专门搞TB级数据的，这个就够了）\n\n## 技术进阶\n\n多线程、分布式\n\n\n","source":"_posts/爬虫相关.md","raw":"---\ntitle: 爬虫相关\ndate: 2017-12-23 17:21:18\ntags: python\n---\n\n# 概念相关：\n\n## 所有网站皆可爬\n\n互联网的内容都是人写出来的，而且都是偷懒写出来的（不会第一页是a，下一页是8），所以肯定有规律，这就给人有了爬取的可能，可以说，天下没有不能爬的网站\n\n## 框架不变\n\n网站不同，但是原理都类似，大部分爬虫都是从 发送请求——获得页面——解析页面——下载内容——储存内容 这样的流程来进行，只是用的工具不同\n\n# 基础相关\n\n## python 基础\n\nlist，dict：用来序列化你爬的东西\n切片：用来对爬取的内容进行分割，生成\n条件判断（if等）：用来解决爬虫过程中哪些要哪些不要的问题\n循环和迭代（for while ）：用来循环，重复爬虫动作\n文件读写操作：用来读取参数、保存爬下来的内容等\n\n## 网页基本知识\n\n基本的HTML语言知识（知道href等大学计算机一级内容即可）\n理解网站的发包和收包的概念（POST GET）\n稍微一点点的js知识，用于理解动态网页（当然如果本身就懂当然更好啦）\n\n## 分析语言相关\n\n### 正则表达式：扛把子技术，总得会最基础的\n\n![正则表达式](/images/爬虫相关/正则.jpg)\n\n### [xpath](http://www.w3school.com.cn/xpath/)：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则\n\n### [BeautifulSoup](http://beautifulsoup.readthedocs.io/zh_CN/latest/)：美丽汤模块解析网页神器,一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本\n\n## 辅助工具相关\n\n### F12开发者工具\n\n1. 看源代码：快速定位元素\n2. 分析xpath：1、此处建议谷歌系浏览器,可以在源码界面直接右键看\n\n### 抓包工具\n\n推荐httpfox，火狐浏览器下的插件,比谷歌火狐系自带的F12工具都要好，可以方便查看网站收包发包的信息\n\n### XPATH CHECKER (火狐插件）\n\n非常不错的xpath测试工具，但是有几个坑，都是个人踩过的，，在此告诫大家：     1、xpath checker生成的是绝对路径，遇到一些动态生成的图标（常见的有列表翻页按钮等），飘忽不定的绝对路径很有可能造成错误，所以这里建议在真正分析的时候，只是作为参考     2、记得把如下图xpath框里的“x:”去掉，貌似这个是早期版本xpath的语法，目前已经和一些模块不兼容（比如scrapy），还是删去避免报错\n\n### 正则表达式测试工具\n\n[在线正则表达式测试](http://tool.oschina.net/regex/)\n拿来多练练手，也辅助分析！里面有很多现成的正则表达式可以用，也可以进行参考！\n\n## 爬虫模块相关\n\nurllib urllib2 requests \n\n### 现成模块 scrapy\n\n### 动态页面解决 selenium phantomJS\n\n### 反爬虫策略验证码 \n\nPIL opencv pybrain 打码平台\n\n## 数据库相关\n\nmysql， mongodb， sqlite\n\n## 数据处理\n\nnumpy 数据分析，类似matlab的模块\npandas（基于numpy的数据分析模块，相信我，如果你不是专门搞TB级数据的，这个就够了）\n\n## 技术进阶\n\n多线程、分布式\n\n\n","slug":"爬虫相关","published":1,"updated":"2019-03-12T09:26:33.168Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttz700573a8kkjlqwowd","content":"<h1 id=\"概念相关：\"><a href=\"#概念相关：\" class=\"headerlink\" title=\"概念相关：\"></a>概念相关：</h1><h2 id=\"所有网站皆可爬\"><a href=\"#所有网站皆可爬\" class=\"headerlink\" title=\"所有网站皆可爬\"></a>所有网站皆可爬</h2><p>互联网的内容都是人写出来的，而且都是偷懒写出来的（不会第一页是a，下一页是8），所以肯定有规律，这就给人有了爬取的可能，可以说，天下没有不能爬的网站</p>\n<h2 id=\"框架不变\"><a href=\"#框架不变\" class=\"headerlink\" title=\"框架不变\"></a>框架不变</h2><p>网站不同，但是原理都类似，大部分爬虫都是从 发送请求——获得页面——解析页面——下载内容——储存内容 这样的流程来进行，只是用的工具不同</p>\n<h1 id=\"基础相关\"><a href=\"#基础相关\" class=\"headerlink\" title=\"基础相关\"></a>基础相关</h1><h2 id=\"python-基础\"><a href=\"#python-基础\" class=\"headerlink\" title=\"python 基础\"></a>python 基础</h2><p>list，dict：用来序列化你爬的东西<br>切片：用来对爬取的内容进行分割，生成<br>条件判断（if等）：用来解决爬虫过程中哪些要哪些不要的问题<br>循环和迭代（for while ）：用来循环，重复爬虫动作<br>文件读写操作：用来读取参数、保存爬下来的内容等</p>\n<h2 id=\"网页基本知识\"><a href=\"#网页基本知识\" class=\"headerlink\" title=\"网页基本知识\"></a>网页基本知识</h2><p>基本的HTML语言知识（知道href等大学计算机一级内容即可）<br>理解网站的发包和收包的概念（POST GET）<br>稍微一点点的js知识，用于理解动态网页（当然如果本身就懂当然更好啦）</p>\n<h2 id=\"分析语言相关\"><a href=\"#分析语言相关\" class=\"headerlink\" title=\"分析语言相关\"></a>分析语言相关</h2><h3 id=\"正则表达式：扛把子技术，总得会最基础的\"><a href=\"#正则表达式：扛把子技术，总得会最基础的\" class=\"headerlink\" title=\"正则表达式：扛把子技术，总得会最基础的\"></a>正则表达式：扛把子技术，总得会最基础的</h3><p><img src=\"/images/爬虫相关/正则.jpg\" alt=\"正则表达式\"></p>\n<h3 id=\"xpath：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则\"><a href=\"#xpath：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则\" class=\"headerlink\" title=\"xpath：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则\"></a><a href=\"http://www.w3school.com.cn/xpath/\" target=\"_blank\" rel=\"noopener\">xpath</a>：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则</h3><h3 id=\"BeautifulSoup：美丽汤模块解析网页神器-一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本\"><a href=\"#BeautifulSoup：美丽汤模块解析网页神器-一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本\" class=\"headerlink\" title=\"BeautifulSoup：美丽汤模块解析网页神器,一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本\"></a><a href=\"http://beautifulsoup.readthedocs.io/zh_CN/latest/\" target=\"_blank\" rel=\"noopener\">BeautifulSoup</a>：美丽汤模块解析网页神器,一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本</h3><h2 id=\"辅助工具相关\"><a href=\"#辅助工具相关\" class=\"headerlink\" title=\"辅助工具相关\"></a>辅助工具相关</h2><h3 id=\"F12开发者工具\"><a href=\"#F12开发者工具\" class=\"headerlink\" title=\"F12开发者工具\"></a>F12开发者工具</h3><ol>\n<li>看源代码：快速定位元素</li>\n<li>分析xpath：1、此处建议谷歌系浏览器,可以在源码界面直接右键看</li>\n</ol>\n<h3 id=\"抓包工具\"><a href=\"#抓包工具\" class=\"headerlink\" title=\"抓包工具\"></a>抓包工具</h3><p>推荐httpfox，火狐浏览器下的插件,比谷歌火狐系自带的F12工具都要好，可以方便查看网站收包发包的信息</p>\n<h3 id=\"XPATH-CHECKER-火狐插件）\"><a href=\"#XPATH-CHECKER-火狐插件）\" class=\"headerlink\" title=\"XPATH CHECKER (火狐插件）\"></a>XPATH CHECKER (火狐插件）</h3><p>非常不错的xpath测试工具，但是有几个坑，都是个人踩过的，，在此告诫大家：     1、xpath checker生成的是绝对路径，遇到一些动态生成的图标（常见的有列表翻页按钮等），飘忽不定的绝对路径很有可能造成错误，所以这里建议在真正分析的时候，只是作为参考     2、记得把如下图xpath框里的“x:”去掉，貌似这个是早期版本xpath的语法，目前已经和一些模块不兼容（比如scrapy），还是删去避免报错</p>\n<h3 id=\"正则表达式测试工具\"><a href=\"#正则表达式测试工具\" class=\"headerlink\" title=\"正则表达式测试工具\"></a>正则表达式测试工具</h3><p><a href=\"http://tool.oschina.net/regex/\" target=\"_blank\" rel=\"noopener\">在线正则表达式测试</a><br>拿来多练练手，也辅助分析！里面有很多现成的正则表达式可以用，也可以进行参考！</p>\n<h2 id=\"爬虫模块相关\"><a href=\"#爬虫模块相关\" class=\"headerlink\" title=\"爬虫模块相关\"></a>爬虫模块相关</h2><p>urllib urllib2 requests </p>\n<h3 id=\"现成模块-scrapy\"><a href=\"#现成模块-scrapy\" class=\"headerlink\" title=\"现成模块 scrapy\"></a>现成模块 scrapy</h3><h3 id=\"动态页面解决-selenium-phantomJS\"><a href=\"#动态页面解决-selenium-phantomJS\" class=\"headerlink\" title=\"动态页面解决 selenium phantomJS\"></a>动态页面解决 selenium phantomJS</h3><h3 id=\"反爬虫策略验证码\"><a href=\"#反爬虫策略验证码\" class=\"headerlink\" title=\"反爬虫策略验证码\"></a>反爬虫策略验证码</h3><p>PIL opencv pybrain 打码平台</p>\n<h2 id=\"数据库相关\"><a href=\"#数据库相关\" class=\"headerlink\" title=\"数据库相关\"></a>数据库相关</h2><p>mysql， mongodb， sqlite</p>\n<h2 id=\"数据处理\"><a href=\"#数据处理\" class=\"headerlink\" title=\"数据处理\"></a>数据处理</h2><p>numpy 数据分析，类似matlab的模块<br>pandas（基于numpy的数据分析模块，相信我，如果你不是专门搞TB级数据的，这个就够了）</p>\n<h2 id=\"技术进阶\"><a href=\"#技术进阶\" class=\"headerlink\" title=\"技术进阶\"></a>技术进阶</h2><p>多线程、分布式</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"概念相关：\"><a href=\"#概念相关：\" class=\"headerlink\" title=\"概念相关：\"></a>概念相关：</h1><h2 id=\"所有网站皆可爬\"><a href=\"#所有网站皆可爬\" class=\"headerlink\" title=\"所有网站皆可爬\"></a>所有网站皆可爬</h2><p>互联网的内容都是人写出来的，而且都是偷懒写出来的（不会第一页是a，下一页是8），所以肯定有规律，这就给人有了爬取的可能，可以说，天下没有不能爬的网站</p>\n<h2 id=\"框架不变\"><a href=\"#框架不变\" class=\"headerlink\" title=\"框架不变\"></a>框架不变</h2><p>网站不同，但是原理都类似，大部分爬虫都是从 发送请求——获得页面——解析页面——下载内容——储存内容 这样的流程来进行，只是用的工具不同</p>\n<h1 id=\"基础相关\"><a href=\"#基础相关\" class=\"headerlink\" title=\"基础相关\"></a>基础相关</h1><h2 id=\"python-基础\"><a href=\"#python-基础\" class=\"headerlink\" title=\"python 基础\"></a>python 基础</h2><p>list，dict：用来序列化你爬的东西<br>切片：用来对爬取的内容进行分割，生成<br>条件判断（if等）：用来解决爬虫过程中哪些要哪些不要的问题<br>循环和迭代（for while ）：用来循环，重复爬虫动作<br>文件读写操作：用来读取参数、保存爬下来的内容等</p>\n<h2 id=\"网页基本知识\"><a href=\"#网页基本知识\" class=\"headerlink\" title=\"网页基本知识\"></a>网页基本知识</h2><p>基本的HTML语言知识（知道href等大学计算机一级内容即可）<br>理解网站的发包和收包的概念（POST GET）<br>稍微一点点的js知识，用于理解动态网页（当然如果本身就懂当然更好啦）</p>\n<h2 id=\"分析语言相关\"><a href=\"#分析语言相关\" class=\"headerlink\" title=\"分析语言相关\"></a>分析语言相关</h2><h3 id=\"正则表达式：扛把子技术，总得会最基础的\"><a href=\"#正则表达式：扛把子技术，总得会最基础的\" class=\"headerlink\" title=\"正则表达式：扛把子技术，总得会最基础的\"></a>正则表达式：扛把子技术，总得会最基础的</h3><p><img src=\"/images/爬虫相关/正则.jpg\" alt=\"正则表达式\"></p>\n<h3 id=\"xpath：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则\"><a href=\"#xpath：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则\" class=\"headerlink\" title=\"xpath：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则\"></a><a href=\"http://www.w3school.com.cn/xpath/\" target=\"_blank\" rel=\"noopener\">xpath</a>：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则</h3><h3 id=\"BeautifulSoup：美丽汤模块解析网页神器-一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本\"><a href=\"#BeautifulSoup：美丽汤模块解析网页神器-一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本\" class=\"headerlink\" title=\"BeautifulSoup：美丽汤模块解析网页神器,一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本\"></a><a href=\"http://beautifulsoup.readthedocs.io/zh_CN/latest/\" target=\"_blank\" rel=\"noopener\">BeautifulSoup</a>：美丽汤模块解析网页神器,一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本</h3><h2 id=\"辅助工具相关\"><a href=\"#辅助工具相关\" class=\"headerlink\" title=\"辅助工具相关\"></a>辅助工具相关</h2><h3 id=\"F12开发者工具\"><a href=\"#F12开发者工具\" class=\"headerlink\" title=\"F12开发者工具\"></a>F12开发者工具</h3><ol>\n<li>看源代码：快速定位元素</li>\n<li>分析xpath：1、此处建议谷歌系浏览器,可以在源码界面直接右键看</li>\n</ol>\n<h3 id=\"抓包工具\"><a href=\"#抓包工具\" class=\"headerlink\" title=\"抓包工具\"></a>抓包工具</h3><p>推荐httpfox，火狐浏览器下的插件,比谷歌火狐系自带的F12工具都要好，可以方便查看网站收包发包的信息</p>\n<h3 id=\"XPATH-CHECKER-火狐插件）\"><a href=\"#XPATH-CHECKER-火狐插件）\" class=\"headerlink\" title=\"XPATH CHECKER (火狐插件）\"></a>XPATH CHECKER (火狐插件）</h3><p>非常不错的xpath测试工具，但是有几个坑，都是个人踩过的，，在此告诫大家：     1、xpath checker生成的是绝对路径，遇到一些动态生成的图标（常见的有列表翻页按钮等），飘忽不定的绝对路径很有可能造成错误，所以这里建议在真正分析的时候，只是作为参考     2、记得把如下图xpath框里的“x:”去掉，貌似这个是早期版本xpath的语法，目前已经和一些模块不兼容（比如scrapy），还是删去避免报错</p>\n<h3 id=\"正则表达式测试工具\"><a href=\"#正则表达式测试工具\" class=\"headerlink\" title=\"正则表达式测试工具\"></a>正则表达式测试工具</h3><p><a href=\"http://tool.oschina.net/regex/\" target=\"_blank\" rel=\"noopener\">在线正则表达式测试</a><br>拿来多练练手，也辅助分析！里面有很多现成的正则表达式可以用，也可以进行参考！</p>\n<h2 id=\"爬虫模块相关\"><a href=\"#爬虫模块相关\" class=\"headerlink\" title=\"爬虫模块相关\"></a>爬虫模块相关</h2><p>urllib urllib2 requests </p>\n<h3 id=\"现成模块-scrapy\"><a href=\"#现成模块-scrapy\" class=\"headerlink\" title=\"现成模块 scrapy\"></a>现成模块 scrapy</h3><h3 id=\"动态页面解决-selenium-phantomJS\"><a href=\"#动态页面解决-selenium-phantomJS\" class=\"headerlink\" title=\"动态页面解决 selenium phantomJS\"></a>动态页面解决 selenium phantomJS</h3><h3 id=\"反爬虫策略验证码\"><a href=\"#反爬虫策略验证码\" class=\"headerlink\" title=\"反爬虫策略验证码\"></a>反爬虫策略验证码</h3><p>PIL opencv pybrain 打码平台</p>\n<h2 id=\"数据库相关\"><a href=\"#数据库相关\" class=\"headerlink\" title=\"数据库相关\"></a>数据库相关</h2><p>mysql， mongodb， sqlite</p>\n<h2 id=\"数据处理\"><a href=\"#数据处理\" class=\"headerlink\" title=\"数据处理\"></a>数据处理</h2><p>numpy 数据分析，类似matlab的模块<br>pandas（基于numpy的数据分析模块，相信我，如果你不是专门搞TB级数据的，这个就够了）</p>\n<h2 id=\"技术进阶\"><a href=\"#技术进阶\" class=\"headerlink\" title=\"技术进阶\"></a>技术进阶</h2><p>多线程、分布式</p>\n"},{"title":"直接插入排序","date":"2018-01-08T14:29:59.000Z","_content":"直接插入排序属于排序中的内部排序的插入排序的一种。\n\n# 算法思想\n\n直接将一个记录插入到已排序好的有序列表中，从而得到一个新的，记录数增1的有序表。\n\n# 空间复杂度\n\n只需要一个待记录的空间，空间复杂度为O(1)\n\n# 时间复杂度\n\n最好情况下，已有列表有序且正序，只需要插入一次，比较n-1次，移动0次\n最坏情况下，已有列表有序但是倒序，需要全部更改，比较n-1次，移动n-1次，复杂度为O(n^2)\n\n# 算法实现思想\n\n把它当作一个牌堆，现在从第一张开始抽。（开启一个循环，循环长度为数组的长度）\n\n假如抽的这一张比右手第一张小，代表需要插到前面。（a[j] < a[j-1]）\n\n从右手第二张开始往左看，如果找到有比抽到的这张小的，插到这张的后面。\n这个过程需要将每个比抽到的这大的往后挪一位，\n\n小技巧，将手中最右边这张先拿出去，然后将抽到的这张加到最右边，然后从最右边开始排序，排序完毕之后将拿出去的这张重新加到最右边。\n\n## java实现\n\n```\npublic static int[] insertSort(int[] array){\n\tint[] arr = array;\n\tint temp;\n\tfor(int i = 1; i < arr.length; i++){\n\t\tfor(int j = i; j >= 1 && arr[j - 1] > arr[j]; j-- ){\n\t\t\ttemp = arr[j];\n\t\t\tarr[j] = arr[j - 1];\n\t\t\tarr[j - 1] = temp;\n\t\t}\n\t}\n\treturn arr;\n}\n```\n\n## c实现\n\n```\nint inser_sort(int s[], int length){\n\tint i, j, t;\n\tfor (i = 1; i < length; i++){\n\t\tfor (j = i - 1; j > -1 && s[j] > t; j--){\n\t\t\tt = s[i];\n\t\t\ts[j + 1] = s[j];\n\t\t\ts[j] = t;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n## python实现\n\n```\ndef insertSort(a):\n\tlength = len(targetList)\n\tfor i in range(1, length:\n\t\tj = i - 1\n\t\tif (target[i] < targetList[j]){\n\t\t\ttemp = targetList[i]\n\t\t\ttarget[i] = targetList[j]\n\t\t\tj = j - 1\n\t\t\twhile j > 0 and targetList[j] > temp:\n\t\t\t\ttargetList[j + 1] = targetList[j]\n\t\t\t\tj = j - 1\n\t\t\ttargetList[j + 1] = temp\n\t\t}\n```\n","source":"_posts/直接插入排序.md","raw":"---\ntitle: 直接插入排序\ndate: 2018-01-08 22:29:59\ntags: 算法\n---\n直接插入排序属于排序中的内部排序的插入排序的一种。\n\n# 算法思想\n\n直接将一个记录插入到已排序好的有序列表中，从而得到一个新的，记录数增1的有序表。\n\n# 空间复杂度\n\n只需要一个待记录的空间，空间复杂度为O(1)\n\n# 时间复杂度\n\n最好情况下，已有列表有序且正序，只需要插入一次，比较n-1次，移动0次\n最坏情况下，已有列表有序但是倒序，需要全部更改，比较n-1次，移动n-1次，复杂度为O(n^2)\n\n# 算法实现思想\n\n把它当作一个牌堆，现在从第一张开始抽。（开启一个循环，循环长度为数组的长度）\n\n假如抽的这一张比右手第一张小，代表需要插到前面。（a[j] < a[j-1]）\n\n从右手第二张开始往左看，如果找到有比抽到的这张小的，插到这张的后面。\n这个过程需要将每个比抽到的这大的往后挪一位，\n\n小技巧，将手中最右边这张先拿出去，然后将抽到的这张加到最右边，然后从最右边开始排序，排序完毕之后将拿出去的这张重新加到最右边。\n\n## java实现\n\n```\npublic static int[] insertSort(int[] array){\n\tint[] arr = array;\n\tint temp;\n\tfor(int i = 1; i < arr.length; i++){\n\t\tfor(int j = i; j >= 1 && arr[j - 1] > arr[j]; j-- ){\n\t\t\ttemp = arr[j];\n\t\t\tarr[j] = arr[j - 1];\n\t\t\tarr[j - 1] = temp;\n\t\t}\n\t}\n\treturn arr;\n}\n```\n\n## c实现\n\n```\nint inser_sort(int s[], int length){\n\tint i, j, t;\n\tfor (i = 1; i < length; i++){\n\t\tfor (j = i - 1; j > -1 && s[j] > t; j--){\n\t\t\tt = s[i];\n\t\t\ts[j + 1] = s[j];\n\t\t\ts[j] = t;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n## python实现\n\n```\ndef insertSort(a):\n\tlength = len(targetList)\n\tfor i in range(1, length:\n\t\tj = i - 1\n\t\tif (target[i] < targetList[j]){\n\t\t\ttemp = targetList[i]\n\t\t\ttarget[i] = targetList[j]\n\t\t\tj = j - 1\n\t\t\twhile j > 0 and targetList[j] > temp:\n\t\t\t\ttargetList[j + 1] = targetList[j]\n\t\t\t\tj = j - 1\n\t\t\ttargetList[j + 1] = temp\n\t\t}\n```\n","slug":"直接插入排序","published":1,"updated":"2019-03-12T09:26:33.168Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttz700583a8k6jrwklyl","content":"<p>直接插入排序属于排序中的内部排序的插入排序的一种。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>直接将一个记录插入到已排序好的有序列表中，从而得到一个新的，记录数增1的有序表。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>只需要一个待记录的空间，空间复杂度为O(1)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>最好情况下，已有列表有序且正序，只需要插入一次，比较n-1次，移动0次<br>最坏情况下，已有列表有序但是倒序，需要全部更改，比较n-1次，移动n-1次，复杂度为O(n^2)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>把它当作一个牌堆，现在从第一张开始抽。（开启一个循环，循环长度为数组的长度）</p>\n<p>假如抽的这一张比右手第一张小，代表需要插到前面。（a[j] &lt; a[j-1]）</p>\n<p>从右手第二张开始往左看，如果找到有比抽到的这张小的，插到这张的后面。<br>这个过程需要将每个比抽到的这大的往后挪一位，</p>\n<p>小技巧，将手中最右边这张先拿出去，然后将抽到的这张加到最右边，然后从最右边开始排序，排序完毕之后将拿出去的这张重新加到最右边。</p>\n<h2 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int[] insertSort(int[] array)&#123;</span><br><span class=\"line\">\tint[] arr = array;</span><br><span class=\"line\">\tint temp;</span><br><span class=\"line\">\tfor(int i = 1; i &lt; arr.length; i++)&#123;</span><br><span class=\"line\">\t\tfor(int j = i; j &gt;= 1 &amp;&amp; arr[j - 1] &gt; arr[j]; j-- )&#123;</span><br><span class=\"line\">\t\t\ttemp = arr[j];</span><br><span class=\"line\">\t\t\tarr[j] = arr[j - 1];</span><br><span class=\"line\">\t\t\tarr[j - 1] = temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int inser_sort(int s[], int length)&#123;</span><br><span class=\"line\">\tint i, j, t;</span><br><span class=\"line\">\tfor (i = 1; i &lt; length; i++)&#123;</span><br><span class=\"line\">\t\tfor (j = i - 1; j &gt; -1 &amp;&amp; s[j] &gt; t; j--)&#123;</span><br><span class=\"line\">\t\t\tt = s[i];</span><br><span class=\"line\">\t\t\ts[j + 1] = s[j];</span><br><span class=\"line\">\t\t\ts[j] = t;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def insertSort(a):</span><br><span class=\"line\">\tlength = len(targetList)</span><br><span class=\"line\">\tfor i in range(1, length:</span><br><span class=\"line\">\t\tj = i - 1</span><br><span class=\"line\">\t\tif (target[i] &lt; targetList[j])&#123;</span><br><span class=\"line\">\t\t\ttemp = targetList[i]</span><br><span class=\"line\">\t\t\ttarget[i] = targetList[j]</span><br><span class=\"line\">\t\t\tj = j - 1</span><br><span class=\"line\">\t\t\twhile j &gt; 0 and targetList[j] &gt; temp:</span><br><span class=\"line\">\t\t\t\ttargetList[j + 1] = targetList[j]</span><br><span class=\"line\">\t\t\t\tj = j - 1</span><br><span class=\"line\">\t\t\ttargetList[j + 1] = temp</span><br><span class=\"line\">\t\t&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>直接插入排序属于排序中的内部排序的插入排序的一种。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>直接将一个记录插入到已排序好的有序列表中，从而得到一个新的，记录数增1的有序表。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>只需要一个待记录的空间，空间复杂度为O(1)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>最好情况下，已有列表有序且正序，只需要插入一次，比较n-1次，移动0次<br>最坏情况下，已有列表有序但是倒序，需要全部更改，比较n-1次，移动n-1次，复杂度为O(n^2)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>把它当作一个牌堆，现在从第一张开始抽。（开启一个循环，循环长度为数组的长度）</p>\n<p>假如抽的这一张比右手第一张小，代表需要插到前面。（a[j] &lt; a[j-1]）</p>\n<p>从右手第二张开始往左看，如果找到有比抽到的这张小的，插到这张的后面。<br>这个过程需要将每个比抽到的这大的往后挪一位，</p>\n<p>小技巧，将手中最右边这张先拿出去，然后将抽到的这张加到最右边，然后从最右边开始排序，排序完毕之后将拿出去的这张重新加到最右边。</p>\n<h2 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int[] insertSort(int[] array)&#123;</span><br><span class=\"line\">\tint[] arr = array;</span><br><span class=\"line\">\tint temp;</span><br><span class=\"line\">\tfor(int i = 1; i &lt; arr.length; i++)&#123;</span><br><span class=\"line\">\t\tfor(int j = i; j &gt;= 1 &amp;&amp; arr[j - 1] &gt; arr[j]; j-- )&#123;</span><br><span class=\"line\">\t\t\ttemp = arr[j];</span><br><span class=\"line\">\t\t\tarr[j] = arr[j - 1];</span><br><span class=\"line\">\t\t\tarr[j - 1] = temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int inser_sort(int s[], int length)&#123;</span><br><span class=\"line\">\tint i, j, t;</span><br><span class=\"line\">\tfor (i = 1; i &lt; length; i++)&#123;</span><br><span class=\"line\">\t\tfor (j = i - 1; j &gt; -1 &amp;&amp; s[j] &gt; t; j--)&#123;</span><br><span class=\"line\">\t\t\tt = s[i];</span><br><span class=\"line\">\t\t\ts[j + 1] = s[j];</span><br><span class=\"line\">\t\t\ts[j] = t;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def insertSort(a):</span><br><span class=\"line\">\tlength = len(targetList)</span><br><span class=\"line\">\tfor i in range(1, length:</span><br><span class=\"line\">\t\tj = i - 1</span><br><span class=\"line\">\t\tif (target[i] &lt; targetList[j])&#123;</span><br><span class=\"line\">\t\t\ttemp = targetList[i]</span><br><span class=\"line\">\t\t\ttarget[i] = targetList[j]</span><br><span class=\"line\">\t\t\tj = j - 1</span><br><span class=\"line\">\t\t\twhile j &gt; 0 and targetList[j] &gt; temp:</span><br><span class=\"line\">\t\t\t\ttargetList[j + 1] = targetList[j]</span><br><span class=\"line\">\t\t\t\tj = j - 1</span><br><span class=\"line\">\t\t\ttargetList[j + 1] = temp</span><br><span class=\"line\">\t\t&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"神策埋点reftype踩坑记","date":"2019-01-16T07:30:27.000Z","_content":"\n项目需要上报埋点，但是部分埋点需要携带reftype，而reftype却需要从上个页面报到下个页面来。\n\n从安卓上面来讲，一个页面是一个activity的形式，而reftype需要传递，有两种方式，一种是reftype以intent的bundle参数传入，第二种是在长于activity的生命周期保存这个reftype实现存储存取方式。\n\n第一种可以完全完美的解决的问题，但是带来的是过于繁琐的步骤，每个启动的intent都需要加，这样十分复杂，在新加的页面中这样写start()函数还是可以的，但是在我们这种有多路径，而且很多老页面中无法这样使用。并且如果单加一个reftype还可以，如果需要加上refid，from等参数，带来的更改复杂度几何度上升。\n\n第二种是借助第三方进行传递。这个是上个版本使用的，当时是通过静态变量进行传递。在当时reftype报的不是很多的情况下，尤其是只希望观察reftype是某个过程的行为的情况下使用比较合适。\n\n不过新的产品每次的埋点方案都很神奇，是单页面多过程埋点，需要兼顾返回清除问题，同时还需要报页面停留时长。\n\n相对于老的静态变量存储行为就不可以这么改了。当这个变量没有和页面的部分方法捆绑的时候，这个操作会造成不可逆的效果。而如果和方法捆绑的话，则又会造成大量的逻辑重构，更加麻烦。\n\n\n组内进行了一次神策的讨论（吐槽一下，其实很久之前就立项想动刀这个了，只是动刀的人一直懒着不动，终于拖到让我来弄了）。大致想法如下：\n\n1. 仍然沿用静态变量的行为\n2. 在页面中保留静态变量的实例，oncreate的时候获取，onresume的时候对全局的静态变量进行覆盖\n3. 更改页面reftype的地方由之前的点击变为oncreate的时候直接获取\n\n这样可以完全完成A->B->C->B，这么一个过程中，B记录了A的reftype，回到b的时候onresume虽然全局是B，但是由于B记录了A，onresume的时候就会使得A覆盖B。同时在没有更改reftype的时候，会保证全局reftype的行为可以传递。\n\n思路上面比较简单，用这个来实现一些数据阶段性传递比较有意义。","source":"_posts/神策埋点reftype踩坑记.md","raw":"---\ntitle: 神策埋点reftype踩坑记\ndate: 2019-01-16 15:30:27\ntags: android\n---\n\n项目需要上报埋点，但是部分埋点需要携带reftype，而reftype却需要从上个页面报到下个页面来。\n\n从安卓上面来讲，一个页面是一个activity的形式，而reftype需要传递，有两种方式，一种是reftype以intent的bundle参数传入，第二种是在长于activity的生命周期保存这个reftype实现存储存取方式。\n\n第一种可以完全完美的解决的问题，但是带来的是过于繁琐的步骤，每个启动的intent都需要加，这样十分复杂，在新加的页面中这样写start()函数还是可以的，但是在我们这种有多路径，而且很多老页面中无法这样使用。并且如果单加一个reftype还可以，如果需要加上refid，from等参数，带来的更改复杂度几何度上升。\n\n第二种是借助第三方进行传递。这个是上个版本使用的，当时是通过静态变量进行传递。在当时reftype报的不是很多的情况下，尤其是只希望观察reftype是某个过程的行为的情况下使用比较合适。\n\n不过新的产品每次的埋点方案都很神奇，是单页面多过程埋点，需要兼顾返回清除问题，同时还需要报页面停留时长。\n\n相对于老的静态变量存储行为就不可以这么改了。当这个变量没有和页面的部分方法捆绑的时候，这个操作会造成不可逆的效果。而如果和方法捆绑的话，则又会造成大量的逻辑重构，更加麻烦。\n\n\n组内进行了一次神策的讨论（吐槽一下，其实很久之前就立项想动刀这个了，只是动刀的人一直懒着不动，终于拖到让我来弄了）。大致想法如下：\n\n1. 仍然沿用静态变量的行为\n2. 在页面中保留静态变量的实例，oncreate的时候获取，onresume的时候对全局的静态变量进行覆盖\n3. 更改页面reftype的地方由之前的点击变为oncreate的时候直接获取\n\n这样可以完全完成A->B->C->B，这么一个过程中，B记录了A的reftype，回到b的时候onresume虽然全局是B，但是由于B记录了A，onresume的时候就会使得A覆盖B。同时在没有更改reftype的时候，会保证全局reftype的行为可以传递。\n\n思路上面比较简单，用这个来实现一些数据阶段性传递比较有意义。","slug":"神策埋点reftype踩坑记","published":1,"updated":"2019-03-12T09:26:33.168Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttz8005b3a8k03xvmut3","content":"<p>项目需要上报埋点，但是部分埋点需要携带reftype，而reftype却需要从上个页面报到下个页面来。</p>\n<p>从安卓上面来讲，一个页面是一个activity的形式，而reftype需要传递，有两种方式，一种是reftype以intent的bundle参数传入，第二种是在长于activity的生命周期保存这个reftype实现存储存取方式。</p>\n<p>第一种可以完全完美的解决的问题，但是带来的是过于繁琐的步骤，每个启动的intent都需要加，这样十分复杂，在新加的页面中这样写start()函数还是可以的，但是在我们这种有多路径，而且很多老页面中无法这样使用。并且如果单加一个reftype还可以，如果需要加上refid，from等参数，带来的更改复杂度几何度上升。</p>\n<p>第二种是借助第三方进行传递。这个是上个版本使用的，当时是通过静态变量进行传递。在当时reftype报的不是很多的情况下，尤其是只希望观察reftype是某个过程的行为的情况下使用比较合适。</p>\n<p>不过新的产品每次的埋点方案都很神奇，是单页面多过程埋点，需要兼顾返回清除问题，同时还需要报页面停留时长。</p>\n<p>相对于老的静态变量存储行为就不可以这么改了。当这个变量没有和页面的部分方法捆绑的时候，这个操作会造成不可逆的效果。而如果和方法捆绑的话，则又会造成大量的逻辑重构，更加麻烦。</p>\n<p>组内进行了一次神策的讨论（吐槽一下，其实很久之前就立项想动刀这个了，只是动刀的人一直懒着不动，终于拖到让我来弄了）。大致想法如下：</p>\n<ol>\n<li>仍然沿用静态变量的行为</li>\n<li>在页面中保留静态变量的实例，oncreate的时候获取，onresume的时候对全局的静态变量进行覆盖</li>\n<li>更改页面reftype的地方由之前的点击变为oncreate的时候直接获取</li>\n</ol>\n<p>这样可以完全完成A-&gt;B-&gt;C-&gt;B，这么一个过程中，B记录了A的reftype，回到b的时候onresume虽然全局是B，但是由于B记录了A，onresume的时候就会使得A覆盖B。同时在没有更改reftype的时候，会保证全局reftype的行为可以传递。</p>\n<p>思路上面比较简单，用这个来实现一些数据阶段性传递比较有意义。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>项目需要上报埋点，但是部分埋点需要携带reftype，而reftype却需要从上个页面报到下个页面来。</p>\n<p>从安卓上面来讲，一个页面是一个activity的形式，而reftype需要传递，有两种方式，一种是reftype以intent的bundle参数传入，第二种是在长于activity的生命周期保存这个reftype实现存储存取方式。</p>\n<p>第一种可以完全完美的解决的问题，但是带来的是过于繁琐的步骤，每个启动的intent都需要加，这样十分复杂，在新加的页面中这样写start()函数还是可以的，但是在我们这种有多路径，而且很多老页面中无法这样使用。并且如果单加一个reftype还可以，如果需要加上refid，from等参数，带来的更改复杂度几何度上升。</p>\n<p>第二种是借助第三方进行传递。这个是上个版本使用的，当时是通过静态变量进行传递。在当时reftype报的不是很多的情况下，尤其是只希望观察reftype是某个过程的行为的情况下使用比较合适。</p>\n<p>不过新的产品每次的埋点方案都很神奇，是单页面多过程埋点，需要兼顾返回清除问题，同时还需要报页面停留时长。</p>\n<p>相对于老的静态变量存储行为就不可以这么改了。当这个变量没有和页面的部分方法捆绑的时候，这个操作会造成不可逆的效果。而如果和方法捆绑的话，则又会造成大量的逻辑重构，更加麻烦。</p>\n<p>组内进行了一次神策的讨论（吐槽一下，其实很久之前就立项想动刀这个了，只是动刀的人一直懒着不动，终于拖到让我来弄了）。大致想法如下：</p>\n<ol>\n<li>仍然沿用静态变量的行为</li>\n<li>在页面中保留静态变量的实例，oncreate的时候获取，onresume的时候对全局的静态变量进行覆盖</li>\n<li>更改页面reftype的地方由之前的点击变为oncreate的时候直接获取</li>\n</ol>\n<p>这样可以完全完成A-&gt;B-&gt;C-&gt;B，这么一个过程中，B记录了A的reftype，回到b的时候onresume虽然全局是B，但是由于B记录了A，onresume的时候就会使得A覆盖B。同时在没有更改reftype的时候，会保证全局reftype的行为可以传递。</p>\n<p>思路上面比较简单，用这个来实现一些数据阶段性传递比较有意义。</p>\n"},{"title":"第八章Activity与Activity调用栈分析笔记","date":"2018-01-24T09:34:25.000Z","_content":"\n# Android任务栈简介\n\nandriod使用栈结构来管理activity\n\n# AndroidMainifest启动模式\n\n1. standard\n\n每次启动都会创建新的实例，覆盖在原来的activity上面\n\n2. singleTop\n\n每次启动时判断栈顶是否是要启动的activity，如果是则不创建新的而直接引用这个activity。不是的话则创建一个并启动。\n\n3. singleTask\n\n每次启动时判断整个栈是否有要启动的activity，如果有就将其以上的activity销毁（同一个app启动这个activity是销毁，不同app启动这个activity则会创建一个新的任务栈），如果activity在后台的一个栈中，后台这个任务栈将同时切换到前台。\n\n这种启动模式可以用来设置主activity，这样主activity启动别的activity，退出回到主activity时可以顺便销毁别的activity。\n\n4. singleInstance\n\n这种启动模式常用于需要与程序分离的界面，不同应用共同享用一个activity\n\nps:不同栈是无法使用startActivityForResult()方法来获得数据的，只可以通过intent绑定来传。\n\n# Intent Flag启动模式\n\n介绍一些常用的Flag\n\n1. Intent.FLAG_ACTIVITY_NEW_TASK\n\n使用一个新的task来启动activity，启动的每个activity都将在一个新的task中。\n\n该flag通常使用在从service中启动activity的场景，由于在service中并不存在activity栈，所以使用该flag来创建一个新的activity栈，并创建新的activty实例。\n\n2. FLAG_ACTIVITY_SINGLE_TOP\n\n与singletop等同\n\n3. FLAG_ACTIVITY_CLEAR_TOP\n\n使用singletask模式来启动一个activity\n\n4. FLAG_ACTIVITY_NO_HISTORY\n\n使用这种模式启动activity，当该activity启动其他activity后，该activity就消失了，不会保存在栈中。\n\n# 清空任务栈\n\n可以在mainifest中activity标签中使用以下几种属性来清理任务栈\n\n1. clearTaskOnLaunch\n\n每次返回该activity时，都将该activity之上的所有activity清除，通过这个属性，可以让这个task每次在初始化的时候，都只有这一个activity\n\n2. finishOnTaskLaunch\n\n当离开这个activity所处的task，用户在返回时，该activity就会被finish掉\n\n3. alwaysRetainTaskState\n\n如果将这个属性设为true，那么该activity所在的task将不受任何清理命令，一直保持当前task状态","source":"_posts/第八章Activity与Activity调用栈分析笔记.md","raw":"---\ntitle: 第八章Activity与Activity调用栈分析笔记\ndate: 2018-01-24 17:34:25\ntags: android\n---\n\n# Android任务栈简介\n\nandriod使用栈结构来管理activity\n\n# AndroidMainifest启动模式\n\n1. standard\n\n每次启动都会创建新的实例，覆盖在原来的activity上面\n\n2. singleTop\n\n每次启动时判断栈顶是否是要启动的activity，如果是则不创建新的而直接引用这个activity。不是的话则创建一个并启动。\n\n3. singleTask\n\n每次启动时判断整个栈是否有要启动的activity，如果有就将其以上的activity销毁（同一个app启动这个activity是销毁，不同app启动这个activity则会创建一个新的任务栈），如果activity在后台的一个栈中，后台这个任务栈将同时切换到前台。\n\n这种启动模式可以用来设置主activity，这样主activity启动别的activity，退出回到主activity时可以顺便销毁别的activity。\n\n4. singleInstance\n\n这种启动模式常用于需要与程序分离的界面，不同应用共同享用一个activity\n\nps:不同栈是无法使用startActivityForResult()方法来获得数据的，只可以通过intent绑定来传。\n\n# Intent Flag启动模式\n\n介绍一些常用的Flag\n\n1. Intent.FLAG_ACTIVITY_NEW_TASK\n\n使用一个新的task来启动activity，启动的每个activity都将在一个新的task中。\n\n该flag通常使用在从service中启动activity的场景，由于在service中并不存在activity栈，所以使用该flag来创建一个新的activity栈，并创建新的activty实例。\n\n2. FLAG_ACTIVITY_SINGLE_TOP\n\n与singletop等同\n\n3. FLAG_ACTIVITY_CLEAR_TOP\n\n使用singletask模式来启动一个activity\n\n4. FLAG_ACTIVITY_NO_HISTORY\n\n使用这种模式启动activity，当该activity启动其他activity后，该activity就消失了，不会保存在栈中。\n\n# 清空任务栈\n\n可以在mainifest中activity标签中使用以下几种属性来清理任务栈\n\n1. clearTaskOnLaunch\n\n每次返回该activity时，都将该activity之上的所有activity清除，通过这个属性，可以让这个task每次在初始化的时候，都只有这一个activity\n\n2. finishOnTaskLaunch\n\n当离开这个activity所处的task，用户在返回时，该activity就会被finish掉\n\n3. alwaysRetainTaskState\n\n如果将这个属性设为true，那么该activity所在的task将不受任何清理命令，一直保持当前task状态","slug":"第八章Activity与Activity调用栈分析笔记","published":1,"updated":"2019-03-12T09:26:33.169Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttz9005d3a8kv7ej0jhj","content":"<h1 id=\"Android任务栈简介\"><a href=\"#Android任务栈简介\" class=\"headerlink\" title=\"Android任务栈简介\"></a>Android任务栈简介</h1><p>andriod使用栈结构来管理activity</p>\n<h1 id=\"AndroidMainifest启动模式\"><a href=\"#AndroidMainifest启动模式\" class=\"headerlink\" title=\"AndroidMainifest启动模式\"></a>AndroidMainifest启动模式</h1><ol>\n<li>standard</li>\n</ol>\n<p>每次启动都会创建新的实例，覆盖在原来的activity上面</p>\n<ol start=\"2\">\n<li>singleTop</li>\n</ol>\n<p>每次启动时判断栈顶是否是要启动的activity，如果是则不创建新的而直接引用这个activity。不是的话则创建一个并启动。</p>\n<ol start=\"3\">\n<li>singleTask</li>\n</ol>\n<p>每次启动时判断整个栈是否有要启动的activity，如果有就将其以上的activity销毁（同一个app启动这个activity是销毁，不同app启动这个activity则会创建一个新的任务栈），如果activity在后台的一个栈中，后台这个任务栈将同时切换到前台。</p>\n<p>这种启动模式可以用来设置主activity，这样主activity启动别的activity，退出回到主activity时可以顺便销毁别的activity。</p>\n<ol start=\"4\">\n<li>singleInstance</li>\n</ol>\n<p>这种启动模式常用于需要与程序分离的界面，不同应用共同享用一个activity</p>\n<p>ps:不同栈是无法使用startActivityForResult()方法来获得数据的，只可以通过intent绑定来传。</p>\n<h1 id=\"Intent-Flag启动模式\"><a href=\"#Intent-Flag启动模式\" class=\"headerlink\" title=\"Intent Flag启动模式\"></a>Intent Flag启动模式</h1><p>介绍一些常用的Flag</p>\n<ol>\n<li>Intent.FLAG_ACTIVITY_NEW_TASK</li>\n</ol>\n<p>使用一个新的task来启动activity，启动的每个activity都将在一个新的task中。</p>\n<p>该flag通常使用在从service中启动activity的场景，由于在service中并不存在activity栈，所以使用该flag来创建一个新的activity栈，并创建新的activty实例。</p>\n<ol start=\"2\">\n<li>FLAG_ACTIVITY_SINGLE_TOP</li>\n</ol>\n<p>与singletop等同</p>\n<ol start=\"3\">\n<li>FLAG_ACTIVITY_CLEAR_TOP</li>\n</ol>\n<p>使用singletask模式来启动一个activity</p>\n<ol start=\"4\">\n<li>FLAG_ACTIVITY_NO_HISTORY</li>\n</ol>\n<p>使用这种模式启动activity，当该activity启动其他activity后，该activity就消失了，不会保存在栈中。</p>\n<h1 id=\"清空任务栈\"><a href=\"#清空任务栈\" class=\"headerlink\" title=\"清空任务栈\"></a>清空任务栈</h1><p>可以在mainifest中activity标签中使用以下几种属性来清理任务栈</p>\n<ol>\n<li>clearTaskOnLaunch</li>\n</ol>\n<p>每次返回该activity时，都将该activity之上的所有activity清除，通过这个属性，可以让这个task每次在初始化的时候，都只有这一个activity</p>\n<ol start=\"2\">\n<li>finishOnTaskLaunch</li>\n</ol>\n<p>当离开这个activity所处的task，用户在返回时，该activity就会被finish掉</p>\n<ol start=\"3\">\n<li>alwaysRetainTaskState</li>\n</ol>\n<p>如果将这个属性设为true，那么该activity所在的task将不受任何清理命令，一直保持当前task状态</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Android任务栈简介\"><a href=\"#Android任务栈简介\" class=\"headerlink\" title=\"Android任务栈简介\"></a>Android任务栈简介</h1><p>andriod使用栈结构来管理activity</p>\n<h1 id=\"AndroidMainifest启动模式\"><a href=\"#AndroidMainifest启动模式\" class=\"headerlink\" title=\"AndroidMainifest启动模式\"></a>AndroidMainifest启动模式</h1><ol>\n<li>standard</li>\n</ol>\n<p>每次启动都会创建新的实例，覆盖在原来的activity上面</p>\n<ol start=\"2\">\n<li>singleTop</li>\n</ol>\n<p>每次启动时判断栈顶是否是要启动的activity，如果是则不创建新的而直接引用这个activity。不是的话则创建一个并启动。</p>\n<ol start=\"3\">\n<li>singleTask</li>\n</ol>\n<p>每次启动时判断整个栈是否有要启动的activity，如果有就将其以上的activity销毁（同一个app启动这个activity是销毁，不同app启动这个activity则会创建一个新的任务栈），如果activity在后台的一个栈中，后台这个任务栈将同时切换到前台。</p>\n<p>这种启动模式可以用来设置主activity，这样主activity启动别的activity，退出回到主activity时可以顺便销毁别的activity。</p>\n<ol start=\"4\">\n<li>singleInstance</li>\n</ol>\n<p>这种启动模式常用于需要与程序分离的界面，不同应用共同享用一个activity</p>\n<p>ps:不同栈是无法使用startActivityForResult()方法来获得数据的，只可以通过intent绑定来传。</p>\n<h1 id=\"Intent-Flag启动模式\"><a href=\"#Intent-Flag启动模式\" class=\"headerlink\" title=\"Intent Flag启动模式\"></a>Intent Flag启动模式</h1><p>介绍一些常用的Flag</p>\n<ol>\n<li>Intent.FLAG_ACTIVITY_NEW_TASK</li>\n</ol>\n<p>使用一个新的task来启动activity，启动的每个activity都将在一个新的task中。</p>\n<p>该flag通常使用在从service中启动activity的场景，由于在service中并不存在activity栈，所以使用该flag来创建一个新的activity栈，并创建新的activty实例。</p>\n<ol start=\"2\">\n<li>FLAG_ACTIVITY_SINGLE_TOP</li>\n</ol>\n<p>与singletop等同</p>\n<ol start=\"3\">\n<li>FLAG_ACTIVITY_CLEAR_TOP</li>\n</ol>\n<p>使用singletask模式来启动一个activity</p>\n<ol start=\"4\">\n<li>FLAG_ACTIVITY_NO_HISTORY</li>\n</ol>\n<p>使用这种模式启动activity，当该activity启动其他activity后，该activity就消失了，不会保存在栈中。</p>\n<h1 id=\"清空任务栈\"><a href=\"#清空任务栈\" class=\"headerlink\" title=\"清空任务栈\"></a>清空任务栈</h1><p>可以在mainifest中activity标签中使用以下几种属性来清理任务栈</p>\n<ol>\n<li>clearTaskOnLaunch</li>\n</ol>\n<p>每次返回该activity时，都将该activity之上的所有activity清除，通过这个属性，可以让这个task每次在初始化的时候，都只有这一个activity</p>\n<ol start=\"2\">\n<li>finishOnTaskLaunch</li>\n</ol>\n<p>当离开这个activity所处的task，用户在返回时，该activity就会被finish掉</p>\n<ol start=\"3\">\n<li>alwaysRetainTaskState</li>\n</ol>\n<p>如果将这个属性设为true，那么该activity所在的task将不受任何清理命令，一直保持当前task状态</p>\n"},{"title":"第七章动画机制与使用技巧学习笔记","date":"2018-01-22T14:47:31.000Z","_content":"# Android View动画框架\n\nAnimation框架定义了透明度、旋转、缩放和位移几种常见的动画，控制的是整个view，原理是每次绘制视图时view所在的viewgroup中的drawchild函数获取该view的animation的transformation值，然后调用canvas.concat(transformToApply.getMatrix())，通过矩阵换算完成动画帧，如果动画没有完成，就继续调用invalidate()函数，启动下次绘制来驱动动画，从而完成整个动画的绘制。\n\n## 视图动画\n\n视图动画使用简单，效果丰富，提供了四种方式，并提供了animationset动画集合，混合使用多种动画。\n\n1. 透明度动画\n\n为视图增加透明度的变换动画。\n\n```\n\tAlphaAnimation aa = new AlphaAnimation(0, 1);\n\taa.setDuration(1000);\n\tview.startAnimation(aa);\n```\t\n\n2. 旋转动画\n\n为视图增加旋转的变换动画。\n\n```\n\tRotateAnimation ra = new RotateAnimation(0, 360, 100, 100);\n\tra.setDuration(1000);\n\tview.startAnimation(ra);\n```\n\n也可以以自身为旋转中心\n\n```\n\tRotateAnimation ra = new RotateAnimation(0, 360,\n\t\tRotateAnimation.RELATIVE_TO_SELF, 0.5F,\n\t\tRotateAnimation.RELATIVE_TO_SELF, 0.5F);\n```\n\n3. 位移动画\n\n为视图移动时增加位移动画\n\n```\n\tTranslationAnimation ta = new TranslationAnimation(0, 200, 0, 300);\n\tta.setDuration(1000);\n\tview.startAnimation(ta);\n```\n\n4. 缩放动画\n\n为视图的缩放增加动画效果\n\n```\n\tScaleAnimation sa = new ScaleAnimation(0, 2, 0, 2);\n\tsa.setDuration(1000);\n\tview.startAnimation(sa);\n```\n\n也可以以自身为缩放中心\n\n```\n\tScaleAnimation sa = new ScaleAnimation(0, 1, 0, 1,\n\t\tAnimation.RELATIVE_TO_SELF, 0.5F,\n\t\tAnimation.RELATIVE_TO_SELF, 0.5F);\n\tsa.setDuration(1000);\n\tview.startAnimation(sa);\n```\n\n5. 动画合集\n\n使用AnimationSet,可以将动画以组合的形式展现出来。\n\n```\n\tAnimationSet as = new AnimationSet(true);\n\tas.setDuration(1000);\n\n\tAlphaAnimation aa = new AlphaAnimation(0, 1);\n\taa.setDuration(1000);\n\tas.addAnimation(aa);\n\n\tTranslateAnimation ta = new TranslateAnimation(0, 100, 0, 200);\n\tta.setDuration(1000);\n\tas.addAnimation(ta);\n\n\tview.startAnimation(as);\n```\n\n## 属性动画\n\n由于视图动画改变的只是view的显示，而并不是view的属性，会导致一些问题。\n\n1. \tObjectAnimator\n\nObjectAnimator是属性动画框架中最重要的实体类，创建一个ObjectAnimator只需要通过他的静态工厂类直接返回一个ObjectAnimator对象。参数包括一个对象和对象的属性名字，但这个属性必须有get和set函数，内部会通过java反射机制来调用set函数修改对象属性值。\n\n```\n\tObjectAnimator animator = ObjectAnimator.ofFloat(\n\t\tview, \"translationX\", 300);\n\tanimator.setDuration(300);\n\tanimator.start();\n```\n\n第一个参数为要操纵的view，第二个参数为要操纵的属性，第三个三处为一个可变数组参数，需要传进该属性变化的一个取值过程。\n\n如果需要操控一个值，但是该值没有setget方法，可以使用wrapper方法来进行一层包装。\n\n```\n\tprivate static class WrapperView{\n\t\tprivate View mTarget;\n\t\tpublic WrapperView(View target){\n\t\t\tmTarget = target;\n\t\t}\n\t\tpublic int getWidth(){\n\t\t\treturn mTarget.getLayoutParams().width;\n\t\t}\n\t\tpublic void setWidth(int width){\n\t\t\tmTarget.getLayoutParams().width = width;\n\t\t\tmTarget.requestLayout();\n\t\t}\n\t}\n```\n\n```\n\tViewWrapper wrapper = new ViewWrapper(mButton);\n\tObjectAnimator.ofInt(wrapper, \"width\", 500).setDuration(5000).start();\n```\n\n2. PropertyValuesHolder\n\n类似视图动画中的AnimationSet,在属性动画中，如果针对同一个对象的多个属性，要同时作用多种动画，可以使用PropertyValuesHolder来实现。\n\n```\n\tPropertyValuesHolder pvh1 = PropertyValuesHolder.ofFloat(\"translationX\", 300f);\n\tPropertyValuesHolder pvh2 = PropertyValuesHolder.ofFloat(\"scaleX\", 1f, 0, 1f);\n\tPropertyValuesHolder pvh3 = PropertyValuesHolder.ofFloat(\"scaleY\", 1f, 0, 1f);\n\tObjectAnimator.ofPropertyValuesHolder(view, pvh1, pvh2, pvh3).setDuration(1000).start();\n```\n\n3. ValueAnimator\n\nValueAnimator本身不提供任何动画效果，它更像一个数值发生器，用来产生具有一定规律的数字，从而让调用者来控制动画的实现过程。\n\n```\n\tValueAnimator animator = ValueAnimator.ofFloat(0, 100);\n\tanimator.setTarget(view);\n\tanimator.setDuration(1000).start();\n\tanimator.addUpdateListener(new AnimatorUpdateListener(){\n\t\t@Override\n\t\tpublic void onAnimationUpdate(ValueAnimator animation){\n\t\t\tFloat value = (Float) animation.getAnimatedValue();\n\t\t\t//TODO use the value\n\t\t}\n\t})\n```\n\n4. 动画事件的监听\n\n一个完整的动画具有Start, Repeat, End, Cancel四个过程，对动画使用AddListener()即可很方便的监听到这四个事件。\n\n5. AnimatorSet\n\n对于一个属性同时作用多个属性动画效果吗可以使用之前的PrpertyValuesHolder实现，而AnimatorSet不仅可以实现效果，还能控制顺序。\n\n```\n\tObjectAnimator animator1 = ObjectAnimator.ofFloat(view, \"translationX\", 300f);\n\tObjectAnimator animator2 = ObjectAnimator.ofFloat(view, \"scaleX\", 1f, 0f, 1f);\n\tObjectAnimator animator3 = ObjectAnimator.ofFloat(view, \"scaleY\", 1f, 0f, 1f);\n\tAnimatorSet set = new AnimatorSet();\n\tset.setDuration(1000);\n\tset.playTogether(animator1, animator2, animator3);\n\tset.start();\n```\n\n使用playTogether(), playSequentially(), animSet.play().with(),before(),after()来控制多个动画的协同工作方式。\n\n6. 在xml中使用属性动画\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<objectAnimator xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\tandroid:duration=\"1000\"\n\tandroid:propertyName=\"scaleX\"\n\tandroid:valueFrom=\"1.0\"\n\tandroid:valueTo=\"2.0\"\n\tandroid:valueType=\"floatType\">\n</objectAnimator>\n```\n\n```\n\tpublic void scaleX(View view){\n\t\tAnimator anim = AnimatorInflater.loadAnimator(this, R.animator.scalex);\n\t\tanim.setTarget(mMv);\n\t\tanim.start();\n\t}\n```\n\n7. View的animate方法\n\nanimate方法是属性动画的一种简写方式\n\n```\n\tview.animate()\n\t\t.alpha(0)\n\t\t.y(300)\n\t\t.setDuration(300)\n\t\t.withStartAction(new Runnable(){\n\t\t\t@Override\n\t\t\tpublic void run(){\n\n\t\t\t}\n\t\t})\n\t\t.withEndAction(new Runnable(){\n\t\t\t@Override\n\t\t\tpublic void run(){\n\n\t\t\t}\n\t\t}).start();\n```\n\n## 布局动画\n\n布局动画是指在ViewGroup上，给ViewGroup添加view时添加一个动画过度效果。\n\n最简单的布局动画，只需要添加\n```\n\tandroid:animateLayoutChanges=\"true\"\n```\n\n另外，还可以通过使用LayoutAnimationController类来自定义一个子View的过度效果。\n\n```\n\tLinearLayout ll = (LinearLayout)findViewById(R.id.ll);\n\t//设置过渡动画\n\tScaleAnimation sa = new ScaleAnimation(0, 1, 0, 1);\n\tsa.setDuration(2000);\n\t//设置布局动画的显示属性\n\tLayoutAnimationController lac = new LayoutAnimationController(sa, 0.5F);\n\tlac.setOrder(LayoutAnimationController.ORDER_NORMAL);\n\t//为viewgroup设置布局动画\n\tll.setLayoutAnimation(lac);\n```\n\n上述代码可以使得子view出现时有一个缩放的效果。\n\n## 插值器\n\n插值器用于定义动画变化速率。\n\n## 自定义动画\n\n自定义动画是继承一个Animation然后自己写，自定义动画可以获得当前矩阵对象，然后对矩阵进行操作变化，可以实现任何效果的动画。\n\n\n","source":"_posts/第七章动画机制与使用技巧学习笔记.md","raw":"---\ntitle: 第七章动画机制与使用技巧学习笔记\ndate: 2018-01-22 22:47:31\ntags: android\n---\n# Android View动画框架\n\nAnimation框架定义了透明度、旋转、缩放和位移几种常见的动画，控制的是整个view，原理是每次绘制视图时view所在的viewgroup中的drawchild函数获取该view的animation的transformation值，然后调用canvas.concat(transformToApply.getMatrix())，通过矩阵换算完成动画帧，如果动画没有完成，就继续调用invalidate()函数，启动下次绘制来驱动动画，从而完成整个动画的绘制。\n\n## 视图动画\n\n视图动画使用简单，效果丰富，提供了四种方式，并提供了animationset动画集合，混合使用多种动画。\n\n1. 透明度动画\n\n为视图增加透明度的变换动画。\n\n```\n\tAlphaAnimation aa = new AlphaAnimation(0, 1);\n\taa.setDuration(1000);\n\tview.startAnimation(aa);\n```\t\n\n2. 旋转动画\n\n为视图增加旋转的变换动画。\n\n```\n\tRotateAnimation ra = new RotateAnimation(0, 360, 100, 100);\n\tra.setDuration(1000);\n\tview.startAnimation(ra);\n```\n\n也可以以自身为旋转中心\n\n```\n\tRotateAnimation ra = new RotateAnimation(0, 360,\n\t\tRotateAnimation.RELATIVE_TO_SELF, 0.5F,\n\t\tRotateAnimation.RELATIVE_TO_SELF, 0.5F);\n```\n\n3. 位移动画\n\n为视图移动时增加位移动画\n\n```\n\tTranslationAnimation ta = new TranslationAnimation(0, 200, 0, 300);\n\tta.setDuration(1000);\n\tview.startAnimation(ta);\n```\n\n4. 缩放动画\n\n为视图的缩放增加动画效果\n\n```\n\tScaleAnimation sa = new ScaleAnimation(0, 2, 0, 2);\n\tsa.setDuration(1000);\n\tview.startAnimation(sa);\n```\n\n也可以以自身为缩放中心\n\n```\n\tScaleAnimation sa = new ScaleAnimation(0, 1, 0, 1,\n\t\tAnimation.RELATIVE_TO_SELF, 0.5F,\n\t\tAnimation.RELATIVE_TO_SELF, 0.5F);\n\tsa.setDuration(1000);\n\tview.startAnimation(sa);\n```\n\n5. 动画合集\n\n使用AnimationSet,可以将动画以组合的形式展现出来。\n\n```\n\tAnimationSet as = new AnimationSet(true);\n\tas.setDuration(1000);\n\n\tAlphaAnimation aa = new AlphaAnimation(0, 1);\n\taa.setDuration(1000);\n\tas.addAnimation(aa);\n\n\tTranslateAnimation ta = new TranslateAnimation(0, 100, 0, 200);\n\tta.setDuration(1000);\n\tas.addAnimation(ta);\n\n\tview.startAnimation(as);\n```\n\n## 属性动画\n\n由于视图动画改变的只是view的显示，而并不是view的属性，会导致一些问题。\n\n1. \tObjectAnimator\n\nObjectAnimator是属性动画框架中最重要的实体类，创建一个ObjectAnimator只需要通过他的静态工厂类直接返回一个ObjectAnimator对象。参数包括一个对象和对象的属性名字，但这个属性必须有get和set函数，内部会通过java反射机制来调用set函数修改对象属性值。\n\n```\n\tObjectAnimator animator = ObjectAnimator.ofFloat(\n\t\tview, \"translationX\", 300);\n\tanimator.setDuration(300);\n\tanimator.start();\n```\n\n第一个参数为要操纵的view，第二个参数为要操纵的属性，第三个三处为一个可变数组参数，需要传进该属性变化的一个取值过程。\n\n如果需要操控一个值，但是该值没有setget方法，可以使用wrapper方法来进行一层包装。\n\n```\n\tprivate static class WrapperView{\n\t\tprivate View mTarget;\n\t\tpublic WrapperView(View target){\n\t\t\tmTarget = target;\n\t\t}\n\t\tpublic int getWidth(){\n\t\t\treturn mTarget.getLayoutParams().width;\n\t\t}\n\t\tpublic void setWidth(int width){\n\t\t\tmTarget.getLayoutParams().width = width;\n\t\t\tmTarget.requestLayout();\n\t\t}\n\t}\n```\n\n```\n\tViewWrapper wrapper = new ViewWrapper(mButton);\n\tObjectAnimator.ofInt(wrapper, \"width\", 500).setDuration(5000).start();\n```\n\n2. PropertyValuesHolder\n\n类似视图动画中的AnimationSet,在属性动画中，如果针对同一个对象的多个属性，要同时作用多种动画，可以使用PropertyValuesHolder来实现。\n\n```\n\tPropertyValuesHolder pvh1 = PropertyValuesHolder.ofFloat(\"translationX\", 300f);\n\tPropertyValuesHolder pvh2 = PropertyValuesHolder.ofFloat(\"scaleX\", 1f, 0, 1f);\n\tPropertyValuesHolder pvh3 = PropertyValuesHolder.ofFloat(\"scaleY\", 1f, 0, 1f);\n\tObjectAnimator.ofPropertyValuesHolder(view, pvh1, pvh2, pvh3).setDuration(1000).start();\n```\n\n3. ValueAnimator\n\nValueAnimator本身不提供任何动画效果，它更像一个数值发生器，用来产生具有一定规律的数字，从而让调用者来控制动画的实现过程。\n\n```\n\tValueAnimator animator = ValueAnimator.ofFloat(0, 100);\n\tanimator.setTarget(view);\n\tanimator.setDuration(1000).start();\n\tanimator.addUpdateListener(new AnimatorUpdateListener(){\n\t\t@Override\n\t\tpublic void onAnimationUpdate(ValueAnimator animation){\n\t\t\tFloat value = (Float) animation.getAnimatedValue();\n\t\t\t//TODO use the value\n\t\t}\n\t})\n```\n\n4. 动画事件的监听\n\n一个完整的动画具有Start, Repeat, End, Cancel四个过程，对动画使用AddListener()即可很方便的监听到这四个事件。\n\n5. AnimatorSet\n\n对于一个属性同时作用多个属性动画效果吗可以使用之前的PrpertyValuesHolder实现，而AnimatorSet不仅可以实现效果，还能控制顺序。\n\n```\n\tObjectAnimator animator1 = ObjectAnimator.ofFloat(view, \"translationX\", 300f);\n\tObjectAnimator animator2 = ObjectAnimator.ofFloat(view, \"scaleX\", 1f, 0f, 1f);\n\tObjectAnimator animator3 = ObjectAnimator.ofFloat(view, \"scaleY\", 1f, 0f, 1f);\n\tAnimatorSet set = new AnimatorSet();\n\tset.setDuration(1000);\n\tset.playTogether(animator1, animator2, animator3);\n\tset.start();\n```\n\n使用playTogether(), playSequentially(), animSet.play().with(),before(),after()来控制多个动画的协同工作方式。\n\n6. 在xml中使用属性动画\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<objectAnimator xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\tandroid:duration=\"1000\"\n\tandroid:propertyName=\"scaleX\"\n\tandroid:valueFrom=\"1.0\"\n\tandroid:valueTo=\"2.0\"\n\tandroid:valueType=\"floatType\">\n</objectAnimator>\n```\n\n```\n\tpublic void scaleX(View view){\n\t\tAnimator anim = AnimatorInflater.loadAnimator(this, R.animator.scalex);\n\t\tanim.setTarget(mMv);\n\t\tanim.start();\n\t}\n```\n\n7. View的animate方法\n\nanimate方法是属性动画的一种简写方式\n\n```\n\tview.animate()\n\t\t.alpha(0)\n\t\t.y(300)\n\t\t.setDuration(300)\n\t\t.withStartAction(new Runnable(){\n\t\t\t@Override\n\t\t\tpublic void run(){\n\n\t\t\t}\n\t\t})\n\t\t.withEndAction(new Runnable(){\n\t\t\t@Override\n\t\t\tpublic void run(){\n\n\t\t\t}\n\t\t}).start();\n```\n\n## 布局动画\n\n布局动画是指在ViewGroup上，给ViewGroup添加view时添加一个动画过度效果。\n\n最简单的布局动画，只需要添加\n```\n\tandroid:animateLayoutChanges=\"true\"\n```\n\n另外，还可以通过使用LayoutAnimationController类来自定义一个子View的过度效果。\n\n```\n\tLinearLayout ll = (LinearLayout)findViewById(R.id.ll);\n\t//设置过渡动画\n\tScaleAnimation sa = new ScaleAnimation(0, 1, 0, 1);\n\tsa.setDuration(2000);\n\t//设置布局动画的显示属性\n\tLayoutAnimationController lac = new LayoutAnimationController(sa, 0.5F);\n\tlac.setOrder(LayoutAnimationController.ORDER_NORMAL);\n\t//为viewgroup设置布局动画\n\tll.setLayoutAnimation(lac);\n```\n\n上述代码可以使得子view出现时有一个缩放的效果。\n\n## 插值器\n\n插值器用于定义动画变化速率。\n\n## 自定义动画\n\n自定义动画是继承一个Animation然后自己写，自定义动画可以获得当前矩阵对象，然后对矩阵进行操作变化，可以实现任何效果的动画。\n\n\n","slug":"第七章动画机制与使用技巧学习笔记","published":1,"updated":"2019-03-12T09:26:33.169Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttza005f3a8k5wze9e8y","content":"<h1 id=\"Android-View动画框架\"><a href=\"#Android-View动画框架\" class=\"headerlink\" title=\"Android View动画框架\"></a>Android View动画框架</h1><p>Animation框架定义了透明度、旋转、缩放和位移几种常见的动画，控制的是整个view，原理是每次绘制视图时view所在的viewgroup中的drawchild函数获取该view的animation的transformation值，然后调用canvas.concat(transformToApply.getMatrix())，通过矩阵换算完成动画帧，如果动画没有完成，就继续调用invalidate()函数，启动下次绘制来驱动动画，从而完成整个动画的绘制。</p>\n<h2 id=\"视图动画\"><a href=\"#视图动画\" class=\"headerlink\" title=\"视图动画\"></a>视图动画</h2><p>视图动画使用简单，效果丰富，提供了四种方式，并提供了animationset动画集合，混合使用多种动画。</p>\n<ol>\n<li>透明度动画</li>\n</ol>\n<p>为视图增加透明度的变换动画。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\tAlphaAnimation aa = new AlphaAnimation(0, 1);</span><br><span class=\"line\">\taa.setDuration(1000);</span><br><span class=\"line\">\tview.startAnimation(aa);</span><br><span class=\"line\">```\t</span><br><span class=\"line\"></span><br><span class=\"line\">2. 旋转动画</span><br><span class=\"line\"></span><br><span class=\"line\">为视图增加旋转的变换动画。</span><br></pre></td></tr></table></figure>\n<pre><code>RotateAnimation ra = new RotateAnimation(0, 360, 100, 100);\nra.setDuration(1000);\nview.startAnimation(ra);\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">也可以以自身为旋转中心</span><br></pre></td></tr></table></figure>\n<pre><code>RotateAnimation ra = new RotateAnimation(0, 360,\n    RotateAnimation.RELATIVE_TO_SELF, 0.5F,\n    RotateAnimation.RELATIVE_TO_SELF, 0.5F);\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. 位移动画</span><br><span class=\"line\"></span><br><span class=\"line\">为视图移动时增加位移动画</span><br></pre></td></tr></table></figure>\n<pre><code>TranslationAnimation ta = new TranslationAnimation(0, 200, 0, 300);\nta.setDuration(1000);\nview.startAnimation(ta);\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">4. 缩放动画</span><br><span class=\"line\"></span><br><span class=\"line\">为视图的缩放增加动画效果</span><br></pre></td></tr></table></figure>\n<pre><code>ScaleAnimation sa = new ScaleAnimation(0, 2, 0, 2);\nsa.setDuration(1000);\nview.startAnimation(sa);\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">也可以以自身为缩放中心</span><br></pre></td></tr></table></figure>\n<pre><code>ScaleAnimation sa = new ScaleAnimation(0, 1, 0, 1,\n    Animation.RELATIVE_TO_SELF, 0.5F,\n    Animation.RELATIVE_TO_SELF, 0.5F);\nsa.setDuration(1000);\nview.startAnimation(sa);\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">5. 动画合集</span><br><span class=\"line\"></span><br><span class=\"line\">使用AnimationSet,可以将动画以组合的形式展现出来。</span><br></pre></td></tr></table></figure>\n<pre><code>AnimationSet as = new AnimationSet(true);\nas.setDuration(1000);\n\nAlphaAnimation aa = new AlphaAnimation(0, 1);\naa.setDuration(1000);\nas.addAnimation(aa);\n\nTranslateAnimation ta = new TranslateAnimation(0, 100, 0, 200);\nta.setDuration(1000);\nas.addAnimation(ta);\n\nview.startAnimation(as);\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 属性动画</span><br><span class=\"line\"></span><br><span class=\"line\">由于视图动画改变的只是view的显示，而并不是view的属性，会导致一些问题。</span><br><span class=\"line\"></span><br><span class=\"line\">1. \tObjectAnimator</span><br><span class=\"line\"></span><br><span class=\"line\">ObjectAnimator是属性动画框架中最重要的实体类，创建一个ObjectAnimator只需要通过他的静态工厂类直接返回一个ObjectAnimator对象。参数包括一个对象和对象的属性名字，但这个属性必须有get和set函数，内部会通过java反射机制来调用set函数修改对象属性值。</span><br></pre></td></tr></table></figure>\n<pre><code>ObjectAnimator animator = ObjectAnimator.ofFloat(\n    view, &quot;translationX&quot;, 300);\nanimator.setDuration(300);\nanimator.start();\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">第一个参数为要操纵的view，第二个参数为要操纵的属性，第三个三处为一个可变数组参数，需要传进该属性变化的一个取值过程。</span><br><span class=\"line\"></span><br><span class=\"line\">如果需要操控一个值，但是该值没有setget方法，可以使用wrapper方法来进行一层包装。</span><br></pre></td></tr></table></figure>\n<pre><code>private static class WrapperView{\n    private View mTarget;\n    public WrapperView(View target){\n        mTarget = target;\n    }\n    public int getWidth(){\n        return mTarget.getLayoutParams().width;\n    }\n    public void setWidth(int width){\n        mTarget.getLayoutParams().width = width;\n        mTarget.requestLayout();\n    }\n}\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<pre><code>ViewWrapper wrapper = new ViewWrapper(mButton);\nObjectAnimator.ofInt(wrapper, &quot;width&quot;, 500).setDuration(5000).start();\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. PropertyValuesHolder</span><br><span class=\"line\"></span><br><span class=\"line\">类似视图动画中的AnimationSet,在属性动画中，如果针对同一个对象的多个属性，要同时作用多种动画，可以使用PropertyValuesHolder来实现。</span><br></pre></td></tr></table></figure>\n<pre><code>PropertyValuesHolder pvh1 = PropertyValuesHolder.ofFloat(&quot;translationX&quot;, 300f);\nPropertyValuesHolder pvh2 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1f, 0, 1f);\nPropertyValuesHolder pvh3 = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1f, 0, 1f);\nObjectAnimator.ofPropertyValuesHolder(view, pvh1, pvh2, pvh3).setDuration(1000).start();\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. ValueAnimator</span><br><span class=\"line\"></span><br><span class=\"line\">ValueAnimator本身不提供任何动画效果，它更像一个数值发生器，用来产生具有一定规律的数字，从而让调用者来控制动画的实现过程。</span><br></pre></td></tr></table></figure>\n<pre><code>ValueAnimator animator = ValueAnimator.ofFloat(0, 100);\nanimator.setTarget(view);\nanimator.setDuration(1000).start();\nanimator.addUpdateListener(new AnimatorUpdateListener(){\n    @Override\n    public void onAnimationUpdate(ValueAnimator animation){\n        Float value = (Float) animation.getAnimatedValue();\n        //TODO use the value\n    }\n})\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">4. 动画事件的监听</span><br><span class=\"line\"></span><br><span class=\"line\">一个完整的动画具有Start, Repeat, End, Cancel四个过程，对动画使用AddListener()即可很方便的监听到这四个事件。</span><br><span class=\"line\"></span><br><span class=\"line\">5. AnimatorSet</span><br><span class=\"line\"></span><br><span class=\"line\">对于一个属性同时作用多个属性动画效果吗可以使用之前的PrpertyValuesHolder实现，而AnimatorSet不仅可以实现效果，还能控制顺序。</span><br></pre></td></tr></table></figure>\n<pre><code>ObjectAnimator animator1 = ObjectAnimator.ofFloat(view, &quot;translationX&quot;, 300f);\nObjectAnimator animator2 = ObjectAnimator.ofFloat(view, &quot;scaleX&quot;, 1f, 0f, 1f);\nObjectAnimator animator3 = ObjectAnimator.ofFloat(view, &quot;scaleY&quot;, 1f, 0f, 1f);\nAnimatorSet set = new AnimatorSet();\nset.setDuration(1000);\nset.playTogether(animator1, animator2, animator3);\nset.start();\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">使用playTogether(), playSequentially(), animSet.play().with(),before(),after()来控制多个动画的协同工作方式。</span><br><span class=\"line\"></span><br><span class=\"line\">6. 在xml中使用属性动画</span><br></pre></td></tr></table></figure>\n<p>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;</p>\n<p><objectanimator xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"1000\" android:propertyname=\"scaleX\" android:valuefrom=\"1.0\" android:valueto=\"2.0\" android:valuetype=\"floatType\"><br></objectanimator><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<pre><code>public void scaleX(View view){\n    Animator anim = AnimatorInflater.loadAnimator(this, R.animator.scalex);\n    anim.setTarget(mMv);\n    anim.start();\n}\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">7. View的animate方法</span><br><span class=\"line\"></span><br><span class=\"line\">animate方法是属性动画的一种简写方式</span><br></pre></td></tr></table></figure>\n<pre><code>view.animate()\n    .alpha(0)\n    .y(300)\n    .setDuration(300)\n    .withStartAction(new Runnable(){\n        @Override\n        public void run(){\n\n        }\n    })\n    .withEndAction(new Runnable(){\n        @Override\n        public void run(){\n\n        }\n    }).start();\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 布局动画</span><br><span class=\"line\"></span><br><span class=\"line\">布局动画是指在ViewGroup上，给ViewGroup添加view时添加一个动画过度效果。</span><br><span class=\"line\"></span><br><span class=\"line\">最简单的布局动画，只需要添加</span><br></pre></td></tr></table></figure>\n<pre><code>android:animateLayoutChanges=&quot;true&quot;\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">另外，还可以通过使用LayoutAnimationController类来自定义一个子View的过度效果。</span><br></pre></td></tr></table></figure>\n<pre><code>LinearLayout ll = (LinearLayout)findViewById(R.id.ll);\n//设置过渡动画\nScaleAnimation sa = new ScaleAnimation(0, 1, 0, 1);\nsa.setDuration(2000);\n//设置布局动画的显示属性\nLayoutAnimationController lac = new LayoutAnimationController(sa, 0.5F);\nlac.setOrder(LayoutAnimationController.ORDER_NORMAL);\n//为viewgroup设置布局动画\nll.setLayoutAnimation(lac);\n</code></pre><p><code>`</code></p>\n<p>上述代码可以使得子view出现时有一个缩放的效果。</p>\n<h2 id=\"插值器\"><a href=\"#插值器\" class=\"headerlink\" title=\"插值器\"></a>插值器</h2><p>插值器用于定义动画变化速率。</p>\n<h2 id=\"自定义动画\"><a href=\"#自定义动画\" class=\"headerlink\" title=\"自定义动画\"></a>自定义动画</h2><p>自定义动画是继承一个Animation然后自己写，自定义动画可以获得当前矩阵对象，然后对矩阵进行操作变化，可以实现任何效果的动画。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Android-View动画框架\"><a href=\"#Android-View动画框架\" class=\"headerlink\" title=\"Android View动画框架\"></a>Android View动画框架</h1><p>Animation框架定义了透明度、旋转、缩放和位移几种常见的动画，控制的是整个view，原理是每次绘制视图时view所在的viewgroup中的drawchild函数获取该view的animation的transformation值，然后调用canvas.concat(transformToApply.getMatrix())，通过矩阵换算完成动画帧，如果动画没有完成，就继续调用invalidate()函数，启动下次绘制来驱动动画，从而完成整个动画的绘制。</p>\n<h2 id=\"视图动画\"><a href=\"#视图动画\" class=\"headerlink\" title=\"视图动画\"></a>视图动画</h2><p>视图动画使用简单，效果丰富，提供了四种方式，并提供了animationset动画集合，混合使用多种动画。</p>\n<ol>\n<li>透明度动画</li>\n</ol>\n<p>为视图增加透明度的变换动画。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\tAlphaAnimation aa = new AlphaAnimation(0, 1);</span><br><span class=\"line\">\taa.setDuration(1000);</span><br><span class=\"line\">\tview.startAnimation(aa);</span><br><span class=\"line\">```\t</span><br><span class=\"line\"></span><br><span class=\"line\">2. 旋转动画</span><br><span class=\"line\"></span><br><span class=\"line\">为视图增加旋转的变换动画。</span><br></pre></td></tr></table></figure>\n<pre><code>RotateAnimation ra = new RotateAnimation(0, 360, 100, 100);\nra.setDuration(1000);\nview.startAnimation(ra);\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">也可以以自身为旋转中心</span><br></pre></td></tr></table></figure>\n<pre><code>RotateAnimation ra = new RotateAnimation(0, 360,\n    RotateAnimation.RELATIVE_TO_SELF, 0.5F,\n    RotateAnimation.RELATIVE_TO_SELF, 0.5F);\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. 位移动画</span><br><span class=\"line\"></span><br><span class=\"line\">为视图移动时增加位移动画</span><br></pre></td></tr></table></figure>\n<pre><code>TranslationAnimation ta = new TranslationAnimation(0, 200, 0, 300);\nta.setDuration(1000);\nview.startAnimation(ta);\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">4. 缩放动画</span><br><span class=\"line\"></span><br><span class=\"line\">为视图的缩放增加动画效果</span><br></pre></td></tr></table></figure>\n<pre><code>ScaleAnimation sa = new ScaleAnimation(0, 2, 0, 2);\nsa.setDuration(1000);\nview.startAnimation(sa);\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">也可以以自身为缩放中心</span><br></pre></td></tr></table></figure>\n<pre><code>ScaleAnimation sa = new ScaleAnimation(0, 1, 0, 1,\n    Animation.RELATIVE_TO_SELF, 0.5F,\n    Animation.RELATIVE_TO_SELF, 0.5F);\nsa.setDuration(1000);\nview.startAnimation(sa);\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">5. 动画合集</span><br><span class=\"line\"></span><br><span class=\"line\">使用AnimationSet,可以将动画以组合的形式展现出来。</span><br></pre></td></tr></table></figure>\n<pre><code>AnimationSet as = new AnimationSet(true);\nas.setDuration(1000);\n\nAlphaAnimation aa = new AlphaAnimation(0, 1);\naa.setDuration(1000);\nas.addAnimation(aa);\n\nTranslateAnimation ta = new TranslateAnimation(0, 100, 0, 200);\nta.setDuration(1000);\nas.addAnimation(ta);\n\nview.startAnimation(as);\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 属性动画</span><br><span class=\"line\"></span><br><span class=\"line\">由于视图动画改变的只是view的显示，而并不是view的属性，会导致一些问题。</span><br><span class=\"line\"></span><br><span class=\"line\">1. \tObjectAnimator</span><br><span class=\"line\"></span><br><span class=\"line\">ObjectAnimator是属性动画框架中最重要的实体类，创建一个ObjectAnimator只需要通过他的静态工厂类直接返回一个ObjectAnimator对象。参数包括一个对象和对象的属性名字，但这个属性必须有get和set函数，内部会通过java反射机制来调用set函数修改对象属性值。</span><br></pre></td></tr></table></figure>\n<pre><code>ObjectAnimator animator = ObjectAnimator.ofFloat(\n    view, &quot;translationX&quot;, 300);\nanimator.setDuration(300);\nanimator.start();\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">第一个参数为要操纵的view，第二个参数为要操纵的属性，第三个三处为一个可变数组参数，需要传进该属性变化的一个取值过程。</span><br><span class=\"line\"></span><br><span class=\"line\">如果需要操控一个值，但是该值没有setget方法，可以使用wrapper方法来进行一层包装。</span><br></pre></td></tr></table></figure>\n<pre><code>private static class WrapperView{\n    private View mTarget;\n    public WrapperView(View target){\n        mTarget = target;\n    }\n    public int getWidth(){\n        return mTarget.getLayoutParams().width;\n    }\n    public void setWidth(int width){\n        mTarget.getLayoutParams().width = width;\n        mTarget.requestLayout();\n    }\n}\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<pre><code>ViewWrapper wrapper = new ViewWrapper(mButton);\nObjectAnimator.ofInt(wrapper, &quot;width&quot;, 500).setDuration(5000).start();\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. PropertyValuesHolder</span><br><span class=\"line\"></span><br><span class=\"line\">类似视图动画中的AnimationSet,在属性动画中，如果针对同一个对象的多个属性，要同时作用多种动画，可以使用PropertyValuesHolder来实现。</span><br></pre></td></tr></table></figure>\n<pre><code>PropertyValuesHolder pvh1 = PropertyValuesHolder.ofFloat(&quot;translationX&quot;, 300f);\nPropertyValuesHolder pvh2 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1f, 0, 1f);\nPropertyValuesHolder pvh3 = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1f, 0, 1f);\nObjectAnimator.ofPropertyValuesHolder(view, pvh1, pvh2, pvh3).setDuration(1000).start();\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. ValueAnimator</span><br><span class=\"line\"></span><br><span class=\"line\">ValueAnimator本身不提供任何动画效果，它更像一个数值发生器，用来产生具有一定规律的数字，从而让调用者来控制动画的实现过程。</span><br></pre></td></tr></table></figure>\n<pre><code>ValueAnimator animator = ValueAnimator.ofFloat(0, 100);\nanimator.setTarget(view);\nanimator.setDuration(1000).start();\nanimator.addUpdateListener(new AnimatorUpdateListener(){\n    @Override\n    public void onAnimationUpdate(ValueAnimator animation){\n        Float value = (Float) animation.getAnimatedValue();\n        //TODO use the value\n    }\n})\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">4. 动画事件的监听</span><br><span class=\"line\"></span><br><span class=\"line\">一个完整的动画具有Start, Repeat, End, Cancel四个过程，对动画使用AddListener()即可很方便的监听到这四个事件。</span><br><span class=\"line\"></span><br><span class=\"line\">5. AnimatorSet</span><br><span class=\"line\"></span><br><span class=\"line\">对于一个属性同时作用多个属性动画效果吗可以使用之前的PrpertyValuesHolder实现，而AnimatorSet不仅可以实现效果，还能控制顺序。</span><br></pre></td></tr></table></figure>\n<pre><code>ObjectAnimator animator1 = ObjectAnimator.ofFloat(view, &quot;translationX&quot;, 300f);\nObjectAnimator animator2 = ObjectAnimator.ofFloat(view, &quot;scaleX&quot;, 1f, 0f, 1f);\nObjectAnimator animator3 = ObjectAnimator.ofFloat(view, &quot;scaleY&quot;, 1f, 0f, 1f);\nAnimatorSet set = new AnimatorSet();\nset.setDuration(1000);\nset.playTogether(animator1, animator2, animator3);\nset.start();\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">使用playTogether(), playSequentially(), animSet.play().with(),before(),after()来控制多个动画的协同工作方式。</span><br><span class=\"line\"></span><br><span class=\"line\">6. 在xml中使用属性动画</span><br></pre></td></tr></table></figure>\n<p>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;</p>\n<p><objectanimator xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"1000\" android:propertyname=\"scaleX\" android:valuefrom=\"1.0\" android:valueto=\"2.0\" android:valuetype=\"floatType\"><br></objectanimator><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<pre><code>public void scaleX(View view){\n    Animator anim = AnimatorInflater.loadAnimator(this, R.animator.scalex);\n    anim.setTarget(mMv);\n    anim.start();\n}\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">7. View的animate方法</span><br><span class=\"line\"></span><br><span class=\"line\">animate方法是属性动画的一种简写方式</span><br></pre></td></tr></table></figure>\n<pre><code>view.animate()\n    .alpha(0)\n    .y(300)\n    .setDuration(300)\n    .withStartAction(new Runnable(){\n        @Override\n        public void run(){\n\n        }\n    })\n    .withEndAction(new Runnable(){\n        @Override\n        public void run(){\n\n        }\n    }).start();\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 布局动画</span><br><span class=\"line\"></span><br><span class=\"line\">布局动画是指在ViewGroup上，给ViewGroup添加view时添加一个动画过度效果。</span><br><span class=\"line\"></span><br><span class=\"line\">最简单的布局动画，只需要添加</span><br></pre></td></tr></table></figure>\n<pre><code>android:animateLayoutChanges=&quot;true&quot;\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">另外，还可以通过使用LayoutAnimationController类来自定义一个子View的过度效果。</span><br></pre></td></tr></table></figure>\n<pre><code>LinearLayout ll = (LinearLayout)findViewById(R.id.ll);\n//设置过渡动画\nScaleAnimation sa = new ScaleAnimation(0, 1, 0, 1);\nsa.setDuration(2000);\n//设置布局动画的显示属性\nLayoutAnimationController lac = new LayoutAnimationController(sa, 0.5F);\nlac.setOrder(LayoutAnimationController.ORDER_NORMAL);\n//为viewgroup设置布局动画\nll.setLayoutAnimation(lac);\n</code></pre><p><code>`</code></p>\n<p>上述代码可以使得子view出现时有一个缩放的效果。</p>\n<h2 id=\"插值器\"><a href=\"#插值器\" class=\"headerlink\" title=\"插值器\"></a>插值器</h2><p>插值器用于定义动画变化速率。</p>\n<h2 id=\"自定义动画\"><a href=\"#自定义动画\" class=\"headerlink\" title=\"自定义动画\"></a>自定义动画</h2><p>自定义动画是继承一个Animation然后自己写，自定义动画可以获得当前矩阵对象，然后对矩阵进行操作变化，可以实现任何效果的动画。</p>\n"},{"title":"简单选择排序","date":"2018-01-09T15:02:00.000Z","_content":"简单选择排序属于内部排序中的选择排序的一种。\n\n# 算法思想\n\n在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。\n\n# 空间复杂度\n\n最优的情况下（已正序）复杂度为O(0)，最差情况下（全部元素都需要排序），空间复杂度为O(n)\n\n# 时间复杂度\n\n最优，最差和平均都是O(n^2)\n\n# 算法实现思想\n\n从牌堆里找出最大的的一张牌，插在左手边。\n\n## java实现\n\n```\npublic int[] selectSort(int[] array){\n\tif (array.length <= 1){\n\t\treturn array;\n\t}\n\tfor(int i = 0; i < array.length - 1; i++){\n\t\tint temp = 0;\n\t\tint index = i;\n\t\tfor (int j = i + 1; j < array.length; j++){\n\t\t\tif (array[index] > array[j]){\n\t\t\t\tindex = j;\n\t\t\t}\n\t\t}\n\t\ttemp = array[index];\n\t\tarray[index] = array[i];\n\t\tarray[i] = temp;\n\t}\n\treturn array;\n}\n```\n\n## c实现\n\n```\nvoid selectSort(int array[], int length){\n\tint i, j, temp;\n\tif(1 >= length)\n\t\treturn;\n\tfor(i = 0; i < length; i ++){\n\t\ttemp = i;\n\t\tfor(j = i; j < length; j++){\n\t\t\tif(array[temp] < array[j])\n\t\t\t\ttemp = j;\n\t\t}\n\t\tif(i != temp){\n\t\t\tj = array[temp];\n\t\t\tarray[temp] = array[i];\n\t\t\tarray[i] = j;\n\t\t}\n\t}\n}\n```\n\n## python实现\n\n```\ndef selectSort(self, A):\n        for i in range(len(A) - 1):\n            min_ind = i\n            for j in range(i + 1,len(A)):\n                if A[min_ind] > A[j]:\n                    min_ind = j\n            if min_ind != i:\n                self.swap(A, min_ind, i)\n```\n","source":"_posts/简单选择排序.md","raw":"---\ntitle: 简单选择排序\ndate: 2018-01-09 23:02:00\ntags: 算法\n---\n简单选择排序属于内部排序中的选择排序的一种。\n\n# 算法思想\n\n在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。\n\n# 空间复杂度\n\n最优的情况下（已正序）复杂度为O(0)，最差情况下（全部元素都需要排序），空间复杂度为O(n)\n\n# 时间复杂度\n\n最优，最差和平均都是O(n^2)\n\n# 算法实现思想\n\n从牌堆里找出最大的的一张牌，插在左手边。\n\n## java实现\n\n```\npublic int[] selectSort(int[] array){\n\tif (array.length <= 1){\n\t\treturn array;\n\t}\n\tfor(int i = 0; i < array.length - 1; i++){\n\t\tint temp = 0;\n\t\tint index = i;\n\t\tfor (int j = i + 1; j < array.length; j++){\n\t\t\tif (array[index] > array[j]){\n\t\t\t\tindex = j;\n\t\t\t}\n\t\t}\n\t\ttemp = array[index];\n\t\tarray[index] = array[i];\n\t\tarray[i] = temp;\n\t}\n\treturn array;\n}\n```\n\n## c实现\n\n```\nvoid selectSort(int array[], int length){\n\tint i, j, temp;\n\tif(1 >= length)\n\t\treturn;\n\tfor(i = 0; i < length; i ++){\n\t\ttemp = i;\n\t\tfor(j = i; j < length; j++){\n\t\t\tif(array[temp] < array[j])\n\t\t\t\ttemp = j;\n\t\t}\n\t\tif(i != temp){\n\t\t\tj = array[temp];\n\t\t\tarray[temp] = array[i];\n\t\t\tarray[i] = j;\n\t\t}\n\t}\n}\n```\n\n## python实现\n\n```\ndef selectSort(self, A):\n        for i in range(len(A) - 1):\n            min_ind = i\n            for j in range(i + 1,len(A)):\n                if A[min_ind] > A[j]:\n                    min_ind = j\n            if min_ind != i:\n                self.swap(A, min_ind, i)\n```\n","slug":"简单选择排序","published":1,"updated":"2019-03-12T09:26:33.169Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttza005h3a8kluzyf53t","content":"<p>简单选择排序属于内部排序中的选择排序的一种。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>最优的情况下（已正序）复杂度为O(0)，最差情况下（全部元素都需要排序），空间复杂度为O(n)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>最优，最差和平均都是O(n^2)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>从牌堆里找出最大的的一张牌，插在左手边。</p>\n<h2 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int[] selectSort(int[] array)&#123;</span><br><span class=\"line\">\tif (array.length &lt;= 1)&#123;</span><br><span class=\"line\">\t\treturn array;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor(int i = 0; i &lt; array.length - 1; i++)&#123;</span><br><span class=\"line\">\t\tint temp = 0;</span><br><span class=\"line\">\t\tint index = i;</span><br><span class=\"line\">\t\tfor (int j = i + 1; j &lt; array.length; j++)&#123;</span><br><span class=\"line\">\t\t\tif (array[index] &gt; array[j])&#123;</span><br><span class=\"line\">\t\t\t\tindex = j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttemp = array[index];</span><br><span class=\"line\">\t\tarray[index] = array[i];</span><br><span class=\"line\">\t\tarray[i] = temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void selectSort(int array[], int length)&#123;</span><br><span class=\"line\">\tint i, j, temp;</span><br><span class=\"line\">\tif(1 &gt;= length)</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\tfor(i = 0; i &lt; length; i ++)&#123;</span><br><span class=\"line\">\t\ttemp = i;</span><br><span class=\"line\">\t\tfor(j = i; j &lt; length; j++)&#123;</span><br><span class=\"line\">\t\t\tif(array[temp] &lt; array[j])</span><br><span class=\"line\">\t\t\t\ttemp = j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(i != temp)&#123;</span><br><span class=\"line\">\t\t\tj = array[temp];</span><br><span class=\"line\">\t\t\tarray[temp] = array[i];</span><br><span class=\"line\">\t\t\tarray[i] = j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def selectSort(self, A):</span><br><span class=\"line\">        for i in range(len(A) - 1):</span><br><span class=\"line\">            min_ind = i</span><br><span class=\"line\">            for j in range(i + 1,len(A)):</span><br><span class=\"line\">                if A[min_ind] &gt; A[j]:</span><br><span class=\"line\">                    min_ind = j</span><br><span class=\"line\">            if min_ind != i:</span><br><span class=\"line\">                self.swap(A, min_ind, i)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>简单选择排序属于内部排序中的选择排序的一种。</p>\n<h1 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h1><p>在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。</p>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>最优的情况下（已正序）复杂度为O(0)，最差情况下（全部元素都需要排序），空间复杂度为O(n)</p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>最优，最差和平均都是O(n^2)</p>\n<h1 id=\"算法实现思想\"><a href=\"#算法实现思想\" class=\"headerlink\" title=\"算法实现思想\"></a>算法实现思想</h1><p>从牌堆里找出最大的的一张牌，插在左手边。</p>\n<h2 id=\"java实现\"><a href=\"#java实现\" class=\"headerlink\" title=\"java实现\"></a>java实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int[] selectSort(int[] array)&#123;</span><br><span class=\"line\">\tif (array.length &lt;= 1)&#123;</span><br><span class=\"line\">\t\treturn array;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor(int i = 0; i &lt; array.length - 1; i++)&#123;</span><br><span class=\"line\">\t\tint temp = 0;</span><br><span class=\"line\">\t\tint index = i;</span><br><span class=\"line\">\t\tfor (int j = i + 1; j &lt; array.length; j++)&#123;</span><br><span class=\"line\">\t\t\tif (array[index] &gt; array[j])&#123;</span><br><span class=\"line\">\t\t\t\tindex = j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttemp = array[index];</span><br><span class=\"line\">\t\tarray[index] = array[i];</span><br><span class=\"line\">\t\tarray[i] = temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"c实现\"><a href=\"#c实现\" class=\"headerlink\" title=\"c实现\"></a>c实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void selectSort(int array[], int length)&#123;</span><br><span class=\"line\">\tint i, j, temp;</span><br><span class=\"line\">\tif(1 &gt;= length)</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\tfor(i = 0; i &lt; length; i ++)&#123;</span><br><span class=\"line\">\t\ttemp = i;</span><br><span class=\"line\">\t\tfor(j = i; j &lt; length; j++)&#123;</span><br><span class=\"line\">\t\t\tif(array[temp] &lt; array[j])</span><br><span class=\"line\">\t\t\t\ttemp = j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(i != temp)&#123;</span><br><span class=\"line\">\t\t\tj = array[temp];</span><br><span class=\"line\">\t\t\tarray[temp] = array[i];</span><br><span class=\"line\">\t\t\tarray[i] = j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"python实现\"><a href=\"#python实现\" class=\"headerlink\" title=\"python实现\"></a>python实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def selectSort(self, A):</span><br><span class=\"line\">        for i in range(len(A) - 1):</span><br><span class=\"line\">            min_ind = i</span><br><span class=\"line\">            for j in range(i + 1,len(A)):</span><br><span class=\"line\">                if A[min_ind] &gt; A[j]:</span><br><span class=\"line\">                    min_ind = j</span><br><span class=\"line\">            if min_ind != i:</span><br><span class=\"line\">                self.swap(A, min_ind, i)</span><br></pre></td></tr></table></figure>\n"},{"title":"记一次“代码过期”错误","date":"2018-04-12T15:42:00.000Z","_content":"\n最近太忙了，每天加班到十一点，都来不及写博客了。\n\n昨天晚上9点，我完成了一个feature，结果编译结束发现apk的hosttab点击事件无效了。\n\n懵逼，因为4点还是好的。\n\n于是回退代码，回退到4点，发现编译好了还是这个问题。懵逼。\n\n然后继续回退，回退到上次释放正确版本的地方，发现还是有这个问题，继续懵逼。\n\n继续回退，回退到上个人离职的时候，发现还是有这个问题。超级懵逼。\n\n也就是原本有用的代码，突然没用了。\n\n排查，发现tabhost的点击事件没传下去，继续排查，发现tabhost各个子tab的点击事件没接收到，然后写父类的ontouch事件，发现父类并没有拦截，而是返回给在上面的父类了。而各个父类都没有拦截。\n\n什么情况？\n\n然后不知道怎么回事了，彻底懵逼了。\n\n然后技术总监和我讲这种情况就应该对比二进制文件。\n\n于是反编译上个版本释放的apk，对比相同代码生成的apk，发现真有问题，butterknife生成代码的时候覆盖了之前的按钮。蛋疼\n\n原因是因为butterknife版本是snapshot，而有个人提交了一个错误的代码到butterknife中，导致我错误了。难受。\n","source":"_posts/记一次“代码过期”错误.md","raw":"---\ntitle: 记一次“代码过期”错误\ndate: 2018-04-12 23:42:00\ntags: 工作小结\n---\n\n最近太忙了，每天加班到十一点，都来不及写博客了。\n\n昨天晚上9点，我完成了一个feature，结果编译结束发现apk的hosttab点击事件无效了。\n\n懵逼，因为4点还是好的。\n\n于是回退代码，回退到4点，发现编译好了还是这个问题。懵逼。\n\n然后继续回退，回退到上次释放正确版本的地方，发现还是有这个问题，继续懵逼。\n\n继续回退，回退到上个人离职的时候，发现还是有这个问题。超级懵逼。\n\n也就是原本有用的代码，突然没用了。\n\n排查，发现tabhost的点击事件没传下去，继续排查，发现tabhost各个子tab的点击事件没接收到，然后写父类的ontouch事件，发现父类并没有拦截，而是返回给在上面的父类了。而各个父类都没有拦截。\n\n什么情况？\n\n然后不知道怎么回事了，彻底懵逼了。\n\n然后技术总监和我讲这种情况就应该对比二进制文件。\n\n于是反编译上个版本释放的apk，对比相同代码生成的apk，发现真有问题，butterknife生成代码的时候覆盖了之前的按钮。蛋疼\n\n原因是因为butterknife版本是snapshot，而有个人提交了一个错误的代码到butterknife中，导致我错误了。难受。\n","slug":"记一次“代码过期”错误","published":1,"updated":"2019-03-12T09:26:33.169Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttzc005j3a8kn8ye5b76","content":"<p>最近太忙了，每天加班到十一点，都来不及写博客了。</p>\n<p>昨天晚上9点，我完成了一个feature，结果编译结束发现apk的hosttab点击事件无效了。</p>\n<p>懵逼，因为4点还是好的。</p>\n<p>于是回退代码，回退到4点，发现编译好了还是这个问题。懵逼。</p>\n<p>然后继续回退，回退到上次释放正确版本的地方，发现还是有这个问题，继续懵逼。</p>\n<p>继续回退，回退到上个人离职的时候，发现还是有这个问题。超级懵逼。</p>\n<p>也就是原本有用的代码，突然没用了。</p>\n<p>排查，发现tabhost的点击事件没传下去，继续排查，发现tabhost各个子tab的点击事件没接收到，然后写父类的ontouch事件，发现父类并没有拦截，而是返回给在上面的父类了。而各个父类都没有拦截。</p>\n<p>什么情况？</p>\n<p>然后不知道怎么回事了，彻底懵逼了。</p>\n<p>然后技术总监和我讲这种情况就应该对比二进制文件。</p>\n<p>于是反编译上个版本释放的apk，对比相同代码生成的apk，发现真有问题，butterknife生成代码的时候覆盖了之前的按钮。蛋疼</p>\n<p>原因是因为butterknife版本是snapshot，而有个人提交了一个错误的代码到butterknife中，导致我错误了。难受。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近太忙了，每天加班到十一点，都来不及写博客了。</p>\n<p>昨天晚上9点，我完成了一个feature，结果编译结束发现apk的hosttab点击事件无效了。</p>\n<p>懵逼，因为4点还是好的。</p>\n<p>于是回退代码，回退到4点，发现编译好了还是这个问题。懵逼。</p>\n<p>然后继续回退，回退到上次释放正确版本的地方，发现还是有这个问题，继续懵逼。</p>\n<p>继续回退，回退到上个人离职的时候，发现还是有这个问题。超级懵逼。</p>\n<p>也就是原本有用的代码，突然没用了。</p>\n<p>排查，发现tabhost的点击事件没传下去，继续排查，发现tabhost各个子tab的点击事件没接收到，然后写父类的ontouch事件，发现父类并没有拦截，而是返回给在上面的父类了。而各个父类都没有拦截。</p>\n<p>什么情况？</p>\n<p>然后不知道怎么回事了，彻底懵逼了。</p>\n<p>然后技术总监和我讲这种情况就应该对比二进制文件。</p>\n<p>于是反编译上个版本释放的apk，对比相同代码生成的apk，发现真有问题，butterknife生成代码的时候覆盖了之前的按钮。蛋疼</p>\n<p>原因是因为butterknife版本是snapshot，而有个人提交了一个错误的代码到butterknife中，导致我错误了。难受。</p>\n"},{"title":"设计模式以及Android举例","date":"2019-02-14T16:13:47.000Z","_content":"\n# 设计模式原则\n\n1. 开闭原则\n\n对拓展开放，对修改关闭。\n\n2. 里氏替换原则\n\n只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正的被复用，而衍生类也能在基类的基础上增加新的行为。\n\n3. 依赖倒转原则\n\n对接口编程，依赖于抽象而不依赖于具体。\n\n4. 接口隔离原则\n\n使用多个隔离的接口来降低耦合度\n\n5. 迪米特法则\n\n一个实体应该尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立\n\n6. 合成复用原则\n\n尽量使用合成/聚合的方式，而不是使用继承，继承实际上破坏了类的封装性，超类的方法可能被子类修改\n\n# 三大类\n\n基于6个设计原则，衍生为3大类23种设计模式\n\n## 创造型模式\n\n- 工厂方法模式\n\n- 抽象工厂模式\n\n- 单例模式\n\n- 建造者模式\n\n- 原型模式\n\n## 结构型模式\n\n- 适配器模式\n\n- 装饰器模式\n\n- 代理模式\n\n- 外观模式\n\n- 桥接模式\n\n- 组合模式\n\n- 享元模式\n\n## 行为型模式\n\n- 策略模式\n\n- 模版方法模式\n\n- 观察者模式\n\n- 迭代子模式\n\n- 责任链模式\n\n- 命令模式\n\n- 备忘录模式\n\n- 状态模式\n\n- 访问者模式\n\n- 中介者模式\n\n- 解释器模式\n\n# 详解\n\n## 工厂模式\n\n通过new创建一个对象，大部分时候需要传入构造参数，或者生成对象之前需要先生成一些辅助功能的对象。\n这样可以抽象的认为一个对象的构建如同机器中的齿轮转动，最后通过生成了很多对象之后，生成了一个最终的对象。\n\n### 解决的问题\n\n不关心对象实例构造的细节和复杂过程，而轻松的创建实例\n\n### 抽象工厂模式\n\n实例构建过程\n```\n//声明抽象接口类\ninterface food{}\n\n//需要的实体类需要继承该接口\nclass A implements food{}\nclass B implements food{}\n```\n\n工厂过程\n```\ninterface produce{ food get();}\n\nclass FactoryForA implements produce{\n    @Override\n    public food get() {\n        return new A();\n    }\n}\nclass FactoryForB implements produce{\n    @Override\n    public food get() {\n        return new B();\n    }\n}\n```\n\n抽象工厂过程\n```\npublic class AbstractFactory {\n    public void ClientCode(String name){\n        if(name.equals(\"A\")){\n            food x= new FactoryForA().get();\n            x = new FactoryForB().get();\n        }\n    }\n}\n```\n\n工厂模式的精髓在于**工厂模式**，就是把类型的定义过程和实例化过程分开\n\n首先是定义过程，定义了一个产品如何创建，然后创建了一个创建这个产品的工厂，这一步是简单工厂，在之后创建了一个创建工厂的工厂，这个就是抽象工厂。\n因为产品之间的构造可能有依赖，这个依赖需要通过简单工厂的协作来解决，因此需要一个抽象工厂来协助处理工厂之间的关系。\n\n### 工厂模式进一步的优化\n\n```\npublic class ConcreateFactory extends Factory{\n    @Override\n    public<T extends Product> T createProduct(Class<T> clz){\n        Product p = null;\n        try{\n            p = (Product) class.forName(clz.getName()).newInstance();\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n        return (T)p;\n    }\n}\n```\n这样的话只需要传入名字即可实例，对比new出来的，不需要代码的变化。\n\n### 工厂模式在Android中的使用例子\n\n\n#### collection\n\nCollection接口继承自Iterable接口\n\n```\npublic interface Iterable<T>{\n    Iterator<T> iterator();\n}\n```\n\n该接口的作用就是返回一个迭代器，这个iterator方法就相当于一个工厂方法，专门为new对象而生。\n\n#### Activity.onCreate()\n\nActivityThread作为一个app的入口，自zygote孵化一个新的进程之后就会被调用。\n\nActivityThread会准备\n在looplooper和消息队列，然后调用attach方法绑定到ActivityManagerService中，\n之后就会不断的读取消息队列中的消息并分发消息。\nlooper准备之前，会调用attach，会将AMS与当前的athread绑定，AMS会调用attachApplication方法，\nattachapplication中主要是做了bindApplication和attachApplicationlocked，会通过mStackSupervisor进行\nrealStartActivityLocked方法，该方法首先会准备启动activity的参数信息，准备完毕后会调用ApplicationThread\n的scheduleLaunchActivity方法启动activity。\n启动的过程是构造一个ActivityClientRecord对象，并将相关参数设置，最后通过sendMessage方法发送一个启动消息到消息队列，\n由ActivityThread的handler处理启动。这也就是looper启动的时候做的事情。\n\n在looper调用该消息的时候，会针对flag做各种处理。比如说启动activity的flag为LAUNCH_ACTIVITY，处理的过程在activitythread中\n复写的handler对象，其接受到了msg之后会触发performLaunchActivity方法，该方法为具体的启动Activity逻辑\n\n从mInstrumentation.callActivityOnCreate()之中就可以看到其调用了activity的oncreate，\n做了activity.performCreate()的操作\n\n```\nfinal void performCreate(Bundle icicle, PersistableBundle persistentState) {\n        mCanEnterPictureInPicture = true;\n        restoreHasCurrentPermissionRequest(icicle);\n        if (persistentState != null) {\n            onCreate(icicle, persistentState);\n        } else {\n            onCreate(icicle);\n        }\n        mActivityTransitionState.readState(icicle);\n\n        mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(\n                com.android.internal.R.styleable.Window_windowNoDisplay, false);\n        mFragments.dispatchActivityCreated();\n        mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());\n    }\n```\n\nactivity的performCreate事实上就是执行了oncreate操作。\n\n说上面这么一大段是什么意思呢?oncreate里面只是通过了setContentView便可以创建出不同的View，可以说是工厂模式的一种\n\n### 总结\n\n#### 优点\n\n- 降低了对象之间的耦合度，代码结构清晰，对调用者隐藏了产品的生产过程，生产过程改变后，调用者不用做什么改变，易于修改。\n- 易于拓展，要增加工厂和产品都非常方便，直接实现接口，不用修改之前的代码。\n\n#### 缺点\n\n- 系统结构复杂化，非常简单的系统不需要这样了。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/设计模式以及Android举例.md","raw":"---\ntitle: 设计模式以及Android举例\ndate: 2019-02-15 00:13:47\ntags: 设计模式\n---\n\n# 设计模式原则\n\n1. 开闭原则\n\n对拓展开放，对修改关闭。\n\n2. 里氏替换原则\n\n只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正的被复用，而衍生类也能在基类的基础上增加新的行为。\n\n3. 依赖倒转原则\n\n对接口编程，依赖于抽象而不依赖于具体。\n\n4. 接口隔离原则\n\n使用多个隔离的接口来降低耦合度\n\n5. 迪米特法则\n\n一个实体应该尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立\n\n6. 合成复用原则\n\n尽量使用合成/聚合的方式，而不是使用继承，继承实际上破坏了类的封装性，超类的方法可能被子类修改\n\n# 三大类\n\n基于6个设计原则，衍生为3大类23种设计模式\n\n## 创造型模式\n\n- 工厂方法模式\n\n- 抽象工厂模式\n\n- 单例模式\n\n- 建造者模式\n\n- 原型模式\n\n## 结构型模式\n\n- 适配器模式\n\n- 装饰器模式\n\n- 代理模式\n\n- 外观模式\n\n- 桥接模式\n\n- 组合模式\n\n- 享元模式\n\n## 行为型模式\n\n- 策略模式\n\n- 模版方法模式\n\n- 观察者模式\n\n- 迭代子模式\n\n- 责任链模式\n\n- 命令模式\n\n- 备忘录模式\n\n- 状态模式\n\n- 访问者模式\n\n- 中介者模式\n\n- 解释器模式\n\n# 详解\n\n## 工厂模式\n\n通过new创建一个对象，大部分时候需要传入构造参数，或者生成对象之前需要先生成一些辅助功能的对象。\n这样可以抽象的认为一个对象的构建如同机器中的齿轮转动，最后通过生成了很多对象之后，生成了一个最终的对象。\n\n### 解决的问题\n\n不关心对象实例构造的细节和复杂过程，而轻松的创建实例\n\n### 抽象工厂模式\n\n实例构建过程\n```\n//声明抽象接口类\ninterface food{}\n\n//需要的实体类需要继承该接口\nclass A implements food{}\nclass B implements food{}\n```\n\n工厂过程\n```\ninterface produce{ food get();}\n\nclass FactoryForA implements produce{\n    @Override\n    public food get() {\n        return new A();\n    }\n}\nclass FactoryForB implements produce{\n    @Override\n    public food get() {\n        return new B();\n    }\n}\n```\n\n抽象工厂过程\n```\npublic class AbstractFactory {\n    public void ClientCode(String name){\n        if(name.equals(\"A\")){\n            food x= new FactoryForA().get();\n            x = new FactoryForB().get();\n        }\n    }\n}\n```\n\n工厂模式的精髓在于**工厂模式**，就是把类型的定义过程和实例化过程分开\n\n首先是定义过程，定义了一个产品如何创建，然后创建了一个创建这个产品的工厂，这一步是简单工厂，在之后创建了一个创建工厂的工厂，这个就是抽象工厂。\n因为产品之间的构造可能有依赖，这个依赖需要通过简单工厂的协作来解决，因此需要一个抽象工厂来协助处理工厂之间的关系。\n\n### 工厂模式进一步的优化\n\n```\npublic class ConcreateFactory extends Factory{\n    @Override\n    public<T extends Product> T createProduct(Class<T> clz){\n        Product p = null;\n        try{\n            p = (Product) class.forName(clz.getName()).newInstance();\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n        return (T)p;\n    }\n}\n```\n这样的话只需要传入名字即可实例，对比new出来的，不需要代码的变化。\n\n### 工厂模式在Android中的使用例子\n\n\n#### collection\n\nCollection接口继承自Iterable接口\n\n```\npublic interface Iterable<T>{\n    Iterator<T> iterator();\n}\n```\n\n该接口的作用就是返回一个迭代器，这个iterator方法就相当于一个工厂方法，专门为new对象而生。\n\n#### Activity.onCreate()\n\nActivityThread作为一个app的入口，自zygote孵化一个新的进程之后就会被调用。\n\nActivityThread会准备\n在looplooper和消息队列，然后调用attach方法绑定到ActivityManagerService中，\n之后就会不断的读取消息队列中的消息并分发消息。\nlooper准备之前，会调用attach，会将AMS与当前的athread绑定，AMS会调用attachApplication方法，\nattachapplication中主要是做了bindApplication和attachApplicationlocked，会通过mStackSupervisor进行\nrealStartActivityLocked方法，该方法首先会准备启动activity的参数信息，准备完毕后会调用ApplicationThread\n的scheduleLaunchActivity方法启动activity。\n启动的过程是构造一个ActivityClientRecord对象，并将相关参数设置，最后通过sendMessage方法发送一个启动消息到消息队列，\n由ActivityThread的handler处理启动。这也就是looper启动的时候做的事情。\n\n在looper调用该消息的时候，会针对flag做各种处理。比如说启动activity的flag为LAUNCH_ACTIVITY，处理的过程在activitythread中\n复写的handler对象，其接受到了msg之后会触发performLaunchActivity方法，该方法为具体的启动Activity逻辑\n\n从mInstrumentation.callActivityOnCreate()之中就可以看到其调用了activity的oncreate，\n做了activity.performCreate()的操作\n\n```\nfinal void performCreate(Bundle icicle, PersistableBundle persistentState) {\n        mCanEnterPictureInPicture = true;\n        restoreHasCurrentPermissionRequest(icicle);\n        if (persistentState != null) {\n            onCreate(icicle, persistentState);\n        } else {\n            onCreate(icicle);\n        }\n        mActivityTransitionState.readState(icicle);\n\n        mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(\n                com.android.internal.R.styleable.Window_windowNoDisplay, false);\n        mFragments.dispatchActivityCreated();\n        mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());\n    }\n```\n\nactivity的performCreate事实上就是执行了oncreate操作。\n\n说上面这么一大段是什么意思呢?oncreate里面只是通过了setContentView便可以创建出不同的View，可以说是工厂模式的一种\n\n### 总结\n\n#### 优点\n\n- 降低了对象之间的耦合度，代码结构清晰，对调用者隐藏了产品的生产过程，生产过程改变后，调用者不用做什么改变，易于修改。\n- 易于拓展，要增加工厂和产品都非常方便，直接实现接口，不用修改之前的代码。\n\n#### 缺点\n\n- 系统结构复杂化，非常简单的系统不需要这样了。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"设计模式以及Android举例","published":1,"updated":"2019-03-12T09:26:33.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttzd005l3a8ki178684k","content":"<h1 id=\"设计模式原则\"><a href=\"#设计模式原则\" class=\"headerlink\" title=\"设计模式原则\"></a>设计模式原则</h1><ol>\n<li>开闭原则</li>\n</ol>\n<p>对拓展开放，对修改关闭。</p>\n<ol start=\"2\">\n<li>里氏替换原则</li>\n</ol>\n<p>只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正的被复用，而衍生类也能在基类的基础上增加新的行为。</p>\n<ol start=\"3\">\n<li>依赖倒转原则</li>\n</ol>\n<p>对接口编程，依赖于抽象而不依赖于具体。</p>\n<ol start=\"4\">\n<li>接口隔离原则</li>\n</ol>\n<p>使用多个隔离的接口来降低耦合度</p>\n<ol start=\"5\">\n<li>迪米特法则</li>\n</ol>\n<p>一个实体应该尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立</p>\n<ol start=\"6\">\n<li>合成复用原则</li>\n</ol>\n<p>尽量使用合成/聚合的方式，而不是使用继承，继承实际上破坏了类的封装性，超类的方法可能被子类修改</p>\n<h1 id=\"三大类\"><a href=\"#三大类\" class=\"headerlink\" title=\"三大类\"></a>三大类</h1><p>基于6个设计原则，衍生为3大类23种设计模式</p>\n<h2 id=\"创造型模式\"><a href=\"#创造型模式\" class=\"headerlink\" title=\"创造型模式\"></a>创造型模式</h2><ul>\n<li><p>工厂方法模式</p>\n</li>\n<li><p>抽象工厂模式</p>\n</li>\n<li><p>单例模式</p>\n</li>\n<li><p>建造者模式</p>\n</li>\n<li><p>原型模式</p>\n</li>\n</ul>\n<h2 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h2><ul>\n<li><p>适配器模式</p>\n</li>\n<li><p>装饰器模式</p>\n</li>\n<li><p>代理模式</p>\n</li>\n<li><p>外观模式</p>\n</li>\n<li><p>桥接模式</p>\n</li>\n<li><p>组合模式</p>\n</li>\n<li><p>享元模式</p>\n</li>\n</ul>\n<h2 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a>行为型模式</h2><ul>\n<li><p>策略模式</p>\n</li>\n<li><p>模版方法模式</p>\n</li>\n<li><p>观察者模式</p>\n</li>\n<li><p>迭代子模式</p>\n</li>\n<li><p>责任链模式</p>\n</li>\n<li><p>命令模式</p>\n</li>\n<li><p>备忘录模式</p>\n</li>\n<li><p>状态模式</p>\n</li>\n<li><p>访问者模式</p>\n</li>\n<li><p>中介者模式</p>\n</li>\n<li><p>解释器模式</p>\n</li>\n</ul>\n<h1 id=\"详解\"><a href=\"#详解\" class=\"headerlink\" title=\"详解\"></a>详解</h1><h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><p>通过new创建一个对象，大部分时候需要传入构造参数，或者生成对象之前需要先生成一些辅助功能的对象。<br>这样可以抽象的认为一个对象的构建如同机器中的齿轮转动，最后通过生成了很多对象之后，生成了一个最终的对象。</p>\n<h3 id=\"解决的问题\"><a href=\"#解决的问题\" class=\"headerlink\" title=\"解决的问题\"></a>解决的问题</h3><p>不关心对象实例构造的细节和复杂过程，而轻松的创建实例</p>\n<h3 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h3><p>实例构建过程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//声明抽象接口类</span><br><span class=\"line\">interface food&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//需要的实体类需要继承该接口</span><br><span class=\"line\">class A implements food&#123;&#125;</span><br><span class=\"line\">class B implements food&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>工厂过程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface produce&#123; food get();&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class FactoryForA implements produce&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public food get() &#123;</span><br><span class=\"line\">        return new A();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class FactoryForB implements produce&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public food get() &#123;</span><br><span class=\"line\">        return new B();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>抽象工厂过程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AbstractFactory &#123;</span><br><span class=\"line\">    public void ClientCode(String name)&#123;</span><br><span class=\"line\">        if(name.equals(&quot;A&quot;))&#123;</span><br><span class=\"line\">            food x= new FactoryForA().get();</span><br><span class=\"line\">            x = new FactoryForB().get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>工厂模式的精髓在于<strong>工厂模式</strong>，就是把类型的定义过程和实例化过程分开</p>\n<p>首先是定义过程，定义了一个产品如何创建，然后创建了一个创建这个产品的工厂，这一步是简单工厂，在之后创建了一个创建工厂的工厂，这个就是抽象工厂。<br>因为产品之间的构造可能有依赖，这个依赖需要通过简单工厂的协作来解决，因此需要一个抽象工厂来协助处理工厂之间的关系。</p>\n<h3 id=\"工厂模式进一步的优化\"><a href=\"#工厂模式进一步的优化\" class=\"headerlink\" title=\"工厂模式进一步的优化\"></a>工厂模式进一步的优化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ConcreateFactory extends Factory&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public&lt;T extends Product&gt; T createProduct(Class&lt;T&gt; clz)&#123;</span><br><span class=\"line\">        Product p = null;</span><br><span class=\"line\">        try&#123;</span><br><span class=\"line\">            p = (Product) class.forName(clz.getName()).newInstance();</span><br><span class=\"line\">        &#125;catch(Exception e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return (T)p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样的话只需要传入名字即可实例，对比new出来的，不需要代码的变化。</p>\n<h3 id=\"工厂模式在Android中的使用例子\"><a href=\"#工厂模式在Android中的使用例子\" class=\"headerlink\" title=\"工厂模式在Android中的使用例子\"></a>工厂模式在Android中的使用例子</h3><h4 id=\"collection\"><a href=\"#collection\" class=\"headerlink\" title=\"collection\"></a>collection</h4><p>Collection接口继承自Iterable接口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Iterable&lt;T&gt;&#123;</span><br><span class=\"line\">    Iterator&lt;T&gt; iterator();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该接口的作用就是返回一个迭代器，这个iterator方法就相当于一个工厂方法，专门为new对象而生。</p>\n<h4 id=\"Activity-onCreate\"><a href=\"#Activity-onCreate\" class=\"headerlink\" title=\"Activity.onCreate()\"></a>Activity.onCreate()</h4><p>ActivityThread作为一个app的入口，自zygote孵化一个新的进程之后就会被调用。</p>\n<p>ActivityThread会准备<br>在looplooper和消息队列，然后调用attach方法绑定到ActivityManagerService中，<br>之后就会不断的读取消息队列中的消息并分发消息。<br>looper准备之前，会调用attach，会将AMS与当前的athread绑定，AMS会调用attachApplication方法，<br>attachapplication中主要是做了bindApplication和attachApplicationlocked，会通过mStackSupervisor进行<br>realStartActivityLocked方法，该方法首先会准备启动activity的参数信息，准备完毕后会调用ApplicationThread<br>的scheduleLaunchActivity方法启动activity。<br>启动的过程是构造一个ActivityClientRecord对象，并将相关参数设置，最后通过sendMessage方法发送一个启动消息到消息队列，<br>由ActivityThread的handler处理启动。这也就是looper启动的时候做的事情。</p>\n<p>在looper调用该消息的时候，会针对flag做各种处理。比如说启动activity的flag为LAUNCH_ACTIVITY，处理的过程在activitythread中<br>复写的handler对象，其接受到了msg之后会触发performLaunchActivity方法，该方法为具体的启动Activity逻辑</p>\n<p>从mInstrumentation.callActivityOnCreate()之中就可以看到其调用了activity的oncreate，<br>做了activity.performCreate()的操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123;</span><br><span class=\"line\">        mCanEnterPictureInPicture = true;</span><br><span class=\"line\">        restoreHasCurrentPermissionRequest(icicle);</span><br><span class=\"line\">        if (persistentState != null) &#123;</span><br><span class=\"line\">            onCreate(icicle, persistentState);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            onCreate(icicle);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mActivityTransitionState.readState(icicle);</span><br><span class=\"line\"></span><br><span class=\"line\">        mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(</span><br><span class=\"line\">                com.android.internal.R.styleable.Window_windowNoDisplay, false);</span><br><span class=\"line\">        mFragments.dispatchActivityCreated();</span><br><span class=\"line\">        mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>activity的performCreate事实上就是执行了oncreate操作。</p>\n<p>说上面这么一大段是什么意思呢?oncreate里面只是通过了setContentView便可以创建出不同的View，可以说是工厂模式的一种</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>降低了对象之间的耦合度，代码结构清晰，对调用者隐藏了产品的生产过程，生产过程改变后，调用者不用做什么改变，易于修改。</li>\n<li>易于拓展，要增加工厂和产品都非常方便，直接实现接口，不用修改之前的代码。</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>系统结构复杂化，非常简单的系统不需要这样了。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"设计模式原则\"><a href=\"#设计模式原则\" class=\"headerlink\" title=\"设计模式原则\"></a>设计模式原则</h1><ol>\n<li>开闭原则</li>\n</ol>\n<p>对拓展开放，对修改关闭。</p>\n<ol start=\"2\">\n<li>里氏替换原则</li>\n</ol>\n<p>只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正的被复用，而衍生类也能在基类的基础上增加新的行为。</p>\n<ol start=\"3\">\n<li>依赖倒转原则</li>\n</ol>\n<p>对接口编程，依赖于抽象而不依赖于具体。</p>\n<ol start=\"4\">\n<li>接口隔离原则</li>\n</ol>\n<p>使用多个隔离的接口来降低耦合度</p>\n<ol start=\"5\">\n<li>迪米特法则</li>\n</ol>\n<p>一个实体应该尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立</p>\n<ol start=\"6\">\n<li>合成复用原则</li>\n</ol>\n<p>尽量使用合成/聚合的方式，而不是使用继承，继承实际上破坏了类的封装性，超类的方法可能被子类修改</p>\n<h1 id=\"三大类\"><a href=\"#三大类\" class=\"headerlink\" title=\"三大类\"></a>三大类</h1><p>基于6个设计原则，衍生为3大类23种设计模式</p>\n<h2 id=\"创造型模式\"><a href=\"#创造型模式\" class=\"headerlink\" title=\"创造型模式\"></a>创造型模式</h2><ul>\n<li><p>工厂方法模式</p>\n</li>\n<li><p>抽象工厂模式</p>\n</li>\n<li><p>单例模式</p>\n</li>\n<li><p>建造者模式</p>\n</li>\n<li><p>原型模式</p>\n</li>\n</ul>\n<h2 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h2><ul>\n<li><p>适配器模式</p>\n</li>\n<li><p>装饰器模式</p>\n</li>\n<li><p>代理模式</p>\n</li>\n<li><p>外观模式</p>\n</li>\n<li><p>桥接模式</p>\n</li>\n<li><p>组合模式</p>\n</li>\n<li><p>享元模式</p>\n</li>\n</ul>\n<h2 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a>行为型模式</h2><ul>\n<li><p>策略模式</p>\n</li>\n<li><p>模版方法模式</p>\n</li>\n<li><p>观察者模式</p>\n</li>\n<li><p>迭代子模式</p>\n</li>\n<li><p>责任链模式</p>\n</li>\n<li><p>命令模式</p>\n</li>\n<li><p>备忘录模式</p>\n</li>\n<li><p>状态模式</p>\n</li>\n<li><p>访问者模式</p>\n</li>\n<li><p>中介者模式</p>\n</li>\n<li><p>解释器模式</p>\n</li>\n</ul>\n<h1 id=\"详解\"><a href=\"#详解\" class=\"headerlink\" title=\"详解\"></a>详解</h1><h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><p>通过new创建一个对象，大部分时候需要传入构造参数，或者生成对象之前需要先生成一些辅助功能的对象。<br>这样可以抽象的认为一个对象的构建如同机器中的齿轮转动，最后通过生成了很多对象之后，生成了一个最终的对象。</p>\n<h3 id=\"解决的问题\"><a href=\"#解决的问题\" class=\"headerlink\" title=\"解决的问题\"></a>解决的问题</h3><p>不关心对象实例构造的细节和复杂过程，而轻松的创建实例</p>\n<h3 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h3><p>实例构建过程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//声明抽象接口类</span><br><span class=\"line\">interface food&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//需要的实体类需要继承该接口</span><br><span class=\"line\">class A implements food&#123;&#125;</span><br><span class=\"line\">class B implements food&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>工厂过程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface produce&#123; food get();&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class FactoryForA implements produce&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public food get() &#123;</span><br><span class=\"line\">        return new A();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class FactoryForB implements produce&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public food get() &#123;</span><br><span class=\"line\">        return new B();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>抽象工厂过程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AbstractFactory &#123;</span><br><span class=\"line\">    public void ClientCode(String name)&#123;</span><br><span class=\"line\">        if(name.equals(&quot;A&quot;))&#123;</span><br><span class=\"line\">            food x= new FactoryForA().get();</span><br><span class=\"line\">            x = new FactoryForB().get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>工厂模式的精髓在于<strong>工厂模式</strong>，就是把类型的定义过程和实例化过程分开</p>\n<p>首先是定义过程，定义了一个产品如何创建，然后创建了一个创建这个产品的工厂，这一步是简单工厂，在之后创建了一个创建工厂的工厂，这个就是抽象工厂。<br>因为产品之间的构造可能有依赖，这个依赖需要通过简单工厂的协作来解决，因此需要一个抽象工厂来协助处理工厂之间的关系。</p>\n<h3 id=\"工厂模式进一步的优化\"><a href=\"#工厂模式进一步的优化\" class=\"headerlink\" title=\"工厂模式进一步的优化\"></a>工厂模式进一步的优化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ConcreateFactory extends Factory&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public&lt;T extends Product&gt; T createProduct(Class&lt;T&gt; clz)&#123;</span><br><span class=\"line\">        Product p = null;</span><br><span class=\"line\">        try&#123;</span><br><span class=\"line\">            p = (Product) class.forName(clz.getName()).newInstance();</span><br><span class=\"line\">        &#125;catch(Exception e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return (T)p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样的话只需要传入名字即可实例，对比new出来的，不需要代码的变化。</p>\n<h3 id=\"工厂模式在Android中的使用例子\"><a href=\"#工厂模式在Android中的使用例子\" class=\"headerlink\" title=\"工厂模式在Android中的使用例子\"></a>工厂模式在Android中的使用例子</h3><h4 id=\"collection\"><a href=\"#collection\" class=\"headerlink\" title=\"collection\"></a>collection</h4><p>Collection接口继承自Iterable接口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Iterable&lt;T&gt;&#123;</span><br><span class=\"line\">    Iterator&lt;T&gt; iterator();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该接口的作用就是返回一个迭代器，这个iterator方法就相当于一个工厂方法，专门为new对象而生。</p>\n<h4 id=\"Activity-onCreate\"><a href=\"#Activity-onCreate\" class=\"headerlink\" title=\"Activity.onCreate()\"></a>Activity.onCreate()</h4><p>ActivityThread作为一个app的入口，自zygote孵化一个新的进程之后就会被调用。</p>\n<p>ActivityThread会准备<br>在looplooper和消息队列，然后调用attach方法绑定到ActivityManagerService中，<br>之后就会不断的读取消息队列中的消息并分发消息。<br>looper准备之前，会调用attach，会将AMS与当前的athread绑定，AMS会调用attachApplication方法，<br>attachapplication中主要是做了bindApplication和attachApplicationlocked，会通过mStackSupervisor进行<br>realStartActivityLocked方法，该方法首先会准备启动activity的参数信息，准备完毕后会调用ApplicationThread<br>的scheduleLaunchActivity方法启动activity。<br>启动的过程是构造一个ActivityClientRecord对象，并将相关参数设置，最后通过sendMessage方法发送一个启动消息到消息队列，<br>由ActivityThread的handler处理启动。这也就是looper启动的时候做的事情。</p>\n<p>在looper调用该消息的时候，会针对flag做各种处理。比如说启动activity的flag为LAUNCH_ACTIVITY，处理的过程在activitythread中<br>复写的handler对象，其接受到了msg之后会触发performLaunchActivity方法，该方法为具体的启动Activity逻辑</p>\n<p>从mInstrumentation.callActivityOnCreate()之中就可以看到其调用了activity的oncreate，<br>做了activity.performCreate()的操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123;</span><br><span class=\"line\">        mCanEnterPictureInPicture = true;</span><br><span class=\"line\">        restoreHasCurrentPermissionRequest(icicle);</span><br><span class=\"line\">        if (persistentState != null) &#123;</span><br><span class=\"line\">            onCreate(icicle, persistentState);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            onCreate(icicle);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mActivityTransitionState.readState(icicle);</span><br><span class=\"line\"></span><br><span class=\"line\">        mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(</span><br><span class=\"line\">                com.android.internal.R.styleable.Window_windowNoDisplay, false);</span><br><span class=\"line\">        mFragments.dispatchActivityCreated();</span><br><span class=\"line\">        mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>activity的performCreate事实上就是执行了oncreate操作。</p>\n<p>说上面这么一大段是什么意思呢?oncreate里面只是通过了setContentView便可以创建出不同的View，可以说是工厂模式的一种</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>降低了对象之间的耦合度，代码结构清晰，对调用者隐藏了产品的生产过程，生产过程改变后，调用者不用做什么改变，易于修改。</li>\n<li>易于拓展，要增加工厂和产品都非常方便，直接实现接口，不用修改之前的代码。</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>系统结构复杂化，非常简单的系统不需要这样了。</li>\n</ul>\n"},{"title":"近期问题回顾 18-02-27","date":"2018-02-27T15:02:25.000Z","_content":"\n这两天面了三家单位，有一些问题暴露的比较明显，也是平时开发过程中没有注意到的问题。\n\n1. 数据结构和算法\n\n虽然安卓也是前端的一部分，但是安卓怎么讲都是基于java的，所以java提供的一些必要的集合包，需要自己有个很详细的理解，这次面试遇到问我Collection与Collections区别的问题，我因为不熟悉，居然没有回答出来。另外问到我为甚么ArrayList的查询速度快于LinkedList,我也没有回答得出来，回来看答案之后发现自己其实是懂一些的，但是并不是全懂，尤其是一些基础的常用的东西，大部分虽然自己都能实现，但是有现成的轮子不用，却自己去造轮子，这是很蠢的行为。\n\n这也给我提了个醒，越是不起眼的东西，其实越能决定一些重要的事情，细节决定成败。\n\n所以针对java部分的数据结构相关的知识，我需要重新看java编程思想这本书。必要的时候自己重写常见的几个数据结构。\n\n人家的确说的没错，有能力造轮子，和造好轮子是两回事，我设计的queue，的确可以用，但是只在单线程的情况下，多线程情况下很明显会出现不同步的问题。当时就没有考虑过这个问题。\n\n2. 网络基础\n\n这次面试还有人问到HTTP1.0和HTTP1.1的差别，事实上我对他们的差别认知只在于api的不同，残酷的是我只知道api不同，却不知道api不同在哪儿。那个人问我知道http1.1可以实现长连接吗？我一脸懵逼，我知道http是可以实现长连接，但是没有想到是http1.1才可以实现，没办法，我只能说我可以用socket实现长连接，然后他就问我socket实现的长连接有哪些问题，我又懵逼了，不就是异常处理吗？虽然那个人好像也不是很懂java，更不懂android，但是他对http相关的知识了解的确是凌驾于我的。\n\n这也暴露了我网络基础的不充足，不论是socket，http，tcpip等等，我都没有一个明确的理解，这部分需要进行一个完全的知识架构的搭建。\n\n3. 流行框架的源码理解\n\n我曾经看别人说过，要理解框架，就需要手动撸一遍。当时看到这句话的时候，我还在传音，那时候别说撸框架了，我连用框架都没办法。后来去崇杏，我的确用了市面上很多的流行框架，然而我却忘了这句话的含义。\n\n直到有人问起了我Butterknife的一些理解。想来真是可笑，明明在群里曾经讨论过，butterknife是用于编译时进行代码补全的框架，但是我却被我之前写过的关于注解的一篇笔记给弄糊涂了，虽然两者实现的功能大致相同，但是明显不是同一回事。我在和面试官窘迫的解释我理解的butterknife的时候，却没有想到我明明是错误的，还这么嚣张。\n\n现在想想真想找个地洞钻进去。\n\n亡羊补牢，这也是之后需要进行的工作侧重点，对常用的代码开发框架，像Butterknife、eventbus、rxjava等等，找时间将它们实现一遍，这样才能深入的理解重点。\n\n大致下来就这三个问题。虽然面试的效果不是很好，但是还是收获到了心仪的offer，希望自己能在新的公司发挥自己的作用，希望自己的水平可以上一个台阶。\n\n天道酬勤。","source":"_posts/近期问题回顾.md","raw":"---\ntitle: 近期问题回顾 18-02-27\ndate: 2018-02-27 23:02:25\ntags: 生活\n---\n\n这两天面了三家单位，有一些问题暴露的比较明显，也是平时开发过程中没有注意到的问题。\n\n1. 数据结构和算法\n\n虽然安卓也是前端的一部分，但是安卓怎么讲都是基于java的，所以java提供的一些必要的集合包，需要自己有个很详细的理解，这次面试遇到问我Collection与Collections区别的问题，我因为不熟悉，居然没有回答出来。另外问到我为甚么ArrayList的查询速度快于LinkedList,我也没有回答得出来，回来看答案之后发现自己其实是懂一些的，但是并不是全懂，尤其是一些基础的常用的东西，大部分虽然自己都能实现，但是有现成的轮子不用，却自己去造轮子，这是很蠢的行为。\n\n这也给我提了个醒，越是不起眼的东西，其实越能决定一些重要的事情，细节决定成败。\n\n所以针对java部分的数据结构相关的知识，我需要重新看java编程思想这本书。必要的时候自己重写常见的几个数据结构。\n\n人家的确说的没错，有能力造轮子，和造好轮子是两回事，我设计的queue，的确可以用，但是只在单线程的情况下，多线程情况下很明显会出现不同步的问题。当时就没有考虑过这个问题。\n\n2. 网络基础\n\n这次面试还有人问到HTTP1.0和HTTP1.1的差别，事实上我对他们的差别认知只在于api的不同，残酷的是我只知道api不同，却不知道api不同在哪儿。那个人问我知道http1.1可以实现长连接吗？我一脸懵逼，我知道http是可以实现长连接，但是没有想到是http1.1才可以实现，没办法，我只能说我可以用socket实现长连接，然后他就问我socket实现的长连接有哪些问题，我又懵逼了，不就是异常处理吗？虽然那个人好像也不是很懂java，更不懂android，但是他对http相关的知识了解的确是凌驾于我的。\n\n这也暴露了我网络基础的不充足，不论是socket，http，tcpip等等，我都没有一个明确的理解，这部分需要进行一个完全的知识架构的搭建。\n\n3. 流行框架的源码理解\n\n我曾经看别人说过，要理解框架，就需要手动撸一遍。当时看到这句话的时候，我还在传音，那时候别说撸框架了，我连用框架都没办法。后来去崇杏，我的确用了市面上很多的流行框架，然而我却忘了这句话的含义。\n\n直到有人问起了我Butterknife的一些理解。想来真是可笑，明明在群里曾经讨论过，butterknife是用于编译时进行代码补全的框架，但是我却被我之前写过的关于注解的一篇笔记给弄糊涂了，虽然两者实现的功能大致相同，但是明显不是同一回事。我在和面试官窘迫的解释我理解的butterknife的时候，却没有想到我明明是错误的，还这么嚣张。\n\n现在想想真想找个地洞钻进去。\n\n亡羊补牢，这也是之后需要进行的工作侧重点，对常用的代码开发框架，像Butterknife、eventbus、rxjava等等，找时间将它们实现一遍，这样才能深入的理解重点。\n\n大致下来就这三个问题。虽然面试的效果不是很好，但是还是收获到了心仪的offer，希望自己能在新的公司发挥自己的作用，希望自己的水平可以上一个台阶。\n\n天道酬勤。","slug":"近期问题回顾","published":1,"updated":"2019-03-12T09:26:33.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttze005n3a8k74wqmfbh","content":"<p>这两天面了三家单位，有一些问题暴露的比较明显，也是平时开发过程中没有注意到的问题。</p>\n<ol>\n<li>数据结构和算法</li>\n</ol>\n<p>虽然安卓也是前端的一部分，但是安卓怎么讲都是基于java的，所以java提供的一些必要的集合包，需要自己有个很详细的理解，这次面试遇到问我Collection与Collections区别的问题，我因为不熟悉，居然没有回答出来。另外问到我为甚么ArrayList的查询速度快于LinkedList,我也没有回答得出来，回来看答案之后发现自己其实是懂一些的，但是并不是全懂，尤其是一些基础的常用的东西，大部分虽然自己都能实现，但是有现成的轮子不用，却自己去造轮子，这是很蠢的行为。</p>\n<p>这也给我提了个醒，越是不起眼的东西，其实越能决定一些重要的事情，细节决定成败。</p>\n<p>所以针对java部分的数据结构相关的知识，我需要重新看java编程思想这本书。必要的时候自己重写常见的几个数据结构。</p>\n<p>人家的确说的没错，有能力造轮子，和造好轮子是两回事，我设计的queue，的确可以用，但是只在单线程的情况下，多线程情况下很明显会出现不同步的问题。当时就没有考虑过这个问题。</p>\n<ol start=\"2\">\n<li>网络基础</li>\n</ol>\n<p>这次面试还有人问到HTTP1.0和HTTP1.1的差别，事实上我对他们的差别认知只在于api的不同，残酷的是我只知道api不同，却不知道api不同在哪儿。那个人问我知道http1.1可以实现长连接吗？我一脸懵逼，我知道http是可以实现长连接，但是没有想到是http1.1才可以实现，没办法，我只能说我可以用socket实现长连接，然后他就问我socket实现的长连接有哪些问题，我又懵逼了，不就是异常处理吗？虽然那个人好像也不是很懂java，更不懂android，但是他对http相关的知识了解的确是凌驾于我的。</p>\n<p>这也暴露了我网络基础的不充足，不论是socket，http，tcpip等等，我都没有一个明确的理解，这部分需要进行一个完全的知识架构的搭建。</p>\n<ol start=\"3\">\n<li>流行框架的源码理解</li>\n</ol>\n<p>我曾经看别人说过，要理解框架，就需要手动撸一遍。当时看到这句话的时候，我还在传音，那时候别说撸框架了，我连用框架都没办法。后来去崇杏，我的确用了市面上很多的流行框架，然而我却忘了这句话的含义。</p>\n<p>直到有人问起了我Butterknife的一些理解。想来真是可笑，明明在群里曾经讨论过，butterknife是用于编译时进行代码补全的框架，但是我却被我之前写过的关于注解的一篇笔记给弄糊涂了，虽然两者实现的功能大致相同，但是明显不是同一回事。我在和面试官窘迫的解释我理解的butterknife的时候，却没有想到我明明是错误的，还这么嚣张。</p>\n<p>现在想想真想找个地洞钻进去。</p>\n<p>亡羊补牢，这也是之后需要进行的工作侧重点，对常用的代码开发框架，像Butterknife、eventbus、rxjava等等，找时间将它们实现一遍，这样才能深入的理解重点。</p>\n<p>大致下来就这三个问题。虽然面试的效果不是很好，但是还是收获到了心仪的offer，希望自己能在新的公司发挥自己的作用，希望自己的水平可以上一个台阶。</p>\n<p>天道酬勤。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这两天面了三家单位，有一些问题暴露的比较明显，也是平时开发过程中没有注意到的问题。</p>\n<ol>\n<li>数据结构和算法</li>\n</ol>\n<p>虽然安卓也是前端的一部分，但是安卓怎么讲都是基于java的，所以java提供的一些必要的集合包，需要自己有个很详细的理解，这次面试遇到问我Collection与Collections区别的问题，我因为不熟悉，居然没有回答出来。另外问到我为甚么ArrayList的查询速度快于LinkedList,我也没有回答得出来，回来看答案之后发现自己其实是懂一些的，但是并不是全懂，尤其是一些基础的常用的东西，大部分虽然自己都能实现，但是有现成的轮子不用，却自己去造轮子，这是很蠢的行为。</p>\n<p>这也给我提了个醒，越是不起眼的东西，其实越能决定一些重要的事情，细节决定成败。</p>\n<p>所以针对java部分的数据结构相关的知识，我需要重新看java编程思想这本书。必要的时候自己重写常见的几个数据结构。</p>\n<p>人家的确说的没错，有能力造轮子，和造好轮子是两回事，我设计的queue，的确可以用，但是只在单线程的情况下，多线程情况下很明显会出现不同步的问题。当时就没有考虑过这个问题。</p>\n<ol start=\"2\">\n<li>网络基础</li>\n</ol>\n<p>这次面试还有人问到HTTP1.0和HTTP1.1的差别，事实上我对他们的差别认知只在于api的不同，残酷的是我只知道api不同，却不知道api不同在哪儿。那个人问我知道http1.1可以实现长连接吗？我一脸懵逼，我知道http是可以实现长连接，但是没有想到是http1.1才可以实现，没办法，我只能说我可以用socket实现长连接，然后他就问我socket实现的长连接有哪些问题，我又懵逼了，不就是异常处理吗？虽然那个人好像也不是很懂java，更不懂android，但是他对http相关的知识了解的确是凌驾于我的。</p>\n<p>这也暴露了我网络基础的不充足，不论是socket，http，tcpip等等，我都没有一个明确的理解，这部分需要进行一个完全的知识架构的搭建。</p>\n<ol start=\"3\">\n<li>流行框架的源码理解</li>\n</ol>\n<p>我曾经看别人说过，要理解框架，就需要手动撸一遍。当时看到这句话的时候，我还在传音，那时候别说撸框架了，我连用框架都没办法。后来去崇杏，我的确用了市面上很多的流行框架，然而我却忘了这句话的含义。</p>\n<p>直到有人问起了我Butterknife的一些理解。想来真是可笑，明明在群里曾经讨论过，butterknife是用于编译时进行代码补全的框架，但是我却被我之前写过的关于注解的一篇笔记给弄糊涂了，虽然两者实现的功能大致相同，但是明显不是同一回事。我在和面试官窘迫的解释我理解的butterknife的时候，却没有想到我明明是错误的，还这么嚣张。</p>\n<p>现在想想真想找个地洞钻进去。</p>\n<p>亡羊补牢，这也是之后需要进行的工作侧重点，对常用的代码开发框架，像Butterknife、eventbus、rxjava等等，找时间将它们实现一遍，这样才能深入的理解重点。</p>\n<p>大致下来就这三个问题。虽然面试的效果不是很好，但是还是收获到了心仪的offer，希望自己能在新的公司发挥自己的作用，希望自己的水平可以上一个台阶。</p>\n<p>天道酬勤。</p>\n"},{"title":"针对activity栈启动模式进行fragment栈的引申","date":"2018-05-03T15:30:29.000Z","_content":"\n“one activity for the whole app, you can use fragments, just don't use the backstack with fragments”\n\n--- jake·warton\n\n安卓开发有其独特的魅力，相对于每个页面不断的切换，事实上前端开发从安卓的角度来看可以有不同的作为。\n\n比如说jake·warton所说的只使用一个activity窗口，外加很多个碎片，来组成一个app。这句话很好理解，可是后面的这半句话是什么意思呢？主要是fragment的后台管理栈比较不容易操控。\n\n所以我们需要了解一下如何操控这个栈。这次就从activity的启动模式来分析。\n\n- standard\n\n默认的启动模式，对fragment来讲，在basefragment中抽取activity的stackedfragments，每次新建一个fragment时，创建一个新的加入到栈顶即可。\n\n- singleTop\n\n在栈顶的话，启动还是会转到自己，而不在栈顶的话就会新建。这个属性对fragment来讲不怎么实用，没怎么遇到过这种情形，如果要用的话，就判断之前的栈顶是否和新传入的相同，相同的话，就仍然返回的自身，不同就创建一个。\n\n- singleTask\n\n在栈内的话，启动一个实例，就会启动栈内的。这个属性比较好用，对fragment来讲，可以用这个来做很多事情，包括回去的时候直接pop起到了cleartop的效果。\n\n开发中还遇到相似的，一次传入三到四个fragment，如果有其中的fragment在栈上方，立即返回他，中断其余判断。这种操作其实就是遍历栈而已，不过能够在fragment多复用的情况下，找到当前回归路径，省了很多其他的事情。\n\n- singleinstance\n\n每次开辟一个新的栈，这个在fragment中没用，因为只有唯一的一个栈在activity中。\n\n\n\n- FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS\n\n对activity来讲，新的Activity不会在最近启动的Activity的列表中保存。对fragment来讲，就是新启动的不入栈，可以考虑设计一个固定大小的栈的时候，只有固定的几个fragment可以用于入栈，其余的都不入。不过这个设计要考虑一下，返回哪些栈。\n\n实际效果可能就是切了很多个页面，最后一个回退，回退到了很久之前的一个页面。使用情景比较局限。\n\n- FLAG_ACTIVITY_FORWARD_RESULT\n\n这个是startactivityforresult的标志位，同样的也可以设计一个startfragmentforresult。事实上也就是在进入这个fragment的时候，basefragment记录一下resultcode的值，然后回退的时候，将这个result值传入到栈顶即可。\n\n- FLAG_ACTIVITY_NO_HISTORY\n\n单纯的不入栈的操作。\n\n- FLAG_ACTIVITY_REORDER_TO_FRONT\n\n该标志位是用于启动时挪动activity栈的，对fragment同样可以设计，不过较为复杂，可以从栈内取出，重新排序之后插入。比较不好的是可能会遗漏状态。\n\n- FLAG_ACTIVITY_NEW_TASK\n\n同 singinstance\n\n- FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET\n\n对activity来讲，是当新进入的activity携带这个标志时，就会清理栈。fragment同样可以设计，若有个携带该标记的进入，也可以清空。虽然我目前仍然是使用老的回到最起初的fragment，不过效果可能没这个设计的好。\n\n\n大致就这些。针对fragment设计一个单独的有特征的栈，我个人觉得是使用fragment代替activity的第一步。\n","source":"_posts/针对activity栈启动模式进行fragment栈的引申.md","raw":"---\ntitle: 针对activity栈启动模式进行fragment栈的引申\ndate: 2018-05-03 23:30:29\ntags: android\n---\n\n“one activity for the whole app, you can use fragments, just don't use the backstack with fragments”\n\n--- jake·warton\n\n安卓开发有其独特的魅力，相对于每个页面不断的切换，事实上前端开发从安卓的角度来看可以有不同的作为。\n\n比如说jake·warton所说的只使用一个activity窗口，外加很多个碎片，来组成一个app。这句话很好理解，可是后面的这半句话是什么意思呢？主要是fragment的后台管理栈比较不容易操控。\n\n所以我们需要了解一下如何操控这个栈。这次就从activity的启动模式来分析。\n\n- standard\n\n默认的启动模式，对fragment来讲，在basefragment中抽取activity的stackedfragments，每次新建一个fragment时，创建一个新的加入到栈顶即可。\n\n- singleTop\n\n在栈顶的话，启动还是会转到自己，而不在栈顶的话就会新建。这个属性对fragment来讲不怎么实用，没怎么遇到过这种情形，如果要用的话，就判断之前的栈顶是否和新传入的相同，相同的话，就仍然返回的自身，不同就创建一个。\n\n- singleTask\n\n在栈内的话，启动一个实例，就会启动栈内的。这个属性比较好用，对fragment来讲，可以用这个来做很多事情，包括回去的时候直接pop起到了cleartop的效果。\n\n开发中还遇到相似的，一次传入三到四个fragment，如果有其中的fragment在栈上方，立即返回他，中断其余判断。这种操作其实就是遍历栈而已，不过能够在fragment多复用的情况下，找到当前回归路径，省了很多其他的事情。\n\n- singleinstance\n\n每次开辟一个新的栈，这个在fragment中没用，因为只有唯一的一个栈在activity中。\n\n\n\n- FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS\n\n对activity来讲，新的Activity不会在最近启动的Activity的列表中保存。对fragment来讲，就是新启动的不入栈，可以考虑设计一个固定大小的栈的时候，只有固定的几个fragment可以用于入栈，其余的都不入。不过这个设计要考虑一下，返回哪些栈。\n\n实际效果可能就是切了很多个页面，最后一个回退，回退到了很久之前的一个页面。使用情景比较局限。\n\n- FLAG_ACTIVITY_FORWARD_RESULT\n\n这个是startactivityforresult的标志位，同样的也可以设计一个startfragmentforresult。事实上也就是在进入这个fragment的时候，basefragment记录一下resultcode的值，然后回退的时候，将这个result值传入到栈顶即可。\n\n- FLAG_ACTIVITY_NO_HISTORY\n\n单纯的不入栈的操作。\n\n- FLAG_ACTIVITY_REORDER_TO_FRONT\n\n该标志位是用于启动时挪动activity栈的，对fragment同样可以设计，不过较为复杂，可以从栈内取出，重新排序之后插入。比较不好的是可能会遗漏状态。\n\n- FLAG_ACTIVITY_NEW_TASK\n\n同 singinstance\n\n- FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET\n\n对activity来讲，是当新进入的activity携带这个标志时，就会清理栈。fragment同样可以设计，若有个携带该标记的进入，也可以清空。虽然我目前仍然是使用老的回到最起初的fragment，不过效果可能没这个设计的好。\n\n\n大致就这些。针对fragment设计一个单独的有特征的栈，我个人觉得是使用fragment代替activity的第一步。\n","slug":"针对activity栈启动模式进行fragment栈的引申","published":1,"updated":"2019-03-12T09:26:33.171Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttzf005q3a8k8f7jmr0c","content":"<p>“one activity for the whole app, you can use fragments, just don’t use the backstack with fragments”</p>\n<p>— jake·warton</p>\n<p>安卓开发有其独特的魅力，相对于每个页面不断的切换，事实上前端开发从安卓的角度来看可以有不同的作为。</p>\n<p>比如说jake·warton所说的只使用一个activity窗口，外加很多个碎片，来组成一个app。这句话很好理解，可是后面的这半句话是什么意思呢？主要是fragment的后台管理栈比较不容易操控。</p>\n<p>所以我们需要了解一下如何操控这个栈。这次就从activity的启动模式来分析。</p>\n<ul>\n<li>standard</li>\n</ul>\n<p>默认的启动模式，对fragment来讲，在basefragment中抽取activity的stackedfragments，每次新建一个fragment时，创建一个新的加入到栈顶即可。</p>\n<ul>\n<li>singleTop</li>\n</ul>\n<p>在栈顶的话，启动还是会转到自己，而不在栈顶的话就会新建。这个属性对fragment来讲不怎么实用，没怎么遇到过这种情形，如果要用的话，就判断之前的栈顶是否和新传入的相同，相同的话，就仍然返回的自身，不同就创建一个。</p>\n<ul>\n<li>singleTask</li>\n</ul>\n<p>在栈内的话，启动一个实例，就会启动栈内的。这个属性比较好用，对fragment来讲，可以用这个来做很多事情，包括回去的时候直接pop起到了cleartop的效果。</p>\n<p>开发中还遇到相似的，一次传入三到四个fragment，如果有其中的fragment在栈上方，立即返回他，中断其余判断。这种操作其实就是遍历栈而已，不过能够在fragment多复用的情况下，找到当前回归路径，省了很多其他的事情。</p>\n<ul>\n<li>singleinstance</li>\n</ul>\n<p>每次开辟一个新的栈，这个在fragment中没用，因为只有唯一的一个栈在activity中。</p>\n<ul>\n<li>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</li>\n</ul>\n<p>对activity来讲，新的Activity不会在最近启动的Activity的列表中保存。对fragment来讲，就是新启动的不入栈，可以考虑设计一个固定大小的栈的时候，只有固定的几个fragment可以用于入栈，其余的都不入。不过这个设计要考虑一下，返回哪些栈。</p>\n<p>实际效果可能就是切了很多个页面，最后一个回退，回退到了很久之前的一个页面。使用情景比较局限。</p>\n<ul>\n<li>FLAG_ACTIVITY_FORWARD_RESULT</li>\n</ul>\n<p>这个是startactivityforresult的标志位，同样的也可以设计一个startfragmentforresult。事实上也就是在进入这个fragment的时候，basefragment记录一下resultcode的值，然后回退的时候，将这个result值传入到栈顶即可。</p>\n<ul>\n<li>FLAG_ACTIVITY_NO_HISTORY</li>\n</ul>\n<p>单纯的不入栈的操作。</p>\n<ul>\n<li>FLAG_ACTIVITY_REORDER_TO_FRONT</li>\n</ul>\n<p>该标志位是用于启动时挪动activity栈的，对fragment同样可以设计，不过较为复杂，可以从栈内取出，重新排序之后插入。比较不好的是可能会遗漏状态。</p>\n<ul>\n<li>FLAG_ACTIVITY_NEW_TASK</li>\n</ul>\n<p>同 singinstance</p>\n<ul>\n<li>FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET</li>\n</ul>\n<p>对activity来讲，是当新进入的activity携带这个标志时，就会清理栈。fragment同样可以设计，若有个携带该标记的进入，也可以清空。虽然我目前仍然是使用老的回到最起初的fragment，不过效果可能没这个设计的好。</p>\n<p>大致就这些。针对fragment设计一个单独的有特征的栈，我个人觉得是使用fragment代替activity的第一步。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>“one activity for the whole app, you can use fragments, just don’t use the backstack with fragments”</p>\n<p>— jake·warton</p>\n<p>安卓开发有其独特的魅力，相对于每个页面不断的切换，事实上前端开发从安卓的角度来看可以有不同的作为。</p>\n<p>比如说jake·warton所说的只使用一个activity窗口，外加很多个碎片，来组成一个app。这句话很好理解，可是后面的这半句话是什么意思呢？主要是fragment的后台管理栈比较不容易操控。</p>\n<p>所以我们需要了解一下如何操控这个栈。这次就从activity的启动模式来分析。</p>\n<ul>\n<li>standard</li>\n</ul>\n<p>默认的启动模式，对fragment来讲，在basefragment中抽取activity的stackedfragments，每次新建一个fragment时，创建一个新的加入到栈顶即可。</p>\n<ul>\n<li>singleTop</li>\n</ul>\n<p>在栈顶的话，启动还是会转到自己，而不在栈顶的话就会新建。这个属性对fragment来讲不怎么实用，没怎么遇到过这种情形，如果要用的话，就判断之前的栈顶是否和新传入的相同，相同的话，就仍然返回的自身，不同就创建一个。</p>\n<ul>\n<li>singleTask</li>\n</ul>\n<p>在栈内的话，启动一个实例，就会启动栈内的。这个属性比较好用，对fragment来讲，可以用这个来做很多事情，包括回去的时候直接pop起到了cleartop的效果。</p>\n<p>开发中还遇到相似的，一次传入三到四个fragment，如果有其中的fragment在栈上方，立即返回他，中断其余判断。这种操作其实就是遍历栈而已，不过能够在fragment多复用的情况下，找到当前回归路径，省了很多其他的事情。</p>\n<ul>\n<li>singleinstance</li>\n</ul>\n<p>每次开辟一个新的栈，这个在fragment中没用，因为只有唯一的一个栈在activity中。</p>\n<ul>\n<li>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</li>\n</ul>\n<p>对activity来讲，新的Activity不会在最近启动的Activity的列表中保存。对fragment来讲，就是新启动的不入栈，可以考虑设计一个固定大小的栈的时候，只有固定的几个fragment可以用于入栈，其余的都不入。不过这个设计要考虑一下，返回哪些栈。</p>\n<p>实际效果可能就是切了很多个页面，最后一个回退，回退到了很久之前的一个页面。使用情景比较局限。</p>\n<ul>\n<li>FLAG_ACTIVITY_FORWARD_RESULT</li>\n</ul>\n<p>这个是startactivityforresult的标志位，同样的也可以设计一个startfragmentforresult。事实上也就是在进入这个fragment的时候，basefragment记录一下resultcode的值，然后回退的时候，将这个result值传入到栈顶即可。</p>\n<ul>\n<li>FLAG_ACTIVITY_NO_HISTORY</li>\n</ul>\n<p>单纯的不入栈的操作。</p>\n<ul>\n<li>FLAG_ACTIVITY_REORDER_TO_FRONT</li>\n</ul>\n<p>该标志位是用于启动时挪动activity栈的，对fragment同样可以设计，不过较为复杂，可以从栈内取出，重新排序之后插入。比较不好的是可能会遗漏状态。</p>\n<ul>\n<li>FLAG_ACTIVITY_NEW_TASK</li>\n</ul>\n<p>同 singinstance</p>\n<ul>\n<li>FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET</li>\n</ul>\n<p>对activity来讲，是当新进入的activity携带这个标志时，就会清理栈。fragment同样可以设计，若有个携带该标记的进入，也可以清空。虽然我目前仍然是使用老的回到最起初的fragment，不过效果可能没这个设计的好。</p>\n<p>大致就这些。针对fragment设计一个单独的有特征的栈，我个人觉得是使用fragment代替activity的第一步。</p>\n"},{"title":"项目卡顿问题优化专题","date":"2018-11-28T03:07:03.000Z","_content":"\n公司做了一波推广，卡顿问题比较明显的显示了出来。华为荣耀系列的卡顿问题尤其明显，很多用户反映在看上新的时候卡顿比较严重，还有用户说在使用时间较长之后，就比较卡顿。\n\n刚好这周把需求做完并且全部提测通过了，因此有三天的时间来做轻度优化。不过这个专题需要常驻，因为app需要优化的地方实在是太多了。\n\n# 商品详情\n\n商品详情页面是所有spu最终展示的地方，这个地方是所有用户必然经过的地方，商品详情页不是所有页面的终点，不是唯一的，所以商品详情页面有很多可以优化的地方。\n\n## 无限跳转优化\n\n商品详情页面作为展示spu的地方，其中却又展示了很多不同的spu，另外相同spu之间也是支持跳转的。\n\n我对比了淘宝和微博，淘宝只支持保留三个spu，但是相同spu是可以跳转的，而微博支持无限跳转，我试了超过10个都可以返回，但是微博不支持在一个人主页里面仍然跳进这个人主页，也就是不支持相同spu的跳转。\n\n和产品讨论了一下，这个地方相同spu仍然支持跳转，但是最多保留5个。\n\n我设计这地方的方案是在application里面持有activity的引用，在activity启动的时候，进行判断，如果是详情页面，就放入数组里面，否则就不管。放进数组里面之后会判断是否数组长度是否超过4个，超过的话就会进行移除的操作，手动执行finish。\n\n另外在destroy的时候，也这样判断，决定是否直接移除。\n\n操作的入口比较好找，直接套用application的registerActivityLifecycleCallbacks即可。\n\n在这个地方有一个问题，关于对activity的持有是否需要使用weakreference。\n\nregisterActivityLifecycleCallbacks的源码在application里面，主要的操作通过collectActivityLifecycleCallbacks来反馈\n\n```\nprivate Object[] collectActivityLifecycleCallbacks() {\n        Object[] callbacks = null;\n        synchronized (mActivityLifecycleCallbacks) {\n            if (mActivityLifecycleCallbacks.size() > 0) {\n                callbacks = mActivityLifecycleCallbacks.toArray();\n            }\n        }\n        return callbacks;\n    }\n```\n这个方法主要是在各activity生命周期开始的时候进行执行\n\n启动的时候如下\n```\n /* package */ void dispatchActivityCreated(Activity activity, Bundle savedInstanceState) {\n        Object[] callbacks = collectActivityLifecycleCallbacks();\n        if (callbacks != null) {\n            for (int i=0; i<callbacks.length; i++) {\n                ((ActivityLifecycleCallbacks)callbacks[i]).onActivityCreated(activity,\n                        savedInstanceState);\n            }\n        }\n    }\n```\n\n关闭的时候如下\n```\n/* package */ void dispatchActivityDestroyed(Activity activity) {\n        Object[] callbacks = collectActivityLifecycleCallbacks();\n        if (callbacks != null) {\n            for (int i=0; i<callbacks.length; i++) {\n                ((ActivityLifecycleCallbacks)callbacks[i]).onActivityDestroyed(activity);\n            }\n        }\n    }\n```\n\n问题就在actvity是在走destroy之前执行该方法，还是走完之后执行的。\n\n```\n protected void onDestroy() {\n        if (DEBUG_LIFECYCLE) Slog.v(TAG, \"onDestroy \" + this);\n        mCalled = true;\n\n        // dismiss any dialogs we are managing.\n        if (mManagedDialogs != null) {\n            final int numDialogs = mManagedDialogs.size();\n            for (int i = 0; i < numDialogs; i++) {\n                final ManagedDialog md = mManagedDialogs.valueAt(i);\n                if (md.mDialog.isShowing()) {\n                    md.mDialog.dismiss();\n                }\n            }\n            mManagedDialogs = null;\n        }\n\n        // close any cursors we are managing.\n        synchronized (mManagedCursors) {\n            int numCursors = mManagedCursors.size();\n            for (int i = 0; i < numCursors; i++) {\n                ManagedCursor c = mManagedCursors.get(i);\n                if (c != null) {\n                    c.mCursor.close();\n                }\n            }\n            mManagedCursors.clear();\n        }\n\n        // Close any open search dialog\n        if (mSearchManager != null) {\n            mSearchManager.stopSearch();\n        }\n\n        if (mActionBar != null) {\n            mActionBar.onDestroy();\n        }\n\n        getApplication().dispatchActivityDestroyed(this);\n    }\n```\n因此就证明了，destroy是在分发之前执行的，此时使用弱引用其实并不碍事，即使destroy的时候发生了gc，也没有太大的问题，只要之后的过程中将被回收的值对应的key清除即可。\n\nweakreference在这边如果使用的话，需要考虑到contain的写法，需要判断的比较多，经过尝试，其实效率和直接强引用差不多。\n\n## 详情页面泄露问题\n\n## 详情页面启动速度慢的问题\n\n详情页面启动速度慢的问题其实并不在详情页。经过排查，发现在有很多medel页面正在加载的地方，会出现启动速度过慢的问题。尤其是主页瀑布流尤为严重。通过一步一步的debug，发现当很多medel的bitmap在绘制时，cpu会爆满。\n因为一直在分配线程，导致cpu调度过慢，甚至有时候会会在点击详情页的时候出现ANR问题。\n\n排查出这个问题就好了，解决方法是将绘制由需要多少线程给多少线程改为固定数量线程池即可。这样cpu不至于说调度不来的问题。\n\n这个问题给我一个想法，如果线程池结合observable，做出一个栈型线程池，但是在这个场景中其实不适合。\n\n因此解决了启动速度慢的问题\n\n# 订单发起页面\n\n订单发起页面和普通页面不同，主要差别在于订单发起页面在很多地方都可以发起，但是其作用是唯一的，就是发起这个订单，并且继续后续的流程。但是由于在很多地方都可以发起订单，且订单页面又可以发起去很多地方。所以订单发起页面事实上也是无限的页面。\n\n但是订单发起页面不需要保留用户的返回路径，仅仅只需要一个活着的页面反复调用即可。\n\n因此我的做法是，在订单发起页面的start函数中，添加flag为FLAG_ACTIVITY_REORDER_TO_FRONT\n\n因为试了一下发现FLAG_ACTIVITY_BROUGHT_TO_FRONT并无效，所以只可以尝试FLAG_ACTIVITY_REORDER_TO_FRONT\n\n详细代码为\n```\npublic static void start(Activity activity){\n        Intent intent = new Intent(activity, OrderConfirmActivity.class);\n        intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n        activity.startActivity(intent);\n    }\n```\n\n# splash页优化\n\nsplash页面是app的进入时必走的页面，从leaks上面看，也有泄露的问题，检查发现泄露在lambda表达式中，而所有的lambda都是rxjava写的回调表达式，因此所做的是将这个页面所有的observable与该splashactivity的lifecycle绑定，另外eventbus也加了一些强判断（其实没啥必要），为了保险。\n\n## 引导页面\n\n2.8.0版本增加了引导页面，引导用户去设置medel，最近出现oom的现象，排查发现整个设置流程都没有进入destroy。因此在登录成功之后，启动了新的task来load，这样可以强制删除这些无用的流程。\n\n# vipZoon页面\n\nvipzone是会员专区，这个页面是滑动式，每个请求发现都没有捆绑住lifecycle，进行了捆绑处理","source":"_posts/项目卡顿问题优化专题.md","raw":"---\ntitle: 项目卡顿问题优化专题\ndate: 2018-11-28 11:07:03\ntags:\n---\n\n公司做了一波推广，卡顿问题比较明显的显示了出来。华为荣耀系列的卡顿问题尤其明显，很多用户反映在看上新的时候卡顿比较严重，还有用户说在使用时间较长之后，就比较卡顿。\n\n刚好这周把需求做完并且全部提测通过了，因此有三天的时间来做轻度优化。不过这个专题需要常驻，因为app需要优化的地方实在是太多了。\n\n# 商品详情\n\n商品详情页面是所有spu最终展示的地方，这个地方是所有用户必然经过的地方，商品详情页不是所有页面的终点，不是唯一的，所以商品详情页面有很多可以优化的地方。\n\n## 无限跳转优化\n\n商品详情页面作为展示spu的地方，其中却又展示了很多不同的spu，另外相同spu之间也是支持跳转的。\n\n我对比了淘宝和微博，淘宝只支持保留三个spu，但是相同spu是可以跳转的，而微博支持无限跳转，我试了超过10个都可以返回，但是微博不支持在一个人主页里面仍然跳进这个人主页，也就是不支持相同spu的跳转。\n\n和产品讨论了一下，这个地方相同spu仍然支持跳转，但是最多保留5个。\n\n我设计这地方的方案是在application里面持有activity的引用，在activity启动的时候，进行判断，如果是详情页面，就放入数组里面，否则就不管。放进数组里面之后会判断是否数组长度是否超过4个，超过的话就会进行移除的操作，手动执行finish。\n\n另外在destroy的时候，也这样判断，决定是否直接移除。\n\n操作的入口比较好找，直接套用application的registerActivityLifecycleCallbacks即可。\n\n在这个地方有一个问题，关于对activity的持有是否需要使用weakreference。\n\nregisterActivityLifecycleCallbacks的源码在application里面，主要的操作通过collectActivityLifecycleCallbacks来反馈\n\n```\nprivate Object[] collectActivityLifecycleCallbacks() {\n        Object[] callbacks = null;\n        synchronized (mActivityLifecycleCallbacks) {\n            if (mActivityLifecycleCallbacks.size() > 0) {\n                callbacks = mActivityLifecycleCallbacks.toArray();\n            }\n        }\n        return callbacks;\n    }\n```\n这个方法主要是在各activity生命周期开始的时候进行执行\n\n启动的时候如下\n```\n /* package */ void dispatchActivityCreated(Activity activity, Bundle savedInstanceState) {\n        Object[] callbacks = collectActivityLifecycleCallbacks();\n        if (callbacks != null) {\n            for (int i=0; i<callbacks.length; i++) {\n                ((ActivityLifecycleCallbacks)callbacks[i]).onActivityCreated(activity,\n                        savedInstanceState);\n            }\n        }\n    }\n```\n\n关闭的时候如下\n```\n/* package */ void dispatchActivityDestroyed(Activity activity) {\n        Object[] callbacks = collectActivityLifecycleCallbacks();\n        if (callbacks != null) {\n            for (int i=0; i<callbacks.length; i++) {\n                ((ActivityLifecycleCallbacks)callbacks[i]).onActivityDestroyed(activity);\n            }\n        }\n    }\n```\n\n问题就在actvity是在走destroy之前执行该方法，还是走完之后执行的。\n\n```\n protected void onDestroy() {\n        if (DEBUG_LIFECYCLE) Slog.v(TAG, \"onDestroy \" + this);\n        mCalled = true;\n\n        // dismiss any dialogs we are managing.\n        if (mManagedDialogs != null) {\n            final int numDialogs = mManagedDialogs.size();\n            for (int i = 0; i < numDialogs; i++) {\n                final ManagedDialog md = mManagedDialogs.valueAt(i);\n                if (md.mDialog.isShowing()) {\n                    md.mDialog.dismiss();\n                }\n            }\n            mManagedDialogs = null;\n        }\n\n        // close any cursors we are managing.\n        synchronized (mManagedCursors) {\n            int numCursors = mManagedCursors.size();\n            for (int i = 0; i < numCursors; i++) {\n                ManagedCursor c = mManagedCursors.get(i);\n                if (c != null) {\n                    c.mCursor.close();\n                }\n            }\n            mManagedCursors.clear();\n        }\n\n        // Close any open search dialog\n        if (mSearchManager != null) {\n            mSearchManager.stopSearch();\n        }\n\n        if (mActionBar != null) {\n            mActionBar.onDestroy();\n        }\n\n        getApplication().dispatchActivityDestroyed(this);\n    }\n```\n因此就证明了，destroy是在分发之前执行的，此时使用弱引用其实并不碍事，即使destroy的时候发生了gc，也没有太大的问题，只要之后的过程中将被回收的值对应的key清除即可。\n\nweakreference在这边如果使用的话，需要考虑到contain的写法，需要判断的比较多，经过尝试，其实效率和直接强引用差不多。\n\n## 详情页面泄露问题\n\n## 详情页面启动速度慢的问题\n\n详情页面启动速度慢的问题其实并不在详情页。经过排查，发现在有很多medel页面正在加载的地方，会出现启动速度过慢的问题。尤其是主页瀑布流尤为严重。通过一步一步的debug，发现当很多medel的bitmap在绘制时，cpu会爆满。\n因为一直在分配线程，导致cpu调度过慢，甚至有时候会会在点击详情页的时候出现ANR问题。\n\n排查出这个问题就好了，解决方法是将绘制由需要多少线程给多少线程改为固定数量线程池即可。这样cpu不至于说调度不来的问题。\n\n这个问题给我一个想法，如果线程池结合observable，做出一个栈型线程池，但是在这个场景中其实不适合。\n\n因此解决了启动速度慢的问题\n\n# 订单发起页面\n\n订单发起页面和普通页面不同，主要差别在于订单发起页面在很多地方都可以发起，但是其作用是唯一的，就是发起这个订单，并且继续后续的流程。但是由于在很多地方都可以发起订单，且订单页面又可以发起去很多地方。所以订单发起页面事实上也是无限的页面。\n\n但是订单发起页面不需要保留用户的返回路径，仅仅只需要一个活着的页面反复调用即可。\n\n因此我的做法是，在订单发起页面的start函数中，添加flag为FLAG_ACTIVITY_REORDER_TO_FRONT\n\n因为试了一下发现FLAG_ACTIVITY_BROUGHT_TO_FRONT并无效，所以只可以尝试FLAG_ACTIVITY_REORDER_TO_FRONT\n\n详细代码为\n```\npublic static void start(Activity activity){\n        Intent intent = new Intent(activity, OrderConfirmActivity.class);\n        intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n        activity.startActivity(intent);\n    }\n```\n\n# splash页优化\n\nsplash页面是app的进入时必走的页面，从leaks上面看，也有泄露的问题，检查发现泄露在lambda表达式中，而所有的lambda都是rxjava写的回调表达式，因此所做的是将这个页面所有的observable与该splashactivity的lifecycle绑定，另外eventbus也加了一些强判断（其实没啥必要），为了保险。\n\n## 引导页面\n\n2.8.0版本增加了引导页面，引导用户去设置medel，最近出现oom的现象，排查发现整个设置流程都没有进入destroy。因此在登录成功之后，启动了新的task来load，这样可以强制删除这些无用的流程。\n\n# vipZoon页面\n\nvipzone是会员专区，这个页面是滑动式，每个请求发现都没有捆绑住lifecycle，进行了捆绑处理","slug":"项目卡顿问题优化专题","published":1,"updated":"2019-03-12T09:26:33.171Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttzg005s3a8kfam4f8h2","content":"<p>公司做了一波推广，卡顿问题比较明显的显示了出来。华为荣耀系列的卡顿问题尤其明显，很多用户反映在看上新的时候卡顿比较严重，还有用户说在使用时间较长之后，就比较卡顿。</p>\n<p>刚好这周把需求做完并且全部提测通过了，因此有三天的时间来做轻度优化。不过这个专题需要常驻，因为app需要优化的地方实在是太多了。</p>\n<h1 id=\"商品详情\"><a href=\"#商品详情\" class=\"headerlink\" title=\"商品详情\"></a>商品详情</h1><p>商品详情页面是所有spu最终展示的地方，这个地方是所有用户必然经过的地方，商品详情页不是所有页面的终点，不是唯一的，所以商品详情页面有很多可以优化的地方。</p>\n<h2 id=\"无限跳转优化\"><a href=\"#无限跳转优化\" class=\"headerlink\" title=\"无限跳转优化\"></a>无限跳转优化</h2><p>商品详情页面作为展示spu的地方，其中却又展示了很多不同的spu，另外相同spu之间也是支持跳转的。</p>\n<p>我对比了淘宝和微博，淘宝只支持保留三个spu，但是相同spu是可以跳转的，而微博支持无限跳转，我试了超过10个都可以返回，但是微博不支持在一个人主页里面仍然跳进这个人主页，也就是不支持相同spu的跳转。</p>\n<p>和产品讨论了一下，这个地方相同spu仍然支持跳转，但是最多保留5个。</p>\n<p>我设计这地方的方案是在application里面持有activity的引用，在activity启动的时候，进行判断，如果是详情页面，就放入数组里面，否则就不管。放进数组里面之后会判断是否数组长度是否超过4个，超过的话就会进行移除的操作，手动执行finish。</p>\n<p>另外在destroy的时候，也这样判断，决定是否直接移除。</p>\n<p>操作的入口比较好找，直接套用application的registerActivityLifecycleCallbacks即可。</p>\n<p>在这个地方有一个问题，关于对activity的持有是否需要使用weakreference。</p>\n<p>registerActivityLifecycleCallbacks的源码在application里面，主要的操作通过collectActivityLifecycleCallbacks来反馈</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Object[] collectActivityLifecycleCallbacks() &#123;</span><br><span class=\"line\">        Object[] callbacks = null;</span><br><span class=\"line\">        synchronized (mActivityLifecycleCallbacks) &#123;</span><br><span class=\"line\">            if (mActivityLifecycleCallbacks.size() &gt; 0) &#123;</span><br><span class=\"line\">                callbacks = mActivityLifecycleCallbacks.toArray();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return callbacks;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法主要是在各activity生命周期开始的时候进行执行</p>\n<p>启动的时候如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* package */ void dispatchActivityCreated(Activity activity, Bundle savedInstanceState) &#123;</span><br><span class=\"line\">       Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class=\"line\">       if (callbacks != null) &#123;</span><br><span class=\"line\">           for (int i=0; i&lt;callbacks.length; i++) &#123;</span><br><span class=\"line\">               ((ActivityLifecycleCallbacks)callbacks[i]).onActivityCreated(activity,</span><br><span class=\"line\">                       savedInstanceState);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>关闭的时候如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* package */ void dispatchActivityDestroyed(Activity activity) &#123;</span><br><span class=\"line\">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class=\"line\">        if (callbacks != null) &#123;</span><br><span class=\"line\">            for (int i=0; i&lt;callbacks.length; i++) &#123;</span><br><span class=\"line\">                ((ActivityLifecycleCallbacks)callbacks[i]).onActivityDestroyed(activity);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>问题就在actvity是在走destroy之前执行该方法，还是走完之后执行的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void onDestroy() &#123;</span><br><span class=\"line\">       if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onDestroy &quot; + this);</span><br><span class=\"line\">       mCalled = true;</span><br><span class=\"line\"></span><br><span class=\"line\">       // dismiss any dialogs we are managing.</span><br><span class=\"line\">       if (mManagedDialogs != null) &#123;</span><br><span class=\"line\">           final int numDialogs = mManagedDialogs.size();</span><br><span class=\"line\">           for (int i = 0; i &lt; numDialogs; i++) &#123;</span><br><span class=\"line\">               final ManagedDialog md = mManagedDialogs.valueAt(i);</span><br><span class=\"line\">               if (md.mDialog.isShowing()) &#123;</span><br><span class=\"line\">                   md.mDialog.dismiss();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           mManagedDialogs = null;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       // close any cursors we are managing.</span><br><span class=\"line\">       synchronized (mManagedCursors) &#123;</span><br><span class=\"line\">           int numCursors = mManagedCursors.size();</span><br><span class=\"line\">           for (int i = 0; i &lt; numCursors; i++) &#123;</span><br><span class=\"line\">               ManagedCursor c = mManagedCursors.get(i);</span><br><span class=\"line\">               if (c != null) &#123;</span><br><span class=\"line\">                   c.mCursor.close();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           mManagedCursors.clear();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       // Close any open search dialog</span><br><span class=\"line\">       if (mSearchManager != null) &#123;</span><br><span class=\"line\">           mSearchManager.stopSearch();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       if (mActionBar != null) &#123;</span><br><span class=\"line\">           mActionBar.onDestroy();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       getApplication().dispatchActivityDestroyed(this);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>因此就证明了，destroy是在分发之前执行的，此时使用弱引用其实并不碍事，即使destroy的时候发生了gc，也没有太大的问题，只要之后的过程中将被回收的值对应的key清除即可。</p>\n<p>weakreference在这边如果使用的话，需要考虑到contain的写法，需要判断的比较多，经过尝试，其实效率和直接强引用差不多。</p>\n<h2 id=\"详情页面泄露问题\"><a href=\"#详情页面泄露问题\" class=\"headerlink\" title=\"详情页面泄露问题\"></a>详情页面泄露问题</h2><h2 id=\"详情页面启动速度慢的问题\"><a href=\"#详情页面启动速度慢的问题\" class=\"headerlink\" title=\"详情页面启动速度慢的问题\"></a>详情页面启动速度慢的问题</h2><p>详情页面启动速度慢的问题其实并不在详情页。经过排查，发现在有很多medel页面正在加载的地方，会出现启动速度过慢的问题。尤其是主页瀑布流尤为严重。通过一步一步的debug，发现当很多medel的bitmap在绘制时，cpu会爆满。<br>因为一直在分配线程，导致cpu调度过慢，甚至有时候会会在点击详情页的时候出现ANR问题。</p>\n<p>排查出这个问题就好了，解决方法是将绘制由需要多少线程给多少线程改为固定数量线程池即可。这样cpu不至于说调度不来的问题。</p>\n<p>这个问题给我一个想法，如果线程池结合observable，做出一个栈型线程池，但是在这个场景中其实不适合。</p>\n<p>因此解决了启动速度慢的问题</p>\n<h1 id=\"订单发起页面\"><a href=\"#订单发起页面\" class=\"headerlink\" title=\"订单发起页面\"></a>订单发起页面</h1><p>订单发起页面和普通页面不同，主要差别在于订单发起页面在很多地方都可以发起，但是其作用是唯一的，就是发起这个订单，并且继续后续的流程。但是由于在很多地方都可以发起订单，且订单页面又可以发起去很多地方。所以订单发起页面事实上也是无限的页面。</p>\n<p>但是订单发起页面不需要保留用户的返回路径，仅仅只需要一个活着的页面反复调用即可。</p>\n<p>因此我的做法是，在订单发起页面的start函数中，添加flag为FLAG_ACTIVITY_REORDER_TO_FRONT</p>\n<p>因为试了一下发现FLAG_ACTIVITY_BROUGHT_TO_FRONT并无效，所以只可以尝试FLAG_ACTIVITY_REORDER_TO_FRONT</p>\n<p>详细代码为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void start(Activity activity)&#123;</span><br><span class=\"line\">        Intent intent = new Intent(activity, OrderConfirmActivity.class);</span><br><span class=\"line\">        intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);</span><br><span class=\"line\">        activity.startActivity(intent);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"splash页优化\"><a href=\"#splash页优化\" class=\"headerlink\" title=\"splash页优化\"></a>splash页优化</h1><p>splash页面是app的进入时必走的页面，从leaks上面看，也有泄露的问题，检查发现泄露在lambda表达式中，而所有的lambda都是rxjava写的回调表达式，因此所做的是将这个页面所有的observable与该splashactivity的lifecycle绑定，另外eventbus也加了一些强判断（其实没啥必要），为了保险。</p>\n<h2 id=\"引导页面\"><a href=\"#引导页面\" class=\"headerlink\" title=\"引导页面\"></a>引导页面</h2><p>2.8.0版本增加了引导页面，引导用户去设置medel，最近出现oom的现象，排查发现整个设置流程都没有进入destroy。因此在登录成功之后，启动了新的task来load，这样可以强制删除这些无用的流程。</p>\n<h1 id=\"vipZoon页面\"><a href=\"#vipZoon页面\" class=\"headerlink\" title=\"vipZoon页面\"></a>vipZoon页面</h1><p>vipzone是会员专区，这个页面是滑动式，每个请求发现都没有捆绑住lifecycle，进行了捆绑处理</p>\n","site":{"data":{}},"excerpt":"","more":"<p>公司做了一波推广，卡顿问题比较明显的显示了出来。华为荣耀系列的卡顿问题尤其明显，很多用户反映在看上新的时候卡顿比较严重，还有用户说在使用时间较长之后，就比较卡顿。</p>\n<p>刚好这周把需求做完并且全部提测通过了，因此有三天的时间来做轻度优化。不过这个专题需要常驻，因为app需要优化的地方实在是太多了。</p>\n<h1 id=\"商品详情\"><a href=\"#商品详情\" class=\"headerlink\" title=\"商品详情\"></a>商品详情</h1><p>商品详情页面是所有spu最终展示的地方，这个地方是所有用户必然经过的地方，商品详情页不是所有页面的终点，不是唯一的，所以商品详情页面有很多可以优化的地方。</p>\n<h2 id=\"无限跳转优化\"><a href=\"#无限跳转优化\" class=\"headerlink\" title=\"无限跳转优化\"></a>无限跳转优化</h2><p>商品详情页面作为展示spu的地方，其中却又展示了很多不同的spu，另外相同spu之间也是支持跳转的。</p>\n<p>我对比了淘宝和微博，淘宝只支持保留三个spu，但是相同spu是可以跳转的，而微博支持无限跳转，我试了超过10个都可以返回，但是微博不支持在一个人主页里面仍然跳进这个人主页，也就是不支持相同spu的跳转。</p>\n<p>和产品讨论了一下，这个地方相同spu仍然支持跳转，但是最多保留5个。</p>\n<p>我设计这地方的方案是在application里面持有activity的引用，在activity启动的时候，进行判断，如果是详情页面，就放入数组里面，否则就不管。放进数组里面之后会判断是否数组长度是否超过4个，超过的话就会进行移除的操作，手动执行finish。</p>\n<p>另外在destroy的时候，也这样判断，决定是否直接移除。</p>\n<p>操作的入口比较好找，直接套用application的registerActivityLifecycleCallbacks即可。</p>\n<p>在这个地方有一个问题，关于对activity的持有是否需要使用weakreference。</p>\n<p>registerActivityLifecycleCallbacks的源码在application里面，主要的操作通过collectActivityLifecycleCallbacks来反馈</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Object[] collectActivityLifecycleCallbacks() &#123;</span><br><span class=\"line\">        Object[] callbacks = null;</span><br><span class=\"line\">        synchronized (mActivityLifecycleCallbacks) &#123;</span><br><span class=\"line\">            if (mActivityLifecycleCallbacks.size() &gt; 0) &#123;</span><br><span class=\"line\">                callbacks = mActivityLifecycleCallbacks.toArray();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return callbacks;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法主要是在各activity生命周期开始的时候进行执行</p>\n<p>启动的时候如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* package */ void dispatchActivityCreated(Activity activity, Bundle savedInstanceState) &#123;</span><br><span class=\"line\">       Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class=\"line\">       if (callbacks != null) &#123;</span><br><span class=\"line\">           for (int i=0; i&lt;callbacks.length; i++) &#123;</span><br><span class=\"line\">               ((ActivityLifecycleCallbacks)callbacks[i]).onActivityCreated(activity,</span><br><span class=\"line\">                       savedInstanceState);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>关闭的时候如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* package */ void dispatchActivityDestroyed(Activity activity) &#123;</span><br><span class=\"line\">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class=\"line\">        if (callbacks != null) &#123;</span><br><span class=\"line\">            for (int i=0; i&lt;callbacks.length; i++) &#123;</span><br><span class=\"line\">                ((ActivityLifecycleCallbacks)callbacks[i]).onActivityDestroyed(activity);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>问题就在actvity是在走destroy之前执行该方法，还是走完之后执行的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void onDestroy() &#123;</span><br><span class=\"line\">       if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onDestroy &quot; + this);</span><br><span class=\"line\">       mCalled = true;</span><br><span class=\"line\"></span><br><span class=\"line\">       // dismiss any dialogs we are managing.</span><br><span class=\"line\">       if (mManagedDialogs != null) &#123;</span><br><span class=\"line\">           final int numDialogs = mManagedDialogs.size();</span><br><span class=\"line\">           for (int i = 0; i &lt; numDialogs; i++) &#123;</span><br><span class=\"line\">               final ManagedDialog md = mManagedDialogs.valueAt(i);</span><br><span class=\"line\">               if (md.mDialog.isShowing()) &#123;</span><br><span class=\"line\">                   md.mDialog.dismiss();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           mManagedDialogs = null;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       // close any cursors we are managing.</span><br><span class=\"line\">       synchronized (mManagedCursors) &#123;</span><br><span class=\"line\">           int numCursors = mManagedCursors.size();</span><br><span class=\"line\">           for (int i = 0; i &lt; numCursors; i++) &#123;</span><br><span class=\"line\">               ManagedCursor c = mManagedCursors.get(i);</span><br><span class=\"line\">               if (c != null) &#123;</span><br><span class=\"line\">                   c.mCursor.close();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           mManagedCursors.clear();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       // Close any open search dialog</span><br><span class=\"line\">       if (mSearchManager != null) &#123;</span><br><span class=\"line\">           mSearchManager.stopSearch();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       if (mActionBar != null) &#123;</span><br><span class=\"line\">           mActionBar.onDestroy();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       getApplication().dispatchActivityDestroyed(this);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>因此就证明了，destroy是在分发之前执行的，此时使用弱引用其实并不碍事，即使destroy的时候发生了gc，也没有太大的问题，只要之后的过程中将被回收的值对应的key清除即可。</p>\n<p>weakreference在这边如果使用的话，需要考虑到contain的写法，需要判断的比较多，经过尝试，其实效率和直接强引用差不多。</p>\n<h2 id=\"详情页面泄露问题\"><a href=\"#详情页面泄露问题\" class=\"headerlink\" title=\"详情页面泄露问题\"></a>详情页面泄露问题</h2><h2 id=\"详情页面启动速度慢的问题\"><a href=\"#详情页面启动速度慢的问题\" class=\"headerlink\" title=\"详情页面启动速度慢的问题\"></a>详情页面启动速度慢的问题</h2><p>详情页面启动速度慢的问题其实并不在详情页。经过排查，发现在有很多medel页面正在加载的地方，会出现启动速度过慢的问题。尤其是主页瀑布流尤为严重。通过一步一步的debug，发现当很多medel的bitmap在绘制时，cpu会爆满。<br>因为一直在分配线程，导致cpu调度过慢，甚至有时候会会在点击详情页的时候出现ANR问题。</p>\n<p>排查出这个问题就好了，解决方法是将绘制由需要多少线程给多少线程改为固定数量线程池即可。这样cpu不至于说调度不来的问题。</p>\n<p>这个问题给我一个想法，如果线程池结合observable，做出一个栈型线程池，但是在这个场景中其实不适合。</p>\n<p>因此解决了启动速度慢的问题</p>\n<h1 id=\"订单发起页面\"><a href=\"#订单发起页面\" class=\"headerlink\" title=\"订单发起页面\"></a>订单发起页面</h1><p>订单发起页面和普通页面不同，主要差别在于订单发起页面在很多地方都可以发起，但是其作用是唯一的，就是发起这个订单，并且继续后续的流程。但是由于在很多地方都可以发起订单，且订单页面又可以发起去很多地方。所以订单发起页面事实上也是无限的页面。</p>\n<p>但是订单发起页面不需要保留用户的返回路径，仅仅只需要一个活着的页面反复调用即可。</p>\n<p>因此我的做法是，在订单发起页面的start函数中，添加flag为FLAG_ACTIVITY_REORDER_TO_FRONT</p>\n<p>因为试了一下发现FLAG_ACTIVITY_BROUGHT_TO_FRONT并无效，所以只可以尝试FLAG_ACTIVITY_REORDER_TO_FRONT</p>\n<p>详细代码为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void start(Activity activity)&#123;</span><br><span class=\"line\">        Intent intent = new Intent(activity, OrderConfirmActivity.class);</span><br><span class=\"line\">        intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);</span><br><span class=\"line\">        activity.startActivity(intent);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"splash页优化\"><a href=\"#splash页优化\" class=\"headerlink\" title=\"splash页优化\"></a>splash页优化</h1><p>splash页面是app的进入时必走的页面，从leaks上面看，也有泄露的问题，检查发现泄露在lambda表达式中，而所有的lambda都是rxjava写的回调表达式，因此所做的是将这个页面所有的observable与该splashactivity的lifecycle绑定，另外eventbus也加了一些强判断（其实没啥必要），为了保险。</p>\n<h2 id=\"引导页面\"><a href=\"#引导页面\" class=\"headerlink\" title=\"引导页面\"></a>引导页面</h2><p>2.8.0版本增加了引导页面，引导用户去设置medel，最近出现oom的现象，排查发现整个设置流程都没有进入destroy。因此在登录成功之后，启动了新的task来load，这样可以强制删除这些无用的流程。</p>\n<h1 id=\"vipZoon页面\"><a href=\"#vipZoon页面\" class=\"headerlink\" title=\"vipZoon页面\"></a>vipZoon页面</h1><p>vipzone是会员专区，这个页面是滑动式，每个请求发现都没有捆绑住lifecycle，进行了捆绑处理</p>\n"},{"title":"2018.3-2018.12记产品死亡总结","date":"2018-12-30T10:59:13.000Z","_content":"\n最近一阵没有写工作小结。并不是不想写，其实是发生了一些没有想到的事情。\n\n总而言之产品挂掉了。\n\n在我们这个团队，产品每日都想的是怎么往后推进，从来没有想过之前的行为为什么有问题。而对于我们开发来讲，基本上也都是上行下效，重心总是在技术上，而不会对产品产生质疑。关于失败的总结一直都是避而不谈，开会的话语中永远都是美好的未来。其实这也是失败的一个因素。\n\n我希望以我全程参与的开发者的身份，来对产品的死亡做一个总结。\n\n# 3月，开始\n\n3月的我加入了好搭，当时项目还没有改名为好搭盒子，app的版本停留在1.9.3，当时做的是导购的模式，通过淘宝客，租赁衣服进来生成模型，然后通过提供服务给用户，通过淘宝客来获取佣金。\n由于老模式竞争很大，需要比较多的投入才能达到比较好的传播的目的，另外在用户上面，其实在当时的传播模式在当时是很有吸引力的，但是当时的效果做的并不是很好。再加上天使轮融资成功，需要抓紧从好买衣脱离，所以仿照了国外Stitch Fix上市的盒子模式，期望能通过虚拟形象加上盒子模式，给虚拟形象带来一个有效的传播。\n\n# 4月，2.0版本上线\n\n由于以前从好买衣转来的后台，和上头吵翻了，因此上头决定新招一个后台，但是只招了一个后台。重构当时给了2周，但是到三月末还是没有好，后来又给了两周，一个月整后端接口好了。在4月中旬我们开启了app的大规模改版计划。\n\n起初是加上盒子，盒子模式需要增加加盒、地址、押金、付款、订单等模块，后续又加上了会员系统，另外在商品的展示阶段，刚开始使用的是单品+合集的模式，商品结合的是medel+单品展示的。改版很大，对于我来讲就是不日不夜的加了两周班。\n\n改版上线前遗留几个比较严重的问题，一个是盒子模式的本地保存和服务端保存冲突模式，服务端保存会导致加盒的模式很卡顿，加盒的过程需要验证服务器库存+操作本地盒子增加删减+push新的盒子到服务器+拉新的盒子到本地更新本地的衣服状态+本地存储新的盒子到sp。由于盒子的操作是一个很高频的模式，但是操作盒子带来的网络操作以及本地操作，当时验证需要大约400ms，而一次增加就会带来400ms的卡顿感，其实对用户来讲是十分不友好的。\n\n由于着急上线，盒子的模式就被直接忽略而直接在4月30号上线了。\n\n从现在的角度来看，当时如果能多用2天的时间，将整个盒子的模式改变一下，应该就不会有2.0版本评分从4.3掉到3.0的问题了。市场对2.0版本最大的评价就是卡。\n\n# 5月,正式由好搭虚拟试衣变更为好搭盒子\n\n5月的产品计划是增加了芝麻信用免押金、加入了人工客服、增加了引导页面，同时对于订单模块进行了较大规模的优化。\n\n这个版本是正式更名为好搭盒子，同时也进行了一定规模的投放。由于客户量增加导致暴露出了一个问题，就是由于信用免押金用户开始通过免押金进行订盒子，然后却不购买不退盒子。针对这个问题，当时唯一的号称“联系芝麻信用进行处罚”的措施，只有打电话追着用户。其实押金模式被ofo搞得臭名昭著，而不用押金，对我们这种小型公司，很难说控制用户的诚信度。我并不知道出问题的人的数量，但是我当时和产品沟通的时候，间接了解到了违规的人数其实不少。\n\n说实话小公司在扩大市场这一方面真的难，像衣盒这些，通过强制要求用户提交几百块的押金，然后还有钱进行市场投放，这样用户规模就算增长不快，起码不会出现这种大规模违规的现象。然而我们公司无法这样，如果加了押金一定会导致用户抵抗情绪上升，因此也会导致用户接受能力降低。不得已才采用免押的模式，然而没想到这个模式这么快就被打脸了。\n\n另外这个版本的商品展示，是机械的随机展示，权重并没有按照用户的喜好来。下拉过程中大概率出现是重复的商品。不过这个版本我将盒子的模式完全更改为内存存储的方式，优化掉了卡顿的问题。\n\n这个版本的评价不再是卡卡卡，而是商品数目不够，想买的一下子就没了。\n\n# 6月，app由简陋转变为精致\n\n整个六月，在连续更换2位ui之后，我们终于定下了ui的风格，并以此将页面逐个更新为新的风格。同时增加了专题和图文专题作为商品的展示模式。\n\n整个六月只发了一个版本，但是针对这个版本提交了300多笔。不过ui定稿总算是完成了，大家都很开心，风格的统一应该会带来用户的提升。\n\n至少当时都是这么想的。\n\n但是发出去之后，6月的数据并不是很好看，至少没有达到想象的那种程度。一方面是因为数据量上去了，但是货品并没有上去，二来是仓库物流erp系统有些问题，造成了比较多的延迟发货问题。当时在确认订货的时候，并不支持取消订单，大量用户操作失误寄出了盒子，但是并不想要，好的人直接退了，不好的就不管，或者收到了衣服拿出来。主打的学生人群感觉更容易出现这种情况，反正是造成了数据并不好看。\n\n6月出了一场比较严重的事故，由于在首页使用fragmentPageAdapter并且没有将缓存数据处理，导致app的内存在首页被消耗太多，因此导致了app极度卡顿。记忆中这个版本的anr达到了10%。事实上当时在测试的过程中就已经发现了这个问题，但是由于需要着急发版。每次卡着时间必须在周五发版，导致改版问题只看数量不看质量，这种质量事故其实很严重，但是产品很着急，老板很着急，开发很疲惫，测试很疲惫。\n\n说实话其实对于小型开发公司来讲，讲究质量是一件很不靠谱的事情，在质量做上来之前，说不定市场就转向了。我们要求是周一给任务，周二出图和接口，周三周四开始做，周五提测测试完毕。如果周五提测不行，周六就加班，最迟最迟是周六提版本。这种进度在一般时候其实是ok的，但是在大改动的时候，尤其是ui改了2周才给设计稿的时候，第三周要求我们弄出来，就会导致这种情况发生。\n\n当时我想了很多，发现其实无解，我们在提高自身效率，提升代码质量的时候，绝大部分时间都是在业务上面，而这种架构方面的问题真的很难发现并处理。很蛋疼。另外就是这种问题需要依赖测试的问题，在我们开发任务结束，开始进行bug修补的时候，这时候应该关注性能方面，然而没办法，这个时候都是和产品测试确定bug以及修改bug。这种性能优化的问题，每次都只能在发版之后，只有任务但是并没有接口和设计图的周一。于是乎我们因此发布了很多hotfix版本。\n\n# 7月，app增加了很多实用的功能\n\n首先是增加的功能，这个版本增加了收藏单品、2件打包、商品状态、匿名状态使用等功能。基本上每个都是在痛点上面的设计。另外移除了强制登陆的逻辑，这个也是痛点。\n\n这个版本的主要改动还是针对用户在使用产品的阶段遇到的问题。以前的用户由于刚开始使用，需要强制登陆，强制设置medel，成本比较高，这样会造成用户第一次使用成本过大，另外由于之前无法收藏，导致用户看到想要的不小心刷新之后再也没办法回到原来的状态，2件打包也是为了让用户更方便的打包盒子。整个设计的逻辑这个月都很简单明了，就是为了增加寄盒率。\n\n这个月我们的盒子也突破了1000个/月。app的uv也突破了1w。\n\n# 8月，人脸升级\n\n8月是融资之前的一个月，这个月紧锣密鼓的进行了很多的事情。具体在我8月份的git基本上没有任何提交就可以看出来。我们把ux完完整整的优化了一遍，同时将人脸也进行了一次升级作为一次融资的噱头。整个ux的优化持续了一个月，这次优化的细节主要体现在订单流程上面，订单流程增加了很多状态，同时对于用户退货的流程做了很大规模的退货。主要的初心我个人猜测就是因为之前退货的流程太过突兀，用户一来可能看不到退货的入口，二来退货过程中细节不好，导致用户可能不一定在这个页面会进行下去。\n\n总之这一版主要功能还是为了保障以购用户退货的过程能够顺畅而做出的优化，另外人脸识别算法部门提供了一个v2的版本，这个版本主要是将人脸从建模变成抠图，看起来仿佛是更好了。\n\n另外这个月是融资之前的一个月，8月末就正式启动了融资。\n\n# 9月，数据爆炸\n\n9月份市场做了很多推广的努力，外加运营部门做了一些调整，优化了搜索引擎，导致app那一阵用户量猛增，由平时的1万ui猛升到了8wuv，当时在appstore排行榜还占到了最热区域。但是服务器重建人脸的效率实在是太慢了，重建队列很多都是堵死状态，我们太依赖好买衣导致他们的缺点在我们这边无限的暴露。而且这个月好买衣的后端leader跑路，前端leader跑路，走之前特地嘱咐了我们服务器的问题。但是当时我们这边重心没有放在这个上面，服务器出现人脸丢失，黑脸，没头，还有没头发的问题，在之后的几个月基本上是无限爆出，我们这边后端压根不涉及这些，核心竞争力没法把握好，导致后续在后端的稳定性上面吃了大亏。\n\n不过9月是进入好搭之后感觉最兴奋的一个月，这一个月数据不断的刷新，让人感觉8月的加班是有意义的，而且这个月的盒子数也顺利的从之前的几百个，突破到了2000+个，至少对我们来讲，这一阶段的里程碑是达成了。\n\n# 10月，a轮找到金主\n\n10月由于是国庆节，外加母亲动手术，我大约半个月没有工作，这个月最繁忙的一周是a轮找到了金主之后的一周，投资人对我们提出了很多的要求，数据当时比较中庸，主要是加盒率和购买复购率比较低，而盒子数量和使用用户则比较好看。当时产品那边的想法是提高会员数量，这样可以使的会员转化率增加，会员的表现一直有比较高的复购和加盒转化率。\n\n当时介于商品本来缺货断码就比较严重，因此开辟了一个会员专区，专门提供给会员特供的商品。这个版本上去之后的数据并没有显示，但是uv开始逐渐的降低了，十月份到最后的时候，我记得uv从2万掉到了1万2左右。\n\n# 11月，强制用户登陆\n\n由于之前将强制登陆和设计medel的步骤给去掉了，导致很多用户在很低的时间成本下，反复叫盒子，然后不够买不寄回，这样导致很多衣服被薅羊毛薅走了。这个现象持续了好几个月，但是这个月开始对这个现象做处理。\n\n我们将新的强制登陆逻辑加上，为此付出了2周的开发周期，并且还delay了一次。但是中途也遇到了很多的问题，问题主要展现在关于medel的接口我们这边不是很了解，需要和好买衣沟通，另外就是服务器不稳定，导致线上环境建模总是失败，导致这样的强制引导很容易出现劝退现象。不过为了能够将羊毛党拒之门外，貌似我们在信用体系下可以做的也就是这样了。\n\n# 12月，融资失败\n\n到了12月，仿佛寒冬一下子来临了，各处裁员。\n\n刚开始以为融资都进入ts了，应该可以稳定，结果还是没躲过，12号的时候说投资人因为一些问题准备不投了，这就很蛋疼了，毕竟已经等了超过一个月的ts了，最后说不投，基本上就是断炊了。然后ceo去跑了一趟，回来之后说又融到了。但是比较神奇的是开始要求我们砍业务。砍掉盒子模式。\n\n很奇怪，融到了为什么要砍。结果吃饭的时候技术leader说其实并没有融到，ceo只是不想说而已。砍业务是因为吃不消损耗了，每个盒子都是亏的，用户热情还很高，这样钱吃不消使用。\n\n于是连我们12月在做的功能都连根拔掉了，砍掉了订单，盒子，支付，会员等等，最后要接上淘宝客，等于我们的版本绕了一圈，回到了1.9.3的版本了。\n\n哎。这样子，我们的好搭盒子就彻彻底底的死了。\n\n\n# 总结\n\n从开发者客观来讲，对这个产品是有感情的，当我来的时候，安卓组那个人准备离职，我在2个月的时间里面独自支撑着并不熟悉的项目。\n\n加班加点在好搭仿佛都是家常便饭，年中的时候统计了一下已经累计了10天的调休。\n\n可是有什么用呢？开发者仅仅是一把刀子，这个刀子或许锋利，或许迟钝，但是如果将锋利的刀子不断砍伐一些无用的东西，这有什么意义呢？\n\n刚开始的时候说我们暂时不需要考虑基础建设的问题，后端，前端，移动端，都是走一步看一步。后期发现基础建设出了问题的时候，却又浪费了大批量的时间来重构。创业公司感觉永远逃离不了这个魔咒。\n\n当听到一直维护的项目突然被砍掉，转成别的项目的时候。心里只有一声叹息。\n\n# 问题出在哪里？\n\n最近一直在想，leader离职的时候说过一句话，“论盒子模式，我们绝对是数据跑的好的”，但是为什么落的如此下场？\n\n## 信用模式\n\n盒子模式首先将衣服寄到了用户手里，然后让用户选择购买或者退回。这中间给了用户极大的自由，前期我们尚且能通过小规模投放来控制风险，后期接入了小红书推广，导致大量学生涌入，很多人仿佛占到了便宜似的拼命下盒子，下完了拿到货不退不购买，导致大量订单逾期坏单。造成了巨量的成本亏损。\n\n## 商品量不足\n\n由于是商城模式的app，对商品量的把控一定要比较高，但是从数据上来看，常年缺码SPU高达40%，造成了好衣服没货，坏衣服卖不出去的问题。加上前期并没有做好消息推送这个环节，对缺货商品的订阅上的过慢，也导致了大量用户的流失现象。\n\n## medel不够稳定\n\nmedel不够稳定是一直存在的问题，首先渲染消耗太多，最高每日光服务器就要跑掉2w块。其次是就算这样仍然不够稳定，不清楚是算法还是好买衣的问题，总是出现光头，绘制失败，没脸的问题。这个问题其实很严重，特别是我们这种主打虚拟试衣模式的app，基本上就是断腿了。\n\n这个问题其实是有解的，开始的时候就可以选择重构那边的代码。但是怎么讲呢，兵熊熊一个，将熊熊一窝，关于这个问题从我入职的时候每次会议必谈，直到leader来了之后禁止我们开会讨论这个。从开始leader就没有想重构，他或许想的是在半年内我们可以拿到a轮融资，之后可以选择完整的重构，或者是想着干脆就不重构了，等着别人来\n\n\n\n\n\n","source":"_posts/2018-3-2018-12记产品死亡总结.md","raw":"---\ntitle: 2018.3-2018.12记产品死亡总结\ndate: 2018-12-30 18:59:13\ntags: 工作小结\n---\n\n最近一阵没有写工作小结。并不是不想写，其实是发生了一些没有想到的事情。\n\n总而言之产品挂掉了。\n\n在我们这个团队，产品每日都想的是怎么往后推进，从来没有想过之前的行为为什么有问题。而对于我们开发来讲，基本上也都是上行下效，重心总是在技术上，而不会对产品产生质疑。关于失败的总结一直都是避而不谈，开会的话语中永远都是美好的未来。其实这也是失败的一个因素。\n\n我希望以我全程参与的开发者的身份，来对产品的死亡做一个总结。\n\n# 3月，开始\n\n3月的我加入了好搭，当时项目还没有改名为好搭盒子，app的版本停留在1.9.3，当时做的是导购的模式，通过淘宝客，租赁衣服进来生成模型，然后通过提供服务给用户，通过淘宝客来获取佣金。\n由于老模式竞争很大，需要比较多的投入才能达到比较好的传播的目的，另外在用户上面，其实在当时的传播模式在当时是很有吸引力的，但是当时的效果做的并不是很好。再加上天使轮融资成功，需要抓紧从好买衣脱离，所以仿照了国外Stitch Fix上市的盒子模式，期望能通过虚拟形象加上盒子模式，给虚拟形象带来一个有效的传播。\n\n# 4月，2.0版本上线\n\n由于以前从好买衣转来的后台，和上头吵翻了，因此上头决定新招一个后台，但是只招了一个后台。重构当时给了2周，但是到三月末还是没有好，后来又给了两周，一个月整后端接口好了。在4月中旬我们开启了app的大规模改版计划。\n\n起初是加上盒子，盒子模式需要增加加盒、地址、押金、付款、订单等模块，后续又加上了会员系统，另外在商品的展示阶段，刚开始使用的是单品+合集的模式，商品结合的是medel+单品展示的。改版很大，对于我来讲就是不日不夜的加了两周班。\n\n改版上线前遗留几个比较严重的问题，一个是盒子模式的本地保存和服务端保存冲突模式，服务端保存会导致加盒的模式很卡顿，加盒的过程需要验证服务器库存+操作本地盒子增加删减+push新的盒子到服务器+拉新的盒子到本地更新本地的衣服状态+本地存储新的盒子到sp。由于盒子的操作是一个很高频的模式，但是操作盒子带来的网络操作以及本地操作，当时验证需要大约400ms，而一次增加就会带来400ms的卡顿感，其实对用户来讲是十分不友好的。\n\n由于着急上线，盒子的模式就被直接忽略而直接在4月30号上线了。\n\n从现在的角度来看，当时如果能多用2天的时间，将整个盒子的模式改变一下，应该就不会有2.0版本评分从4.3掉到3.0的问题了。市场对2.0版本最大的评价就是卡。\n\n# 5月,正式由好搭虚拟试衣变更为好搭盒子\n\n5月的产品计划是增加了芝麻信用免押金、加入了人工客服、增加了引导页面，同时对于订单模块进行了较大规模的优化。\n\n这个版本是正式更名为好搭盒子，同时也进行了一定规模的投放。由于客户量增加导致暴露出了一个问题，就是由于信用免押金用户开始通过免押金进行订盒子，然后却不购买不退盒子。针对这个问题，当时唯一的号称“联系芝麻信用进行处罚”的措施，只有打电话追着用户。其实押金模式被ofo搞得臭名昭著，而不用押金，对我们这种小型公司，很难说控制用户的诚信度。我并不知道出问题的人的数量，但是我当时和产品沟通的时候，间接了解到了违规的人数其实不少。\n\n说实话小公司在扩大市场这一方面真的难，像衣盒这些，通过强制要求用户提交几百块的押金，然后还有钱进行市场投放，这样用户规模就算增长不快，起码不会出现这种大规模违规的现象。然而我们公司无法这样，如果加了押金一定会导致用户抵抗情绪上升，因此也会导致用户接受能力降低。不得已才采用免押的模式，然而没想到这个模式这么快就被打脸了。\n\n另外这个版本的商品展示，是机械的随机展示，权重并没有按照用户的喜好来。下拉过程中大概率出现是重复的商品。不过这个版本我将盒子的模式完全更改为内存存储的方式，优化掉了卡顿的问题。\n\n这个版本的评价不再是卡卡卡，而是商品数目不够，想买的一下子就没了。\n\n# 6月，app由简陋转变为精致\n\n整个六月，在连续更换2位ui之后，我们终于定下了ui的风格，并以此将页面逐个更新为新的风格。同时增加了专题和图文专题作为商品的展示模式。\n\n整个六月只发了一个版本，但是针对这个版本提交了300多笔。不过ui定稿总算是完成了，大家都很开心，风格的统一应该会带来用户的提升。\n\n至少当时都是这么想的。\n\n但是发出去之后，6月的数据并不是很好看，至少没有达到想象的那种程度。一方面是因为数据量上去了，但是货品并没有上去，二来是仓库物流erp系统有些问题，造成了比较多的延迟发货问题。当时在确认订货的时候，并不支持取消订单，大量用户操作失误寄出了盒子，但是并不想要，好的人直接退了，不好的就不管，或者收到了衣服拿出来。主打的学生人群感觉更容易出现这种情况，反正是造成了数据并不好看。\n\n6月出了一场比较严重的事故，由于在首页使用fragmentPageAdapter并且没有将缓存数据处理，导致app的内存在首页被消耗太多，因此导致了app极度卡顿。记忆中这个版本的anr达到了10%。事实上当时在测试的过程中就已经发现了这个问题，但是由于需要着急发版。每次卡着时间必须在周五发版，导致改版问题只看数量不看质量，这种质量事故其实很严重，但是产品很着急，老板很着急，开发很疲惫，测试很疲惫。\n\n说实话其实对于小型开发公司来讲，讲究质量是一件很不靠谱的事情，在质量做上来之前，说不定市场就转向了。我们要求是周一给任务，周二出图和接口，周三周四开始做，周五提测测试完毕。如果周五提测不行，周六就加班，最迟最迟是周六提版本。这种进度在一般时候其实是ok的，但是在大改动的时候，尤其是ui改了2周才给设计稿的时候，第三周要求我们弄出来，就会导致这种情况发生。\n\n当时我想了很多，发现其实无解，我们在提高自身效率，提升代码质量的时候，绝大部分时间都是在业务上面，而这种架构方面的问题真的很难发现并处理。很蛋疼。另外就是这种问题需要依赖测试的问题，在我们开发任务结束，开始进行bug修补的时候，这时候应该关注性能方面，然而没办法，这个时候都是和产品测试确定bug以及修改bug。这种性能优化的问题，每次都只能在发版之后，只有任务但是并没有接口和设计图的周一。于是乎我们因此发布了很多hotfix版本。\n\n# 7月，app增加了很多实用的功能\n\n首先是增加的功能，这个版本增加了收藏单品、2件打包、商品状态、匿名状态使用等功能。基本上每个都是在痛点上面的设计。另外移除了强制登陆的逻辑，这个也是痛点。\n\n这个版本的主要改动还是针对用户在使用产品的阶段遇到的问题。以前的用户由于刚开始使用，需要强制登陆，强制设置medel，成本比较高，这样会造成用户第一次使用成本过大，另外由于之前无法收藏，导致用户看到想要的不小心刷新之后再也没办法回到原来的状态，2件打包也是为了让用户更方便的打包盒子。整个设计的逻辑这个月都很简单明了，就是为了增加寄盒率。\n\n这个月我们的盒子也突破了1000个/月。app的uv也突破了1w。\n\n# 8月，人脸升级\n\n8月是融资之前的一个月，这个月紧锣密鼓的进行了很多的事情。具体在我8月份的git基本上没有任何提交就可以看出来。我们把ux完完整整的优化了一遍，同时将人脸也进行了一次升级作为一次融资的噱头。整个ux的优化持续了一个月，这次优化的细节主要体现在订单流程上面，订单流程增加了很多状态，同时对于用户退货的流程做了很大规模的退货。主要的初心我个人猜测就是因为之前退货的流程太过突兀，用户一来可能看不到退货的入口，二来退货过程中细节不好，导致用户可能不一定在这个页面会进行下去。\n\n总之这一版主要功能还是为了保障以购用户退货的过程能够顺畅而做出的优化，另外人脸识别算法部门提供了一个v2的版本，这个版本主要是将人脸从建模变成抠图，看起来仿佛是更好了。\n\n另外这个月是融资之前的一个月，8月末就正式启动了融资。\n\n# 9月，数据爆炸\n\n9月份市场做了很多推广的努力，外加运营部门做了一些调整，优化了搜索引擎，导致app那一阵用户量猛增，由平时的1万ui猛升到了8wuv，当时在appstore排行榜还占到了最热区域。但是服务器重建人脸的效率实在是太慢了，重建队列很多都是堵死状态，我们太依赖好买衣导致他们的缺点在我们这边无限的暴露。而且这个月好买衣的后端leader跑路，前端leader跑路，走之前特地嘱咐了我们服务器的问题。但是当时我们这边重心没有放在这个上面，服务器出现人脸丢失，黑脸，没头，还有没头发的问题，在之后的几个月基本上是无限爆出，我们这边后端压根不涉及这些，核心竞争力没法把握好，导致后续在后端的稳定性上面吃了大亏。\n\n不过9月是进入好搭之后感觉最兴奋的一个月，这一个月数据不断的刷新，让人感觉8月的加班是有意义的，而且这个月的盒子数也顺利的从之前的几百个，突破到了2000+个，至少对我们来讲，这一阶段的里程碑是达成了。\n\n# 10月，a轮找到金主\n\n10月由于是国庆节，外加母亲动手术，我大约半个月没有工作，这个月最繁忙的一周是a轮找到了金主之后的一周，投资人对我们提出了很多的要求，数据当时比较中庸，主要是加盒率和购买复购率比较低，而盒子数量和使用用户则比较好看。当时产品那边的想法是提高会员数量，这样可以使的会员转化率增加，会员的表现一直有比较高的复购和加盒转化率。\n\n当时介于商品本来缺货断码就比较严重，因此开辟了一个会员专区，专门提供给会员特供的商品。这个版本上去之后的数据并没有显示，但是uv开始逐渐的降低了，十月份到最后的时候，我记得uv从2万掉到了1万2左右。\n\n# 11月，强制用户登陆\n\n由于之前将强制登陆和设计medel的步骤给去掉了，导致很多用户在很低的时间成本下，反复叫盒子，然后不够买不寄回，这样导致很多衣服被薅羊毛薅走了。这个现象持续了好几个月，但是这个月开始对这个现象做处理。\n\n我们将新的强制登陆逻辑加上，为此付出了2周的开发周期，并且还delay了一次。但是中途也遇到了很多的问题，问题主要展现在关于medel的接口我们这边不是很了解，需要和好买衣沟通，另外就是服务器不稳定，导致线上环境建模总是失败，导致这样的强制引导很容易出现劝退现象。不过为了能够将羊毛党拒之门外，貌似我们在信用体系下可以做的也就是这样了。\n\n# 12月，融资失败\n\n到了12月，仿佛寒冬一下子来临了，各处裁员。\n\n刚开始以为融资都进入ts了，应该可以稳定，结果还是没躲过，12号的时候说投资人因为一些问题准备不投了，这就很蛋疼了，毕竟已经等了超过一个月的ts了，最后说不投，基本上就是断炊了。然后ceo去跑了一趟，回来之后说又融到了。但是比较神奇的是开始要求我们砍业务。砍掉盒子模式。\n\n很奇怪，融到了为什么要砍。结果吃饭的时候技术leader说其实并没有融到，ceo只是不想说而已。砍业务是因为吃不消损耗了，每个盒子都是亏的，用户热情还很高，这样钱吃不消使用。\n\n于是连我们12月在做的功能都连根拔掉了，砍掉了订单，盒子，支付，会员等等，最后要接上淘宝客，等于我们的版本绕了一圈，回到了1.9.3的版本了。\n\n哎。这样子，我们的好搭盒子就彻彻底底的死了。\n\n\n# 总结\n\n从开发者客观来讲，对这个产品是有感情的，当我来的时候，安卓组那个人准备离职，我在2个月的时间里面独自支撑着并不熟悉的项目。\n\n加班加点在好搭仿佛都是家常便饭，年中的时候统计了一下已经累计了10天的调休。\n\n可是有什么用呢？开发者仅仅是一把刀子，这个刀子或许锋利，或许迟钝，但是如果将锋利的刀子不断砍伐一些无用的东西，这有什么意义呢？\n\n刚开始的时候说我们暂时不需要考虑基础建设的问题，后端，前端，移动端，都是走一步看一步。后期发现基础建设出了问题的时候，却又浪费了大批量的时间来重构。创业公司感觉永远逃离不了这个魔咒。\n\n当听到一直维护的项目突然被砍掉，转成别的项目的时候。心里只有一声叹息。\n\n# 问题出在哪里？\n\n最近一直在想，leader离职的时候说过一句话，“论盒子模式，我们绝对是数据跑的好的”，但是为什么落的如此下场？\n\n## 信用模式\n\n盒子模式首先将衣服寄到了用户手里，然后让用户选择购买或者退回。这中间给了用户极大的自由，前期我们尚且能通过小规模投放来控制风险，后期接入了小红书推广，导致大量学生涌入，很多人仿佛占到了便宜似的拼命下盒子，下完了拿到货不退不购买，导致大量订单逾期坏单。造成了巨量的成本亏损。\n\n## 商品量不足\n\n由于是商城模式的app，对商品量的把控一定要比较高，但是从数据上来看，常年缺码SPU高达40%，造成了好衣服没货，坏衣服卖不出去的问题。加上前期并没有做好消息推送这个环节，对缺货商品的订阅上的过慢，也导致了大量用户的流失现象。\n\n## medel不够稳定\n\nmedel不够稳定是一直存在的问题，首先渲染消耗太多，最高每日光服务器就要跑掉2w块。其次是就算这样仍然不够稳定，不清楚是算法还是好买衣的问题，总是出现光头，绘制失败，没脸的问题。这个问题其实很严重，特别是我们这种主打虚拟试衣模式的app，基本上就是断腿了。\n\n这个问题其实是有解的，开始的时候就可以选择重构那边的代码。但是怎么讲呢，兵熊熊一个，将熊熊一窝，关于这个问题从我入职的时候每次会议必谈，直到leader来了之后禁止我们开会讨论这个。从开始leader就没有想重构，他或许想的是在半年内我们可以拿到a轮融资，之后可以选择完整的重构，或者是想着干脆就不重构了，等着别人来\n\n\n\n\n\n","slug":"2018-3-2018-12记产品死亡总结","published":1,"updated":"2019-03-12T09:26:33.133Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttzo005w3a8kmhwvv7dg","content":"<p>最近一阵没有写工作小结。并不是不想写，其实是发生了一些没有想到的事情。</p>\n<p>总而言之产品挂掉了。</p>\n<p>在我们这个团队，产品每日都想的是怎么往后推进，从来没有想过之前的行为为什么有问题。而对于我们开发来讲，基本上也都是上行下效，重心总是在技术上，而不会对产品产生质疑。关于失败的总结一直都是避而不谈，开会的话语中永远都是美好的未来。其实这也是失败的一个因素。</p>\n<p>我希望以我全程参与的开发者的身份，来对产品的死亡做一个总结。</p>\n<h1 id=\"3月，开始\"><a href=\"#3月，开始\" class=\"headerlink\" title=\"3月，开始\"></a>3月，开始</h1><p>3月的我加入了好搭，当时项目还没有改名为好搭盒子，app的版本停留在1.9.3，当时做的是导购的模式，通过淘宝客，租赁衣服进来生成模型，然后通过提供服务给用户，通过淘宝客来获取佣金。<br>由于老模式竞争很大，需要比较多的投入才能达到比较好的传播的目的，另外在用户上面，其实在当时的传播模式在当时是很有吸引力的，但是当时的效果做的并不是很好。再加上天使轮融资成功，需要抓紧从好买衣脱离，所以仿照了国外Stitch Fix上市的盒子模式，期望能通过虚拟形象加上盒子模式，给虚拟形象带来一个有效的传播。</p>\n<h1 id=\"4月，2-0版本上线\"><a href=\"#4月，2-0版本上线\" class=\"headerlink\" title=\"4月，2.0版本上线\"></a>4月，2.0版本上线</h1><p>由于以前从好买衣转来的后台，和上头吵翻了，因此上头决定新招一个后台，但是只招了一个后台。重构当时给了2周，但是到三月末还是没有好，后来又给了两周，一个月整后端接口好了。在4月中旬我们开启了app的大规模改版计划。</p>\n<p>起初是加上盒子，盒子模式需要增加加盒、地址、押金、付款、订单等模块，后续又加上了会员系统，另外在商品的展示阶段，刚开始使用的是单品+合集的模式，商品结合的是medel+单品展示的。改版很大，对于我来讲就是不日不夜的加了两周班。</p>\n<p>改版上线前遗留几个比较严重的问题，一个是盒子模式的本地保存和服务端保存冲突模式，服务端保存会导致加盒的模式很卡顿，加盒的过程需要验证服务器库存+操作本地盒子增加删减+push新的盒子到服务器+拉新的盒子到本地更新本地的衣服状态+本地存储新的盒子到sp。由于盒子的操作是一个很高频的模式，但是操作盒子带来的网络操作以及本地操作，当时验证需要大约400ms，而一次增加就会带来400ms的卡顿感，其实对用户来讲是十分不友好的。</p>\n<p>由于着急上线，盒子的模式就被直接忽略而直接在4月30号上线了。</p>\n<p>从现在的角度来看，当时如果能多用2天的时间，将整个盒子的模式改变一下，应该就不会有2.0版本评分从4.3掉到3.0的问题了。市场对2.0版本最大的评价就是卡。</p>\n<h1 id=\"5月-正式由好搭虚拟试衣变更为好搭盒子\"><a href=\"#5月-正式由好搭虚拟试衣变更为好搭盒子\" class=\"headerlink\" title=\"5月,正式由好搭虚拟试衣变更为好搭盒子\"></a>5月,正式由好搭虚拟试衣变更为好搭盒子</h1><p>5月的产品计划是增加了芝麻信用免押金、加入了人工客服、增加了引导页面，同时对于订单模块进行了较大规模的优化。</p>\n<p>这个版本是正式更名为好搭盒子，同时也进行了一定规模的投放。由于客户量增加导致暴露出了一个问题，就是由于信用免押金用户开始通过免押金进行订盒子，然后却不购买不退盒子。针对这个问题，当时唯一的号称“联系芝麻信用进行处罚”的措施，只有打电话追着用户。其实押金模式被ofo搞得臭名昭著，而不用押金，对我们这种小型公司，很难说控制用户的诚信度。我并不知道出问题的人的数量，但是我当时和产品沟通的时候，间接了解到了违规的人数其实不少。</p>\n<p>说实话小公司在扩大市场这一方面真的难，像衣盒这些，通过强制要求用户提交几百块的押金，然后还有钱进行市场投放，这样用户规模就算增长不快，起码不会出现这种大规模违规的现象。然而我们公司无法这样，如果加了押金一定会导致用户抵抗情绪上升，因此也会导致用户接受能力降低。不得已才采用免押的模式，然而没想到这个模式这么快就被打脸了。</p>\n<p>另外这个版本的商品展示，是机械的随机展示，权重并没有按照用户的喜好来。下拉过程中大概率出现是重复的商品。不过这个版本我将盒子的模式完全更改为内存存储的方式，优化掉了卡顿的问题。</p>\n<p>这个版本的评价不再是卡卡卡，而是商品数目不够，想买的一下子就没了。</p>\n<h1 id=\"6月，app由简陋转变为精致\"><a href=\"#6月，app由简陋转变为精致\" class=\"headerlink\" title=\"6月，app由简陋转变为精致\"></a>6月，app由简陋转变为精致</h1><p>整个六月，在连续更换2位ui之后，我们终于定下了ui的风格，并以此将页面逐个更新为新的风格。同时增加了专题和图文专题作为商品的展示模式。</p>\n<p>整个六月只发了一个版本，但是针对这个版本提交了300多笔。不过ui定稿总算是完成了，大家都很开心，风格的统一应该会带来用户的提升。</p>\n<p>至少当时都是这么想的。</p>\n<p>但是发出去之后，6月的数据并不是很好看，至少没有达到想象的那种程度。一方面是因为数据量上去了，但是货品并没有上去，二来是仓库物流erp系统有些问题，造成了比较多的延迟发货问题。当时在确认订货的时候，并不支持取消订单，大量用户操作失误寄出了盒子，但是并不想要，好的人直接退了，不好的就不管，或者收到了衣服拿出来。主打的学生人群感觉更容易出现这种情况，反正是造成了数据并不好看。</p>\n<p>6月出了一场比较严重的事故，由于在首页使用fragmentPageAdapter并且没有将缓存数据处理，导致app的内存在首页被消耗太多，因此导致了app极度卡顿。记忆中这个版本的anr达到了10%。事实上当时在测试的过程中就已经发现了这个问题，但是由于需要着急发版。每次卡着时间必须在周五发版，导致改版问题只看数量不看质量，这种质量事故其实很严重，但是产品很着急，老板很着急，开发很疲惫，测试很疲惫。</p>\n<p>说实话其实对于小型开发公司来讲，讲究质量是一件很不靠谱的事情，在质量做上来之前，说不定市场就转向了。我们要求是周一给任务，周二出图和接口，周三周四开始做，周五提测测试完毕。如果周五提测不行，周六就加班，最迟最迟是周六提版本。这种进度在一般时候其实是ok的，但是在大改动的时候，尤其是ui改了2周才给设计稿的时候，第三周要求我们弄出来，就会导致这种情况发生。</p>\n<p>当时我想了很多，发现其实无解，我们在提高自身效率，提升代码质量的时候，绝大部分时间都是在业务上面，而这种架构方面的问题真的很难发现并处理。很蛋疼。另外就是这种问题需要依赖测试的问题，在我们开发任务结束，开始进行bug修补的时候，这时候应该关注性能方面，然而没办法，这个时候都是和产品测试确定bug以及修改bug。这种性能优化的问题，每次都只能在发版之后，只有任务但是并没有接口和设计图的周一。于是乎我们因此发布了很多hotfix版本。</p>\n<h1 id=\"7月，app增加了很多实用的功能\"><a href=\"#7月，app增加了很多实用的功能\" class=\"headerlink\" title=\"7月，app增加了很多实用的功能\"></a>7月，app增加了很多实用的功能</h1><p>首先是增加的功能，这个版本增加了收藏单品、2件打包、商品状态、匿名状态使用等功能。基本上每个都是在痛点上面的设计。另外移除了强制登陆的逻辑，这个也是痛点。</p>\n<p>这个版本的主要改动还是针对用户在使用产品的阶段遇到的问题。以前的用户由于刚开始使用，需要强制登陆，强制设置medel，成本比较高，这样会造成用户第一次使用成本过大，另外由于之前无法收藏，导致用户看到想要的不小心刷新之后再也没办法回到原来的状态，2件打包也是为了让用户更方便的打包盒子。整个设计的逻辑这个月都很简单明了，就是为了增加寄盒率。</p>\n<p>这个月我们的盒子也突破了1000个/月。app的uv也突破了1w。</p>\n<h1 id=\"8月，人脸升级\"><a href=\"#8月，人脸升级\" class=\"headerlink\" title=\"8月，人脸升级\"></a>8月，人脸升级</h1><p>8月是融资之前的一个月，这个月紧锣密鼓的进行了很多的事情。具体在我8月份的git基本上没有任何提交就可以看出来。我们把ux完完整整的优化了一遍，同时将人脸也进行了一次升级作为一次融资的噱头。整个ux的优化持续了一个月，这次优化的细节主要体现在订单流程上面，订单流程增加了很多状态，同时对于用户退货的流程做了很大规模的退货。主要的初心我个人猜测就是因为之前退货的流程太过突兀，用户一来可能看不到退货的入口，二来退货过程中细节不好，导致用户可能不一定在这个页面会进行下去。</p>\n<p>总之这一版主要功能还是为了保障以购用户退货的过程能够顺畅而做出的优化，另外人脸识别算法部门提供了一个v2的版本，这个版本主要是将人脸从建模变成抠图，看起来仿佛是更好了。</p>\n<p>另外这个月是融资之前的一个月，8月末就正式启动了融资。</p>\n<h1 id=\"9月，数据爆炸\"><a href=\"#9月，数据爆炸\" class=\"headerlink\" title=\"9月，数据爆炸\"></a>9月，数据爆炸</h1><p>9月份市场做了很多推广的努力，外加运营部门做了一些调整，优化了搜索引擎，导致app那一阵用户量猛增，由平时的1万ui猛升到了8wuv，当时在appstore排行榜还占到了最热区域。但是服务器重建人脸的效率实在是太慢了，重建队列很多都是堵死状态，我们太依赖好买衣导致他们的缺点在我们这边无限的暴露。而且这个月好买衣的后端leader跑路，前端leader跑路，走之前特地嘱咐了我们服务器的问题。但是当时我们这边重心没有放在这个上面，服务器出现人脸丢失，黑脸，没头，还有没头发的问题，在之后的几个月基本上是无限爆出，我们这边后端压根不涉及这些，核心竞争力没法把握好，导致后续在后端的稳定性上面吃了大亏。</p>\n<p>不过9月是进入好搭之后感觉最兴奋的一个月，这一个月数据不断的刷新，让人感觉8月的加班是有意义的，而且这个月的盒子数也顺利的从之前的几百个，突破到了2000+个，至少对我们来讲，这一阶段的里程碑是达成了。</p>\n<h1 id=\"10月，a轮找到金主\"><a href=\"#10月，a轮找到金主\" class=\"headerlink\" title=\"10月，a轮找到金主\"></a>10月，a轮找到金主</h1><p>10月由于是国庆节，外加母亲动手术，我大约半个月没有工作，这个月最繁忙的一周是a轮找到了金主之后的一周，投资人对我们提出了很多的要求，数据当时比较中庸，主要是加盒率和购买复购率比较低，而盒子数量和使用用户则比较好看。当时产品那边的想法是提高会员数量，这样可以使的会员转化率增加，会员的表现一直有比较高的复购和加盒转化率。</p>\n<p>当时介于商品本来缺货断码就比较严重，因此开辟了一个会员专区，专门提供给会员特供的商品。这个版本上去之后的数据并没有显示，但是uv开始逐渐的降低了，十月份到最后的时候，我记得uv从2万掉到了1万2左右。</p>\n<h1 id=\"11月，强制用户登陆\"><a href=\"#11月，强制用户登陆\" class=\"headerlink\" title=\"11月，强制用户登陆\"></a>11月，强制用户登陆</h1><p>由于之前将强制登陆和设计medel的步骤给去掉了，导致很多用户在很低的时间成本下，反复叫盒子，然后不够买不寄回，这样导致很多衣服被薅羊毛薅走了。这个现象持续了好几个月，但是这个月开始对这个现象做处理。</p>\n<p>我们将新的强制登陆逻辑加上，为此付出了2周的开发周期，并且还delay了一次。但是中途也遇到了很多的问题，问题主要展现在关于medel的接口我们这边不是很了解，需要和好买衣沟通，另外就是服务器不稳定，导致线上环境建模总是失败，导致这样的强制引导很容易出现劝退现象。不过为了能够将羊毛党拒之门外，貌似我们在信用体系下可以做的也就是这样了。</p>\n<h1 id=\"12月，融资失败\"><a href=\"#12月，融资失败\" class=\"headerlink\" title=\"12月，融资失败\"></a>12月，融资失败</h1><p>到了12月，仿佛寒冬一下子来临了，各处裁员。</p>\n<p>刚开始以为融资都进入ts了，应该可以稳定，结果还是没躲过，12号的时候说投资人因为一些问题准备不投了，这就很蛋疼了，毕竟已经等了超过一个月的ts了，最后说不投，基本上就是断炊了。然后ceo去跑了一趟，回来之后说又融到了。但是比较神奇的是开始要求我们砍业务。砍掉盒子模式。</p>\n<p>很奇怪，融到了为什么要砍。结果吃饭的时候技术leader说其实并没有融到，ceo只是不想说而已。砍业务是因为吃不消损耗了，每个盒子都是亏的，用户热情还很高，这样钱吃不消使用。</p>\n<p>于是连我们12月在做的功能都连根拔掉了，砍掉了订单，盒子，支付，会员等等，最后要接上淘宝客，等于我们的版本绕了一圈，回到了1.9.3的版本了。</p>\n<p>哎。这样子，我们的好搭盒子就彻彻底底的死了。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>从开发者客观来讲，对这个产品是有感情的，当我来的时候，安卓组那个人准备离职，我在2个月的时间里面独自支撑着并不熟悉的项目。</p>\n<p>加班加点在好搭仿佛都是家常便饭，年中的时候统计了一下已经累计了10天的调休。</p>\n<p>可是有什么用呢？开发者仅仅是一把刀子，这个刀子或许锋利，或许迟钝，但是如果将锋利的刀子不断砍伐一些无用的东西，这有什么意义呢？</p>\n<p>刚开始的时候说我们暂时不需要考虑基础建设的问题，后端，前端，移动端，都是走一步看一步。后期发现基础建设出了问题的时候，却又浪费了大批量的时间来重构。创业公司感觉永远逃离不了这个魔咒。</p>\n<p>当听到一直维护的项目突然被砍掉，转成别的项目的时候。心里只有一声叹息。</p>\n<h1 id=\"问题出在哪里？\"><a href=\"#问题出在哪里？\" class=\"headerlink\" title=\"问题出在哪里？\"></a>问题出在哪里？</h1><p>最近一直在想，leader离职的时候说过一句话，“论盒子模式，我们绝对是数据跑的好的”，但是为什么落的如此下场？</p>\n<h2 id=\"信用模式\"><a href=\"#信用模式\" class=\"headerlink\" title=\"信用模式\"></a>信用模式</h2><p>盒子模式首先将衣服寄到了用户手里，然后让用户选择购买或者退回。这中间给了用户极大的自由，前期我们尚且能通过小规模投放来控制风险，后期接入了小红书推广，导致大量学生涌入，很多人仿佛占到了便宜似的拼命下盒子，下完了拿到货不退不购买，导致大量订单逾期坏单。造成了巨量的成本亏损。</p>\n<h2 id=\"商品量不足\"><a href=\"#商品量不足\" class=\"headerlink\" title=\"商品量不足\"></a>商品量不足</h2><p>由于是商城模式的app，对商品量的把控一定要比较高，但是从数据上来看，常年缺码SPU高达40%，造成了好衣服没货，坏衣服卖不出去的问题。加上前期并没有做好消息推送这个环节，对缺货商品的订阅上的过慢，也导致了大量用户的流失现象。</p>\n<h2 id=\"medel不够稳定\"><a href=\"#medel不够稳定\" class=\"headerlink\" title=\"medel不够稳定\"></a>medel不够稳定</h2><p>medel不够稳定是一直存在的问题，首先渲染消耗太多，最高每日光服务器就要跑掉2w块。其次是就算这样仍然不够稳定，不清楚是算法还是好买衣的问题，总是出现光头，绘制失败，没脸的问题。这个问题其实很严重，特别是我们这种主打虚拟试衣模式的app，基本上就是断腿了。</p>\n<p>这个问题其实是有解的，开始的时候就可以选择重构那边的代码。但是怎么讲呢，兵熊熊一个，将熊熊一窝，关于这个问题从我入职的时候每次会议必谈，直到leader来了之后禁止我们开会讨论这个。从开始leader就没有想重构，他或许想的是在半年内我们可以拿到a轮融资，之后可以选择完整的重构，或者是想着干脆就不重构了，等着别人来</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近一阵没有写工作小结。并不是不想写，其实是发生了一些没有想到的事情。</p>\n<p>总而言之产品挂掉了。</p>\n<p>在我们这个团队，产品每日都想的是怎么往后推进，从来没有想过之前的行为为什么有问题。而对于我们开发来讲，基本上也都是上行下效，重心总是在技术上，而不会对产品产生质疑。关于失败的总结一直都是避而不谈，开会的话语中永远都是美好的未来。其实这也是失败的一个因素。</p>\n<p>我希望以我全程参与的开发者的身份，来对产品的死亡做一个总结。</p>\n<h1 id=\"3月，开始\"><a href=\"#3月，开始\" class=\"headerlink\" title=\"3月，开始\"></a>3月，开始</h1><p>3月的我加入了好搭，当时项目还没有改名为好搭盒子，app的版本停留在1.9.3，当时做的是导购的模式，通过淘宝客，租赁衣服进来生成模型，然后通过提供服务给用户，通过淘宝客来获取佣金。<br>由于老模式竞争很大，需要比较多的投入才能达到比较好的传播的目的，另外在用户上面，其实在当时的传播模式在当时是很有吸引力的，但是当时的效果做的并不是很好。再加上天使轮融资成功，需要抓紧从好买衣脱离，所以仿照了国外Stitch Fix上市的盒子模式，期望能通过虚拟形象加上盒子模式，给虚拟形象带来一个有效的传播。</p>\n<h1 id=\"4月，2-0版本上线\"><a href=\"#4月，2-0版本上线\" class=\"headerlink\" title=\"4月，2.0版本上线\"></a>4月，2.0版本上线</h1><p>由于以前从好买衣转来的后台，和上头吵翻了，因此上头决定新招一个后台，但是只招了一个后台。重构当时给了2周，但是到三月末还是没有好，后来又给了两周，一个月整后端接口好了。在4月中旬我们开启了app的大规模改版计划。</p>\n<p>起初是加上盒子，盒子模式需要增加加盒、地址、押金、付款、订单等模块，后续又加上了会员系统，另外在商品的展示阶段，刚开始使用的是单品+合集的模式，商品结合的是medel+单品展示的。改版很大，对于我来讲就是不日不夜的加了两周班。</p>\n<p>改版上线前遗留几个比较严重的问题，一个是盒子模式的本地保存和服务端保存冲突模式，服务端保存会导致加盒的模式很卡顿，加盒的过程需要验证服务器库存+操作本地盒子增加删减+push新的盒子到服务器+拉新的盒子到本地更新本地的衣服状态+本地存储新的盒子到sp。由于盒子的操作是一个很高频的模式，但是操作盒子带来的网络操作以及本地操作，当时验证需要大约400ms，而一次增加就会带来400ms的卡顿感，其实对用户来讲是十分不友好的。</p>\n<p>由于着急上线，盒子的模式就被直接忽略而直接在4月30号上线了。</p>\n<p>从现在的角度来看，当时如果能多用2天的时间，将整个盒子的模式改变一下，应该就不会有2.0版本评分从4.3掉到3.0的问题了。市场对2.0版本最大的评价就是卡。</p>\n<h1 id=\"5月-正式由好搭虚拟试衣变更为好搭盒子\"><a href=\"#5月-正式由好搭虚拟试衣变更为好搭盒子\" class=\"headerlink\" title=\"5月,正式由好搭虚拟试衣变更为好搭盒子\"></a>5月,正式由好搭虚拟试衣变更为好搭盒子</h1><p>5月的产品计划是增加了芝麻信用免押金、加入了人工客服、增加了引导页面，同时对于订单模块进行了较大规模的优化。</p>\n<p>这个版本是正式更名为好搭盒子，同时也进行了一定规模的投放。由于客户量增加导致暴露出了一个问题，就是由于信用免押金用户开始通过免押金进行订盒子，然后却不购买不退盒子。针对这个问题，当时唯一的号称“联系芝麻信用进行处罚”的措施，只有打电话追着用户。其实押金模式被ofo搞得臭名昭著，而不用押金，对我们这种小型公司，很难说控制用户的诚信度。我并不知道出问题的人的数量，但是我当时和产品沟通的时候，间接了解到了违规的人数其实不少。</p>\n<p>说实话小公司在扩大市场这一方面真的难，像衣盒这些，通过强制要求用户提交几百块的押金，然后还有钱进行市场投放，这样用户规模就算增长不快，起码不会出现这种大规模违规的现象。然而我们公司无法这样，如果加了押金一定会导致用户抵抗情绪上升，因此也会导致用户接受能力降低。不得已才采用免押的模式，然而没想到这个模式这么快就被打脸了。</p>\n<p>另外这个版本的商品展示，是机械的随机展示，权重并没有按照用户的喜好来。下拉过程中大概率出现是重复的商品。不过这个版本我将盒子的模式完全更改为内存存储的方式，优化掉了卡顿的问题。</p>\n<p>这个版本的评价不再是卡卡卡，而是商品数目不够，想买的一下子就没了。</p>\n<h1 id=\"6月，app由简陋转变为精致\"><a href=\"#6月，app由简陋转变为精致\" class=\"headerlink\" title=\"6月，app由简陋转变为精致\"></a>6月，app由简陋转变为精致</h1><p>整个六月，在连续更换2位ui之后，我们终于定下了ui的风格，并以此将页面逐个更新为新的风格。同时增加了专题和图文专题作为商品的展示模式。</p>\n<p>整个六月只发了一个版本，但是针对这个版本提交了300多笔。不过ui定稿总算是完成了，大家都很开心，风格的统一应该会带来用户的提升。</p>\n<p>至少当时都是这么想的。</p>\n<p>但是发出去之后，6月的数据并不是很好看，至少没有达到想象的那种程度。一方面是因为数据量上去了，但是货品并没有上去，二来是仓库物流erp系统有些问题，造成了比较多的延迟发货问题。当时在确认订货的时候，并不支持取消订单，大量用户操作失误寄出了盒子，但是并不想要，好的人直接退了，不好的就不管，或者收到了衣服拿出来。主打的学生人群感觉更容易出现这种情况，反正是造成了数据并不好看。</p>\n<p>6月出了一场比较严重的事故，由于在首页使用fragmentPageAdapter并且没有将缓存数据处理，导致app的内存在首页被消耗太多，因此导致了app极度卡顿。记忆中这个版本的anr达到了10%。事实上当时在测试的过程中就已经发现了这个问题，但是由于需要着急发版。每次卡着时间必须在周五发版，导致改版问题只看数量不看质量，这种质量事故其实很严重，但是产品很着急，老板很着急，开发很疲惫，测试很疲惫。</p>\n<p>说实话其实对于小型开发公司来讲，讲究质量是一件很不靠谱的事情，在质量做上来之前，说不定市场就转向了。我们要求是周一给任务，周二出图和接口，周三周四开始做，周五提测测试完毕。如果周五提测不行，周六就加班，最迟最迟是周六提版本。这种进度在一般时候其实是ok的，但是在大改动的时候，尤其是ui改了2周才给设计稿的时候，第三周要求我们弄出来，就会导致这种情况发生。</p>\n<p>当时我想了很多，发现其实无解，我们在提高自身效率，提升代码质量的时候，绝大部分时间都是在业务上面，而这种架构方面的问题真的很难发现并处理。很蛋疼。另外就是这种问题需要依赖测试的问题，在我们开发任务结束，开始进行bug修补的时候，这时候应该关注性能方面，然而没办法，这个时候都是和产品测试确定bug以及修改bug。这种性能优化的问题，每次都只能在发版之后，只有任务但是并没有接口和设计图的周一。于是乎我们因此发布了很多hotfix版本。</p>\n<h1 id=\"7月，app增加了很多实用的功能\"><a href=\"#7月，app增加了很多实用的功能\" class=\"headerlink\" title=\"7月，app增加了很多实用的功能\"></a>7月，app增加了很多实用的功能</h1><p>首先是增加的功能，这个版本增加了收藏单品、2件打包、商品状态、匿名状态使用等功能。基本上每个都是在痛点上面的设计。另外移除了强制登陆的逻辑，这个也是痛点。</p>\n<p>这个版本的主要改动还是针对用户在使用产品的阶段遇到的问题。以前的用户由于刚开始使用，需要强制登陆，强制设置medel，成本比较高，这样会造成用户第一次使用成本过大，另外由于之前无法收藏，导致用户看到想要的不小心刷新之后再也没办法回到原来的状态，2件打包也是为了让用户更方便的打包盒子。整个设计的逻辑这个月都很简单明了，就是为了增加寄盒率。</p>\n<p>这个月我们的盒子也突破了1000个/月。app的uv也突破了1w。</p>\n<h1 id=\"8月，人脸升级\"><a href=\"#8月，人脸升级\" class=\"headerlink\" title=\"8月，人脸升级\"></a>8月，人脸升级</h1><p>8月是融资之前的一个月，这个月紧锣密鼓的进行了很多的事情。具体在我8月份的git基本上没有任何提交就可以看出来。我们把ux完完整整的优化了一遍，同时将人脸也进行了一次升级作为一次融资的噱头。整个ux的优化持续了一个月，这次优化的细节主要体现在订单流程上面，订单流程增加了很多状态，同时对于用户退货的流程做了很大规模的退货。主要的初心我个人猜测就是因为之前退货的流程太过突兀，用户一来可能看不到退货的入口，二来退货过程中细节不好，导致用户可能不一定在这个页面会进行下去。</p>\n<p>总之这一版主要功能还是为了保障以购用户退货的过程能够顺畅而做出的优化，另外人脸识别算法部门提供了一个v2的版本，这个版本主要是将人脸从建模变成抠图，看起来仿佛是更好了。</p>\n<p>另外这个月是融资之前的一个月，8月末就正式启动了融资。</p>\n<h1 id=\"9月，数据爆炸\"><a href=\"#9月，数据爆炸\" class=\"headerlink\" title=\"9月，数据爆炸\"></a>9月，数据爆炸</h1><p>9月份市场做了很多推广的努力，外加运营部门做了一些调整，优化了搜索引擎，导致app那一阵用户量猛增，由平时的1万ui猛升到了8wuv，当时在appstore排行榜还占到了最热区域。但是服务器重建人脸的效率实在是太慢了，重建队列很多都是堵死状态，我们太依赖好买衣导致他们的缺点在我们这边无限的暴露。而且这个月好买衣的后端leader跑路，前端leader跑路，走之前特地嘱咐了我们服务器的问题。但是当时我们这边重心没有放在这个上面，服务器出现人脸丢失，黑脸，没头，还有没头发的问题，在之后的几个月基本上是无限爆出，我们这边后端压根不涉及这些，核心竞争力没法把握好，导致后续在后端的稳定性上面吃了大亏。</p>\n<p>不过9月是进入好搭之后感觉最兴奋的一个月，这一个月数据不断的刷新，让人感觉8月的加班是有意义的，而且这个月的盒子数也顺利的从之前的几百个，突破到了2000+个，至少对我们来讲，这一阶段的里程碑是达成了。</p>\n<h1 id=\"10月，a轮找到金主\"><a href=\"#10月，a轮找到金主\" class=\"headerlink\" title=\"10月，a轮找到金主\"></a>10月，a轮找到金主</h1><p>10月由于是国庆节，外加母亲动手术，我大约半个月没有工作，这个月最繁忙的一周是a轮找到了金主之后的一周，投资人对我们提出了很多的要求，数据当时比较中庸，主要是加盒率和购买复购率比较低，而盒子数量和使用用户则比较好看。当时产品那边的想法是提高会员数量，这样可以使的会员转化率增加，会员的表现一直有比较高的复购和加盒转化率。</p>\n<p>当时介于商品本来缺货断码就比较严重，因此开辟了一个会员专区，专门提供给会员特供的商品。这个版本上去之后的数据并没有显示，但是uv开始逐渐的降低了，十月份到最后的时候，我记得uv从2万掉到了1万2左右。</p>\n<h1 id=\"11月，强制用户登陆\"><a href=\"#11月，强制用户登陆\" class=\"headerlink\" title=\"11月，强制用户登陆\"></a>11月，强制用户登陆</h1><p>由于之前将强制登陆和设计medel的步骤给去掉了，导致很多用户在很低的时间成本下，反复叫盒子，然后不够买不寄回，这样导致很多衣服被薅羊毛薅走了。这个现象持续了好几个月，但是这个月开始对这个现象做处理。</p>\n<p>我们将新的强制登陆逻辑加上，为此付出了2周的开发周期，并且还delay了一次。但是中途也遇到了很多的问题，问题主要展现在关于medel的接口我们这边不是很了解，需要和好买衣沟通，另外就是服务器不稳定，导致线上环境建模总是失败，导致这样的强制引导很容易出现劝退现象。不过为了能够将羊毛党拒之门外，貌似我们在信用体系下可以做的也就是这样了。</p>\n<h1 id=\"12月，融资失败\"><a href=\"#12月，融资失败\" class=\"headerlink\" title=\"12月，融资失败\"></a>12月，融资失败</h1><p>到了12月，仿佛寒冬一下子来临了，各处裁员。</p>\n<p>刚开始以为融资都进入ts了，应该可以稳定，结果还是没躲过，12号的时候说投资人因为一些问题准备不投了，这就很蛋疼了，毕竟已经等了超过一个月的ts了，最后说不投，基本上就是断炊了。然后ceo去跑了一趟，回来之后说又融到了。但是比较神奇的是开始要求我们砍业务。砍掉盒子模式。</p>\n<p>很奇怪，融到了为什么要砍。结果吃饭的时候技术leader说其实并没有融到，ceo只是不想说而已。砍业务是因为吃不消损耗了，每个盒子都是亏的，用户热情还很高，这样钱吃不消使用。</p>\n<p>于是连我们12月在做的功能都连根拔掉了，砍掉了订单，盒子，支付，会员等等，最后要接上淘宝客，等于我们的版本绕了一圈，回到了1.9.3的版本了。</p>\n<p>哎。这样子，我们的好搭盒子就彻彻底底的死了。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>从开发者客观来讲，对这个产品是有感情的，当我来的时候，安卓组那个人准备离职，我在2个月的时间里面独自支撑着并不熟悉的项目。</p>\n<p>加班加点在好搭仿佛都是家常便饭，年中的时候统计了一下已经累计了10天的调休。</p>\n<p>可是有什么用呢？开发者仅仅是一把刀子，这个刀子或许锋利，或许迟钝，但是如果将锋利的刀子不断砍伐一些无用的东西，这有什么意义呢？</p>\n<p>刚开始的时候说我们暂时不需要考虑基础建设的问题，后端，前端，移动端，都是走一步看一步。后期发现基础建设出了问题的时候，却又浪费了大批量的时间来重构。创业公司感觉永远逃离不了这个魔咒。</p>\n<p>当听到一直维护的项目突然被砍掉，转成别的项目的时候。心里只有一声叹息。</p>\n<h1 id=\"问题出在哪里？\"><a href=\"#问题出在哪里？\" class=\"headerlink\" title=\"问题出在哪里？\"></a>问题出在哪里？</h1><p>最近一直在想，leader离职的时候说过一句话，“论盒子模式，我们绝对是数据跑的好的”，但是为什么落的如此下场？</p>\n<h2 id=\"信用模式\"><a href=\"#信用模式\" class=\"headerlink\" title=\"信用模式\"></a>信用模式</h2><p>盒子模式首先将衣服寄到了用户手里，然后让用户选择购买或者退回。这中间给了用户极大的自由，前期我们尚且能通过小规模投放来控制风险，后期接入了小红书推广，导致大量学生涌入，很多人仿佛占到了便宜似的拼命下盒子，下完了拿到货不退不购买，导致大量订单逾期坏单。造成了巨量的成本亏损。</p>\n<h2 id=\"商品量不足\"><a href=\"#商品量不足\" class=\"headerlink\" title=\"商品量不足\"></a>商品量不足</h2><p>由于是商城模式的app，对商品量的把控一定要比较高，但是从数据上来看，常年缺码SPU高达40%，造成了好衣服没货，坏衣服卖不出去的问题。加上前期并没有做好消息推送这个环节，对缺货商品的订阅上的过慢，也导致了大量用户的流失现象。</p>\n<h2 id=\"medel不够稳定\"><a href=\"#medel不够稳定\" class=\"headerlink\" title=\"medel不够稳定\"></a>medel不够稳定</h2><p>medel不够稳定是一直存在的问题，首先渲染消耗太多，最高每日光服务器就要跑掉2w块。其次是就算这样仍然不够稳定，不清楚是算法还是好买衣的问题，总是出现光头，绘制失败，没脸的问题。这个问题其实很严重，特别是我们这种主打虚拟试衣模式的app，基本上就是断腿了。</p>\n<p>这个问题其实是有解的，开始的时候就可以选择重构那边的代码。但是怎么讲呢，兵熊熊一个，将熊熊一窝，关于这个问题从我入职的时候每次会议必谈，直到leader来了之后禁止我们开会讨论这个。从开始leader就没有想重构，他或许想的是在半年内我们可以拿到a轮融资，之后可以选择完整的重构，或者是想着干脆就不重构了，等着别人来</p>\n"},{"title":"2018八月-第三十一周到三十五周-工作小结","date":"2018-08-29T10:37:05.000Z","_content":"\n这个月都没有写小结，发生了很多事情，都没有来的及记录。\n\n首先是公司进入了a轮的加速期，为了提高转化率使投资人满意，所有人都进入了8月的倒计时奋战期。其实和之前差不多，唯一变的是每周一开需求大会，之前都会假意征求一下开发的意见，现在这个流程也省略了。\n\n其次是由于好几个前端跑路，导致之前做的很多动态页面需要本地化，也相当于增加了业务量。\n\n这个月基本上是围绕着优化，订单来工作的。\n\n首先讲讲优化。\n\n- ui优化\n\napp在oppor9m上面贼卡，一方面是过度绘制比较严重，二方面是内存泄漏比较严重。之前写布局很多地方都用的relativylayout或者framelayout，嵌套比较严重，红色过度绘制的区域十分多，查看gpu绘制，发现滑动的时候绘制较多，在专题详情页面尤其明显。\n\n-- 过度绘制\n\n因此对主要流程，主要流程的卡顿页面做了调整，完全按照constraintlayout的设计规则，无论多复杂的布局，统一使用一层或者2层（带scrollview）的布局结构。写的十分顺畅，使用的过程中完善了我对于constraintlayout的理解，包括guideline，group，基准点等。constraintlayou有一个问题，就是背景问题，以往的情况下，习惯性的使用linearlayout，或者部分布局包装，然后针对包装布局进行背景设置，但是在constraintlayout下面，其实单层布局不是很好设置背景，只可以使用单独的一层view来在之前设置，但是view的下方padding就有一些问题，尤其是在提前布局的情况下。针对这个情况，我通过guideline和viewtip来解决，不过这样多了很多奇怪的点，这些点也只可以通过group来进行布局的绑定。\n\n整个constraintlayout给我的感觉，是牺牲了逻辑效率，带来布局效率，很多的逻辑牵扯在的xml中，而代码中我们一般指判断view是否显示，但是这样就会导致xml中的部分逻辑在不显示的情况下，产生了偏差。因此我觉得在大多数遇到逻辑复杂的布局排列中，还是不要轻易强行单层布局，逻辑偏差带来的时间损失，绝对比使用嵌套布局之后在进行代码优化的多。\n\n-- bitmap大图\n\n由于我们的项目就是围绕着人脸，身材，妆容这些来进行的，这些无一例外都是bitmap的使用者。\n\n整合人脸，整合身材，整合妆容之后形成的完整的人模型，原本需要占用大约5m的内存。在优化之前，很多地方使用的是fragmentpageradapter，每个fragment持有很多的bitmap，当时算了一下，一个framgent如果在不上滑加载更多的时候，会持有8个bitmap对象，就是约40m内存。\n\n在2.1.3版本上面，anr的发生率提高到了14%，绝大多数都是在首页滑动的时候产生的卡死。\n\n针对这个问题，也做了针对性的优化。首先是使用fragmentstatepageradapter，这样可以在fragment进入销毁流程的时候，释放引用而让他自然销毁。这样首先是切换的时候内存占用问题解决了。\n\n其次是单fragment下滑导致的内存占用问题。刚开始使用的recyclerview，为了让用户有比较好的体验（雾），而将最大item设为了20（大雾）。这下子用户上滑超过20个，光bitmap 的占用率就飙升到了100m，还不谈item的其他内存占用问题。在一般的华为和oppo手机上面，光这项就吃掉了分给app的50%以上的内存。基本上这个时候如果系统在吃点内存，app就anr了。\n\n因此针对这个问题，想到的是动态持有，根据可用内存堆分配来实时更新缓存堆的内容。使用的是比较常见的lrucache，但是这个lrucache只缓存了bitmap的信息，item其余的信息就直接释放了，这样动态缓存1/4最大内存堆的内存，同时也保证了bitmap加载不会有太多的问题。\n\n使用缓存有个小问题，就是强制刷新的时候不注意的话其实是无法清除的，强制刷新的时候得clearcache。\n\n-- bimap色深\n\n在解决了缓存占用问题之后，基于bitmap的内存问题其实得到了很大的解决。但是仍然有一个巨大的问题，就是bitmap的加载速度。\n\n即使缓存到lrucache里面，也得首先下载下来，在普通4g网大约200K下载速度的时候，一张基准图下载需要大约0.5-1秒，但是经过渲染和加载，总共大约需要1.5秒的样子才可以呈现，这个速度实在是很慢。\n\n处理这个的问题一般就是从图片质量上面入手，图片存储方式一般是写死的，虽然我们使用的是oss，可以通过传递参数到服务器，来获取不同的图片大小，但是在做到这个地步之后，就是图像的渲染，也就是从网上下载的数据映射到bitmap上面的这个过程。\n\n一般的bitmap是rgb888，一个像素占3Byte，我用的手机5.5英寸，1080x1920像素，一般图片设置大约140dp宽高，也就是约420x420像素，占用内存就是420x420x3 = 516K,jpg的压缩率我不是很清楚，大约在10%-90%之间，也就是这么一个呈现为516k的图片，大约需要下载5-50k之间的样子，专题详情页面的大图，宽度是130dp，高度是400dp，就一下子扩了将近3倍，下载如果在200k就要全速一秒了。\n\n流量并不是很关心的事情，下载其实也不是很关心的事情，因为我无法决定用户的网速，那是framework的事情，我只可以确保下载的内容到本机能够快速加载出来。因此采取的措施是压缩色深，从rgb888，压缩到rgb565，然后压缩到了rgb444。图片质量压缩到如此之低，基本上是能接受的极限了。改完之后速度大约快了一点，加载的时候下载完的条结束就可以出来了。\n\n-- 主线程任务过多引起的卡顿\n\n在sku详情页面，逻辑是这样的，2线并行，1线先请求人体数据，人体数据的返回值会引起整个页面结构的初始化，2线后行，直接请求sku的数据，进行数据的web填充。问题出现在这两条线都涉及到了ui的修改，所以都跑在主线程，还有个问题是双线有依赖，会导致加载的时候互相调用，而在安卓中很少对于view进行上锁措施，因此此时的操作极为繁琐，而且卡顿及其严重。\n\n针对此问题主要是优化主线程任务措施，rxjava中其实还是比较好做的，一来使用concat操作符，二来在数据初始化的步骤可以放到子线程，之后实现的操作可以放到主线程，逻辑复杂的部分可以放在子线程，结果传到主线程。（此处mark一下，需要对rxjava的原理做个完整的学习）\n\n双线我通过整合成为单线，然后线程切换的方式，加载速度，滑动速度响应都足够了。\n\n- 性能优化\n\n-- 内存泄漏\n\n之前项目中整合了lecancary，每次gc和泄漏的时候会弹出提示，但是在项目中的表现并不好，一来是fragment和activity的多层引用，基类中有很多资源持有引用，而这些引用是后来自己手动释放的，但是在lecancary中就会爆这些引用泄漏了，其二是我们所有的网络代码通过clean的结构，在最顶层使用dagger来解耦，因此造成了在ondestroy过程中会销毁，但是切换过程中并不会销毁。切换的过程需要等待，但是这个过程已经造成了泄漏。\n\n采取的措施比较粗暴，就是直接在切换的时候触发presenter的destroy方法，这样切换的时候，会先关闭引用，之后在切换，切换之后销毁自己，这就是比较正常的过程了。\n\n-- oom\n\noom的问题就如同bitmap大图的问题，掠过不讲\n\n\n- 订单流程\n\n整个订单流程进行了完整的更新，大部分计算价格的部分给予后台来处理，不在由前端显示相关内容，对于我们来讲逻辑更新容易很多。出问题的地方是由于都给予后台显示了，前端势必要判断是否成功，失败的处理逻辑等等。因此针对网络失败的地方做了处理\n\n```\nprivate void handleHttpError(Throwable e){\n        if (e instanceof RuntimeException){\n            if (e.getCause() instanceof ConnectException){\n                mEventBus.post(new OnHttpErrorEvent(\"连接失败，请检查网络后再试\"));\n            }\n            if (e.getCause() instanceof SocketTimeoutException){\n                mEventBus.post(new OnHttpErrorEvent(\"请求超时，请检查网络后再试\"));\n            }\n            if (e.getCause() instanceof UnknownHostException){\n                mEventBus.post(new OnHttpErrorEvent(\"域名连接失败，请检查网络后再试\"));\n            }\n            if (e.getCause() instanceof NetworkErrorException){\n                mEventBus.post(new OnHttpErrorEvent(\"网络异常，请检查网络后再试\"));\n            }\n        }\n        if (e instanceof ConnectException){\n            mEventBus.post(new OnHttpErrorEvent(\"连接失败，请检查网络后再试\"));\n        }\n        if (e instanceof SocketTimeoutException){\n            mEventBus.post(new OnHttpErrorEvent(\"请求超时，请检查网络后再试\"));\n        }\n        if (e instanceof UnknownHostException){\n            mEventBus.post(new OnHttpErrorEvent(\"域名连接失败，请检查网络后再试\"));\n        }\n        if (e instanceof NetworkErrorException){\n            mEventBus.post(new OnHttpErrorEvent(\"网络异常，请检查网络后再试\"));\n        }\n    }\n```\n处理方式如上，主要是针对rxjava网络异常的各个问题进行鉴别性操作，然后根据不同的类型显示不同的页面。\n\n大致分了2种页面，一种是正常的失败，没有数据的那种，叫emptyview，还有一种就是网络失败的，叫errorview，都是可以抽出来单独做的。\n\n除此之外由于大多都是业务方面的内容，可总结的比较少。\n\n能够抽出来说的有一点，是优惠卷的ui处理方面，一般是使用recyclerview，但是由于用户的优惠卷比较少，我使用的是普通的linearlayout，通过addview来进行加载视图，问题是无法通过recyclerview那种通过一张表来更改数据和view。我需要维护2个表，一个是选中的view表，一个是所有的view表，每次点击的时候需要从选中表中进行遍历，然后处理一些关于选中优惠卷的县骨干内容，本次版本主要是互斥卷和叠加卷的逻辑问题。处理完之后会重新刷新选中表。这样一定程度上是牺牲了代码简洁，而照顾了加载速度。其实recyclerview也有很多bug，比如说每次notifydatasetchanged，数据源变更会强制触发重新刷新的功能，这就不适合数据源并不多的情况。而且recycerview本身作为一个较为重型的控件，处理单纯的几个view，有些大材小用。\n\n\n大致如上，四周都没什么时间好好整理一下，做项目的时候总是想着要总结总结，但是到了要总结的时候，仿佛踩过的坑，处理过的问题，都一下子不见了。脑袋里就剩下了最近处理的一些问题。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2018八月-第三十一周到三十五周-工作小结.md","raw":"---\ntitle: 2018八月-第三十一周到三十五周-工作小结\ndate: 2018-08-29 18:37:05\ntags: 工作小结\n---\n\n这个月都没有写小结，发生了很多事情，都没有来的及记录。\n\n首先是公司进入了a轮的加速期，为了提高转化率使投资人满意，所有人都进入了8月的倒计时奋战期。其实和之前差不多，唯一变的是每周一开需求大会，之前都会假意征求一下开发的意见，现在这个流程也省略了。\n\n其次是由于好几个前端跑路，导致之前做的很多动态页面需要本地化，也相当于增加了业务量。\n\n这个月基本上是围绕着优化，订单来工作的。\n\n首先讲讲优化。\n\n- ui优化\n\napp在oppor9m上面贼卡，一方面是过度绘制比较严重，二方面是内存泄漏比较严重。之前写布局很多地方都用的relativylayout或者framelayout，嵌套比较严重，红色过度绘制的区域十分多，查看gpu绘制，发现滑动的时候绘制较多，在专题详情页面尤其明显。\n\n-- 过度绘制\n\n因此对主要流程，主要流程的卡顿页面做了调整，完全按照constraintlayout的设计规则，无论多复杂的布局，统一使用一层或者2层（带scrollview）的布局结构。写的十分顺畅，使用的过程中完善了我对于constraintlayout的理解，包括guideline，group，基准点等。constraintlayou有一个问题，就是背景问题，以往的情况下，习惯性的使用linearlayout，或者部分布局包装，然后针对包装布局进行背景设置，但是在constraintlayout下面，其实单层布局不是很好设置背景，只可以使用单独的一层view来在之前设置，但是view的下方padding就有一些问题，尤其是在提前布局的情况下。针对这个情况，我通过guideline和viewtip来解决，不过这样多了很多奇怪的点，这些点也只可以通过group来进行布局的绑定。\n\n整个constraintlayout给我的感觉，是牺牲了逻辑效率，带来布局效率，很多的逻辑牵扯在的xml中，而代码中我们一般指判断view是否显示，但是这样就会导致xml中的部分逻辑在不显示的情况下，产生了偏差。因此我觉得在大多数遇到逻辑复杂的布局排列中，还是不要轻易强行单层布局，逻辑偏差带来的时间损失，绝对比使用嵌套布局之后在进行代码优化的多。\n\n-- bitmap大图\n\n由于我们的项目就是围绕着人脸，身材，妆容这些来进行的，这些无一例外都是bitmap的使用者。\n\n整合人脸，整合身材，整合妆容之后形成的完整的人模型，原本需要占用大约5m的内存。在优化之前，很多地方使用的是fragmentpageradapter，每个fragment持有很多的bitmap，当时算了一下，一个framgent如果在不上滑加载更多的时候，会持有8个bitmap对象，就是约40m内存。\n\n在2.1.3版本上面，anr的发生率提高到了14%，绝大多数都是在首页滑动的时候产生的卡死。\n\n针对这个问题，也做了针对性的优化。首先是使用fragmentstatepageradapter，这样可以在fragment进入销毁流程的时候，释放引用而让他自然销毁。这样首先是切换的时候内存占用问题解决了。\n\n其次是单fragment下滑导致的内存占用问题。刚开始使用的recyclerview，为了让用户有比较好的体验（雾），而将最大item设为了20（大雾）。这下子用户上滑超过20个，光bitmap 的占用率就飙升到了100m，还不谈item的其他内存占用问题。在一般的华为和oppo手机上面，光这项就吃掉了分给app的50%以上的内存。基本上这个时候如果系统在吃点内存，app就anr了。\n\n因此针对这个问题，想到的是动态持有，根据可用内存堆分配来实时更新缓存堆的内容。使用的是比较常见的lrucache，但是这个lrucache只缓存了bitmap的信息，item其余的信息就直接释放了，这样动态缓存1/4最大内存堆的内存，同时也保证了bitmap加载不会有太多的问题。\n\n使用缓存有个小问题，就是强制刷新的时候不注意的话其实是无法清除的，强制刷新的时候得clearcache。\n\n-- bimap色深\n\n在解决了缓存占用问题之后，基于bitmap的内存问题其实得到了很大的解决。但是仍然有一个巨大的问题，就是bitmap的加载速度。\n\n即使缓存到lrucache里面，也得首先下载下来，在普通4g网大约200K下载速度的时候，一张基准图下载需要大约0.5-1秒，但是经过渲染和加载，总共大约需要1.5秒的样子才可以呈现，这个速度实在是很慢。\n\n处理这个的问题一般就是从图片质量上面入手，图片存储方式一般是写死的，虽然我们使用的是oss，可以通过传递参数到服务器，来获取不同的图片大小，但是在做到这个地步之后，就是图像的渲染，也就是从网上下载的数据映射到bitmap上面的这个过程。\n\n一般的bitmap是rgb888，一个像素占3Byte，我用的手机5.5英寸，1080x1920像素，一般图片设置大约140dp宽高，也就是约420x420像素，占用内存就是420x420x3 = 516K,jpg的压缩率我不是很清楚，大约在10%-90%之间，也就是这么一个呈现为516k的图片，大约需要下载5-50k之间的样子，专题详情页面的大图，宽度是130dp，高度是400dp，就一下子扩了将近3倍，下载如果在200k就要全速一秒了。\n\n流量并不是很关心的事情，下载其实也不是很关心的事情，因为我无法决定用户的网速，那是framework的事情，我只可以确保下载的内容到本机能够快速加载出来。因此采取的措施是压缩色深，从rgb888，压缩到rgb565，然后压缩到了rgb444。图片质量压缩到如此之低，基本上是能接受的极限了。改完之后速度大约快了一点，加载的时候下载完的条结束就可以出来了。\n\n-- 主线程任务过多引起的卡顿\n\n在sku详情页面，逻辑是这样的，2线并行，1线先请求人体数据，人体数据的返回值会引起整个页面结构的初始化，2线后行，直接请求sku的数据，进行数据的web填充。问题出现在这两条线都涉及到了ui的修改，所以都跑在主线程，还有个问题是双线有依赖，会导致加载的时候互相调用，而在安卓中很少对于view进行上锁措施，因此此时的操作极为繁琐，而且卡顿及其严重。\n\n针对此问题主要是优化主线程任务措施，rxjava中其实还是比较好做的，一来使用concat操作符，二来在数据初始化的步骤可以放到子线程，之后实现的操作可以放到主线程，逻辑复杂的部分可以放在子线程，结果传到主线程。（此处mark一下，需要对rxjava的原理做个完整的学习）\n\n双线我通过整合成为单线，然后线程切换的方式，加载速度，滑动速度响应都足够了。\n\n- 性能优化\n\n-- 内存泄漏\n\n之前项目中整合了lecancary，每次gc和泄漏的时候会弹出提示，但是在项目中的表现并不好，一来是fragment和activity的多层引用，基类中有很多资源持有引用，而这些引用是后来自己手动释放的，但是在lecancary中就会爆这些引用泄漏了，其二是我们所有的网络代码通过clean的结构，在最顶层使用dagger来解耦，因此造成了在ondestroy过程中会销毁，但是切换过程中并不会销毁。切换的过程需要等待，但是这个过程已经造成了泄漏。\n\n采取的措施比较粗暴，就是直接在切换的时候触发presenter的destroy方法，这样切换的时候，会先关闭引用，之后在切换，切换之后销毁自己，这就是比较正常的过程了。\n\n-- oom\n\noom的问题就如同bitmap大图的问题，掠过不讲\n\n\n- 订单流程\n\n整个订单流程进行了完整的更新，大部分计算价格的部分给予后台来处理，不在由前端显示相关内容，对于我们来讲逻辑更新容易很多。出问题的地方是由于都给予后台显示了，前端势必要判断是否成功，失败的处理逻辑等等。因此针对网络失败的地方做了处理\n\n```\nprivate void handleHttpError(Throwable e){\n        if (e instanceof RuntimeException){\n            if (e.getCause() instanceof ConnectException){\n                mEventBus.post(new OnHttpErrorEvent(\"连接失败，请检查网络后再试\"));\n            }\n            if (e.getCause() instanceof SocketTimeoutException){\n                mEventBus.post(new OnHttpErrorEvent(\"请求超时，请检查网络后再试\"));\n            }\n            if (e.getCause() instanceof UnknownHostException){\n                mEventBus.post(new OnHttpErrorEvent(\"域名连接失败，请检查网络后再试\"));\n            }\n            if (e.getCause() instanceof NetworkErrorException){\n                mEventBus.post(new OnHttpErrorEvent(\"网络异常，请检查网络后再试\"));\n            }\n        }\n        if (e instanceof ConnectException){\n            mEventBus.post(new OnHttpErrorEvent(\"连接失败，请检查网络后再试\"));\n        }\n        if (e instanceof SocketTimeoutException){\n            mEventBus.post(new OnHttpErrorEvent(\"请求超时，请检查网络后再试\"));\n        }\n        if (e instanceof UnknownHostException){\n            mEventBus.post(new OnHttpErrorEvent(\"域名连接失败，请检查网络后再试\"));\n        }\n        if (e instanceof NetworkErrorException){\n            mEventBus.post(new OnHttpErrorEvent(\"网络异常，请检查网络后再试\"));\n        }\n    }\n```\n处理方式如上，主要是针对rxjava网络异常的各个问题进行鉴别性操作，然后根据不同的类型显示不同的页面。\n\n大致分了2种页面，一种是正常的失败，没有数据的那种，叫emptyview，还有一种就是网络失败的，叫errorview，都是可以抽出来单独做的。\n\n除此之外由于大多都是业务方面的内容，可总结的比较少。\n\n能够抽出来说的有一点，是优惠卷的ui处理方面，一般是使用recyclerview，但是由于用户的优惠卷比较少，我使用的是普通的linearlayout，通过addview来进行加载视图，问题是无法通过recyclerview那种通过一张表来更改数据和view。我需要维护2个表，一个是选中的view表，一个是所有的view表，每次点击的时候需要从选中表中进行遍历，然后处理一些关于选中优惠卷的县骨干内容，本次版本主要是互斥卷和叠加卷的逻辑问题。处理完之后会重新刷新选中表。这样一定程度上是牺牲了代码简洁，而照顾了加载速度。其实recyclerview也有很多bug，比如说每次notifydatasetchanged，数据源变更会强制触发重新刷新的功能，这就不适合数据源并不多的情况。而且recycerview本身作为一个较为重型的控件，处理单纯的几个view，有些大材小用。\n\n\n大致如上，四周都没什么时间好好整理一下，做项目的时候总是想着要总结总结，但是到了要总结的时候，仿佛踩过的坑，处理过的问题，都一下子不见了。脑袋里就剩下了最近处理的一些问题。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2018八月-第三十一周到三十五周-工作小结","published":1,"updated":"2019-03-12T09:26:33.135Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttzp005x3a8kcklxi5wb","content":"<p>这个月都没有写小结，发生了很多事情，都没有来的及记录。</p>\n<p>首先是公司进入了a轮的加速期，为了提高转化率使投资人满意，所有人都进入了8月的倒计时奋战期。其实和之前差不多，唯一变的是每周一开需求大会，之前都会假意征求一下开发的意见，现在这个流程也省略了。</p>\n<p>其次是由于好几个前端跑路，导致之前做的很多动态页面需要本地化，也相当于增加了业务量。</p>\n<p>这个月基本上是围绕着优化，订单来工作的。</p>\n<p>首先讲讲优化。</p>\n<ul>\n<li>ui优化</li>\n</ul>\n<p>app在oppor9m上面贼卡，一方面是过度绘制比较严重，二方面是内存泄漏比较严重。之前写布局很多地方都用的relativylayout或者framelayout，嵌套比较严重，红色过度绘制的区域十分多，查看gpu绘制，发现滑动的时候绘制较多，在专题详情页面尤其明显。</p>\n<p>– 过度绘制</p>\n<p>因此对主要流程，主要流程的卡顿页面做了调整，完全按照constraintlayout的设计规则，无论多复杂的布局，统一使用一层或者2层（带scrollview）的布局结构。写的十分顺畅，使用的过程中完善了我对于constraintlayout的理解，包括guideline，group，基准点等。constraintlayou有一个问题，就是背景问题，以往的情况下，习惯性的使用linearlayout，或者部分布局包装，然后针对包装布局进行背景设置，但是在constraintlayout下面，其实单层布局不是很好设置背景，只可以使用单独的一层view来在之前设置，但是view的下方padding就有一些问题，尤其是在提前布局的情况下。针对这个情况，我通过guideline和viewtip来解决，不过这样多了很多奇怪的点，这些点也只可以通过group来进行布局的绑定。</p>\n<p>整个constraintlayout给我的感觉，是牺牲了逻辑效率，带来布局效率，很多的逻辑牵扯在的xml中，而代码中我们一般指判断view是否显示，但是这样就会导致xml中的部分逻辑在不显示的情况下，产生了偏差。因此我觉得在大多数遇到逻辑复杂的布局排列中，还是不要轻易强行单层布局，逻辑偏差带来的时间损失，绝对比使用嵌套布局之后在进行代码优化的多。</p>\n<p>– bitmap大图</p>\n<p>由于我们的项目就是围绕着人脸，身材，妆容这些来进行的，这些无一例外都是bitmap的使用者。</p>\n<p>整合人脸，整合身材，整合妆容之后形成的完整的人模型，原本需要占用大约5m的内存。在优化之前，很多地方使用的是fragmentpageradapter，每个fragment持有很多的bitmap，当时算了一下，一个framgent如果在不上滑加载更多的时候，会持有8个bitmap对象，就是约40m内存。</p>\n<p>在2.1.3版本上面，anr的发生率提高到了14%，绝大多数都是在首页滑动的时候产生的卡死。</p>\n<p>针对这个问题，也做了针对性的优化。首先是使用fragmentstatepageradapter，这样可以在fragment进入销毁流程的时候，释放引用而让他自然销毁。这样首先是切换的时候内存占用问题解决了。</p>\n<p>其次是单fragment下滑导致的内存占用问题。刚开始使用的recyclerview，为了让用户有比较好的体验（雾），而将最大item设为了20（大雾）。这下子用户上滑超过20个，光bitmap 的占用率就飙升到了100m，还不谈item的其他内存占用问题。在一般的华为和oppo手机上面，光这项就吃掉了分给app的50%以上的内存。基本上这个时候如果系统在吃点内存，app就anr了。</p>\n<p>因此针对这个问题，想到的是动态持有，根据可用内存堆分配来实时更新缓存堆的内容。使用的是比较常见的lrucache，但是这个lrucache只缓存了bitmap的信息，item其余的信息就直接释放了，这样动态缓存1/4最大内存堆的内存，同时也保证了bitmap加载不会有太多的问题。</p>\n<p>使用缓存有个小问题，就是强制刷新的时候不注意的话其实是无法清除的，强制刷新的时候得clearcache。</p>\n<p>– bimap色深</p>\n<p>在解决了缓存占用问题之后，基于bitmap的内存问题其实得到了很大的解决。但是仍然有一个巨大的问题，就是bitmap的加载速度。</p>\n<p>即使缓存到lrucache里面，也得首先下载下来，在普通4g网大约200K下载速度的时候，一张基准图下载需要大约0.5-1秒，但是经过渲染和加载，总共大约需要1.5秒的样子才可以呈现，这个速度实在是很慢。</p>\n<p>处理这个的问题一般就是从图片质量上面入手，图片存储方式一般是写死的，虽然我们使用的是oss，可以通过传递参数到服务器，来获取不同的图片大小，但是在做到这个地步之后，就是图像的渲染，也就是从网上下载的数据映射到bitmap上面的这个过程。</p>\n<p>一般的bitmap是rgb888，一个像素占3Byte，我用的手机5.5英寸，1080x1920像素，一般图片设置大约140dp宽高，也就是约420x420像素，占用内存就是420x420x3 = 516K,jpg的压缩率我不是很清楚，大约在10%-90%之间，也就是这么一个呈现为516k的图片，大约需要下载5-50k之间的样子，专题详情页面的大图，宽度是130dp，高度是400dp，就一下子扩了将近3倍，下载如果在200k就要全速一秒了。</p>\n<p>流量并不是很关心的事情，下载其实也不是很关心的事情，因为我无法决定用户的网速，那是framework的事情，我只可以确保下载的内容到本机能够快速加载出来。因此采取的措施是压缩色深，从rgb888，压缩到rgb565，然后压缩到了rgb444。图片质量压缩到如此之低，基本上是能接受的极限了。改完之后速度大约快了一点，加载的时候下载完的条结束就可以出来了。</p>\n<p>– 主线程任务过多引起的卡顿</p>\n<p>在sku详情页面，逻辑是这样的，2线并行，1线先请求人体数据，人体数据的返回值会引起整个页面结构的初始化，2线后行，直接请求sku的数据，进行数据的web填充。问题出现在这两条线都涉及到了ui的修改，所以都跑在主线程，还有个问题是双线有依赖，会导致加载的时候互相调用，而在安卓中很少对于view进行上锁措施，因此此时的操作极为繁琐，而且卡顿及其严重。</p>\n<p>针对此问题主要是优化主线程任务措施，rxjava中其实还是比较好做的，一来使用concat操作符，二来在数据初始化的步骤可以放到子线程，之后实现的操作可以放到主线程，逻辑复杂的部分可以放在子线程，结果传到主线程。（此处mark一下，需要对rxjava的原理做个完整的学习）</p>\n<p>双线我通过整合成为单线，然后线程切换的方式，加载速度，滑动速度响应都足够了。</p>\n<ul>\n<li>性能优化</li>\n</ul>\n<p>– 内存泄漏</p>\n<p>之前项目中整合了lecancary，每次gc和泄漏的时候会弹出提示，但是在项目中的表现并不好，一来是fragment和activity的多层引用，基类中有很多资源持有引用，而这些引用是后来自己手动释放的，但是在lecancary中就会爆这些引用泄漏了，其二是我们所有的网络代码通过clean的结构，在最顶层使用dagger来解耦，因此造成了在ondestroy过程中会销毁，但是切换过程中并不会销毁。切换的过程需要等待，但是这个过程已经造成了泄漏。</p>\n<p>采取的措施比较粗暴，就是直接在切换的时候触发presenter的destroy方法，这样切换的时候，会先关闭引用，之后在切换，切换之后销毁自己，这就是比较正常的过程了。</p>\n<p>– oom</p>\n<p>oom的问题就如同bitmap大图的问题，掠过不讲</p>\n<ul>\n<li>订单流程</li>\n</ul>\n<p>整个订单流程进行了完整的更新，大部分计算价格的部分给予后台来处理，不在由前端显示相关内容，对于我们来讲逻辑更新容易很多。出问题的地方是由于都给予后台显示了，前端势必要判断是否成功，失败的处理逻辑等等。因此针对网络失败的地方做了处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void handleHttpError(Throwable e)&#123;</span><br><span class=\"line\">        if (e instanceof RuntimeException)&#123;</span><br><span class=\"line\">            if (e.getCause() instanceof ConnectException)&#123;</span><br><span class=\"line\">                mEventBus.post(new OnHttpErrorEvent(&quot;连接失败，请检查网络后再试&quot;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (e.getCause() instanceof SocketTimeoutException)&#123;</span><br><span class=\"line\">                mEventBus.post(new OnHttpErrorEvent(&quot;请求超时，请检查网络后再试&quot;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (e.getCause() instanceof UnknownHostException)&#123;</span><br><span class=\"line\">                mEventBus.post(new OnHttpErrorEvent(&quot;域名连接失败，请检查网络后再试&quot;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (e.getCause() instanceof NetworkErrorException)&#123;</span><br><span class=\"line\">                mEventBus.post(new OnHttpErrorEvent(&quot;网络异常，请检查网络后再试&quot;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (e instanceof ConnectException)&#123;</span><br><span class=\"line\">            mEventBus.post(new OnHttpErrorEvent(&quot;连接失败，请检查网络后再试&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (e instanceof SocketTimeoutException)&#123;</span><br><span class=\"line\">            mEventBus.post(new OnHttpErrorEvent(&quot;请求超时，请检查网络后再试&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (e instanceof UnknownHostException)&#123;</span><br><span class=\"line\">            mEventBus.post(new OnHttpErrorEvent(&quot;域名连接失败，请检查网络后再试&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (e instanceof NetworkErrorException)&#123;</span><br><span class=\"line\">            mEventBus.post(new OnHttpErrorEvent(&quot;网络异常，请检查网络后再试&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>处理方式如上，主要是针对rxjava网络异常的各个问题进行鉴别性操作，然后根据不同的类型显示不同的页面。</p>\n<p>大致分了2种页面，一种是正常的失败，没有数据的那种，叫emptyview，还有一种就是网络失败的，叫errorview，都是可以抽出来单独做的。</p>\n<p>除此之外由于大多都是业务方面的内容，可总结的比较少。</p>\n<p>能够抽出来说的有一点，是优惠卷的ui处理方面，一般是使用recyclerview，但是由于用户的优惠卷比较少，我使用的是普通的linearlayout，通过addview来进行加载视图，问题是无法通过recyclerview那种通过一张表来更改数据和view。我需要维护2个表，一个是选中的view表，一个是所有的view表，每次点击的时候需要从选中表中进行遍历，然后处理一些关于选中优惠卷的县骨干内容，本次版本主要是互斥卷和叠加卷的逻辑问题。处理完之后会重新刷新选中表。这样一定程度上是牺牲了代码简洁，而照顾了加载速度。其实recyclerview也有很多bug，比如说每次notifydatasetchanged，数据源变更会强制触发重新刷新的功能，这就不适合数据源并不多的情况。而且recycerview本身作为一个较为重型的控件，处理单纯的几个view，有些大材小用。</p>\n<p>大致如上，四周都没什么时间好好整理一下，做项目的时候总是想着要总结总结，但是到了要总结的时候，仿佛踩过的坑，处理过的问题，都一下子不见了。脑袋里就剩下了最近处理的一些问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这个月都没有写小结，发生了很多事情，都没有来的及记录。</p>\n<p>首先是公司进入了a轮的加速期，为了提高转化率使投资人满意，所有人都进入了8月的倒计时奋战期。其实和之前差不多，唯一变的是每周一开需求大会，之前都会假意征求一下开发的意见，现在这个流程也省略了。</p>\n<p>其次是由于好几个前端跑路，导致之前做的很多动态页面需要本地化，也相当于增加了业务量。</p>\n<p>这个月基本上是围绕着优化，订单来工作的。</p>\n<p>首先讲讲优化。</p>\n<ul>\n<li>ui优化</li>\n</ul>\n<p>app在oppor9m上面贼卡，一方面是过度绘制比较严重，二方面是内存泄漏比较严重。之前写布局很多地方都用的relativylayout或者framelayout，嵌套比较严重，红色过度绘制的区域十分多，查看gpu绘制，发现滑动的时候绘制较多，在专题详情页面尤其明显。</p>\n<p>– 过度绘制</p>\n<p>因此对主要流程，主要流程的卡顿页面做了调整，完全按照constraintlayout的设计规则，无论多复杂的布局，统一使用一层或者2层（带scrollview）的布局结构。写的十分顺畅，使用的过程中完善了我对于constraintlayout的理解，包括guideline，group，基准点等。constraintlayou有一个问题，就是背景问题，以往的情况下，习惯性的使用linearlayout，或者部分布局包装，然后针对包装布局进行背景设置，但是在constraintlayout下面，其实单层布局不是很好设置背景，只可以使用单独的一层view来在之前设置，但是view的下方padding就有一些问题，尤其是在提前布局的情况下。针对这个情况，我通过guideline和viewtip来解决，不过这样多了很多奇怪的点，这些点也只可以通过group来进行布局的绑定。</p>\n<p>整个constraintlayout给我的感觉，是牺牲了逻辑效率，带来布局效率，很多的逻辑牵扯在的xml中，而代码中我们一般指判断view是否显示，但是这样就会导致xml中的部分逻辑在不显示的情况下，产生了偏差。因此我觉得在大多数遇到逻辑复杂的布局排列中，还是不要轻易强行单层布局，逻辑偏差带来的时间损失，绝对比使用嵌套布局之后在进行代码优化的多。</p>\n<p>– bitmap大图</p>\n<p>由于我们的项目就是围绕着人脸，身材，妆容这些来进行的，这些无一例外都是bitmap的使用者。</p>\n<p>整合人脸，整合身材，整合妆容之后形成的完整的人模型，原本需要占用大约5m的内存。在优化之前，很多地方使用的是fragmentpageradapter，每个fragment持有很多的bitmap，当时算了一下，一个framgent如果在不上滑加载更多的时候，会持有8个bitmap对象，就是约40m内存。</p>\n<p>在2.1.3版本上面，anr的发生率提高到了14%，绝大多数都是在首页滑动的时候产生的卡死。</p>\n<p>针对这个问题，也做了针对性的优化。首先是使用fragmentstatepageradapter，这样可以在fragment进入销毁流程的时候，释放引用而让他自然销毁。这样首先是切换的时候内存占用问题解决了。</p>\n<p>其次是单fragment下滑导致的内存占用问题。刚开始使用的recyclerview，为了让用户有比较好的体验（雾），而将最大item设为了20（大雾）。这下子用户上滑超过20个，光bitmap 的占用率就飙升到了100m，还不谈item的其他内存占用问题。在一般的华为和oppo手机上面，光这项就吃掉了分给app的50%以上的内存。基本上这个时候如果系统在吃点内存，app就anr了。</p>\n<p>因此针对这个问题，想到的是动态持有，根据可用内存堆分配来实时更新缓存堆的内容。使用的是比较常见的lrucache，但是这个lrucache只缓存了bitmap的信息，item其余的信息就直接释放了，这样动态缓存1/4最大内存堆的内存，同时也保证了bitmap加载不会有太多的问题。</p>\n<p>使用缓存有个小问题，就是强制刷新的时候不注意的话其实是无法清除的，强制刷新的时候得clearcache。</p>\n<p>– bimap色深</p>\n<p>在解决了缓存占用问题之后，基于bitmap的内存问题其实得到了很大的解决。但是仍然有一个巨大的问题，就是bitmap的加载速度。</p>\n<p>即使缓存到lrucache里面，也得首先下载下来，在普通4g网大约200K下载速度的时候，一张基准图下载需要大约0.5-1秒，但是经过渲染和加载，总共大约需要1.5秒的样子才可以呈现，这个速度实在是很慢。</p>\n<p>处理这个的问题一般就是从图片质量上面入手，图片存储方式一般是写死的，虽然我们使用的是oss，可以通过传递参数到服务器，来获取不同的图片大小，但是在做到这个地步之后，就是图像的渲染，也就是从网上下载的数据映射到bitmap上面的这个过程。</p>\n<p>一般的bitmap是rgb888，一个像素占3Byte，我用的手机5.5英寸，1080x1920像素，一般图片设置大约140dp宽高，也就是约420x420像素，占用内存就是420x420x3 = 516K,jpg的压缩率我不是很清楚，大约在10%-90%之间，也就是这么一个呈现为516k的图片，大约需要下载5-50k之间的样子，专题详情页面的大图，宽度是130dp，高度是400dp，就一下子扩了将近3倍，下载如果在200k就要全速一秒了。</p>\n<p>流量并不是很关心的事情，下载其实也不是很关心的事情，因为我无法决定用户的网速，那是framework的事情，我只可以确保下载的内容到本机能够快速加载出来。因此采取的措施是压缩色深，从rgb888，压缩到rgb565，然后压缩到了rgb444。图片质量压缩到如此之低，基本上是能接受的极限了。改完之后速度大约快了一点，加载的时候下载完的条结束就可以出来了。</p>\n<p>– 主线程任务过多引起的卡顿</p>\n<p>在sku详情页面，逻辑是这样的，2线并行，1线先请求人体数据，人体数据的返回值会引起整个页面结构的初始化，2线后行，直接请求sku的数据，进行数据的web填充。问题出现在这两条线都涉及到了ui的修改，所以都跑在主线程，还有个问题是双线有依赖，会导致加载的时候互相调用，而在安卓中很少对于view进行上锁措施，因此此时的操作极为繁琐，而且卡顿及其严重。</p>\n<p>针对此问题主要是优化主线程任务措施，rxjava中其实还是比较好做的，一来使用concat操作符，二来在数据初始化的步骤可以放到子线程，之后实现的操作可以放到主线程，逻辑复杂的部分可以放在子线程，结果传到主线程。（此处mark一下，需要对rxjava的原理做个完整的学习）</p>\n<p>双线我通过整合成为单线，然后线程切换的方式，加载速度，滑动速度响应都足够了。</p>\n<ul>\n<li>性能优化</li>\n</ul>\n<p>– 内存泄漏</p>\n<p>之前项目中整合了lecancary，每次gc和泄漏的时候会弹出提示，但是在项目中的表现并不好，一来是fragment和activity的多层引用，基类中有很多资源持有引用，而这些引用是后来自己手动释放的，但是在lecancary中就会爆这些引用泄漏了，其二是我们所有的网络代码通过clean的结构，在最顶层使用dagger来解耦，因此造成了在ondestroy过程中会销毁，但是切换过程中并不会销毁。切换的过程需要等待，但是这个过程已经造成了泄漏。</p>\n<p>采取的措施比较粗暴，就是直接在切换的时候触发presenter的destroy方法，这样切换的时候，会先关闭引用，之后在切换，切换之后销毁自己，这就是比较正常的过程了。</p>\n<p>– oom</p>\n<p>oom的问题就如同bitmap大图的问题，掠过不讲</p>\n<ul>\n<li>订单流程</li>\n</ul>\n<p>整个订单流程进行了完整的更新，大部分计算价格的部分给予后台来处理，不在由前端显示相关内容，对于我们来讲逻辑更新容易很多。出问题的地方是由于都给予后台显示了，前端势必要判断是否成功，失败的处理逻辑等等。因此针对网络失败的地方做了处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void handleHttpError(Throwable e)&#123;</span><br><span class=\"line\">        if (e instanceof RuntimeException)&#123;</span><br><span class=\"line\">            if (e.getCause() instanceof ConnectException)&#123;</span><br><span class=\"line\">                mEventBus.post(new OnHttpErrorEvent(&quot;连接失败，请检查网络后再试&quot;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (e.getCause() instanceof SocketTimeoutException)&#123;</span><br><span class=\"line\">                mEventBus.post(new OnHttpErrorEvent(&quot;请求超时，请检查网络后再试&quot;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (e.getCause() instanceof UnknownHostException)&#123;</span><br><span class=\"line\">                mEventBus.post(new OnHttpErrorEvent(&quot;域名连接失败，请检查网络后再试&quot;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (e.getCause() instanceof NetworkErrorException)&#123;</span><br><span class=\"line\">                mEventBus.post(new OnHttpErrorEvent(&quot;网络异常，请检查网络后再试&quot;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (e instanceof ConnectException)&#123;</span><br><span class=\"line\">            mEventBus.post(new OnHttpErrorEvent(&quot;连接失败，请检查网络后再试&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (e instanceof SocketTimeoutException)&#123;</span><br><span class=\"line\">            mEventBus.post(new OnHttpErrorEvent(&quot;请求超时，请检查网络后再试&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (e instanceof UnknownHostException)&#123;</span><br><span class=\"line\">            mEventBus.post(new OnHttpErrorEvent(&quot;域名连接失败，请检查网络后再试&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (e instanceof NetworkErrorException)&#123;</span><br><span class=\"line\">            mEventBus.post(new OnHttpErrorEvent(&quot;网络异常，请检查网络后再试&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>处理方式如上，主要是针对rxjava网络异常的各个问题进行鉴别性操作，然后根据不同的类型显示不同的页面。</p>\n<p>大致分了2种页面，一种是正常的失败，没有数据的那种，叫emptyview，还有一种就是网络失败的，叫errorview，都是可以抽出来单独做的。</p>\n<p>除此之外由于大多都是业务方面的内容，可总结的比较少。</p>\n<p>能够抽出来说的有一点，是优惠卷的ui处理方面，一般是使用recyclerview，但是由于用户的优惠卷比较少，我使用的是普通的linearlayout，通过addview来进行加载视图，问题是无法通过recyclerview那种通过一张表来更改数据和view。我需要维护2个表，一个是选中的view表，一个是所有的view表，每次点击的时候需要从选中表中进行遍历，然后处理一些关于选中优惠卷的县骨干内容，本次版本主要是互斥卷和叠加卷的逻辑问题。处理完之后会重新刷新选中表。这样一定程度上是牺牲了代码简洁，而照顾了加载速度。其实recyclerview也有很多bug，比如说每次notifydatasetchanged，数据源变更会强制触发重新刷新的功能，这就不适合数据源并不多的情况。而且recycerview本身作为一个较为重型的控件，处理单纯的几个view，有些大材小用。</p>\n<p>大致如上，四周都没什么时间好好整理一下，做项目的时候总是想着要总结总结，但是到了要总结的时候，仿佛踩过的坑，处理过的问题，都一下子不见了。脑袋里就剩下了最近处理的一些问题。</p>\n"},{"title":"2018开年愿景","date":"2018-01-01T07:47:32.000Z","_content":"# 凡事欲则立，不预则废\n\n在此2018年的开端，也是我人生的第25个年头开始之际，回顾一下2017年发生的事情，同时也为自己2018年的计划写下一个开端。\n古话说的好，“凡事欲则立，不预则废”，万事开头难，难在一个完善完整理性的计划。凡事都可以量化，足够完美的量化计划，可以将事情完整的捋清，这样之后行动的时候便有一个完整的大纲，这也是此篇文章的初心。\n\n# 2017回顾\n\n> 人生在世，太多事情身不由己。在其位必谋其政，有所得，也必有所失。\n\n2016年毕业，2017是我进入社会的第二个年头。\n\n## 传音\n1月-6月，我仍然在传音工作，也是我技术的一个打磨期。这段时间对我的影响还是比较大的，包括并不局限于身体，三观，但我仍然会从这两方面来解析事情的发生。\n\n首先是技术方面。由于此阶段，我仍然从事于android-framework-systemui部分，未接触app层开发，因此工作任务仍然是处理bug。此阶段处理了大量的statusbar,navigationbar,keyguard,recents,volume等部分的bug，熟练了bug处理的技术，能够及时快速的定位bug发生点然后进行规模测试复现等，之后进行补丁更改，这一阶段给我阅读代码的能力带来了很大的提升，但是问题也出现了。\n\n### 技术问题方面。\n\n由于掌握的开发技术过少，经常遇到遇到bug问题，不知道如何高效正确的处理。换言之，仍然使用的是死方法，例如有一次遇到一个线程更新监听导致的ui刷新不及时问题，由于对线程的掌握不足，对监听器的使用不足，导致我修改策略竟然是在此处加一个固定延时，虽然解决了问题，但是明显是下下之策，造成了固定的性能浪费。我也因此被批评了一顿。这件事情的发生，给我之后决定转型下了一个决心。\n\n### 三观-世界观。\n\n我曾经以为这个世界是黑暗的，但是在传音工作的时间，让我改变了很多。\n首先是我的导师-韦灵春，作为传音导师制下我的导师，她对我的能力提升做了很大的努力。她教导我，应该如何去解决问题，对我的职业规划也进行了很多的指点。最感谢的，还是在我辞职之后，她对我的鼓励，给我很大的动力去解决当时的困境。导师于17年结婚了，祝福。\n之后是我遇到的同事，瑞辰，莫通，宇杰，春孟，汪涵，德华，还有当时的老大，凯旋。大家都是年轻人，对我这么一个新人，都有很大的关照。在没有利益面前，大家其实都愿意对新人给予关怀的。之后小组更改，凯旋哥走了，来了新的老大，新的同事，我和新的老大没有什么沟通，不过新的同事倒是有交流。新同事叫权力，他也给我很多的指导。\n在这么多人的指点下，我也成为了应届生当中较为出色的人。\n人在这个世界上，终归不是孤独的，只要姿态不高调，事实上很多人会愿意给予帮助。将来我若是组建团队，或者面对新人的时候，也要尽量给予足够的帮助。让这份温暖能够流转下去。\n\n### 三观-价值观\n\n我曾经以为，每个公司的升职制度都是约定俗成的。当然在传音的这一阶段，完全摧毁了这个设想。\n我们这一届，加薪的只有一个人。而且还是瞒着加薪的。也就是说，实际上给我们承诺的加薪，就是一句空话。\n在传音的时候，我的工资转正之后，只有5400多的到手工资，当然，额外还有大约1000多的五险一金和根据加班时间来提供的大约540-840的补贴。\n这份工资实在是摧毁了我的自信心。我原本从事程序这个行业，就是冲着高薪而去。但是这份到手甚至略低于上海平均工资的薪水，让我一时间自信心沮丧到极点。\n\n> 会叫的孩子有奶吃\n\n我一瞬间意识到了这句话的意义。\n\n### 三观-人生观\n\n在传音的时候我下了一个巨大的决心，买房子。\n\n人生究竟是为了什么？\n1. 家庭\n2. 事业\n3. 社会责任\n\n家庭的成立因素是什么？\n1. 妻子\n2. 父母\n3. 子女\n\n妻子的满足因素是什么？\n1. 女朋友\n2. 婚姻\n\n女朋友的满足因素是什么？\n1. 人品\n2. 情商\n3. 房子/车子\n\n因此，房子是一个死路，是必须要走的路。\n房子在哪儿买？这个问题思考了很久，原本决定是在南京，但是南京的房价实在是太贵了，当时估价一下，首付在30%，尚且需要大约80万的首付，同时之后需要每个月背负大约6000的房贷持续20年或者5000多持续30年。实在是一笔沉重的负担。\n之后南京政府发布限购令，一瞬间把我在南京定居的想法给摧毁了，按照当时的市价，一年后的房价大约会涨30%，这就代表了总价大约70万的增长，首付大约需要多出20万。这是压死骆驼的最后一根稻草，何况当时我在上海工作，根本无法获得一年的南京的社保。\n之后便思考回去购买，考虑了一圈，最后决定买在城北。城北一是靠家，二是靠近北车站，三是靠近宽广的马路，当然最重要的是，价格可以接受。\n最后是首付25万加上商贷16万和公积金贷8万，便买下了第一个属于自己的房子，124平。\n事实上现在也已经验证了我决定的重要性。在2月份，高铁尚且没有定论是否会落地大丰的时候，房价仍然处于动荡期，当时的价格可以4800左右一平。而在我购买之后，高铁落户大丰，房价一通猛涨，站在18年年初来看，算上了活动诱惑，仍然超过了6000一平。\n这一个决定，站在如今的立场上，我少付出了156000+的总价，这是我2年能存下来的钱。\n另外，由于月供只需要3700，这笔钱我如果拖到10年期，是获得利息甚至大于付出利息的。\n之所以把这段话写在在传音的期间，是因为在传音导致的思虑决定的。当然，也因为过于孤独导致的思考，来决定的。\n孤独是17年整年的格局。\n工资低导致的自我怀疑，让我的性格产生了严重的变化。我失去了当时关系特别好的黄琦，很难过。之后人生便如同一条江的两条分流，从此再也没有可能汇合的可能。这是我17年最大的遗憾，也许会成为我人生的遗憾。\n在传音的时间，我规划好了将来。当然是一个虚拟的规划。大致计划了一个五年。\n16-18 技术沉淀 -24周岁\n18-19 技术深化 -25周岁 \n19-21 自我事业 -27周岁\n这个时间需要跟随着时间来不断细化，但是有个起步的计划，将来会少走很多弯路。\n\n传音的段落告结，总而言之，虽然传音压榨了我的价值，但也同时锻炼了我的技术。仍然感恩。\n在17年5月19日我提交了离职报告，并于6月19日离开了传音。\n\n## 崇杏\n\n原本接受了华勤通讯的offer，却由华勤单方面毁约，于是17年6月19日离职之后，我便参与了各大公司的面试，在电话面试了2家，正式面试了一家之后，顺利的拿到了两个offer，一个是崇杏，一个某博彩公司。最后\n于17年6月27日顺利入职崇杏。\n在崇杏我遇到了新的同事，新的老大，从事的也是和framework截然不同的app开发，薪资也总体提升了大约40%，到手直接接近翻倍。很开心，完成了我跳槽的愿望。\n新公司的氛围就是放手去干，独立开发给我带来了技术上很大的进步，响应式，aop，mvp，等等，几个月学到了传音一年都没有学到的东西。\n但是问题也很大，独立开发，我遇到的所有的问题，都需要自己解决。我的技术沉浸于一种“不了解就只能用死办法”的程度，没有人指点的情况下，技术其实是停滞不前的。\n我缺少了信息获取的渠道，这是很致命的。我因此加入了android developer群，关注了技术社区，使用github进行技术搜索，虽然对最新技术能有一定的获取渠道了，但是新的问题就暴露出来了。\n对新技术的学习需要长时间持久的投入，我很缺少耐心，长时间的专注力。\n17年我开读了《概率论》，《算法导论》，《head first html》，《数据结构与算法（java实现）》，公务员公考系列书籍。无一例外，全部没有读完。\n这个缺点是致命的，学习没有长久的投入，没有技术上面的厚积薄发，而浅尝辄止无疑会带来崩溃。\n\n> 一个人会n份初级开发技能，并不能带来n份初级开发工资\n\n这个问题暴露的很严重，对我将来的发展将有很大的干扰。\n\n## 反思总结\n\n17年可谓收获满满，整个人是顺利的变成了社会人。放弃了幻想，而拥抱了实际。\n\n### 问题暴露\n\n#### 收入仍需提高\n\n在目前阶段，这个收入尚且满足，但是若是战线拉开到五年计划之中，便不足够了。因此新的一年，仍然要密切把握赚钱的方面。\n\n1. 工资提高\n毋庸置疑，这是最直接的方法。但是我对崇信能否给我加薪抱有一种怀疑的态度，这个需要在第一季度总结里面来进行反馈。\n\n2. 理财投入\n最近买的是支付宝的招行人寿理财，年化接近5%，新的一年需要继续开源，希望能够将一些钱进行分化投入。股市是我一直想进去而不敢进去的领域，新的一年我需要多和汝昌交流，了解这个领域，从而决定是否进行投入。\n\n3. 积蓄\n节流是个很好的方法。在上海的消费较高，尤其是吃饭方面，若是每顿都在外面吃，馆子还好，若是外卖的话，是在是太贵，而且不够干净。\n新的一年要在厨艺方面有些投入，最好伙食能够自给自足，这样能省很多的钱下来。\n目前争取一个月固定开销，1200房租+200水电和公共投入+200的通行+400的额外支出。其余的节省下来用于别的地方。\n\n#### 学习需要抓紧\n1. 把握好地铁上的时间，每天早一小时，晚一小时，这些时间段用于阅读技术代码和学习新的语言。\n\n2. 晚上回来要保持一小时的学习时间，会很累，但是要戒掉斗鱼，戒掉不良的习惯。\n\n3. 周末时间不能过度用于浪费了，周末时间需要进行技术的实战。macbookpro已经买了，一定要用到实处。\n\n#### 身体健康\n\n1. 戒烟。\n\n2. 健身房一周去2-3次。\n\n3. 不能晚于23：00之前上床，23：30入睡。\n\n4. 每日早饭必须要吃\n\n5. 每日晚上19:00之后不可以在入食。\n\n## 18年计划安排\n\n1. 阅读10本书，并做详细的读书笔记。\n书单目前是：《Android群英传》《数据结构与算法（java）》《算法导论》《python核心卷2》《javascript dom编程艺术》《博弈论》《运筹学教程》《运筹学习题》。\n暂定8本，酌情添加。\n\n2. 掌握一门新的语言。\n暂定是俄语。能够达到会说简单口语的地步。\n\n3. 体重减轻到140。\n这个一定要成功。\n\n4. github每日更新。\n可以把读书笔记放上去，最好是技术的锻炼。\n\n5. 戒烟/酒。\n\n## 细分量化计划安排\n\n2018年，全年共365天，四个季度12个月共52周余一天。\n每本书平均阅读5周，体重平均一周减一斤。抛去不可抗力，进行下列理想化安排。\n\n### 工作日\n8:00起床->8:30洗漱完毕->8:50到地铁站:背一小时单词\n12:00吃饭->12:20看书40分钟->13:00休息半小时\n19:00下班->19:30到地铁站:学习一小时pdf版书籍\n工作日周二和周四：\n20:30出站->健身房力量锻炼15分钟+30分钟慢跑+洗澡->10:20回家->做饭20分钟->洗漱20分钟->上床\n工作日1，3，5:\n20:30出战->20:50回家->做饭20分钟->整理笔记一小时->洗漱20分钟->上床看书20分钟->睡觉\n\n### 节假日\n8:00起床->8:30洗漱完毕->20分钟煮粥->吃完早饭9:00\n看书2小时->11:00->做午饭20分钟吃午饭->11：40午休\n12:30起床看书2小时->娱乐2小时->健身房力量锻炼30分钟+慢跑30分钟+洗澡->17:30回家\n18:00做晚饭20分钟+吃饭->18:30读书1小时+整理笔记1小时->娱乐2小时->23:00上床睡觉\n\n每一季度一次反馈，视成果和问题进行调整。同时记录不可抗力影响因素。","source":"_posts/2018开年愿景.md","raw":"---\ntitle: 2018开年愿景\ndate: 2018-01-01 15:47:32\ntags: 计划\n---\n# 凡事欲则立，不预则废\n\n在此2018年的开端，也是我人生的第25个年头开始之际，回顾一下2017年发生的事情，同时也为自己2018年的计划写下一个开端。\n古话说的好，“凡事欲则立，不预则废”，万事开头难，难在一个完善完整理性的计划。凡事都可以量化，足够完美的量化计划，可以将事情完整的捋清，这样之后行动的时候便有一个完整的大纲，这也是此篇文章的初心。\n\n# 2017回顾\n\n> 人生在世，太多事情身不由己。在其位必谋其政，有所得，也必有所失。\n\n2016年毕业，2017是我进入社会的第二个年头。\n\n## 传音\n1月-6月，我仍然在传音工作，也是我技术的一个打磨期。这段时间对我的影响还是比较大的，包括并不局限于身体，三观，但我仍然会从这两方面来解析事情的发生。\n\n首先是技术方面。由于此阶段，我仍然从事于android-framework-systemui部分，未接触app层开发，因此工作任务仍然是处理bug。此阶段处理了大量的statusbar,navigationbar,keyguard,recents,volume等部分的bug，熟练了bug处理的技术，能够及时快速的定位bug发生点然后进行规模测试复现等，之后进行补丁更改，这一阶段给我阅读代码的能力带来了很大的提升，但是问题也出现了。\n\n### 技术问题方面。\n\n由于掌握的开发技术过少，经常遇到遇到bug问题，不知道如何高效正确的处理。换言之，仍然使用的是死方法，例如有一次遇到一个线程更新监听导致的ui刷新不及时问题，由于对线程的掌握不足，对监听器的使用不足，导致我修改策略竟然是在此处加一个固定延时，虽然解决了问题，但是明显是下下之策，造成了固定的性能浪费。我也因此被批评了一顿。这件事情的发生，给我之后决定转型下了一个决心。\n\n### 三观-世界观。\n\n我曾经以为这个世界是黑暗的，但是在传音工作的时间，让我改变了很多。\n首先是我的导师-韦灵春，作为传音导师制下我的导师，她对我的能力提升做了很大的努力。她教导我，应该如何去解决问题，对我的职业规划也进行了很多的指点。最感谢的，还是在我辞职之后，她对我的鼓励，给我很大的动力去解决当时的困境。导师于17年结婚了，祝福。\n之后是我遇到的同事，瑞辰，莫通，宇杰，春孟，汪涵，德华，还有当时的老大，凯旋。大家都是年轻人，对我这么一个新人，都有很大的关照。在没有利益面前，大家其实都愿意对新人给予关怀的。之后小组更改，凯旋哥走了，来了新的老大，新的同事，我和新的老大没有什么沟通，不过新的同事倒是有交流。新同事叫权力，他也给我很多的指导。\n在这么多人的指点下，我也成为了应届生当中较为出色的人。\n人在这个世界上，终归不是孤独的，只要姿态不高调，事实上很多人会愿意给予帮助。将来我若是组建团队，或者面对新人的时候，也要尽量给予足够的帮助。让这份温暖能够流转下去。\n\n### 三观-价值观\n\n我曾经以为，每个公司的升职制度都是约定俗成的。当然在传音的这一阶段，完全摧毁了这个设想。\n我们这一届，加薪的只有一个人。而且还是瞒着加薪的。也就是说，实际上给我们承诺的加薪，就是一句空话。\n在传音的时候，我的工资转正之后，只有5400多的到手工资，当然，额外还有大约1000多的五险一金和根据加班时间来提供的大约540-840的补贴。\n这份工资实在是摧毁了我的自信心。我原本从事程序这个行业，就是冲着高薪而去。但是这份到手甚至略低于上海平均工资的薪水，让我一时间自信心沮丧到极点。\n\n> 会叫的孩子有奶吃\n\n我一瞬间意识到了这句话的意义。\n\n### 三观-人生观\n\n在传音的时候我下了一个巨大的决心，买房子。\n\n人生究竟是为了什么？\n1. 家庭\n2. 事业\n3. 社会责任\n\n家庭的成立因素是什么？\n1. 妻子\n2. 父母\n3. 子女\n\n妻子的满足因素是什么？\n1. 女朋友\n2. 婚姻\n\n女朋友的满足因素是什么？\n1. 人品\n2. 情商\n3. 房子/车子\n\n因此，房子是一个死路，是必须要走的路。\n房子在哪儿买？这个问题思考了很久，原本决定是在南京，但是南京的房价实在是太贵了，当时估价一下，首付在30%，尚且需要大约80万的首付，同时之后需要每个月背负大约6000的房贷持续20年或者5000多持续30年。实在是一笔沉重的负担。\n之后南京政府发布限购令，一瞬间把我在南京定居的想法给摧毁了，按照当时的市价，一年后的房价大约会涨30%，这就代表了总价大约70万的增长，首付大约需要多出20万。这是压死骆驼的最后一根稻草，何况当时我在上海工作，根本无法获得一年的南京的社保。\n之后便思考回去购买，考虑了一圈，最后决定买在城北。城北一是靠家，二是靠近北车站，三是靠近宽广的马路，当然最重要的是，价格可以接受。\n最后是首付25万加上商贷16万和公积金贷8万，便买下了第一个属于自己的房子，124平。\n事实上现在也已经验证了我决定的重要性。在2月份，高铁尚且没有定论是否会落地大丰的时候，房价仍然处于动荡期，当时的价格可以4800左右一平。而在我购买之后，高铁落户大丰，房价一通猛涨，站在18年年初来看，算上了活动诱惑，仍然超过了6000一平。\n这一个决定，站在如今的立场上，我少付出了156000+的总价，这是我2年能存下来的钱。\n另外，由于月供只需要3700，这笔钱我如果拖到10年期，是获得利息甚至大于付出利息的。\n之所以把这段话写在在传音的期间，是因为在传音导致的思虑决定的。当然，也因为过于孤独导致的思考，来决定的。\n孤独是17年整年的格局。\n工资低导致的自我怀疑，让我的性格产生了严重的变化。我失去了当时关系特别好的黄琦，很难过。之后人生便如同一条江的两条分流，从此再也没有可能汇合的可能。这是我17年最大的遗憾，也许会成为我人生的遗憾。\n在传音的时间，我规划好了将来。当然是一个虚拟的规划。大致计划了一个五年。\n16-18 技术沉淀 -24周岁\n18-19 技术深化 -25周岁 \n19-21 自我事业 -27周岁\n这个时间需要跟随着时间来不断细化，但是有个起步的计划，将来会少走很多弯路。\n\n传音的段落告结，总而言之，虽然传音压榨了我的价值，但也同时锻炼了我的技术。仍然感恩。\n在17年5月19日我提交了离职报告，并于6月19日离开了传音。\n\n## 崇杏\n\n原本接受了华勤通讯的offer，却由华勤单方面毁约，于是17年6月19日离职之后，我便参与了各大公司的面试，在电话面试了2家，正式面试了一家之后，顺利的拿到了两个offer，一个是崇杏，一个某博彩公司。最后\n于17年6月27日顺利入职崇杏。\n在崇杏我遇到了新的同事，新的老大，从事的也是和framework截然不同的app开发，薪资也总体提升了大约40%，到手直接接近翻倍。很开心，完成了我跳槽的愿望。\n新公司的氛围就是放手去干，独立开发给我带来了技术上很大的进步，响应式，aop，mvp，等等，几个月学到了传音一年都没有学到的东西。\n但是问题也很大，独立开发，我遇到的所有的问题，都需要自己解决。我的技术沉浸于一种“不了解就只能用死办法”的程度，没有人指点的情况下，技术其实是停滞不前的。\n我缺少了信息获取的渠道，这是很致命的。我因此加入了android developer群，关注了技术社区，使用github进行技术搜索，虽然对最新技术能有一定的获取渠道了，但是新的问题就暴露出来了。\n对新技术的学习需要长时间持久的投入，我很缺少耐心，长时间的专注力。\n17年我开读了《概率论》，《算法导论》，《head first html》，《数据结构与算法（java实现）》，公务员公考系列书籍。无一例外，全部没有读完。\n这个缺点是致命的，学习没有长久的投入，没有技术上面的厚积薄发，而浅尝辄止无疑会带来崩溃。\n\n> 一个人会n份初级开发技能，并不能带来n份初级开发工资\n\n这个问题暴露的很严重，对我将来的发展将有很大的干扰。\n\n## 反思总结\n\n17年可谓收获满满，整个人是顺利的变成了社会人。放弃了幻想，而拥抱了实际。\n\n### 问题暴露\n\n#### 收入仍需提高\n\n在目前阶段，这个收入尚且满足，但是若是战线拉开到五年计划之中，便不足够了。因此新的一年，仍然要密切把握赚钱的方面。\n\n1. 工资提高\n毋庸置疑，这是最直接的方法。但是我对崇信能否给我加薪抱有一种怀疑的态度，这个需要在第一季度总结里面来进行反馈。\n\n2. 理财投入\n最近买的是支付宝的招行人寿理财，年化接近5%，新的一年需要继续开源，希望能够将一些钱进行分化投入。股市是我一直想进去而不敢进去的领域，新的一年我需要多和汝昌交流，了解这个领域，从而决定是否进行投入。\n\n3. 积蓄\n节流是个很好的方法。在上海的消费较高，尤其是吃饭方面，若是每顿都在外面吃，馆子还好，若是外卖的话，是在是太贵，而且不够干净。\n新的一年要在厨艺方面有些投入，最好伙食能够自给自足，这样能省很多的钱下来。\n目前争取一个月固定开销，1200房租+200水电和公共投入+200的通行+400的额外支出。其余的节省下来用于别的地方。\n\n#### 学习需要抓紧\n1. 把握好地铁上的时间，每天早一小时，晚一小时，这些时间段用于阅读技术代码和学习新的语言。\n\n2. 晚上回来要保持一小时的学习时间，会很累，但是要戒掉斗鱼，戒掉不良的习惯。\n\n3. 周末时间不能过度用于浪费了，周末时间需要进行技术的实战。macbookpro已经买了，一定要用到实处。\n\n#### 身体健康\n\n1. 戒烟。\n\n2. 健身房一周去2-3次。\n\n3. 不能晚于23：00之前上床，23：30入睡。\n\n4. 每日早饭必须要吃\n\n5. 每日晚上19:00之后不可以在入食。\n\n## 18年计划安排\n\n1. 阅读10本书，并做详细的读书笔记。\n书单目前是：《Android群英传》《数据结构与算法（java）》《算法导论》《python核心卷2》《javascript dom编程艺术》《博弈论》《运筹学教程》《运筹学习题》。\n暂定8本，酌情添加。\n\n2. 掌握一门新的语言。\n暂定是俄语。能够达到会说简单口语的地步。\n\n3. 体重减轻到140。\n这个一定要成功。\n\n4. github每日更新。\n可以把读书笔记放上去，最好是技术的锻炼。\n\n5. 戒烟/酒。\n\n## 细分量化计划安排\n\n2018年，全年共365天，四个季度12个月共52周余一天。\n每本书平均阅读5周，体重平均一周减一斤。抛去不可抗力，进行下列理想化安排。\n\n### 工作日\n8:00起床->8:30洗漱完毕->8:50到地铁站:背一小时单词\n12:00吃饭->12:20看书40分钟->13:00休息半小时\n19:00下班->19:30到地铁站:学习一小时pdf版书籍\n工作日周二和周四：\n20:30出站->健身房力量锻炼15分钟+30分钟慢跑+洗澡->10:20回家->做饭20分钟->洗漱20分钟->上床\n工作日1，3，5:\n20:30出战->20:50回家->做饭20分钟->整理笔记一小时->洗漱20分钟->上床看书20分钟->睡觉\n\n### 节假日\n8:00起床->8:30洗漱完毕->20分钟煮粥->吃完早饭9:00\n看书2小时->11:00->做午饭20分钟吃午饭->11：40午休\n12:30起床看书2小时->娱乐2小时->健身房力量锻炼30分钟+慢跑30分钟+洗澡->17:30回家\n18:00做晚饭20分钟+吃饭->18:30读书1小时+整理笔记1小时->娱乐2小时->23:00上床睡觉\n\n每一季度一次反馈，视成果和问题进行调整。同时记录不可抗力影响因素。","slug":"2018开年愿景","published":1,"updated":"2019-03-12T09:26:33.138Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttzr005z3a8k9t7jg6yi","content":"<h1 id=\"凡事欲则立，不预则废\"><a href=\"#凡事欲则立，不预则废\" class=\"headerlink\" title=\"凡事欲则立，不预则废\"></a>凡事欲则立，不预则废</h1><p>在此2018年的开端，也是我人生的第25个年头开始之际，回顾一下2017年发生的事情，同时也为自己2018年的计划写下一个开端。<br>古话说的好，“凡事欲则立，不预则废”，万事开头难，难在一个完善完整理性的计划。凡事都可以量化，足够完美的量化计划，可以将事情完整的捋清，这样之后行动的时候便有一个完整的大纲，这也是此篇文章的初心。</p>\n<h1 id=\"2017回顾\"><a href=\"#2017回顾\" class=\"headerlink\" title=\"2017回顾\"></a>2017回顾</h1><blockquote>\n<p>人生在世，太多事情身不由己。在其位必谋其政，有所得，也必有所失。</p>\n</blockquote>\n<p>2016年毕业，2017是我进入社会的第二个年头。</p>\n<h2 id=\"传音\"><a href=\"#传音\" class=\"headerlink\" title=\"传音\"></a>传音</h2><p>1月-6月，我仍然在传音工作，也是我技术的一个打磨期。这段时间对我的影响还是比较大的，包括并不局限于身体，三观，但我仍然会从这两方面来解析事情的发生。</p>\n<p>首先是技术方面。由于此阶段，我仍然从事于android-framework-systemui部分，未接触app层开发，因此工作任务仍然是处理bug。此阶段处理了大量的statusbar,navigationbar,keyguard,recents,volume等部分的bug，熟练了bug处理的技术，能够及时快速的定位bug发生点然后进行规模测试复现等，之后进行补丁更改，这一阶段给我阅读代码的能力带来了很大的提升，但是问题也出现了。</p>\n<h3 id=\"技术问题方面。\"><a href=\"#技术问题方面。\" class=\"headerlink\" title=\"技术问题方面。\"></a>技术问题方面。</h3><p>由于掌握的开发技术过少，经常遇到遇到bug问题，不知道如何高效正确的处理。换言之，仍然使用的是死方法，例如有一次遇到一个线程更新监听导致的ui刷新不及时问题，由于对线程的掌握不足，对监听器的使用不足，导致我修改策略竟然是在此处加一个固定延时，虽然解决了问题，但是明显是下下之策，造成了固定的性能浪费。我也因此被批评了一顿。这件事情的发生，给我之后决定转型下了一个决心。</p>\n<h3 id=\"三观-世界观。\"><a href=\"#三观-世界观。\" class=\"headerlink\" title=\"三观-世界观。\"></a>三观-世界观。</h3><p>我曾经以为这个世界是黑暗的，但是在传音工作的时间，让我改变了很多。<br>首先是我的导师-韦灵春，作为传音导师制下我的导师，她对我的能力提升做了很大的努力。她教导我，应该如何去解决问题，对我的职业规划也进行了很多的指点。最感谢的，还是在我辞职之后，她对我的鼓励，给我很大的动力去解决当时的困境。导师于17年结婚了，祝福。<br>之后是我遇到的同事，瑞辰，莫通，宇杰，春孟，汪涵，德华，还有当时的老大，凯旋。大家都是年轻人，对我这么一个新人，都有很大的关照。在没有利益面前，大家其实都愿意对新人给予关怀的。之后小组更改，凯旋哥走了，来了新的老大，新的同事，我和新的老大没有什么沟通，不过新的同事倒是有交流。新同事叫权力，他也给我很多的指导。<br>在这么多人的指点下，我也成为了应届生当中较为出色的人。<br>人在这个世界上，终归不是孤独的，只要姿态不高调，事实上很多人会愿意给予帮助。将来我若是组建团队，或者面对新人的时候，也要尽量给予足够的帮助。让这份温暖能够流转下去。</p>\n<h3 id=\"三观-价值观\"><a href=\"#三观-价值观\" class=\"headerlink\" title=\"三观-价值观\"></a>三观-价值观</h3><p>我曾经以为，每个公司的升职制度都是约定俗成的。当然在传音的这一阶段，完全摧毁了这个设想。<br>我们这一届，加薪的只有一个人。而且还是瞒着加薪的。也就是说，实际上给我们承诺的加薪，就是一句空话。<br>在传音的时候，我的工资转正之后，只有5400多的到手工资，当然，额外还有大约1000多的五险一金和根据加班时间来提供的大约540-840的补贴。<br>这份工资实在是摧毁了我的自信心。我原本从事程序这个行业，就是冲着高薪而去。但是这份到手甚至略低于上海平均工资的薪水，让我一时间自信心沮丧到极点。</p>\n<blockquote>\n<p>会叫的孩子有奶吃</p>\n</blockquote>\n<p>我一瞬间意识到了这句话的意义。</p>\n<h3 id=\"三观-人生观\"><a href=\"#三观-人生观\" class=\"headerlink\" title=\"三观-人生观\"></a>三观-人生观</h3><p>在传音的时候我下了一个巨大的决心，买房子。</p>\n<p>人生究竟是为了什么？</p>\n<ol>\n<li>家庭</li>\n<li>事业</li>\n<li>社会责任</li>\n</ol>\n<p>家庭的成立因素是什么？</p>\n<ol>\n<li>妻子</li>\n<li>父母</li>\n<li>子女</li>\n</ol>\n<p>妻子的满足因素是什么？</p>\n<ol>\n<li>女朋友</li>\n<li>婚姻</li>\n</ol>\n<p>女朋友的满足因素是什么？</p>\n<ol>\n<li>人品</li>\n<li>情商</li>\n<li>房子/车子</li>\n</ol>\n<p>因此，房子是一个死路，是必须要走的路。<br>房子在哪儿买？这个问题思考了很久，原本决定是在南京，但是南京的房价实在是太贵了，当时估价一下，首付在30%，尚且需要大约80万的首付，同时之后需要每个月背负大约6000的房贷持续20年或者5000多持续30年。实在是一笔沉重的负担。<br>之后南京政府发布限购令，一瞬间把我在南京定居的想法给摧毁了，按照当时的市价，一年后的房价大约会涨30%，这就代表了总价大约70万的增长，首付大约需要多出20万。这是压死骆驼的最后一根稻草，何况当时我在上海工作，根本无法获得一年的南京的社保。<br>之后便思考回去购买，考虑了一圈，最后决定买在城北。城北一是靠家，二是靠近北车站，三是靠近宽广的马路，当然最重要的是，价格可以接受。<br>最后是首付25万加上商贷16万和公积金贷8万，便买下了第一个属于自己的房子，124平。<br>事实上现在也已经验证了我决定的重要性。在2月份，高铁尚且没有定论是否会落地大丰的时候，房价仍然处于动荡期，当时的价格可以4800左右一平。而在我购买之后，高铁落户大丰，房价一通猛涨，站在18年年初来看，算上了活动诱惑，仍然超过了6000一平。<br>这一个决定，站在如今的立场上，我少付出了156000+的总价，这是我2年能存下来的钱。<br>另外，由于月供只需要3700，这笔钱我如果拖到10年期，是获得利息甚至大于付出利息的。<br>之所以把这段话写在在传音的期间，是因为在传音导致的思虑决定的。当然，也因为过于孤独导致的思考，来决定的。<br>孤独是17年整年的格局。<br>工资低导致的自我怀疑，让我的性格产生了严重的变化。我失去了当时关系特别好的黄琦，很难过。之后人生便如同一条江的两条分流，从此再也没有可能汇合的可能。这是我17年最大的遗憾，也许会成为我人生的遗憾。<br>在传音的时间，我规划好了将来。当然是一个虚拟的规划。大致计划了一个五年。<br>16-18 技术沉淀 -24周岁<br>18-19 技术深化 -25周岁<br>19-21 自我事业 -27周岁<br>这个时间需要跟随着时间来不断细化，但是有个起步的计划，将来会少走很多弯路。</p>\n<p>传音的段落告结，总而言之，虽然传音压榨了我的价值，但也同时锻炼了我的技术。仍然感恩。<br>在17年5月19日我提交了离职报告，并于6月19日离开了传音。</p>\n<h2 id=\"崇杏\"><a href=\"#崇杏\" class=\"headerlink\" title=\"崇杏\"></a>崇杏</h2><p>原本接受了华勤通讯的offer，却由华勤单方面毁约，于是17年6月19日离职之后，我便参与了各大公司的面试，在电话面试了2家，正式面试了一家之后，顺利的拿到了两个offer，一个是崇杏，一个某博彩公司。最后<br>于17年6月27日顺利入职崇杏。<br>在崇杏我遇到了新的同事，新的老大，从事的也是和framework截然不同的app开发，薪资也总体提升了大约40%，到手直接接近翻倍。很开心，完成了我跳槽的愿望。<br>新公司的氛围就是放手去干，独立开发给我带来了技术上很大的进步，响应式，aop，mvp，等等，几个月学到了传音一年都没有学到的东西。<br>但是问题也很大，独立开发，我遇到的所有的问题，都需要自己解决。我的技术沉浸于一种“不了解就只能用死办法”的程度，没有人指点的情况下，技术其实是停滞不前的。<br>我缺少了信息获取的渠道，这是很致命的。我因此加入了android developer群，关注了技术社区，使用github进行技术搜索，虽然对最新技术能有一定的获取渠道了，但是新的问题就暴露出来了。<br>对新技术的学习需要长时间持久的投入，我很缺少耐心，长时间的专注力。<br>17年我开读了《概率论》，《算法导论》，《head first html》，《数据结构与算法（java实现）》，公务员公考系列书籍。无一例外，全部没有读完。<br>这个缺点是致命的，学习没有长久的投入，没有技术上面的厚积薄发，而浅尝辄止无疑会带来崩溃。</p>\n<blockquote>\n<p>一个人会n份初级开发技能，并不能带来n份初级开发工资</p>\n</blockquote>\n<p>这个问题暴露的很严重，对我将来的发展将有很大的干扰。</p>\n<h2 id=\"反思总结\"><a href=\"#反思总结\" class=\"headerlink\" title=\"反思总结\"></a>反思总结</h2><p>17年可谓收获满满，整个人是顺利的变成了社会人。放弃了幻想，而拥抱了实际。</p>\n<h3 id=\"问题暴露\"><a href=\"#问题暴露\" class=\"headerlink\" title=\"问题暴露\"></a>问题暴露</h3><h4 id=\"收入仍需提高\"><a href=\"#收入仍需提高\" class=\"headerlink\" title=\"收入仍需提高\"></a>收入仍需提高</h4><p>在目前阶段，这个收入尚且满足，但是若是战线拉开到五年计划之中，便不足够了。因此新的一年，仍然要密切把握赚钱的方面。</p>\n<ol>\n<li><p>工资提高<br>毋庸置疑，这是最直接的方法。但是我对崇信能否给我加薪抱有一种怀疑的态度，这个需要在第一季度总结里面来进行反馈。</p>\n</li>\n<li><p>理财投入<br>最近买的是支付宝的招行人寿理财，年化接近5%，新的一年需要继续开源，希望能够将一些钱进行分化投入。股市是我一直想进去而不敢进去的领域，新的一年我需要多和汝昌交流，了解这个领域，从而决定是否进行投入。</p>\n</li>\n<li><p>积蓄<br>节流是个很好的方法。在上海的消费较高，尤其是吃饭方面，若是每顿都在外面吃，馆子还好，若是外卖的话，是在是太贵，而且不够干净。<br>新的一年要在厨艺方面有些投入，最好伙食能够自给自足，这样能省很多的钱下来。<br>目前争取一个月固定开销，1200房租+200水电和公共投入+200的通行+400的额外支出。其余的节省下来用于别的地方。</p>\n</li>\n</ol>\n<h4 id=\"学习需要抓紧\"><a href=\"#学习需要抓紧\" class=\"headerlink\" title=\"学习需要抓紧\"></a>学习需要抓紧</h4><ol>\n<li><p>把握好地铁上的时间，每天早一小时，晚一小时，这些时间段用于阅读技术代码和学习新的语言。</p>\n</li>\n<li><p>晚上回来要保持一小时的学习时间，会很累，但是要戒掉斗鱼，戒掉不良的习惯。</p>\n</li>\n<li><p>周末时间不能过度用于浪费了，周末时间需要进行技术的实战。macbookpro已经买了，一定要用到实处。</p>\n</li>\n</ol>\n<h4 id=\"身体健康\"><a href=\"#身体健康\" class=\"headerlink\" title=\"身体健康\"></a>身体健康</h4><ol>\n<li><p>戒烟。</p>\n</li>\n<li><p>健身房一周去2-3次。</p>\n</li>\n<li><p>不能晚于23：00之前上床，23：30入睡。</p>\n</li>\n<li><p>每日早饭必须要吃</p>\n</li>\n<li><p>每日晚上19:00之后不可以在入食。</p>\n</li>\n</ol>\n<h2 id=\"18年计划安排\"><a href=\"#18年计划安排\" class=\"headerlink\" title=\"18年计划安排\"></a>18年计划安排</h2><ol>\n<li><p>阅读10本书，并做详细的读书笔记。<br>书单目前是：《Android群英传》《数据结构与算法（java）》《算法导论》《python核心卷2》《javascript dom编程艺术》《博弈论》《运筹学教程》《运筹学习题》。<br>暂定8本，酌情添加。</p>\n</li>\n<li><p>掌握一门新的语言。<br>暂定是俄语。能够达到会说简单口语的地步。</p>\n</li>\n<li><p>体重减轻到140。<br>这个一定要成功。</p>\n</li>\n<li><p>github每日更新。<br>可以把读书笔记放上去，最好是技术的锻炼。</p>\n</li>\n<li><p>戒烟/酒。</p>\n</li>\n</ol>\n<h2 id=\"细分量化计划安排\"><a href=\"#细分量化计划安排\" class=\"headerlink\" title=\"细分量化计划安排\"></a>细分量化计划安排</h2><p>2018年，全年共365天，四个季度12个月共52周余一天。<br>每本书平均阅读5周，体重平均一周减一斤。抛去不可抗力，进行下列理想化安排。</p>\n<h3 id=\"工作日\"><a href=\"#工作日\" class=\"headerlink\" title=\"工作日\"></a>工作日</h3><p>8:00起床-&gt;8:30洗漱完毕-&gt;8:50到地铁站:背一小时单词<br>12:00吃饭-&gt;12:20看书40分钟-&gt;13:00休息半小时<br>19:00下班-&gt;19:30到地铁站:学习一小时pdf版书籍<br>工作日周二和周四：<br>20:30出站-&gt;健身房力量锻炼15分钟+30分钟慢跑+洗澡-&gt;10:20回家-&gt;做饭20分钟-&gt;洗漱20分钟-&gt;上床<br>工作日1，3，5:<br>20:30出战-&gt;20:50回家-&gt;做饭20分钟-&gt;整理笔记一小时-&gt;洗漱20分钟-&gt;上床看书20分钟-&gt;睡觉</p>\n<h3 id=\"节假日\"><a href=\"#节假日\" class=\"headerlink\" title=\"节假日\"></a>节假日</h3><p>8:00起床-&gt;8:30洗漱完毕-&gt;20分钟煮粥-&gt;吃完早饭9:00<br>看书2小时-&gt;11:00-&gt;做午饭20分钟吃午饭-&gt;11：40午休<br>12:30起床看书2小时-&gt;娱乐2小时-&gt;健身房力量锻炼30分钟+慢跑30分钟+洗澡-&gt;17:30回家<br>18:00做晚饭20分钟+吃饭-&gt;18:30读书1小时+整理笔记1小时-&gt;娱乐2小时-&gt;23:00上床睡觉</p>\n<p>每一季度一次反馈，视成果和问题进行调整。同时记录不可抗力影响因素。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"凡事欲则立，不预则废\"><a href=\"#凡事欲则立，不预则废\" class=\"headerlink\" title=\"凡事欲则立，不预则废\"></a>凡事欲则立，不预则废</h1><p>在此2018年的开端，也是我人生的第25个年头开始之际，回顾一下2017年发生的事情，同时也为自己2018年的计划写下一个开端。<br>古话说的好，“凡事欲则立，不预则废”，万事开头难，难在一个完善完整理性的计划。凡事都可以量化，足够完美的量化计划，可以将事情完整的捋清，这样之后行动的时候便有一个完整的大纲，这也是此篇文章的初心。</p>\n<h1 id=\"2017回顾\"><a href=\"#2017回顾\" class=\"headerlink\" title=\"2017回顾\"></a>2017回顾</h1><blockquote>\n<p>人生在世，太多事情身不由己。在其位必谋其政，有所得，也必有所失。</p>\n</blockquote>\n<p>2016年毕业，2017是我进入社会的第二个年头。</p>\n<h2 id=\"传音\"><a href=\"#传音\" class=\"headerlink\" title=\"传音\"></a>传音</h2><p>1月-6月，我仍然在传音工作，也是我技术的一个打磨期。这段时间对我的影响还是比较大的，包括并不局限于身体，三观，但我仍然会从这两方面来解析事情的发生。</p>\n<p>首先是技术方面。由于此阶段，我仍然从事于android-framework-systemui部分，未接触app层开发，因此工作任务仍然是处理bug。此阶段处理了大量的statusbar,navigationbar,keyguard,recents,volume等部分的bug，熟练了bug处理的技术，能够及时快速的定位bug发生点然后进行规模测试复现等，之后进行补丁更改，这一阶段给我阅读代码的能力带来了很大的提升，但是问题也出现了。</p>\n<h3 id=\"技术问题方面。\"><a href=\"#技术问题方面。\" class=\"headerlink\" title=\"技术问题方面。\"></a>技术问题方面。</h3><p>由于掌握的开发技术过少，经常遇到遇到bug问题，不知道如何高效正确的处理。换言之，仍然使用的是死方法，例如有一次遇到一个线程更新监听导致的ui刷新不及时问题，由于对线程的掌握不足，对监听器的使用不足，导致我修改策略竟然是在此处加一个固定延时，虽然解决了问题，但是明显是下下之策，造成了固定的性能浪费。我也因此被批评了一顿。这件事情的发生，给我之后决定转型下了一个决心。</p>\n<h3 id=\"三观-世界观。\"><a href=\"#三观-世界观。\" class=\"headerlink\" title=\"三观-世界观。\"></a>三观-世界观。</h3><p>我曾经以为这个世界是黑暗的，但是在传音工作的时间，让我改变了很多。<br>首先是我的导师-韦灵春，作为传音导师制下我的导师，她对我的能力提升做了很大的努力。她教导我，应该如何去解决问题，对我的职业规划也进行了很多的指点。最感谢的，还是在我辞职之后，她对我的鼓励，给我很大的动力去解决当时的困境。导师于17年结婚了，祝福。<br>之后是我遇到的同事，瑞辰，莫通，宇杰，春孟，汪涵，德华，还有当时的老大，凯旋。大家都是年轻人，对我这么一个新人，都有很大的关照。在没有利益面前，大家其实都愿意对新人给予关怀的。之后小组更改，凯旋哥走了，来了新的老大，新的同事，我和新的老大没有什么沟通，不过新的同事倒是有交流。新同事叫权力，他也给我很多的指导。<br>在这么多人的指点下，我也成为了应届生当中较为出色的人。<br>人在这个世界上，终归不是孤独的，只要姿态不高调，事实上很多人会愿意给予帮助。将来我若是组建团队，或者面对新人的时候，也要尽量给予足够的帮助。让这份温暖能够流转下去。</p>\n<h3 id=\"三观-价值观\"><a href=\"#三观-价值观\" class=\"headerlink\" title=\"三观-价值观\"></a>三观-价值观</h3><p>我曾经以为，每个公司的升职制度都是约定俗成的。当然在传音的这一阶段，完全摧毁了这个设想。<br>我们这一届，加薪的只有一个人。而且还是瞒着加薪的。也就是说，实际上给我们承诺的加薪，就是一句空话。<br>在传音的时候，我的工资转正之后，只有5400多的到手工资，当然，额外还有大约1000多的五险一金和根据加班时间来提供的大约540-840的补贴。<br>这份工资实在是摧毁了我的自信心。我原本从事程序这个行业，就是冲着高薪而去。但是这份到手甚至略低于上海平均工资的薪水，让我一时间自信心沮丧到极点。</p>\n<blockquote>\n<p>会叫的孩子有奶吃</p>\n</blockquote>\n<p>我一瞬间意识到了这句话的意义。</p>\n<h3 id=\"三观-人生观\"><a href=\"#三观-人生观\" class=\"headerlink\" title=\"三观-人生观\"></a>三观-人生观</h3><p>在传音的时候我下了一个巨大的决心，买房子。</p>\n<p>人生究竟是为了什么？</p>\n<ol>\n<li>家庭</li>\n<li>事业</li>\n<li>社会责任</li>\n</ol>\n<p>家庭的成立因素是什么？</p>\n<ol>\n<li>妻子</li>\n<li>父母</li>\n<li>子女</li>\n</ol>\n<p>妻子的满足因素是什么？</p>\n<ol>\n<li>女朋友</li>\n<li>婚姻</li>\n</ol>\n<p>女朋友的满足因素是什么？</p>\n<ol>\n<li>人品</li>\n<li>情商</li>\n<li>房子/车子</li>\n</ol>\n<p>因此，房子是一个死路，是必须要走的路。<br>房子在哪儿买？这个问题思考了很久，原本决定是在南京，但是南京的房价实在是太贵了，当时估价一下，首付在30%，尚且需要大约80万的首付，同时之后需要每个月背负大约6000的房贷持续20年或者5000多持续30年。实在是一笔沉重的负担。<br>之后南京政府发布限购令，一瞬间把我在南京定居的想法给摧毁了，按照当时的市价，一年后的房价大约会涨30%，这就代表了总价大约70万的增长，首付大约需要多出20万。这是压死骆驼的最后一根稻草，何况当时我在上海工作，根本无法获得一年的南京的社保。<br>之后便思考回去购买，考虑了一圈，最后决定买在城北。城北一是靠家，二是靠近北车站，三是靠近宽广的马路，当然最重要的是，价格可以接受。<br>最后是首付25万加上商贷16万和公积金贷8万，便买下了第一个属于自己的房子，124平。<br>事实上现在也已经验证了我决定的重要性。在2月份，高铁尚且没有定论是否会落地大丰的时候，房价仍然处于动荡期，当时的价格可以4800左右一平。而在我购买之后，高铁落户大丰，房价一通猛涨，站在18年年初来看，算上了活动诱惑，仍然超过了6000一平。<br>这一个决定，站在如今的立场上，我少付出了156000+的总价，这是我2年能存下来的钱。<br>另外，由于月供只需要3700，这笔钱我如果拖到10年期，是获得利息甚至大于付出利息的。<br>之所以把这段话写在在传音的期间，是因为在传音导致的思虑决定的。当然，也因为过于孤独导致的思考，来决定的。<br>孤独是17年整年的格局。<br>工资低导致的自我怀疑，让我的性格产生了严重的变化。我失去了当时关系特别好的黄琦，很难过。之后人生便如同一条江的两条分流，从此再也没有可能汇合的可能。这是我17年最大的遗憾，也许会成为我人生的遗憾。<br>在传音的时间，我规划好了将来。当然是一个虚拟的规划。大致计划了一个五年。<br>16-18 技术沉淀 -24周岁<br>18-19 技术深化 -25周岁<br>19-21 自我事业 -27周岁<br>这个时间需要跟随着时间来不断细化，但是有个起步的计划，将来会少走很多弯路。</p>\n<p>传音的段落告结，总而言之，虽然传音压榨了我的价值，但也同时锻炼了我的技术。仍然感恩。<br>在17年5月19日我提交了离职报告，并于6月19日离开了传音。</p>\n<h2 id=\"崇杏\"><a href=\"#崇杏\" class=\"headerlink\" title=\"崇杏\"></a>崇杏</h2><p>原本接受了华勤通讯的offer，却由华勤单方面毁约，于是17年6月19日离职之后，我便参与了各大公司的面试，在电话面试了2家，正式面试了一家之后，顺利的拿到了两个offer，一个是崇杏，一个某博彩公司。最后<br>于17年6月27日顺利入职崇杏。<br>在崇杏我遇到了新的同事，新的老大，从事的也是和framework截然不同的app开发，薪资也总体提升了大约40%，到手直接接近翻倍。很开心，完成了我跳槽的愿望。<br>新公司的氛围就是放手去干，独立开发给我带来了技术上很大的进步，响应式，aop，mvp，等等，几个月学到了传音一年都没有学到的东西。<br>但是问题也很大，独立开发，我遇到的所有的问题，都需要自己解决。我的技术沉浸于一种“不了解就只能用死办法”的程度，没有人指点的情况下，技术其实是停滞不前的。<br>我缺少了信息获取的渠道，这是很致命的。我因此加入了android developer群，关注了技术社区，使用github进行技术搜索，虽然对最新技术能有一定的获取渠道了，但是新的问题就暴露出来了。<br>对新技术的学习需要长时间持久的投入，我很缺少耐心，长时间的专注力。<br>17年我开读了《概率论》，《算法导论》，《head first html》，《数据结构与算法（java实现）》，公务员公考系列书籍。无一例外，全部没有读完。<br>这个缺点是致命的，学习没有长久的投入，没有技术上面的厚积薄发，而浅尝辄止无疑会带来崩溃。</p>\n<blockquote>\n<p>一个人会n份初级开发技能，并不能带来n份初级开发工资</p>\n</blockquote>\n<p>这个问题暴露的很严重，对我将来的发展将有很大的干扰。</p>\n<h2 id=\"反思总结\"><a href=\"#反思总结\" class=\"headerlink\" title=\"反思总结\"></a>反思总结</h2><p>17年可谓收获满满，整个人是顺利的变成了社会人。放弃了幻想，而拥抱了实际。</p>\n<h3 id=\"问题暴露\"><a href=\"#问题暴露\" class=\"headerlink\" title=\"问题暴露\"></a>问题暴露</h3><h4 id=\"收入仍需提高\"><a href=\"#收入仍需提高\" class=\"headerlink\" title=\"收入仍需提高\"></a>收入仍需提高</h4><p>在目前阶段，这个收入尚且满足，但是若是战线拉开到五年计划之中，便不足够了。因此新的一年，仍然要密切把握赚钱的方面。</p>\n<ol>\n<li><p>工资提高<br>毋庸置疑，这是最直接的方法。但是我对崇信能否给我加薪抱有一种怀疑的态度，这个需要在第一季度总结里面来进行反馈。</p>\n</li>\n<li><p>理财投入<br>最近买的是支付宝的招行人寿理财，年化接近5%，新的一年需要继续开源，希望能够将一些钱进行分化投入。股市是我一直想进去而不敢进去的领域，新的一年我需要多和汝昌交流，了解这个领域，从而决定是否进行投入。</p>\n</li>\n<li><p>积蓄<br>节流是个很好的方法。在上海的消费较高，尤其是吃饭方面，若是每顿都在外面吃，馆子还好，若是外卖的话，是在是太贵，而且不够干净。<br>新的一年要在厨艺方面有些投入，最好伙食能够自给自足，这样能省很多的钱下来。<br>目前争取一个月固定开销，1200房租+200水电和公共投入+200的通行+400的额外支出。其余的节省下来用于别的地方。</p>\n</li>\n</ol>\n<h4 id=\"学习需要抓紧\"><a href=\"#学习需要抓紧\" class=\"headerlink\" title=\"学习需要抓紧\"></a>学习需要抓紧</h4><ol>\n<li><p>把握好地铁上的时间，每天早一小时，晚一小时，这些时间段用于阅读技术代码和学习新的语言。</p>\n</li>\n<li><p>晚上回来要保持一小时的学习时间，会很累，但是要戒掉斗鱼，戒掉不良的习惯。</p>\n</li>\n<li><p>周末时间不能过度用于浪费了，周末时间需要进行技术的实战。macbookpro已经买了，一定要用到实处。</p>\n</li>\n</ol>\n<h4 id=\"身体健康\"><a href=\"#身体健康\" class=\"headerlink\" title=\"身体健康\"></a>身体健康</h4><ol>\n<li><p>戒烟。</p>\n</li>\n<li><p>健身房一周去2-3次。</p>\n</li>\n<li><p>不能晚于23：00之前上床，23：30入睡。</p>\n</li>\n<li><p>每日早饭必须要吃</p>\n</li>\n<li><p>每日晚上19:00之后不可以在入食。</p>\n</li>\n</ol>\n<h2 id=\"18年计划安排\"><a href=\"#18年计划安排\" class=\"headerlink\" title=\"18年计划安排\"></a>18年计划安排</h2><ol>\n<li><p>阅读10本书，并做详细的读书笔记。<br>书单目前是：《Android群英传》《数据结构与算法（java）》《算法导论》《python核心卷2》《javascript dom编程艺术》《博弈论》《运筹学教程》《运筹学习题》。<br>暂定8本，酌情添加。</p>\n</li>\n<li><p>掌握一门新的语言。<br>暂定是俄语。能够达到会说简单口语的地步。</p>\n</li>\n<li><p>体重减轻到140。<br>这个一定要成功。</p>\n</li>\n<li><p>github每日更新。<br>可以把读书笔记放上去，最好是技术的锻炼。</p>\n</li>\n<li><p>戒烟/酒。</p>\n</li>\n</ol>\n<h2 id=\"细分量化计划安排\"><a href=\"#细分量化计划安排\" class=\"headerlink\" title=\"细分量化计划安排\"></a>细分量化计划安排</h2><p>2018年，全年共365天，四个季度12个月共52周余一天。<br>每本书平均阅读5周，体重平均一周减一斤。抛去不可抗力，进行下列理想化安排。</p>\n<h3 id=\"工作日\"><a href=\"#工作日\" class=\"headerlink\" title=\"工作日\"></a>工作日</h3><p>8:00起床-&gt;8:30洗漱完毕-&gt;8:50到地铁站:背一小时单词<br>12:00吃饭-&gt;12:20看书40分钟-&gt;13:00休息半小时<br>19:00下班-&gt;19:30到地铁站:学习一小时pdf版书籍<br>工作日周二和周四：<br>20:30出站-&gt;健身房力量锻炼15分钟+30分钟慢跑+洗澡-&gt;10:20回家-&gt;做饭20分钟-&gt;洗漱20分钟-&gt;上床<br>工作日1，3，5:<br>20:30出战-&gt;20:50回家-&gt;做饭20分钟-&gt;整理笔记一小时-&gt;洗漱20分钟-&gt;上床看书20分钟-&gt;睡觉</p>\n<h3 id=\"节假日\"><a href=\"#节假日\" class=\"headerlink\" title=\"节假日\"></a>节假日</h3><p>8:00起床-&gt;8:30洗漱完毕-&gt;20分钟煮粥-&gt;吃完早饭9:00<br>看书2小时-&gt;11:00-&gt;做午饭20分钟吃午饭-&gt;11：40午休<br>12:30起床看书2小时-&gt;娱乐2小时-&gt;健身房力量锻炼30分钟+慢跑30分钟+洗澡-&gt;17:30回家<br>18:00做晚饭20分钟+吃饭-&gt;18:30读书1小时+整理笔记1小时-&gt;娱乐2小时-&gt;23:00上床睡觉</p>\n<p>每一季度一次反馈，视成果和问题进行调整。同时记录不可抗力影响因素。</p>\n"},{"title":"ARouter组件化框架学习笔记","date":"2018-03-14T08:29:53.000Z","_content":"\nARouter是用于组件化的比较好的一个方案，不过性能方面肯定不如直接跳转。\n\n\n# 基本使用方法\n\n- 添加依赖\n\n```\nandroid {\n    defaultConfig {\n\t...\n\tjavaCompileOptions {\n\t    annotationProcessorOptions {\n\t\targuments = [ moduleName : project.getName() ]\n\t    }\n\t}\n    }\n}\n\ndependencies {\n    // 替换成最新版本, 需要注意的是api\n    // 要与compiler匹配使用，均使用最新版可以保证兼容\n    compile 'com.alibaba:arouter-api:x.x.x'\n    annotationProcessor 'com.alibaba:arouter-compiler:x.x.x'\n    ...\n}\n// 旧版本gradle插件(< 2.2)，可以使用apt插件，配置方法见文末'其他#4'\n// Kotlin配置参考文末'其他#5'\n```\n\n- 添加注解\n\n```\n@Route(path = \"/test/activity\")\npublic class YourActivity extend Activity {\n    ...\n}\n```\n\n- 初始化sdk\n\n```\nif (isDebug()) {           // 这两行必须写在init之前，否则这些配置在init过程中将无效\n    ARouter.openLog();     // 打印日志\n    ARouter.openDebug();   // 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)\n}\nARouter.init(mApplication); // 尽可能早，推荐在Application中初始化\n```\n\n- 进行路由操作\n\n```\n// 1. 应用内简单的跳转(通过URL跳转在'进阶用法'中)\nARouter.getInstance().build(\"/test/activity\").navigation();\n\n// 2. 跳转并携带参数\nARouter.getInstance().build(\"/test/1\")\n\t\t\t.withLong(\"key1\", 666L)\n\t\t\t.withString(\"key3\", \"888\")\n\t\t\t.withObject(\"key4\", new Test(\"Jack\", \"Rose\"))\n\t\t\t.navigation();\n\n```\n\n- 混淆\n\n```\n-keep public class com.alibaba.android.arouter.routes.**{*;}\n-keep class * implements com.alibaba.android.arouter.facade.template.ISyringe{*;}\n\n# 如果使用了 byType 的方式获取 Service，需添加下面规则，保护接口\n-keep interface * implements com.alibaba.android.arouter.facade.template.IProvider\n\n# 如果使用了 单类注入，即不定义接口实现 IProvider，需添加下面规则，保护实现\n-keep class * implements com.alibaba.android.arouter.facade.template.IProvider\n```\n\n- 使用gradle进行路由表的自动加载\n\n```\napply plugin: 'com.alibaba.arouter'\n\nbuildscript {\n    repositories {\n        jcenter()\n    }\n\n    dependencies {\n        classpath \"com.alibaba:arouter-register:1.0.0\"\n    }\n}\n```\n\n# 进阶使用方法\n\n- 通过url跳转\n```\n// 新建一个Activity用于监听Schame事件,之后直接把url传递给ARouter即可\npublic class SchameFilterActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n\tsuper.onCreate(savedInstanceState);\n\n\tUri uri = getIntent().getData();\n\tARouter.getInstance().build(uri).navigation();\n\tfinish();\n    }\n}\n```\n\nmainfest\n```\n<activity android:name=\".activity.SchameFilterActivity\">\n\t<!-- Schame -->\n\t<intent-filter>\n\t    <data\n\t\tandroid:host=\"m.aliyun.com\"\n\t\tandroid:scheme=\"arouter\"/>\n\n\t    <action android:name=\"android.intent.action.VIEW\"/>\n\n\t    <category android:name=\"android.intent.category.DEFAULT\"/>\n\t    <category android:name=\"android.intent.category.BROWSABLE\"/>\n\t</intent-filter>\n</activity>\n```\n\n- 解析url中的参数\n\n```\n// 为每一个参数声明一个字段，并使用 @Autowired 标注\n// URL中不能传递Parcelable类型数据，通过ARouter api可以传递Parcelable对象\n@Route(path = \"/test/activity\")\npublic class Test1Activity extends Activity {\n    @Autowired\n    public String name;\n    @Autowired\n    int age;\n    @Autowired(name = \"girl\") // 通过name来映射URL中的不同参数\n    boolean boy;\n    @Autowired\n    TestObj obj;    // 支持解析自定义对象，URL中使用json传递\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n\tsuper.onCreate(savedInstanceState);\n\tARouter.getInstance().inject(this);\n\n\t// ARouter会自动对字段进行赋值，无需主动获取\n\tLog.d(\"param\", name + age + boy);\n    }\n}\n\n\n// 如果需要传递自定义对象，需要实现 SerializationService,并使用@Route注解标注(方便用户自行选择序列化方式)，例如：\n@Route(path = \"/service/json\")\npublic class JsonServiceImpl implements SerializationService {\n    @Override\n    public void init(Context context) {\n\n    }\n\n    @Override\n    public <T> T json2Object(String text, Class<T> clazz) {\n        return JSON.parseObject(text, clazz);\n    }\n\n    @Override\n    public String object2Json(Object instance) {\n        return JSON.toJSONString(instance);\n    }\n}\n```\n\n- 声明拦截器\n\n```\n// 比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查\n// 拦截器会在跳转之间执行，多个拦截器会按优先级顺序依次执行\n@Interceptor(priority = 8, name = \"测试用拦截器\")\npublic class TestInterceptor implements IInterceptor {\n    @Override\n    public void process(Postcard postcard, InterceptorCallback callback) {\n\t...\n\tcallback.onContinue(postcard);  // 处理完成，交还控制权\n\t// callback.onInterrupt(new RuntimeException(\"我觉得有点异常\"));      // 觉得有问题，中断路由流程\n\n\t// 以上两种至少需要调用其中一种，否则不会继续路由\n    }\n\n    @Override\n    public void init(Context context) {\n\t// 拦截器的初始化，会在sdk初始化的时候调用该方法，仅会调用一次\n    }\n}\n```\n\n- 处理跳转结果\n\n```\n// 使用两个参数的navigation方法，可以获取单次跳转的结果\nARouter.getInstance().build(\"/test/1\").navigation(this, new NavigationCallback() {\n    @Override\n    public void onFound(Postcard postcard) {\n      ...\n    }\n\n    @Override\n    public void onLost(Postcard postcard) {\n\t...\n    }\n});\n```\n\n- 自定义全局降级策略\n\n```\n// 实现DegradeService接口，并加上一个Path内容任意的注解即可\n@Route(path = \"/xxx/xxx\")\npublic class DegradeServiceImpl implements DegradeService {\n  @Override\n  public void onLost(Context context, Postcard postcard) {\n\t// do something.\n  }\n\n  @Override\n  public void init(Context context) {\n\n  }\n}\n```\n\n- 为目标页面声明更多信息\n\n```\n// 我们经常需要在目标页面中配置一些属性，比方说\"是否需要登陆\"之类的\n// 可以通过 Route 注解中的 extras 属性进行扩展，这个属性是一个 int值，换句话说，单个int有4字节，也就是32位，可以配置32个开关\n// 剩下的可以自行发挥，通过字节操作可以标识32个开关，通过开关标记目标页面的一些属性，在拦截器中可以拿到这个标记进行业务逻辑判断\n@Route(path = \"/test/activity\", extras = Consts.XXXX)\n```\n\n- 通过依赖注入解耦:服务管理(一) 暴露服务\n\n```\n// 声明接口,其他组件通过接口来调用服务\npublic interface HelloService extends IProvider {\n    String sayHello(String name);\n}\n\n// 实现接口\n@Route(path = \"/service/hello\", name = \"测试服务\")\npublic class HelloServiceImpl implements HelloService {\n\n    @Override\n    public String sayHello(String name) {\n\treturn \"hello, \" + name;\n    }\n\n    @Override\n    public void init(Context context) {\n\n    }\n}\n```\n\n- 通过依赖注入解耦:服务管理(二) 发现服务\n\n```\npublic class Test {\n    @Autowired\n    HelloService helloService;\n\n    @Autowired(name = \"/service/hello\")\n    HelloService helloService2;\n\n    HelloService helloService3;\n\n    HelloService helloService4;\n\n    public Test() {\n\tARouter.getInstance().inject(this);\n    }\n\n    public void testService() {\n\t // 1. (推荐)使用依赖注入的方式发现服务,通过注解标注字段,即可使用，无需主动获取\n\t // Autowired注解中标注name之后，将会使用byName的方式注入对应的字段，不设置name属性，会默认使用byType的方式发现服务(当同一接口有多个实现的时候，必须使用byName的方式发现服务)\n\thelloService.sayHello(\"Vergil\");\n\thelloService2.sayHello(\"Vergil\");\n\n\t// 2. 使用依赖查找的方式发现服务，主动去发现服务并使用，下面两种方式分别是byName和byType\n\thelloService3 = ARouter.getInstance().navigation(HelloService.class);\n\thelloService4 = (HelloService) ARouter.getInstance().build(\"/service/hello\").navigation();\n\thelloService3.sayHello(\"Vergil\");\n\thelloService4.sayHello(\"Vergil\");\n    }\n}\n```\n\n# 原理解析\n\n\n\n\n","source":"_posts/ARouter组件化框架学习笔记.md","raw":"---\ntitle: ARouter组件化框架学习笔记\ndate: 2018-03-14 16:29:53\ntags: android\n---\n\nARouter是用于组件化的比较好的一个方案，不过性能方面肯定不如直接跳转。\n\n\n# 基本使用方法\n\n- 添加依赖\n\n```\nandroid {\n    defaultConfig {\n\t...\n\tjavaCompileOptions {\n\t    annotationProcessorOptions {\n\t\targuments = [ moduleName : project.getName() ]\n\t    }\n\t}\n    }\n}\n\ndependencies {\n    // 替换成最新版本, 需要注意的是api\n    // 要与compiler匹配使用，均使用最新版可以保证兼容\n    compile 'com.alibaba:arouter-api:x.x.x'\n    annotationProcessor 'com.alibaba:arouter-compiler:x.x.x'\n    ...\n}\n// 旧版本gradle插件(< 2.2)，可以使用apt插件，配置方法见文末'其他#4'\n// Kotlin配置参考文末'其他#5'\n```\n\n- 添加注解\n\n```\n@Route(path = \"/test/activity\")\npublic class YourActivity extend Activity {\n    ...\n}\n```\n\n- 初始化sdk\n\n```\nif (isDebug()) {           // 这两行必须写在init之前，否则这些配置在init过程中将无效\n    ARouter.openLog();     // 打印日志\n    ARouter.openDebug();   // 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)\n}\nARouter.init(mApplication); // 尽可能早，推荐在Application中初始化\n```\n\n- 进行路由操作\n\n```\n// 1. 应用内简单的跳转(通过URL跳转在'进阶用法'中)\nARouter.getInstance().build(\"/test/activity\").navigation();\n\n// 2. 跳转并携带参数\nARouter.getInstance().build(\"/test/1\")\n\t\t\t.withLong(\"key1\", 666L)\n\t\t\t.withString(\"key3\", \"888\")\n\t\t\t.withObject(\"key4\", new Test(\"Jack\", \"Rose\"))\n\t\t\t.navigation();\n\n```\n\n- 混淆\n\n```\n-keep public class com.alibaba.android.arouter.routes.**{*;}\n-keep class * implements com.alibaba.android.arouter.facade.template.ISyringe{*;}\n\n# 如果使用了 byType 的方式获取 Service，需添加下面规则，保护接口\n-keep interface * implements com.alibaba.android.arouter.facade.template.IProvider\n\n# 如果使用了 单类注入，即不定义接口实现 IProvider，需添加下面规则，保护实现\n-keep class * implements com.alibaba.android.arouter.facade.template.IProvider\n```\n\n- 使用gradle进行路由表的自动加载\n\n```\napply plugin: 'com.alibaba.arouter'\n\nbuildscript {\n    repositories {\n        jcenter()\n    }\n\n    dependencies {\n        classpath \"com.alibaba:arouter-register:1.0.0\"\n    }\n}\n```\n\n# 进阶使用方法\n\n- 通过url跳转\n```\n// 新建一个Activity用于监听Schame事件,之后直接把url传递给ARouter即可\npublic class SchameFilterActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n\tsuper.onCreate(savedInstanceState);\n\n\tUri uri = getIntent().getData();\n\tARouter.getInstance().build(uri).navigation();\n\tfinish();\n    }\n}\n```\n\nmainfest\n```\n<activity android:name=\".activity.SchameFilterActivity\">\n\t<!-- Schame -->\n\t<intent-filter>\n\t    <data\n\t\tandroid:host=\"m.aliyun.com\"\n\t\tandroid:scheme=\"arouter\"/>\n\n\t    <action android:name=\"android.intent.action.VIEW\"/>\n\n\t    <category android:name=\"android.intent.category.DEFAULT\"/>\n\t    <category android:name=\"android.intent.category.BROWSABLE\"/>\n\t</intent-filter>\n</activity>\n```\n\n- 解析url中的参数\n\n```\n// 为每一个参数声明一个字段，并使用 @Autowired 标注\n// URL中不能传递Parcelable类型数据，通过ARouter api可以传递Parcelable对象\n@Route(path = \"/test/activity\")\npublic class Test1Activity extends Activity {\n    @Autowired\n    public String name;\n    @Autowired\n    int age;\n    @Autowired(name = \"girl\") // 通过name来映射URL中的不同参数\n    boolean boy;\n    @Autowired\n    TestObj obj;    // 支持解析自定义对象，URL中使用json传递\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n\tsuper.onCreate(savedInstanceState);\n\tARouter.getInstance().inject(this);\n\n\t// ARouter会自动对字段进行赋值，无需主动获取\n\tLog.d(\"param\", name + age + boy);\n    }\n}\n\n\n// 如果需要传递自定义对象，需要实现 SerializationService,并使用@Route注解标注(方便用户自行选择序列化方式)，例如：\n@Route(path = \"/service/json\")\npublic class JsonServiceImpl implements SerializationService {\n    @Override\n    public void init(Context context) {\n\n    }\n\n    @Override\n    public <T> T json2Object(String text, Class<T> clazz) {\n        return JSON.parseObject(text, clazz);\n    }\n\n    @Override\n    public String object2Json(Object instance) {\n        return JSON.toJSONString(instance);\n    }\n}\n```\n\n- 声明拦截器\n\n```\n// 比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查\n// 拦截器会在跳转之间执行，多个拦截器会按优先级顺序依次执行\n@Interceptor(priority = 8, name = \"测试用拦截器\")\npublic class TestInterceptor implements IInterceptor {\n    @Override\n    public void process(Postcard postcard, InterceptorCallback callback) {\n\t...\n\tcallback.onContinue(postcard);  // 处理完成，交还控制权\n\t// callback.onInterrupt(new RuntimeException(\"我觉得有点异常\"));      // 觉得有问题，中断路由流程\n\n\t// 以上两种至少需要调用其中一种，否则不会继续路由\n    }\n\n    @Override\n    public void init(Context context) {\n\t// 拦截器的初始化，会在sdk初始化的时候调用该方法，仅会调用一次\n    }\n}\n```\n\n- 处理跳转结果\n\n```\n// 使用两个参数的navigation方法，可以获取单次跳转的结果\nARouter.getInstance().build(\"/test/1\").navigation(this, new NavigationCallback() {\n    @Override\n    public void onFound(Postcard postcard) {\n      ...\n    }\n\n    @Override\n    public void onLost(Postcard postcard) {\n\t...\n    }\n});\n```\n\n- 自定义全局降级策略\n\n```\n// 实现DegradeService接口，并加上一个Path内容任意的注解即可\n@Route(path = \"/xxx/xxx\")\npublic class DegradeServiceImpl implements DegradeService {\n  @Override\n  public void onLost(Context context, Postcard postcard) {\n\t// do something.\n  }\n\n  @Override\n  public void init(Context context) {\n\n  }\n}\n```\n\n- 为目标页面声明更多信息\n\n```\n// 我们经常需要在目标页面中配置一些属性，比方说\"是否需要登陆\"之类的\n// 可以通过 Route 注解中的 extras 属性进行扩展，这个属性是一个 int值，换句话说，单个int有4字节，也就是32位，可以配置32个开关\n// 剩下的可以自行发挥，通过字节操作可以标识32个开关，通过开关标记目标页面的一些属性，在拦截器中可以拿到这个标记进行业务逻辑判断\n@Route(path = \"/test/activity\", extras = Consts.XXXX)\n```\n\n- 通过依赖注入解耦:服务管理(一) 暴露服务\n\n```\n// 声明接口,其他组件通过接口来调用服务\npublic interface HelloService extends IProvider {\n    String sayHello(String name);\n}\n\n// 实现接口\n@Route(path = \"/service/hello\", name = \"测试服务\")\npublic class HelloServiceImpl implements HelloService {\n\n    @Override\n    public String sayHello(String name) {\n\treturn \"hello, \" + name;\n    }\n\n    @Override\n    public void init(Context context) {\n\n    }\n}\n```\n\n- 通过依赖注入解耦:服务管理(二) 发现服务\n\n```\npublic class Test {\n    @Autowired\n    HelloService helloService;\n\n    @Autowired(name = \"/service/hello\")\n    HelloService helloService2;\n\n    HelloService helloService3;\n\n    HelloService helloService4;\n\n    public Test() {\n\tARouter.getInstance().inject(this);\n    }\n\n    public void testService() {\n\t // 1. (推荐)使用依赖注入的方式发现服务,通过注解标注字段,即可使用，无需主动获取\n\t // Autowired注解中标注name之后，将会使用byName的方式注入对应的字段，不设置name属性，会默认使用byType的方式发现服务(当同一接口有多个实现的时候，必须使用byName的方式发现服务)\n\thelloService.sayHello(\"Vergil\");\n\thelloService2.sayHello(\"Vergil\");\n\n\t// 2. 使用依赖查找的方式发现服务，主动去发现服务并使用，下面两种方式分别是byName和byType\n\thelloService3 = ARouter.getInstance().navigation(HelloService.class);\n\thelloService4 = (HelloService) ARouter.getInstance().build(\"/service/hello\").navigation();\n\thelloService3.sayHello(\"Vergil\");\n\thelloService4.sayHello(\"Vergil\");\n    }\n}\n```\n\n# 原理解析\n\n\n\n\n","slug":"ARouter组件化框架学习笔记","published":1,"updated":"2019-03-12T09:26:33.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttzs00613a8k5pbfqyc8","content":"<p>ARouter是用于组件化的比较好的一个方案，不过性能方面肯定不如直接跳转。</p>\n<h1 id=\"基本使用方法\"><a href=\"#基本使用方法\" class=\"headerlink\" title=\"基本使用方法\"></a>基本使用方法</h1><ul>\n<li>添加依赖</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tjavaCompileOptions &#123;</span><br><span class=\"line\">\t    annotationProcessorOptions &#123;</span><br><span class=\"line\">\t\targuments = [ moduleName : project.getName() ]</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    // 替换成最新版本, 需要注意的是api</span><br><span class=\"line\">    // 要与compiler匹配使用，均使用最新版可以保证兼容</span><br><span class=\"line\">    compile &apos;com.alibaba:arouter-api:x.x.x&apos;</span><br><span class=\"line\">    annotationProcessor &apos;com.alibaba:arouter-compiler:x.x.x&apos;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 旧版本gradle插件(&lt; 2.2)，可以使用apt插件，配置方法见文末&apos;其他#4&apos;</span><br><span class=\"line\">// Kotlin配置参考文末&apos;其他#5&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>添加注解</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Route(path = &quot;/test/activity&quot;)</span><br><span class=\"line\">public class YourActivity extend Activity &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>初始化sdk</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (isDebug()) &#123;           // 这两行必须写在init之前，否则这些配置在init过程中将无效</span><br><span class=\"line\">    ARouter.openLog();     // 打印日志</span><br><span class=\"line\">    ARouter.openDebug();   // 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ARouter.init(mApplication); // 尽可能早，推荐在Application中初始化</span><br></pre></td></tr></table></figure>\n<ul>\n<li>进行路由操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1. 应用内简单的跳转(通过URL跳转在&apos;进阶用法&apos;中)</span><br><span class=\"line\">ARouter.getInstance().build(&quot;/test/activity&quot;).navigation();</span><br><span class=\"line\"></span><br><span class=\"line\">// 2. 跳转并携带参数</span><br><span class=\"line\">ARouter.getInstance().build(&quot;/test/1&quot;)</span><br><span class=\"line\">\t\t\t.withLong(&quot;key1&quot;, 666L)</span><br><span class=\"line\">\t\t\t.withString(&quot;key3&quot;, &quot;888&quot;)</span><br><span class=\"line\">\t\t\t.withObject(&quot;key4&quot;, new Test(&quot;Jack&quot;, &quot;Rose&quot;))</span><br><span class=\"line\">\t\t\t.navigation();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>混淆</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-keep public class com.alibaba.android.arouter.routes.**&#123;*;&#125;</span><br><span class=\"line\">-keep class * implements com.alibaba.android.arouter.facade.template.ISyringe&#123;*;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 如果使用了 byType 的方式获取 Service，需添加下面规则，保护接口</span><br><span class=\"line\">-keep interface * implements com.alibaba.android.arouter.facade.template.IProvider</span><br><span class=\"line\"></span><br><span class=\"line\"># 如果使用了 单类注入，即不定义接口实现 IProvider，需添加下面规则，保护实现</span><br><span class=\"line\">-keep class * implements com.alibaba.android.arouter.facade.template.IProvider</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用gradle进行路由表的自动加载</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &apos;com.alibaba.arouter&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath &quot;com.alibaba:arouter-register:1.0.0&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"进阶使用方法\"><a href=\"#进阶使用方法\" class=\"headerlink\" title=\"进阶使用方法\"></a>进阶使用方法</h1><ul>\n<li>通过url跳转<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 新建一个Activity用于监听Schame事件,之后直接把url传递给ARouter即可</span><br><span class=\"line\">public class SchameFilterActivity extends Activity &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">\tsuper.onCreate(savedInstanceState);</span><br><span class=\"line\"></span><br><span class=\"line\">\tUri uri = getIntent().getData();</span><br><span class=\"line\">\tARouter.getInstance().build(uri).navigation();</span><br><span class=\"line\">\tfinish();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>mainfest<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;activity android:name=&quot;.activity.SchameFilterActivity&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- Schame --&gt;</span><br><span class=\"line\">\t&lt;intent-filter&gt;</span><br><span class=\"line\">\t    &lt;data</span><br><span class=\"line\">\t\tandroid:host=&quot;m.aliyun.com&quot;</span><br><span class=\"line\">\t\tandroid:scheme=&quot;arouter&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class=\"line\">\t    &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;</span><br><span class=\"line\">\t&lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>解析url中的参数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 为每一个参数声明一个字段，并使用 @Autowired 标注</span><br><span class=\"line\">// URL中不能传递Parcelable类型数据，通过ARouter api可以传递Parcelable对象</span><br><span class=\"line\">@Route(path = &quot;/test/activity&quot;)</span><br><span class=\"line\">public class Test1Activity extends Activity &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    public String name;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">    @Autowired(name = &quot;girl&quot;) // 通过name来映射URL中的不同参数</span><br><span class=\"line\">    boolean boy;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    TestObj obj;    // 支持解析自定义对象，URL中使用json传递</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">\tsuper.onCreate(savedInstanceState);</span><br><span class=\"line\">\tARouter.getInstance().inject(this);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// ARouter会自动对字段进行赋值，无需主动获取</span><br><span class=\"line\">\tLog.d(&quot;param&quot;, name + age + boy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 如果需要传递自定义对象，需要实现 SerializationService,并使用@Route注解标注(方便用户自行选择序列化方式)，例如：</span><br><span class=\"line\">@Route(path = &quot;/service/json&quot;)</span><br><span class=\"line\">public class JsonServiceImpl implements SerializationService &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void init(Context context) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public &lt;T&gt; T json2Object(String text, Class&lt;T&gt; clazz) &#123;</span><br><span class=\"line\">        return JSON.parseObject(text, clazz);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String object2Json(Object instance) &#123;</span><br><span class=\"line\">        return JSON.toJSONString(instance);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>声明拦截器</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查</span><br><span class=\"line\">// 拦截器会在跳转之间执行，多个拦截器会按优先级顺序依次执行</span><br><span class=\"line\">@Interceptor(priority = 8, name = &quot;测试用拦截器&quot;)</span><br><span class=\"line\">public class TestInterceptor implements IInterceptor &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void process(Postcard postcard, InterceptorCallback callback) &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tcallback.onContinue(postcard);  // 处理完成，交还控制权</span><br><span class=\"line\">\t// callback.onInterrupt(new RuntimeException(&quot;我觉得有点异常&quot;));      // 觉得有问题，中断路由流程</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 以上两种至少需要调用其中一种，否则不会继续路由</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void init(Context context) &#123;</span><br><span class=\"line\">\t// 拦截器的初始化，会在sdk初始化的时候调用该方法，仅会调用一次</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>处理跳转结果</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用两个参数的navigation方法，可以获取单次跳转的结果</span><br><span class=\"line\">ARouter.getInstance().build(&quot;/test/1&quot;).navigation(this, new NavigationCallback() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onFound(Postcard postcard) &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onLost(Postcard postcard) &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>自定义全局降级策略</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 实现DegradeService接口，并加上一个Path内容任意的注解即可</span><br><span class=\"line\">@Route(path = &quot;/xxx/xxx&quot;)</span><br><span class=\"line\">public class DegradeServiceImpl implements DegradeService &#123;</span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  public void onLost(Context context, Postcard postcard) &#123;</span><br><span class=\"line\">\t// do something.</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  public void init(Context context) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>为目标页面声明更多信息</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 我们经常需要在目标页面中配置一些属性，比方说&quot;是否需要登陆&quot;之类的</span><br><span class=\"line\">// 可以通过 Route 注解中的 extras 属性进行扩展，这个属性是一个 int值，换句话说，单个int有4字节，也就是32位，可以配置32个开关</span><br><span class=\"line\">// 剩下的可以自行发挥，通过字节操作可以标识32个开关，通过开关标记目标页面的一些属性，在拦截器中可以拿到这个标记进行业务逻辑判断</span><br><span class=\"line\">@Route(path = &quot;/test/activity&quot;, extras = Consts.XXXX)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过依赖注入解耦:服务管理(一) 暴露服务</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 声明接口,其他组件通过接口来调用服务</span><br><span class=\"line\">public interface HelloService extends IProvider &#123;</span><br><span class=\"line\">    String sayHello(String name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 实现接口</span><br><span class=\"line\">@Route(path = &quot;/service/hello&quot;, name = &quot;测试服务&quot;)</span><br><span class=\"line\">public class HelloServiceImpl implements HelloService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String sayHello(String name) &#123;</span><br><span class=\"line\">\treturn &quot;hello, &quot; + name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void init(Context context) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过依赖注入解耦:服务管理(二) 发现服务</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    HelloService helloService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired(name = &quot;/service/hello&quot;)</span><br><span class=\"line\">    HelloService helloService2;</span><br><span class=\"line\"></span><br><span class=\"line\">    HelloService helloService3;</span><br><span class=\"line\"></span><br><span class=\"line\">    HelloService helloService4;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Test() &#123;</span><br><span class=\"line\">\tARouter.getInstance().inject(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void testService() &#123;</span><br><span class=\"line\">\t // 1. (推荐)使用依赖注入的方式发现服务,通过注解标注字段,即可使用，无需主动获取</span><br><span class=\"line\">\t // Autowired注解中标注name之后，将会使用byName的方式注入对应的字段，不设置name属性，会默认使用byType的方式发现服务(当同一接口有多个实现的时候，必须使用byName的方式发现服务)</span><br><span class=\"line\">\thelloService.sayHello(&quot;Vergil&quot;);</span><br><span class=\"line\">\thelloService2.sayHello(&quot;Vergil&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 2. 使用依赖查找的方式发现服务，主动去发现服务并使用，下面两种方式分别是byName和byType</span><br><span class=\"line\">\thelloService3 = ARouter.getInstance().navigation(HelloService.class);</span><br><span class=\"line\">\thelloService4 = (HelloService) ARouter.getInstance().build(&quot;/service/hello&quot;).navigation();</span><br><span class=\"line\">\thelloService3.sayHello(&quot;Vergil&quot;);</span><br><span class=\"line\">\thelloService4.sayHello(&quot;Vergil&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"原理解析\"><a href=\"#原理解析\" class=\"headerlink\" title=\"原理解析\"></a>原理解析</h1>","site":{"data":{}},"excerpt":"","more":"<p>ARouter是用于组件化的比较好的一个方案，不过性能方面肯定不如直接跳转。</p>\n<h1 id=\"基本使用方法\"><a href=\"#基本使用方法\" class=\"headerlink\" title=\"基本使用方法\"></a>基本使用方法</h1><ul>\n<li>添加依赖</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tjavaCompileOptions &#123;</span><br><span class=\"line\">\t    annotationProcessorOptions &#123;</span><br><span class=\"line\">\t\targuments = [ moduleName : project.getName() ]</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    // 替换成最新版本, 需要注意的是api</span><br><span class=\"line\">    // 要与compiler匹配使用，均使用最新版可以保证兼容</span><br><span class=\"line\">    compile &apos;com.alibaba:arouter-api:x.x.x&apos;</span><br><span class=\"line\">    annotationProcessor &apos;com.alibaba:arouter-compiler:x.x.x&apos;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 旧版本gradle插件(&lt; 2.2)，可以使用apt插件，配置方法见文末&apos;其他#4&apos;</span><br><span class=\"line\">// Kotlin配置参考文末&apos;其他#5&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>添加注解</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Route(path = &quot;/test/activity&quot;)</span><br><span class=\"line\">public class YourActivity extend Activity &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>初始化sdk</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (isDebug()) &#123;           // 这两行必须写在init之前，否则这些配置在init过程中将无效</span><br><span class=\"line\">    ARouter.openLog();     // 打印日志</span><br><span class=\"line\">    ARouter.openDebug();   // 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ARouter.init(mApplication); // 尽可能早，推荐在Application中初始化</span><br></pre></td></tr></table></figure>\n<ul>\n<li>进行路由操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1. 应用内简单的跳转(通过URL跳转在&apos;进阶用法&apos;中)</span><br><span class=\"line\">ARouter.getInstance().build(&quot;/test/activity&quot;).navigation();</span><br><span class=\"line\"></span><br><span class=\"line\">// 2. 跳转并携带参数</span><br><span class=\"line\">ARouter.getInstance().build(&quot;/test/1&quot;)</span><br><span class=\"line\">\t\t\t.withLong(&quot;key1&quot;, 666L)</span><br><span class=\"line\">\t\t\t.withString(&quot;key3&quot;, &quot;888&quot;)</span><br><span class=\"line\">\t\t\t.withObject(&quot;key4&quot;, new Test(&quot;Jack&quot;, &quot;Rose&quot;))</span><br><span class=\"line\">\t\t\t.navigation();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>混淆</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-keep public class com.alibaba.android.arouter.routes.**&#123;*;&#125;</span><br><span class=\"line\">-keep class * implements com.alibaba.android.arouter.facade.template.ISyringe&#123;*;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 如果使用了 byType 的方式获取 Service，需添加下面规则，保护接口</span><br><span class=\"line\">-keep interface * implements com.alibaba.android.arouter.facade.template.IProvider</span><br><span class=\"line\"></span><br><span class=\"line\"># 如果使用了 单类注入，即不定义接口实现 IProvider，需添加下面规则，保护实现</span><br><span class=\"line\">-keep class * implements com.alibaba.android.arouter.facade.template.IProvider</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用gradle进行路由表的自动加载</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &apos;com.alibaba.arouter&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath &quot;com.alibaba:arouter-register:1.0.0&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"进阶使用方法\"><a href=\"#进阶使用方法\" class=\"headerlink\" title=\"进阶使用方法\"></a>进阶使用方法</h1><ul>\n<li>通过url跳转<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 新建一个Activity用于监听Schame事件,之后直接把url传递给ARouter即可</span><br><span class=\"line\">public class SchameFilterActivity extends Activity &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">\tsuper.onCreate(savedInstanceState);</span><br><span class=\"line\"></span><br><span class=\"line\">\tUri uri = getIntent().getData();</span><br><span class=\"line\">\tARouter.getInstance().build(uri).navigation();</span><br><span class=\"line\">\tfinish();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>mainfest<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;activity android:name=&quot;.activity.SchameFilterActivity&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- Schame --&gt;</span><br><span class=\"line\">\t&lt;intent-filter&gt;</span><br><span class=\"line\">\t    &lt;data</span><br><span class=\"line\">\t\tandroid:host=&quot;m.aliyun.com&quot;</span><br><span class=\"line\">\t\tandroid:scheme=&quot;arouter&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class=\"line\">\t    &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;</span><br><span class=\"line\">\t&lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>解析url中的参数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 为每一个参数声明一个字段，并使用 @Autowired 标注</span><br><span class=\"line\">// URL中不能传递Parcelable类型数据，通过ARouter api可以传递Parcelable对象</span><br><span class=\"line\">@Route(path = &quot;/test/activity&quot;)</span><br><span class=\"line\">public class Test1Activity extends Activity &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    public String name;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">    @Autowired(name = &quot;girl&quot;) // 通过name来映射URL中的不同参数</span><br><span class=\"line\">    boolean boy;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    TestObj obj;    // 支持解析自定义对象，URL中使用json传递</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">\tsuper.onCreate(savedInstanceState);</span><br><span class=\"line\">\tARouter.getInstance().inject(this);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// ARouter会自动对字段进行赋值，无需主动获取</span><br><span class=\"line\">\tLog.d(&quot;param&quot;, name + age + boy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 如果需要传递自定义对象，需要实现 SerializationService,并使用@Route注解标注(方便用户自行选择序列化方式)，例如：</span><br><span class=\"line\">@Route(path = &quot;/service/json&quot;)</span><br><span class=\"line\">public class JsonServiceImpl implements SerializationService &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void init(Context context) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public &lt;T&gt; T json2Object(String text, Class&lt;T&gt; clazz) &#123;</span><br><span class=\"line\">        return JSON.parseObject(text, clazz);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String object2Json(Object instance) &#123;</span><br><span class=\"line\">        return JSON.toJSONString(instance);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>声明拦截器</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查</span><br><span class=\"line\">// 拦截器会在跳转之间执行，多个拦截器会按优先级顺序依次执行</span><br><span class=\"line\">@Interceptor(priority = 8, name = &quot;测试用拦截器&quot;)</span><br><span class=\"line\">public class TestInterceptor implements IInterceptor &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void process(Postcard postcard, InterceptorCallback callback) &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tcallback.onContinue(postcard);  // 处理完成，交还控制权</span><br><span class=\"line\">\t// callback.onInterrupt(new RuntimeException(&quot;我觉得有点异常&quot;));      // 觉得有问题，中断路由流程</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 以上两种至少需要调用其中一种，否则不会继续路由</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void init(Context context) &#123;</span><br><span class=\"line\">\t// 拦截器的初始化，会在sdk初始化的时候调用该方法，仅会调用一次</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>处理跳转结果</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用两个参数的navigation方法，可以获取单次跳转的结果</span><br><span class=\"line\">ARouter.getInstance().build(&quot;/test/1&quot;).navigation(this, new NavigationCallback() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onFound(Postcard postcard) &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onLost(Postcard postcard) &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>自定义全局降级策略</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 实现DegradeService接口，并加上一个Path内容任意的注解即可</span><br><span class=\"line\">@Route(path = &quot;/xxx/xxx&quot;)</span><br><span class=\"line\">public class DegradeServiceImpl implements DegradeService &#123;</span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  public void onLost(Context context, Postcard postcard) &#123;</span><br><span class=\"line\">\t// do something.</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  public void init(Context context) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>为目标页面声明更多信息</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 我们经常需要在目标页面中配置一些属性，比方说&quot;是否需要登陆&quot;之类的</span><br><span class=\"line\">// 可以通过 Route 注解中的 extras 属性进行扩展，这个属性是一个 int值，换句话说，单个int有4字节，也就是32位，可以配置32个开关</span><br><span class=\"line\">// 剩下的可以自行发挥，通过字节操作可以标识32个开关，通过开关标记目标页面的一些属性，在拦截器中可以拿到这个标记进行业务逻辑判断</span><br><span class=\"line\">@Route(path = &quot;/test/activity&quot;, extras = Consts.XXXX)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过依赖注入解耦:服务管理(一) 暴露服务</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 声明接口,其他组件通过接口来调用服务</span><br><span class=\"line\">public interface HelloService extends IProvider &#123;</span><br><span class=\"line\">    String sayHello(String name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 实现接口</span><br><span class=\"line\">@Route(path = &quot;/service/hello&quot;, name = &quot;测试服务&quot;)</span><br><span class=\"line\">public class HelloServiceImpl implements HelloService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String sayHello(String name) &#123;</span><br><span class=\"line\">\treturn &quot;hello, &quot; + name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void init(Context context) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过依赖注入解耦:服务管理(二) 发现服务</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    HelloService helloService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired(name = &quot;/service/hello&quot;)</span><br><span class=\"line\">    HelloService helloService2;</span><br><span class=\"line\"></span><br><span class=\"line\">    HelloService helloService3;</span><br><span class=\"line\"></span><br><span class=\"line\">    HelloService helloService4;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Test() &#123;</span><br><span class=\"line\">\tARouter.getInstance().inject(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void testService() &#123;</span><br><span class=\"line\">\t // 1. (推荐)使用依赖注入的方式发现服务,通过注解标注字段,即可使用，无需主动获取</span><br><span class=\"line\">\t // Autowired注解中标注name之后，将会使用byName的方式注入对应的字段，不设置name属性，会默认使用byType的方式发现服务(当同一接口有多个实现的时候，必须使用byName的方式发现服务)</span><br><span class=\"line\">\thelloService.sayHello(&quot;Vergil&quot;);</span><br><span class=\"line\">\thelloService2.sayHello(&quot;Vergil&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 2. 使用依赖查找的方式发现服务，主动去发现服务并使用，下面两种方式分别是byName和byType</span><br><span class=\"line\">\thelloService3 = ARouter.getInstance().navigation(HelloService.class);</span><br><span class=\"line\">\thelloService4 = (HelloService) ARouter.getInstance().build(&quot;/service/hello&quot;).navigation();</span><br><span class=\"line\">\thelloService3.sayHello(&quot;Vergil&quot;);</span><br><span class=\"line\">\thelloService4.sayHello(&quot;Vergil&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"原理解析\"><a href=\"#原理解析\" class=\"headerlink\" title=\"原理解析\"></a>原理解析</h1>"},{"title":"Android基础知识点","date":"2018-02-06T10:49:15.000Z","_content":"\n+ 为什么建议只使用默认的构造方法来创建 Fragment？\n\n之所以建议只使用默认的构造方式来创建fragment，是为了避免构造的过程中进行数据的设置。我们在oncreate和oncreateview的过程中可以获取bundle，这个bundle在存储fragment的时候同样可以被存储，而假如构造的模式进行设置参数的话，这些值就不会被系统存储。并且fragment的创建，其实是由fragmentmanager来初始化的，其初始化过程依靠了反射，并且是无参数反射，因此若不使用默认的构造的话会直接编译报错。\n\n+ 为什么 Bundle 被用来传递数据，为什么不能使用简单的 Map 数据结构？\n\nBundle内部是由ArrayMap实现的，ArrayMap的内部实现是两个数组，一个int数组是存储对象数据对应下标，一个对象数组保存key和value，内部使用二分法对key进行排序，所以在添加、删除、查找数据的时候，都会使用二分法查找，只适合于小数据量操作，如果在数据量比较大的情况下，那么它的性能将退化。而HashMap内部则是数组+链表结构，所以在数据量较少的时候，HashMap的Entry Array比ArrayMap占用更多的内存。因为使用Bundle的场景大多数为小数据量，我没见过在两个Activity之间传递10个以上数据的场景，所以相比之下，在这种情况下使用ArrayMap保存数据，在操作速度和内存占用上都具有优势，因此使用Bundle来传递数据，可以保证更快的速度和更少的内存占用。\n另外一个原因，则是在Android中如果使用Intent来携带数据的话，需要数据是基本类型或者是可序列化类型，HashMap使用Serializable进行序列化，而Bundle则是使用Parcelable进行序列化。而在Android平台中，更推荐使用Parcelable实现序列化，虽然写法复杂，但是开销更小，所以为了更加快速的进行数据的序列化和反序列化，系统封装了Bundle类，方便我们进行数据的传输。\n\n+ 什么是 JobScheduler ？\n\njobscheduler提供了一种不同于alarmmanager的唤醒app的方式，其主要工作场景：应用具有您可以推迟的非面向用户的工作。/应用具有当插入设备时您希望优先执行的工作。/应用具有需要访问网络或 Wi-Fi 连接的任务。/应用具有您希望作为一个批次定期运行的许多任务。\n\n+ 什么是 ANR ？如何避免发生 ANR ？\n\nANR = application not response\n\nanr一般有三种类型：\nKeyDispatchTimeout(5 seconds) --主要类型按键或触摸事件在特定时间内无响应；\nBroadcastTimeout(10 seconds) --BroadcastReceiver在特定时间内无法处理完成；\nServiceTimeout(20 seconds) --小概率类型 Service在特定的时间内无法处理完成\n\n避免的方法：\n\nUI线程尽量只做跟UI相关的工作\n耗时的工作（比如数据库操作，I/O，连接网络或者别的有可能阻碍UI线程的操作）把它放入单独的线程处理\n尽量用Handler来处理UIthread和别的thread之间的交互\n\n措施：\n\n首先分析log\n从trace.txt文件查看调用stack.\n看代码\n仔细查看ANR的成因（iowait?block?memoryleak?）\n\n+ 解释一下 broadcast 和 intent 在 app 内传递消息的工作流程。\n\n广播的注册过程 ：最终在ActivityManagerService中将远程的InnerInnerReceiver以及Intent－filter对象存储起来。 \n广播的发送以及接受：内部会首先根据传入的Intent－filter 查找出匹配的广播接受者，并将改接受者放到BroadcastQueue中，紧接着系统会遍历ArrayList中的广播，并将其发送给它们对应的广播接受者，最后调用到广播接受者的onReceiver方法。\n\nIntent传递消息过程：intent在putextra的过程中将消息放入bundle中，bundle由于实现了parcel接口，故可以进行ipc通信，最后通过目标activity从parcel中恢复状态信息，这里面的parcel完成了数据的序列化传输。\n\n+ 当 Bitmap 占用较多内存时，你是怎么处理的？\n\n由于内存管理上将外部内存完全当成了当前堆的一部分，也就是说Bitmap对象通过栈上的引用来指向堆上的Bitmap对象，而堆上的Bitmap对象又对应了一个使用了外部存储的native图像，也就是实际上使用的字节数组byte[]来存储的位图信息，因此解码之后的Bitmap的总大小就不能超过8M了。\n\n设置系统的最小堆大小：\n```\n\tint newSize = 4 * 1024 * 1024 ; //设置最小堆内存大小为4MB  \n\tVMRuntime.getRuntime().setMinimumHeapSize(newSize);  \n\tVMRuntime.getRuntime().setTargetHeapUtilization(0.75); // 设置堆内存的利用率为75%  \n```\n\n对图片的大小进行控制:\n```\n\tBitmapFactory.Options options = new BitmapFactory.Options();  \n\toptions.inSampleSize = 2; //图片宽高都为原来的二分之一，即图片为原来的四分之一  \n\tBitmap bitmap = BitmapFactory.decodeFile(\"/mnt/sdcard/a.jpg\",options);  \n```\n\n对bitmapfactory解码的参数进行设置：\n```\n\tBitmapFactory.Options options = new BitmapFactory.Options();  \n\toptions.inTempStorage = new byte[1024*1024*5]; //5MB的临时存储空间  \n\tBitmap bm = BitmapFactory.decodeFile(\"/mnt/sdcard/a.jpg\",options);  \n```\n\n+ 什么是 Dalvik 虚拟机？\n\n每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。\ndalvik虚拟机使用dex文件的java文件格式，class文件中会附带着不少额外信息，dex文件对其进行精简，将所有的class文件整合一起，减少了文件尺寸和io操作的同时也提高了类的加载速度。\n\n每一个应用都运行在一个dalvik虚拟机里面，而每一个虚拟机都有一个独立的进程空间\n\n+ 什么是 Sticky Intent？\n\n在MainActivity里面会有sendBroadcast和sendStickyBroacat.在ReceverActivity里面通 过BroadcastReceiver来接收这两个消息，在ReceiverActivity里是通过代码来注册Recevier而不是在 Manifest里面注册的。所以通过sendBroadcast中发出的intent在ReceverActivity不处于onResume状态是无 法接受到的，即使后面再次使其处于该状态也无法接受到。而sendStickyBroadcast发出的Intent当ReceverActivity重 新处于onResume状态之后就能重新接受到其Intent.这就是the Intent will be held to be re-broadcast to future receivers这句话的表现。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Recevier处于活跃的 时候，又会接受到它。\n\n+ Android 的权限有多少个不同的保护等级？\n\n四种，normal，dangerous，signature，signatureOrSystem\n\n普通权限 会在App安装期间被默认赋予。这类权限不需要开发人员进行额外操作。\n\n危险权限是在开发6.0程序时，必须要注意的。这些权限处理不好，程序可能会直接被系统干掉。危险权限以组进行划分，对该组内的一个权限授权视为对整个组进行授权，但是对开发来讲，仍然需要正对每个需要的权限进行获取，否则后期版本的变更会导致权限组划分更改。\n\n签名级别权限和系统签名级别权限需要拥有platform级别的认证才能申请。\n\n+ 在转屏时你如何保存 Activity 的状态？\n\n不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次\n\n设置Activity的android:configChanges=\"orientation\"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次\n\n设置Activity的android:configChanges=\"orientation|keyboardHidden\"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法\n\n但是，自从Android 3.2（API 13），在设置Activity的android:configChanges=\"orientation|keyboardHidden\"后，还是一样会重新调用各个生命周期的。因为screen size也开始跟着设备的横竖切换而改变。所以，在AndroidManifest.xml里设置的MiniSdkVersion和 TargetSdkVersion属性大于等于13的情况下，如果你想阻止程序在运行时重新加载Activity，除了设置\"orientation\"，你还必须设置\"ScreenSize\"。\n解决方法：\n\nAndroidManifest.xml中设置android:configChanges=\"orientation|screenSize\"\n\n+ 如何实现 XML 命名空间？\n\n常见命名空间\nandroid：xmlns:android=”http://schemas.android.com/apk/res/android”\n解析：xmlns:即xml namespace，声明我们要开始定义一个命名空间了 \nandroid：称作namespace-prefix，它是命名空间的名字 \nhttp://schemas.android.com/apk/res/android：这看起来是一个URL，但是这个地址是不可访问的。实际上这是一个URI(统一资源标识符),所以它的值是固定不变的,相当于一个常量)。\n\n```\n\t<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center\"\n        android:text=\"New Text\"\n        android:id=\"@+id/textView\" />\n\t</LinearLayout>\n```\n\n亦可以写成\n\n```\n\t<LinearLayout xmlns:myns=\"http://schemas.android.com/apk/res/android\"\n    myns:layout_width=\"match_parent\"\n    myns:layout_height=\"match_parent\" >\n    <TextView\n        myns:layout_width=\"wrap_content\"\n        myns:layout_height=\"wrap_content\"\n        myns:layout_gravity=\"center\"\n        myns:text=\"New Text\"\n        myns:id=\"@+id/textView\" />\n\t</LinearLayout>\n```\n\n\ntools:xmlns:tools=”http://schemas.android.com/tools”\n\ntools只作用于开发阶段\n我们可以把他理解为一个工具(tools)的命名空间,它的只作用于开发阶段,当app被打包时,所有关于tools属性将都会被摒弃掉！\n\ntools:context开发中查看Activity布局效果\ncontext的用法，在后面跟一个Activtiy的完整包名,它有什么作用呢?\n\n当我们设置一个Activity主题时,是在AndroidManifest.xml中设置中,而主题的效果又只能在运行后在Activtiy中显示\n\n使用context属性, 可以在开发阶段中看到设置在Activity中的主题效果\n\ntools:context=”com.littlehan.myapplication.MainActivity”\n\n在布局中加入这行代码,就可以在design视图中看到与MainActivity绑定主题的效果。\n\ntools:layout开发中查看fragment布局效果\n当我们在Activity上加载一个fragment时，是需要在运行后才可以看到加载后的效果,有没有方法在测试阶段就在布局预览窗口上显示呢?\n\n答案是有的,借助layout属性,例如,在布局中加入这样一行代码: \ntools:layout=@layout/yourfragmentlayoutname \n这样你的编写的fragment布局就会预览在指定主布局上了\n\napp:xmlns:app=”http://schemas.android.com/apk/res-auto”\n\napp命名空间为用户自定义，通过attrs进行设置，然后通过自定义view进行解析。\n\n\n+ Application 和 Activity 的 Context 对象的区别\n\n这是两种不同的context，也是最常见的两种.第一种中context的生命周期与Application的生命周期相关的，context随着Application的销毁而销毁，伴随application的一生，与activity的生命周期无关.第二种中的context跟Activity的生命周期是相关的，但是对一个Application来说，Activity可以销毁几次，那么属于Activity的context就会销毁多次.至于用哪种context，得看应用场景，个人感觉用Activity的context好一点，不过也有的时候必须使用Application的context.application context可以通过\nContext.getApplicationContext或者Activity.getApplication方法获取.\n\n还有就是，在使用context的时候，小心内存泄露，防止内存泄露，注意一下几个方面：\n\n　1. 不要让生命周期长的对象引用activity context，即保证引用activity的对象要与activity本身生命周期是一样的\n\n　2. 对于生命周期长的对象，可以使用application context\n\n　3. 避免非静态的内部类，尽量使用静态类，避免生命周期问题，注意内部类对外部对象引用导致的生命周期变化\n\n","source":"_posts/Android基础知识点.md","raw":"---\ntitle: Android基础知识点\ndate: 2018-02-06 18:49:15\ntags: android\n---\n\n+ 为什么建议只使用默认的构造方法来创建 Fragment？\n\n之所以建议只使用默认的构造方式来创建fragment，是为了避免构造的过程中进行数据的设置。我们在oncreate和oncreateview的过程中可以获取bundle，这个bundle在存储fragment的时候同样可以被存储，而假如构造的模式进行设置参数的话，这些值就不会被系统存储。并且fragment的创建，其实是由fragmentmanager来初始化的，其初始化过程依靠了反射，并且是无参数反射，因此若不使用默认的构造的话会直接编译报错。\n\n+ 为什么 Bundle 被用来传递数据，为什么不能使用简单的 Map 数据结构？\n\nBundle内部是由ArrayMap实现的，ArrayMap的内部实现是两个数组，一个int数组是存储对象数据对应下标，一个对象数组保存key和value，内部使用二分法对key进行排序，所以在添加、删除、查找数据的时候，都会使用二分法查找，只适合于小数据量操作，如果在数据量比较大的情况下，那么它的性能将退化。而HashMap内部则是数组+链表结构，所以在数据量较少的时候，HashMap的Entry Array比ArrayMap占用更多的内存。因为使用Bundle的场景大多数为小数据量，我没见过在两个Activity之间传递10个以上数据的场景，所以相比之下，在这种情况下使用ArrayMap保存数据，在操作速度和内存占用上都具有优势，因此使用Bundle来传递数据，可以保证更快的速度和更少的内存占用。\n另外一个原因，则是在Android中如果使用Intent来携带数据的话，需要数据是基本类型或者是可序列化类型，HashMap使用Serializable进行序列化，而Bundle则是使用Parcelable进行序列化。而在Android平台中，更推荐使用Parcelable实现序列化，虽然写法复杂，但是开销更小，所以为了更加快速的进行数据的序列化和反序列化，系统封装了Bundle类，方便我们进行数据的传输。\n\n+ 什么是 JobScheduler ？\n\njobscheduler提供了一种不同于alarmmanager的唤醒app的方式，其主要工作场景：应用具有您可以推迟的非面向用户的工作。/应用具有当插入设备时您希望优先执行的工作。/应用具有需要访问网络或 Wi-Fi 连接的任务。/应用具有您希望作为一个批次定期运行的许多任务。\n\n+ 什么是 ANR ？如何避免发生 ANR ？\n\nANR = application not response\n\nanr一般有三种类型：\nKeyDispatchTimeout(5 seconds) --主要类型按键或触摸事件在特定时间内无响应；\nBroadcastTimeout(10 seconds) --BroadcastReceiver在特定时间内无法处理完成；\nServiceTimeout(20 seconds) --小概率类型 Service在特定的时间内无法处理完成\n\n避免的方法：\n\nUI线程尽量只做跟UI相关的工作\n耗时的工作（比如数据库操作，I/O，连接网络或者别的有可能阻碍UI线程的操作）把它放入单独的线程处理\n尽量用Handler来处理UIthread和别的thread之间的交互\n\n措施：\n\n首先分析log\n从trace.txt文件查看调用stack.\n看代码\n仔细查看ANR的成因（iowait?block?memoryleak?）\n\n+ 解释一下 broadcast 和 intent 在 app 内传递消息的工作流程。\n\n广播的注册过程 ：最终在ActivityManagerService中将远程的InnerInnerReceiver以及Intent－filter对象存储起来。 \n广播的发送以及接受：内部会首先根据传入的Intent－filter 查找出匹配的广播接受者，并将改接受者放到BroadcastQueue中，紧接着系统会遍历ArrayList中的广播，并将其发送给它们对应的广播接受者，最后调用到广播接受者的onReceiver方法。\n\nIntent传递消息过程：intent在putextra的过程中将消息放入bundle中，bundle由于实现了parcel接口，故可以进行ipc通信，最后通过目标activity从parcel中恢复状态信息，这里面的parcel完成了数据的序列化传输。\n\n+ 当 Bitmap 占用较多内存时，你是怎么处理的？\n\n由于内存管理上将外部内存完全当成了当前堆的一部分，也就是说Bitmap对象通过栈上的引用来指向堆上的Bitmap对象，而堆上的Bitmap对象又对应了一个使用了外部存储的native图像，也就是实际上使用的字节数组byte[]来存储的位图信息，因此解码之后的Bitmap的总大小就不能超过8M了。\n\n设置系统的最小堆大小：\n```\n\tint newSize = 4 * 1024 * 1024 ; //设置最小堆内存大小为4MB  \n\tVMRuntime.getRuntime().setMinimumHeapSize(newSize);  \n\tVMRuntime.getRuntime().setTargetHeapUtilization(0.75); // 设置堆内存的利用率为75%  \n```\n\n对图片的大小进行控制:\n```\n\tBitmapFactory.Options options = new BitmapFactory.Options();  \n\toptions.inSampleSize = 2; //图片宽高都为原来的二分之一，即图片为原来的四分之一  \n\tBitmap bitmap = BitmapFactory.decodeFile(\"/mnt/sdcard/a.jpg\",options);  \n```\n\n对bitmapfactory解码的参数进行设置：\n```\n\tBitmapFactory.Options options = new BitmapFactory.Options();  \n\toptions.inTempStorage = new byte[1024*1024*5]; //5MB的临时存储空间  \n\tBitmap bm = BitmapFactory.decodeFile(\"/mnt/sdcard/a.jpg\",options);  \n```\n\n+ 什么是 Dalvik 虚拟机？\n\n每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。\ndalvik虚拟机使用dex文件的java文件格式，class文件中会附带着不少额外信息，dex文件对其进行精简，将所有的class文件整合一起，减少了文件尺寸和io操作的同时也提高了类的加载速度。\n\n每一个应用都运行在一个dalvik虚拟机里面，而每一个虚拟机都有一个独立的进程空间\n\n+ 什么是 Sticky Intent？\n\n在MainActivity里面会有sendBroadcast和sendStickyBroacat.在ReceverActivity里面通 过BroadcastReceiver来接收这两个消息，在ReceiverActivity里是通过代码来注册Recevier而不是在 Manifest里面注册的。所以通过sendBroadcast中发出的intent在ReceverActivity不处于onResume状态是无 法接受到的，即使后面再次使其处于该状态也无法接受到。而sendStickyBroadcast发出的Intent当ReceverActivity重 新处于onResume状态之后就能重新接受到其Intent.这就是the Intent will be held to be re-broadcast to future receivers这句话的表现。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Recevier处于活跃的 时候，又会接受到它。\n\n+ Android 的权限有多少个不同的保护等级？\n\n四种，normal，dangerous，signature，signatureOrSystem\n\n普通权限 会在App安装期间被默认赋予。这类权限不需要开发人员进行额外操作。\n\n危险权限是在开发6.0程序时，必须要注意的。这些权限处理不好，程序可能会直接被系统干掉。危险权限以组进行划分，对该组内的一个权限授权视为对整个组进行授权，但是对开发来讲，仍然需要正对每个需要的权限进行获取，否则后期版本的变更会导致权限组划分更改。\n\n签名级别权限和系统签名级别权限需要拥有platform级别的认证才能申请。\n\n+ 在转屏时你如何保存 Activity 的状态？\n\n不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次\n\n设置Activity的android:configChanges=\"orientation\"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次\n\n设置Activity的android:configChanges=\"orientation|keyboardHidden\"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法\n\n但是，自从Android 3.2（API 13），在设置Activity的android:configChanges=\"orientation|keyboardHidden\"后，还是一样会重新调用各个生命周期的。因为screen size也开始跟着设备的横竖切换而改变。所以，在AndroidManifest.xml里设置的MiniSdkVersion和 TargetSdkVersion属性大于等于13的情况下，如果你想阻止程序在运行时重新加载Activity，除了设置\"orientation\"，你还必须设置\"ScreenSize\"。\n解决方法：\n\nAndroidManifest.xml中设置android:configChanges=\"orientation|screenSize\"\n\n+ 如何实现 XML 命名空间？\n\n常见命名空间\nandroid：xmlns:android=”http://schemas.android.com/apk/res/android”\n解析：xmlns:即xml namespace，声明我们要开始定义一个命名空间了 \nandroid：称作namespace-prefix，它是命名空间的名字 \nhttp://schemas.android.com/apk/res/android：这看起来是一个URL，但是这个地址是不可访问的。实际上这是一个URI(统一资源标识符),所以它的值是固定不变的,相当于一个常量)。\n\n```\n\t<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center\"\n        android:text=\"New Text\"\n        android:id=\"@+id/textView\" />\n\t</LinearLayout>\n```\n\n亦可以写成\n\n```\n\t<LinearLayout xmlns:myns=\"http://schemas.android.com/apk/res/android\"\n    myns:layout_width=\"match_parent\"\n    myns:layout_height=\"match_parent\" >\n    <TextView\n        myns:layout_width=\"wrap_content\"\n        myns:layout_height=\"wrap_content\"\n        myns:layout_gravity=\"center\"\n        myns:text=\"New Text\"\n        myns:id=\"@+id/textView\" />\n\t</LinearLayout>\n```\n\n\ntools:xmlns:tools=”http://schemas.android.com/tools”\n\ntools只作用于开发阶段\n我们可以把他理解为一个工具(tools)的命名空间,它的只作用于开发阶段,当app被打包时,所有关于tools属性将都会被摒弃掉！\n\ntools:context开发中查看Activity布局效果\ncontext的用法，在后面跟一个Activtiy的完整包名,它有什么作用呢?\n\n当我们设置一个Activity主题时,是在AndroidManifest.xml中设置中,而主题的效果又只能在运行后在Activtiy中显示\n\n使用context属性, 可以在开发阶段中看到设置在Activity中的主题效果\n\ntools:context=”com.littlehan.myapplication.MainActivity”\n\n在布局中加入这行代码,就可以在design视图中看到与MainActivity绑定主题的效果。\n\ntools:layout开发中查看fragment布局效果\n当我们在Activity上加载一个fragment时，是需要在运行后才可以看到加载后的效果,有没有方法在测试阶段就在布局预览窗口上显示呢?\n\n答案是有的,借助layout属性,例如,在布局中加入这样一行代码: \ntools:layout=@layout/yourfragmentlayoutname \n这样你的编写的fragment布局就会预览在指定主布局上了\n\napp:xmlns:app=”http://schemas.android.com/apk/res-auto”\n\napp命名空间为用户自定义，通过attrs进行设置，然后通过自定义view进行解析。\n\n\n+ Application 和 Activity 的 Context 对象的区别\n\n这是两种不同的context，也是最常见的两种.第一种中context的生命周期与Application的生命周期相关的，context随着Application的销毁而销毁，伴随application的一生，与activity的生命周期无关.第二种中的context跟Activity的生命周期是相关的，但是对一个Application来说，Activity可以销毁几次，那么属于Activity的context就会销毁多次.至于用哪种context，得看应用场景，个人感觉用Activity的context好一点，不过也有的时候必须使用Application的context.application context可以通过\nContext.getApplicationContext或者Activity.getApplication方法获取.\n\n还有就是，在使用context的时候，小心内存泄露，防止内存泄露，注意一下几个方面：\n\n　1. 不要让生命周期长的对象引用activity context，即保证引用activity的对象要与activity本身生命周期是一样的\n\n　2. 对于生命周期长的对象，可以使用application context\n\n　3. 避免非静态的内部类，尽量使用静态类，避免生命周期问题，注意内部类对外部对象引用导致的生命周期变化\n\n","slug":"Android基础知识点","published":1,"updated":"2019-03-12T09:26:33.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttzt00633a8k1hlkcvdq","content":"<ul>\n<li>为什么建议只使用默认的构造方法来创建 Fragment？</li>\n</ul>\n<p>之所以建议只使用默认的构造方式来创建fragment，是为了避免构造的过程中进行数据的设置。我们在oncreate和oncreateview的过程中可以获取bundle，这个bundle在存储fragment的时候同样可以被存储，而假如构造的模式进行设置参数的话，这些值就不会被系统存储。并且fragment的创建，其实是由fragmentmanager来初始化的，其初始化过程依靠了反射，并且是无参数反射，因此若不使用默认的构造的话会直接编译报错。</p>\n<ul>\n<li>为什么 Bundle 被用来传递数据，为什么不能使用简单的 Map 数据结构？</li>\n</ul>\n<p>Bundle内部是由ArrayMap实现的，ArrayMap的内部实现是两个数组，一个int数组是存储对象数据对应下标，一个对象数组保存key和value，内部使用二分法对key进行排序，所以在添加、删除、查找数据的时候，都会使用二分法查找，只适合于小数据量操作，如果在数据量比较大的情况下，那么它的性能将退化。而HashMap内部则是数组+链表结构，所以在数据量较少的时候，HashMap的Entry Array比ArrayMap占用更多的内存。因为使用Bundle的场景大多数为小数据量，我没见过在两个Activity之间传递10个以上数据的场景，所以相比之下，在这种情况下使用ArrayMap保存数据，在操作速度和内存占用上都具有优势，因此使用Bundle来传递数据，可以保证更快的速度和更少的内存占用。<br>另外一个原因，则是在Android中如果使用Intent来携带数据的话，需要数据是基本类型或者是可序列化类型，HashMap使用Serializable进行序列化，而Bundle则是使用Parcelable进行序列化。而在Android平台中，更推荐使用Parcelable实现序列化，虽然写法复杂，但是开销更小，所以为了更加快速的进行数据的序列化和反序列化，系统封装了Bundle类，方便我们进行数据的传输。</p>\n<ul>\n<li>什么是 JobScheduler ？</li>\n</ul>\n<p>jobscheduler提供了一种不同于alarmmanager的唤醒app的方式，其主要工作场景：应用具有您可以推迟的非面向用户的工作。/应用具有当插入设备时您希望优先执行的工作。/应用具有需要访问网络或 Wi-Fi 连接的任务。/应用具有您希望作为一个批次定期运行的许多任务。</p>\n<ul>\n<li>什么是 ANR ？如何避免发生 ANR ？</li>\n</ul>\n<p>ANR = application not response</p>\n<p>anr一般有三种类型：<br>KeyDispatchTimeout(5 seconds) –主要类型按键或触摸事件在特定时间内无响应；<br>BroadcastTimeout(10 seconds) –BroadcastReceiver在特定时间内无法处理完成；<br>ServiceTimeout(20 seconds) –小概率类型 Service在特定的时间内无法处理完成</p>\n<p>避免的方法：</p>\n<p>UI线程尽量只做跟UI相关的工作<br>耗时的工作（比如数据库操作，I/O，连接网络或者别的有可能阻碍UI线程的操作）把它放入单独的线程处理<br>尽量用Handler来处理UIthread和别的thread之间的交互</p>\n<p>措施：</p>\n<p>首先分析log<br>从trace.txt文件查看调用stack.<br>看代码<br>仔细查看ANR的成因（iowait?block?memoryleak?）</p>\n<ul>\n<li>解释一下 broadcast 和 intent 在 app 内传递消息的工作流程。</li>\n</ul>\n<p>广播的注册过程 ：最终在ActivityManagerService中将远程的InnerInnerReceiver以及Intent－filter对象存储起来。<br>广播的发送以及接受：内部会首先根据传入的Intent－filter 查找出匹配的广播接受者，并将改接受者放到BroadcastQueue中，紧接着系统会遍历ArrayList中的广播，并将其发送给它们对应的广播接受者，最后调用到广播接受者的onReceiver方法。</p>\n<p>Intent传递消息过程：intent在putextra的过程中将消息放入bundle中，bundle由于实现了parcel接口，故可以进行ipc通信，最后通过目标activity从parcel中恢复状态信息，这里面的parcel完成了数据的序列化传输。</p>\n<ul>\n<li>当 Bitmap 占用较多内存时，你是怎么处理的？</li>\n</ul>\n<p>由于内存管理上将外部内存完全当成了当前堆的一部分，也就是说Bitmap对象通过栈上的引用来指向堆上的Bitmap对象，而堆上的Bitmap对象又对应了一个使用了外部存储的native图像，也就是实际上使用的字节数组byte[]来存储的位图信息，因此解码之后的Bitmap的总大小就不能超过8M了。</p>\n<p>设置系统的最小堆大小：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int newSize = 4 * 1024 * 1024 ; //设置最小堆内存大小为4MB  </span><br><span class=\"line\">VMRuntime.getRuntime().setMinimumHeapSize(newSize);  </span><br><span class=\"line\">VMRuntime.getRuntime().setTargetHeapUtilization(0.75); // 设置堆内存的利用率为75%</span><br></pre></td></tr></table></figure></p>\n<p>对图片的大小进行控制:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BitmapFactory.Options options = new BitmapFactory.Options();  </span><br><span class=\"line\">options.inSampleSize = 2; //图片宽高都为原来的二分之一，即图片为原来的四分之一  </span><br><span class=\"line\">Bitmap bitmap = BitmapFactory.decodeFile(&quot;/mnt/sdcard/a.jpg&quot;,options);</span><br></pre></td></tr></table></figure></p>\n<p>对bitmapfactory解码的参数进行设置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BitmapFactory.Options options = new BitmapFactory.Options();  </span><br><span class=\"line\">options.inTempStorage = new byte[1024*1024*5]; //5MB的临时存储空间  </span><br><span class=\"line\">Bitmap bm = BitmapFactory.decodeFile(&quot;/mnt/sdcard/a.jpg&quot;,options);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>什么是 Dalvik 虚拟机？</li>\n</ul>\n<p>每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。<br>dalvik虚拟机使用dex文件的java文件格式，class文件中会附带着不少额外信息，dex文件对其进行精简，将所有的class文件整合一起，减少了文件尺寸和io操作的同时也提高了类的加载速度。</p>\n<p>每一个应用都运行在一个dalvik虚拟机里面，而每一个虚拟机都有一个独立的进程空间</p>\n<ul>\n<li>什么是 Sticky Intent？</li>\n</ul>\n<p>在MainActivity里面会有sendBroadcast和sendStickyBroacat.在ReceverActivity里面通 过BroadcastReceiver来接收这两个消息，在ReceiverActivity里是通过代码来注册Recevier而不是在 Manifest里面注册的。所以通过sendBroadcast中发出的intent在ReceverActivity不处于onResume状态是无 法接受到的，即使后面再次使其处于该状态也无法接受到。而sendStickyBroadcast发出的Intent当ReceverActivity重 新处于onResume状态之后就能重新接受到其Intent.这就是the Intent will be held to be re-broadcast to future receivers这句话的表现。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Recevier处于活跃的 时候，又会接受到它。</p>\n<ul>\n<li>Android 的权限有多少个不同的保护等级？</li>\n</ul>\n<p>四种，normal，dangerous，signature，signatureOrSystem</p>\n<p>普通权限 会在App安装期间被默认赋予。这类权限不需要开发人员进行额外操作。</p>\n<p>危险权限是在开发6.0程序时，必须要注意的。这些权限处理不好，程序可能会直接被系统干掉。危险权限以组进行划分，对该组内的一个权限授权视为对整个组进行授权，但是对开发来讲，仍然需要正对每个需要的权限进行获取，否则后期版本的变更会导致权限组划分更改。</p>\n<p>签名级别权限和系统签名级别权限需要拥有platform级别的认证才能申请。</p>\n<ul>\n<li>在转屏时你如何保存 Activity 的状态？</li>\n</ul>\n<p>不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次</p>\n<p>设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次</p>\n<p>设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</p>\n<p>但是，自从Android 3.2（API 13），在设置Activity的android:configChanges=”orientation|keyboardHidden”后，还是一样会重新调用各个生命周期的。因为screen size也开始跟着设备的横竖切换而改变。所以，在AndroidManifest.xml里设置的MiniSdkVersion和 TargetSdkVersion属性大于等于13的情况下，如果你想阻止程序在运行时重新加载Activity，除了设置”orientation”，你还必须设置”ScreenSize”。<br>解决方法：</p>\n<p>AndroidManifest.xml中设置android:configChanges=”orientation|screenSize”</p>\n<ul>\n<li>如何实现 XML 命名空间？</li>\n</ul>\n<p>常见命名空间<br>android：xmlns:android=”<a href=\"http://schemas.android.com/apk/res/android”\" target=\"_blank\" rel=\"noopener\">http://schemas.android.com/apk/res/android”</a><br>解析：xmlns:即xml namespace，声明我们要开始定义一个命名空间了<br>android：称作namespace-prefix，它是命名空间的名字<br><a href=\"http://schemas.android.com/apk/res/android：这看起来是一个URL，但是这个地址是不可访问的。实际上这是一个URI(统一资源标识符),所以它的值是固定不变的,相当于一个常量)。\" target=\"_blank\" rel=\"noopener\">http://schemas.android.com/apk/res/android：这看起来是一个URL，但是这个地址是不可访问的。实际上这是一个URI(统一资源标识符),所以它的值是固定不变的,相当于一个常量)。</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">   android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">   android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class=\"line\">   &lt;TextView</span><br><span class=\"line\">       android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">       android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">       android:layout_gravity=&quot;center&quot;</span><br><span class=\"line\">       android:text=&quot;New Text&quot;</span><br><span class=\"line\">       android:id=&quot;@+id/textView&quot; /&gt;</span><br><span class=\"line\">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>\n<p>亦可以写成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;LinearLayout xmlns:myns=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">   myns:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">   myns:layout_height=&quot;match_parent&quot; &gt;</span><br><span class=\"line\">   &lt;TextView</span><br><span class=\"line\">       myns:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">       myns:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">       myns:layout_gravity=&quot;center&quot;</span><br><span class=\"line\">       myns:text=&quot;New Text&quot;</span><br><span class=\"line\">       myns:id=&quot;@+id/textView&quot; /&gt;</span><br><span class=\"line\">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>\n<p>tools:xmlns:tools=”<a href=\"http://schemas.android.com/tools”\" target=\"_blank\" rel=\"noopener\">http://schemas.android.com/tools”</a></p>\n<p>tools只作用于开发阶段<br>我们可以把他理解为一个工具(tools)的命名空间,它的只作用于开发阶段,当app被打包时,所有关于tools属性将都会被摒弃掉！</p>\n<p>tools:context开发中查看Activity布局效果<br>context的用法，在后面跟一个Activtiy的完整包名,它有什么作用呢?</p>\n<p>当我们设置一个Activity主题时,是在AndroidManifest.xml中设置中,而主题的效果又只能在运行后在Activtiy中显示</p>\n<p>使用context属性, 可以在开发阶段中看到设置在Activity中的主题效果</p>\n<p>tools:context=”com.littlehan.myapplication.MainActivity”</p>\n<p>在布局中加入这行代码,就可以在design视图中看到与MainActivity绑定主题的效果。</p>\n<p>tools:layout开发中查看fragment布局效果<br>当我们在Activity上加载一个fragment时，是需要在运行后才可以看到加载后的效果,有没有方法在测试阶段就在布局预览窗口上显示呢?</p>\n<p>答案是有的,借助layout属性,例如,在布局中加入这样一行代码:<br>tools:layout=@layout/yourfragmentlayoutname<br>这样你的编写的fragment布局就会预览在指定主布局上了</p>\n<p>app:xmlns:app=”<a href=\"http://schemas.android.com/apk/res-auto”\" target=\"_blank\" rel=\"noopener\">http://schemas.android.com/apk/res-auto”</a></p>\n<p>app命名空间为用户自定义，通过attrs进行设置，然后通过自定义view进行解析。</p>\n<ul>\n<li>Application 和 Activity 的 Context 对象的区别</li>\n</ul>\n<p>这是两种不同的context，也是最常见的两种.第一种中context的生命周期与Application的生命周期相关的，context随着Application的销毁而销毁，伴随application的一生，与activity的生命周期无关.第二种中的context跟Activity的生命周期是相关的，但是对一个Application来说，Activity可以销毁几次，那么属于Activity的context就会销毁多次.至于用哪种context，得看应用场景，个人感觉用Activity的context好一点，不过也有的时候必须使用Application的context.application context可以通过<br>Context.getApplicationContext或者Activity.getApplication方法获取.</p>\n<p>还有就是，在使用context的时候，小心内存泄露，防止内存泄露，注意一下几个方面：</p>\n<p>　1. 不要让生命周期长的对象引用activity context，即保证引用activity的对象要与activity本身生命周期是一样的</p>\n<p>　2. 对于生命周期长的对象，可以使用application context</p>\n<p>　3. 避免非静态的内部类，尽量使用静态类，避免生命周期问题，注意内部类对外部对象引用导致的生命周期变化</p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>为什么建议只使用默认的构造方法来创建 Fragment？</li>\n</ul>\n<p>之所以建议只使用默认的构造方式来创建fragment，是为了避免构造的过程中进行数据的设置。我们在oncreate和oncreateview的过程中可以获取bundle，这个bundle在存储fragment的时候同样可以被存储，而假如构造的模式进行设置参数的话，这些值就不会被系统存储。并且fragment的创建，其实是由fragmentmanager来初始化的，其初始化过程依靠了反射，并且是无参数反射，因此若不使用默认的构造的话会直接编译报错。</p>\n<ul>\n<li>为什么 Bundle 被用来传递数据，为什么不能使用简单的 Map 数据结构？</li>\n</ul>\n<p>Bundle内部是由ArrayMap实现的，ArrayMap的内部实现是两个数组，一个int数组是存储对象数据对应下标，一个对象数组保存key和value，内部使用二分法对key进行排序，所以在添加、删除、查找数据的时候，都会使用二分法查找，只适合于小数据量操作，如果在数据量比较大的情况下，那么它的性能将退化。而HashMap内部则是数组+链表结构，所以在数据量较少的时候，HashMap的Entry Array比ArrayMap占用更多的内存。因为使用Bundle的场景大多数为小数据量，我没见过在两个Activity之间传递10个以上数据的场景，所以相比之下，在这种情况下使用ArrayMap保存数据，在操作速度和内存占用上都具有优势，因此使用Bundle来传递数据，可以保证更快的速度和更少的内存占用。<br>另外一个原因，则是在Android中如果使用Intent来携带数据的话，需要数据是基本类型或者是可序列化类型，HashMap使用Serializable进行序列化，而Bundle则是使用Parcelable进行序列化。而在Android平台中，更推荐使用Parcelable实现序列化，虽然写法复杂，但是开销更小，所以为了更加快速的进行数据的序列化和反序列化，系统封装了Bundle类，方便我们进行数据的传输。</p>\n<ul>\n<li>什么是 JobScheduler ？</li>\n</ul>\n<p>jobscheduler提供了一种不同于alarmmanager的唤醒app的方式，其主要工作场景：应用具有您可以推迟的非面向用户的工作。/应用具有当插入设备时您希望优先执行的工作。/应用具有需要访问网络或 Wi-Fi 连接的任务。/应用具有您希望作为一个批次定期运行的许多任务。</p>\n<ul>\n<li>什么是 ANR ？如何避免发生 ANR ？</li>\n</ul>\n<p>ANR = application not response</p>\n<p>anr一般有三种类型：<br>KeyDispatchTimeout(5 seconds) –主要类型按键或触摸事件在特定时间内无响应；<br>BroadcastTimeout(10 seconds) –BroadcastReceiver在特定时间内无法处理完成；<br>ServiceTimeout(20 seconds) –小概率类型 Service在特定的时间内无法处理完成</p>\n<p>避免的方法：</p>\n<p>UI线程尽量只做跟UI相关的工作<br>耗时的工作（比如数据库操作，I/O，连接网络或者别的有可能阻碍UI线程的操作）把它放入单独的线程处理<br>尽量用Handler来处理UIthread和别的thread之间的交互</p>\n<p>措施：</p>\n<p>首先分析log<br>从trace.txt文件查看调用stack.<br>看代码<br>仔细查看ANR的成因（iowait?block?memoryleak?）</p>\n<ul>\n<li>解释一下 broadcast 和 intent 在 app 内传递消息的工作流程。</li>\n</ul>\n<p>广播的注册过程 ：最终在ActivityManagerService中将远程的InnerInnerReceiver以及Intent－filter对象存储起来。<br>广播的发送以及接受：内部会首先根据传入的Intent－filter 查找出匹配的广播接受者，并将改接受者放到BroadcastQueue中，紧接着系统会遍历ArrayList中的广播，并将其发送给它们对应的广播接受者，最后调用到广播接受者的onReceiver方法。</p>\n<p>Intent传递消息过程：intent在putextra的过程中将消息放入bundle中，bundle由于实现了parcel接口，故可以进行ipc通信，最后通过目标activity从parcel中恢复状态信息，这里面的parcel完成了数据的序列化传输。</p>\n<ul>\n<li>当 Bitmap 占用较多内存时，你是怎么处理的？</li>\n</ul>\n<p>由于内存管理上将外部内存完全当成了当前堆的一部分，也就是说Bitmap对象通过栈上的引用来指向堆上的Bitmap对象，而堆上的Bitmap对象又对应了一个使用了外部存储的native图像，也就是实际上使用的字节数组byte[]来存储的位图信息，因此解码之后的Bitmap的总大小就不能超过8M了。</p>\n<p>设置系统的最小堆大小：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int newSize = 4 * 1024 * 1024 ; //设置最小堆内存大小为4MB  </span><br><span class=\"line\">VMRuntime.getRuntime().setMinimumHeapSize(newSize);  </span><br><span class=\"line\">VMRuntime.getRuntime().setTargetHeapUtilization(0.75); // 设置堆内存的利用率为75%</span><br></pre></td></tr></table></figure></p>\n<p>对图片的大小进行控制:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BitmapFactory.Options options = new BitmapFactory.Options();  </span><br><span class=\"line\">options.inSampleSize = 2; //图片宽高都为原来的二分之一，即图片为原来的四分之一  </span><br><span class=\"line\">Bitmap bitmap = BitmapFactory.decodeFile(&quot;/mnt/sdcard/a.jpg&quot;,options);</span><br></pre></td></tr></table></figure></p>\n<p>对bitmapfactory解码的参数进行设置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BitmapFactory.Options options = new BitmapFactory.Options();  </span><br><span class=\"line\">options.inTempStorage = new byte[1024*1024*5]; //5MB的临时存储空间  </span><br><span class=\"line\">Bitmap bm = BitmapFactory.decodeFile(&quot;/mnt/sdcard/a.jpg&quot;,options);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>什么是 Dalvik 虚拟机？</li>\n</ul>\n<p>每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。<br>dalvik虚拟机使用dex文件的java文件格式，class文件中会附带着不少额外信息，dex文件对其进行精简，将所有的class文件整合一起，减少了文件尺寸和io操作的同时也提高了类的加载速度。</p>\n<p>每一个应用都运行在一个dalvik虚拟机里面，而每一个虚拟机都有一个独立的进程空间</p>\n<ul>\n<li>什么是 Sticky Intent？</li>\n</ul>\n<p>在MainActivity里面会有sendBroadcast和sendStickyBroacat.在ReceverActivity里面通 过BroadcastReceiver来接收这两个消息，在ReceiverActivity里是通过代码来注册Recevier而不是在 Manifest里面注册的。所以通过sendBroadcast中发出的intent在ReceverActivity不处于onResume状态是无 法接受到的，即使后面再次使其处于该状态也无法接受到。而sendStickyBroadcast发出的Intent当ReceverActivity重 新处于onResume状态之后就能重新接受到其Intent.这就是the Intent will be held to be re-broadcast to future receivers这句话的表现。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Recevier处于活跃的 时候，又会接受到它。</p>\n<ul>\n<li>Android 的权限有多少个不同的保护等级？</li>\n</ul>\n<p>四种，normal，dangerous，signature，signatureOrSystem</p>\n<p>普通权限 会在App安装期间被默认赋予。这类权限不需要开发人员进行额外操作。</p>\n<p>危险权限是在开发6.0程序时，必须要注意的。这些权限处理不好，程序可能会直接被系统干掉。危险权限以组进行划分，对该组内的一个权限授权视为对整个组进行授权，但是对开发来讲，仍然需要正对每个需要的权限进行获取，否则后期版本的变更会导致权限组划分更改。</p>\n<p>签名级别权限和系统签名级别权限需要拥有platform级别的认证才能申请。</p>\n<ul>\n<li>在转屏时你如何保存 Activity 的状态？</li>\n</ul>\n<p>不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次</p>\n<p>设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次</p>\n<p>设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</p>\n<p>但是，自从Android 3.2（API 13），在设置Activity的android:configChanges=”orientation|keyboardHidden”后，还是一样会重新调用各个生命周期的。因为screen size也开始跟着设备的横竖切换而改变。所以，在AndroidManifest.xml里设置的MiniSdkVersion和 TargetSdkVersion属性大于等于13的情况下，如果你想阻止程序在运行时重新加载Activity，除了设置”orientation”，你还必须设置”ScreenSize”。<br>解决方法：</p>\n<p>AndroidManifest.xml中设置android:configChanges=”orientation|screenSize”</p>\n<ul>\n<li>如何实现 XML 命名空间？</li>\n</ul>\n<p>常见命名空间<br>android：xmlns:android=”<a href=\"http://schemas.android.com/apk/res/android”\" target=\"_blank\" rel=\"noopener\">http://schemas.android.com/apk/res/android”</a><br>解析：xmlns:即xml namespace，声明我们要开始定义一个命名空间了<br>android：称作namespace-prefix，它是命名空间的名字<br><a href=\"http://schemas.android.com/apk/res/android：这看起来是一个URL，但是这个地址是不可访问的。实际上这是一个URI(统一资源标识符),所以它的值是固定不变的,相当于一个常量)。\" target=\"_blank\" rel=\"noopener\">http://schemas.android.com/apk/res/android：这看起来是一个URL，但是这个地址是不可访问的。实际上这是一个URI(统一资源标识符),所以它的值是固定不变的,相当于一个常量)。</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">   android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">   android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class=\"line\">   &lt;TextView</span><br><span class=\"line\">       android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">       android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">       android:layout_gravity=&quot;center&quot;</span><br><span class=\"line\">       android:text=&quot;New Text&quot;</span><br><span class=\"line\">       android:id=&quot;@+id/textView&quot; /&gt;</span><br><span class=\"line\">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>\n<p>亦可以写成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;LinearLayout xmlns:myns=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">   myns:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">   myns:layout_height=&quot;match_parent&quot; &gt;</span><br><span class=\"line\">   &lt;TextView</span><br><span class=\"line\">       myns:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">       myns:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">       myns:layout_gravity=&quot;center&quot;</span><br><span class=\"line\">       myns:text=&quot;New Text&quot;</span><br><span class=\"line\">       myns:id=&quot;@+id/textView&quot; /&gt;</span><br><span class=\"line\">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>\n<p>tools:xmlns:tools=”<a href=\"http://schemas.android.com/tools”\" target=\"_blank\" rel=\"noopener\">http://schemas.android.com/tools”</a></p>\n<p>tools只作用于开发阶段<br>我们可以把他理解为一个工具(tools)的命名空间,它的只作用于开发阶段,当app被打包时,所有关于tools属性将都会被摒弃掉！</p>\n<p>tools:context开发中查看Activity布局效果<br>context的用法，在后面跟一个Activtiy的完整包名,它有什么作用呢?</p>\n<p>当我们设置一个Activity主题时,是在AndroidManifest.xml中设置中,而主题的效果又只能在运行后在Activtiy中显示</p>\n<p>使用context属性, 可以在开发阶段中看到设置在Activity中的主题效果</p>\n<p>tools:context=”com.littlehan.myapplication.MainActivity”</p>\n<p>在布局中加入这行代码,就可以在design视图中看到与MainActivity绑定主题的效果。</p>\n<p>tools:layout开发中查看fragment布局效果<br>当我们在Activity上加载一个fragment时，是需要在运行后才可以看到加载后的效果,有没有方法在测试阶段就在布局预览窗口上显示呢?</p>\n<p>答案是有的,借助layout属性,例如,在布局中加入这样一行代码:<br>tools:layout=@layout/yourfragmentlayoutname<br>这样你的编写的fragment布局就会预览在指定主布局上了</p>\n<p>app:xmlns:app=”<a href=\"http://schemas.android.com/apk/res-auto”\" target=\"_blank\" rel=\"noopener\">http://schemas.android.com/apk/res-auto”</a></p>\n<p>app命名空间为用户自定义，通过attrs进行设置，然后通过自定义view进行解析。</p>\n<ul>\n<li>Application 和 Activity 的 Context 对象的区别</li>\n</ul>\n<p>这是两种不同的context，也是最常见的两种.第一种中context的生命周期与Application的生命周期相关的，context随着Application的销毁而销毁，伴随application的一生，与activity的生命周期无关.第二种中的context跟Activity的生命周期是相关的，但是对一个Application来说，Activity可以销毁几次，那么属于Activity的context就会销毁多次.至于用哪种context，得看应用场景，个人感觉用Activity的context好一点，不过也有的时候必须使用Application的context.application context可以通过<br>Context.getApplicationContext或者Activity.getApplication方法获取.</p>\n<p>还有就是，在使用context的时候，小心内存泄露，防止内存泄露，注意一下几个方面：</p>\n<p>　1. 不要让生命周期长的对象引用activity context，即保证引用activity的对象要与activity本身生命周期是一样的</p>\n<p>　2. 对于生命周期长的对象，可以使用application context</p>\n<p>　3. 避免非静态的内部类，尽量使用静态类，避免生命周期问题，注意内部类对外部对象引用导致的生命周期变化</p>\n"},{"title":"Android绘图机制与处理技巧","date":"2018-01-16T13:53:31.000Z","_content":"\n本章用于做群英传第六章《Android绘图机制与处理技巧》的学习笔记。主要是整理自己不熟悉的知识点。\n\n# 屏幕的尺寸信息\n\n1. 屏幕大小\n\n屏幕大小指对角线的长度，一般使用寸来度量，寸指英寸，一英寸为2.54cm\n\n2. 分辨率\n\n分辨率指手机屏幕的像素点个数。1920*1080指宽有1920个像素点，高有1080个像素点\n\n3. ppi\n\npixel per inch，每英寸像素，又称为dpi，为对角线的像素点除以屏幕大小得到。\n\n# 系统屏幕密度\n\n根据dpi大小来进行设置，系统定义了几个标准的dpi值。\n\n120: ldpi\n160: mdpi\n240: hdpi\n320: xhdpi\n480: xxhdpi\n\n# 独立像素密度 dp\n\n在mdpi，即dpi为160时， 1dp = 1px。之后顺推即可，xxhdpi为160的3倍，即1dp = 3px\n\ndp涉及到像素工具类的使用。\n\n```\npublic class DisplayUtil{\n\n\tpublic static int px2dp(Context context, float px){\n\t\tfinal float scale = context.getResource().getDisplayMetrics().density;\n\t\treturn (int)(px/scale + 0.5f);\n\t}\n\n\tpublic static int dp2px(Context context, float dp){\n\t\tfinal float scale = context.getResource().getDisplayMetrics().density;\n\t\treturn (int)(dp*scale + 0.5f);\n\t}\n\n\tpublic static int px2sp(Context context, float px){\n\t\tfinal float fontScale = context.getResource().getDisplayMetrics().scaledDensity;\n\t\treturn (int)(px/fontScale + 0.5f);\n\t}\n\n\tpublic static int sp2dp(Context context, float sp){\n\t\tfinal float fontScale = context.getResource().getDisplayMetrics().scaledDensity;\n\t\treturn (int)(sp*fontScale + 0.5f);\n\t}\n\n\t//以上为使用公式进行换算的\n\t//还可以使用TypedValue进行换算\n\n\tpublic static int dp2px(int dp){\n\t\treturn (int)TypedValue.applyDimension(\n\t\t\tTypedValue.COMPLEX_UNIT_DIP,\n\t\t\tdp,\n\t\t\tgetResources().getDisplayMetrics());\n\t}\n\n\tpublic static int sp2px(int sp){\n\t\treturn (int)TypeValue.applyDimension(\n\t\t\tTypedValue.COMPLEX_UNIT_SP,\n\t\t\tsp,\n\t\t\tgetResources().getDisplayMetrics());\n\t}\n\n}\n```\n\n# 2D绘图基础\n\n2d绘图即使用系统提供的Canvas对象来提供绘图方法，该章主要是复习一些常用的api。\n\n1. paint\n\nsetAntiAlias():设置抗锯齿效果\nsetColor():设置画笔的颜色\nsetARGB():设置画笔的啊a,r,g,b值\nsetAlpha():设置画笔透明度\nsetTextSize():设置字体的尺寸\nsetStyle():设置画笔的风格（空心或者实心）\nsetStrokeWidth():设置空心边框的宽度\n\n2. canvas\n\ncanvas.drawPoint(x, y, paint): 绘制点\n\ncanvas.drawLine(startX, startY, endX, endY, paint): 绘制直线\n\n```\n\tfloat[] pts = {\n\t\tstartX1, startY1, endX1, endY1,\n\t\t... ...\n\t\tstartXn, startYn, endXn, endYn\n\t};\n\tcanvas.drawLines(pts, paint);\n\t//画多条直线\n```\n\ncanvas.drawRect(left, top, right, bottom, paint): 绘制矩形\n\ncanvas.drawRoundRect(left, top, right, bottom, radiusX, radiuxY, paint):绘制圆角矩形\n\ncanvas.drawCircle(circleX, circleY, radius, paint):绘制圆\n\ncanvas.drawArc(left, top, right, bottom, startAngle, sweepAngle, useCenter, paint):绘制弧形，扇形，区别在于useCenter\n\ncanvas.drawOval(left, top, right, bottom, paint):画椭圆\n\ncanvas.drawText(text, startX, startY, paint):绘制文本\n\ncanvas.drawPosText(text, new float[]{X1, Y1, X2, Y2... ... Xn, Yn}, paint):在制定位置绘制文本\n\ncanvas.drawPath(path, paint):绘制路径\n\n# Android xml绘图\n\n1. Bitmap\n\n在xml中使用bitmap\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<bitmap xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\tandroid:src=\"@drawable/ic_launcher\"/>\n```\n\n2. Shape\n\n```\n<shape xmlns:android:\"http://schemas.android.com/apk/res/android\"\n\tandroid:shape=[\"rectangle\" | \"oval\" | \"line\" | \"ring\"]>\n\t//默认为rectangle\n\t<corners //shape = \"rectangle\" 有用\n\t\t// 半径，会被后面的单个半径属性覆盖，默认为1dp\n\t\tandroid:radius=\"integer\"\n\t\tandroid:topLeftRadius=\"integer\"\n\t\tandroid:topRightRadius=\"integer\"\n\t\tandroid:bottomLeftRadius=\"integer\"\n\t\tandroid:bottomRightRadius=\"integer\"/>\n\t<gradient //渐变\n\t\tandroid:angle=\"integer\"\n\t\tandroid:centerX=\"integer\"\n\t\tandroid:centerY=\"integer\"\n\t\tandroid:centerColor=\"integer\"\n\t\tandroid:endColor=\"color\"\n\t\tandroid:gradientRadius=\"integer\"\n\t\tandroid:startColor=\"color\"\n\t\tandroid:type=[\"linear\"| \"radius\" | \"sweep\"]\n\t\tandroid:useLevel=[\"true\" | \"false\"]/>\n\t<padding\n\t\tandroid:left=\"integer\"\n\t\tandroid:top=\"integer\"\n\t\tandroid:right=\"integer\"\n\t\tandroid:bottom=\"integer\"/>\n\t<size // 指定大小，一般用在imageview配合scaletype属性使用\n\t\tandroid:width=\"integer\"\n\t\tandroid:height=\"integer\"/>\n\t<solid // 填充颜色\n\t\tandroid:color=\"color\"/>\n\t<stroke //指定边框\n\t\tandroid:width=\"integer\"\n\t\tandroid:color=\"color\"\n\t\tandroid:dashWidth=\"integer\" //虚线宽度\n\t\tandroid:dashGap=\"integer\" // 虚线间隔宽度\n\t\t/>\n</shape>\n```\n\n3. Layer\n\nlayer中可以使用层级来进行叠加，主要是用item，item可以使用drawable，也可使用shape\n\n4. Selector\n\nSelector用于帮开发者实现静态绘图中的事件反馈，通过不同的事件设置不同的图像。\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\t//默认时的背景图片\n\t<item android:drawable=\"@drawable/x1\"/>\n\t//没有焦点时的图片\n\t<item android:state_window_focused=\"false\" android:drawable=\"@drawable/x2\"/>\n\t//非触摸模式下获得焦点并单击时的背景图片\n\t<item android:state_focuse=\"true\" android:state_pressed=\"true\" android:drawable=\"@drawable/x3\"/>\n\t//触摸模式下单击时的背景图片\n\t<item android:state_focuse=\"false\" android:state_pressed=\"true\" android:drawable=\"@drawable/x4\"/>\n\t//选中时的背景图片\n\t<item android:state_selected=\"true\" android:drawable=\"@drawable/x5\"/>\n\t//获得焦点时的背景图片\n\t<item android:state_focused=\"true\" android:drawable=\"@drawable/x6\"/>\n</selector>\n```\n\n以上可以用于制作view的触摸反馈。\n\n# android 绘图技巧\n\n之上的是基本绘图技巧，之下的是常用绘图技巧\n\n1. Canvas\n\nCanvas.save(): 将之前的所有绘制图像保存起来，之后的操作就好像在一个新的图层上面操作一样。\n\nCanvas.restore(): 用于合并图层，可以用于将save之后绘制的所有图像与save之前的图像合并\n\nCanvas.translate():调用translate(x, y)操作可以将原点(0, 0)移动到(x, y)之后的所有操作都将以(x, y)为原点执行\n\nCanvas.rotate():调用rotate(degree)之后可以将canvas调转一定的角度。\n\n2. Layer图层\n\nAndroid通过调用saveLayer()方法，saveLayerAlpha()方法将一个图层入栈，使用restore()方法,restoreToCount()方法将一个图层出栈。出栈的时候，会把图像绘制到上层Canvas上。\n\n# 画笔特效处理\n\n1. PorterDuffXferMode\n\n该模式控制的是两个图像间的混合显示模式。dst是先画的图形，src是后画的图形。\n\n2. Shader\n\nshader被称为着色器，渲染器。可以用来实现一系列的渐变、渲染效果。\n\n其中shader包括：\nBitmapShader   ---  位图shader\nLinearGradient ---  线性shader\nRadialGradient ---  光束shader\nSweepGradient  ---  梯度shader\nComposeShader  ---  混合shader\n\nshader的作用就是通过paint对画布进行指定的bitmap的填充，填充时有三种模式\n\nCLAMP  --- 拉伸的是图片最后的那一个像素，不断重复\nREPEAT --- 横向纵向不断重复\nMIRROR --- 横向不断翻转重复，纵向不断翻转重复\n\n3. PathEffect\n\npatheffect是指用各种笔触效果来绘制一个路径。\n\nCornerPathEffect:   将拐角处变的圆滑\nDiscretePathEffect:\t使用这个之后线段上会出现很多杂点\nDashPathEffect:\t\t使用这个可以绘制虚线，用一个数组来设置各个点之间的间隔，此后绘制虚线时就重复这样的间隔进行绘制，另一个参数phase可以用来绘制时数组的一个偏移量，可以通过设置值来实现路径的动态效果。\nPathDashPathEffect: 与dashpatheffect类似，不过功能更强大，可以设置点的图形，例如方形点的虚线，圆形点的虚线\nComposePathEffect   可以通过composepatheffect来组合patheffect，这个方法的功能就是将任意的两种路径特性组合起来形成一个新的效果。\n\n# SurfaceView\n\n1. surfaceview 和view的区别\n\n对view来说，android系统通过发出VSYNC信号来进行屏幕的重绘，刷新的间隔为16ms，如果在16ms内view完成了所需要执行的所有操作，那么用户在视觉上就不会产生卡顿的感觉。但是执行的操作逻辑太多，在需要频繁刷新的界面上，就会阻塞主线程，因此android提供了surfaceview。\n\nview主要适用于主动更新的情况下，而surfaceview主要适用于被动更新，例如频繁刷新\nview在主线程中对画面进行刷新，surfaceview则通常会通过一个子线程来进行页面的刷新\nview在绘图时没有使用双缓冲机制，而surfaceview在底层实现机制中就已经实现了双缓冲机制\n\n2. surfaceview的使用\n\nsurfaceview使用有一套模版可以根据模版进行操作\n\n## 创建surfaceview：\n\n创建自定义的surfaceview需要继承SurfaceView,并实现两个接口-- surfaceholder callback和 runnable\n\n```\n\tpublic class SurfaceViewTemplate extends SurfaceView implements SurfaceHolder.Callback, Runnable\n```\n\n之后需要实现这两个接口\n\n## 初始化SurfaceView\n\n自定义surfaceview的构造方法中，需要对surfaceview进行初始化，在自定义的surfaceview中，通常需要定义三个成员变量\n\n```\n\t//SurfaceHolder\n\tprivate SurfaceHolder mHolder;\n\t//用于绘图的Canvas\n\tprivate Canvas mCanvas;\n\t//子线程标识位\n\tprivate boolean mIsDrawing;\n```\n\ncanvas用于绘图，标志位用于控制子线程。\n\n## 使用SurfaceView\n\n通过surfaceholder对象的lockCanvas()方法，就可以得到当前的canvas绘图对象，接下来就可以与在view中绘制一样的操作了。\n每次调用这个方法获取到的canvas都是继续上次的对象。清屏可以使用drawColor()操作。\n\n绘制的时候，在surfaceCreated()中开启子线程进行绘制，而子线程使用一个while(mIsDrawing)的循环来不停的进行绘制。\n绘制的具体过程，使用lockCanvas()方法获得的Canvas对象进行绘制，并通过unlockCanvasAndPost(mCanvas)方法对画布内容进行提交。","source":"_posts/Android绘图机制与处理技巧.md","raw":"---\ntitle: Android绘图机制与处理技巧\ndate: 2018-01-16 21:53:31\ntags: android\n---\n\n本章用于做群英传第六章《Android绘图机制与处理技巧》的学习笔记。主要是整理自己不熟悉的知识点。\n\n# 屏幕的尺寸信息\n\n1. 屏幕大小\n\n屏幕大小指对角线的长度，一般使用寸来度量，寸指英寸，一英寸为2.54cm\n\n2. 分辨率\n\n分辨率指手机屏幕的像素点个数。1920*1080指宽有1920个像素点，高有1080个像素点\n\n3. ppi\n\npixel per inch，每英寸像素，又称为dpi，为对角线的像素点除以屏幕大小得到。\n\n# 系统屏幕密度\n\n根据dpi大小来进行设置，系统定义了几个标准的dpi值。\n\n120: ldpi\n160: mdpi\n240: hdpi\n320: xhdpi\n480: xxhdpi\n\n# 独立像素密度 dp\n\n在mdpi，即dpi为160时， 1dp = 1px。之后顺推即可，xxhdpi为160的3倍，即1dp = 3px\n\ndp涉及到像素工具类的使用。\n\n```\npublic class DisplayUtil{\n\n\tpublic static int px2dp(Context context, float px){\n\t\tfinal float scale = context.getResource().getDisplayMetrics().density;\n\t\treturn (int)(px/scale + 0.5f);\n\t}\n\n\tpublic static int dp2px(Context context, float dp){\n\t\tfinal float scale = context.getResource().getDisplayMetrics().density;\n\t\treturn (int)(dp*scale + 0.5f);\n\t}\n\n\tpublic static int px2sp(Context context, float px){\n\t\tfinal float fontScale = context.getResource().getDisplayMetrics().scaledDensity;\n\t\treturn (int)(px/fontScale + 0.5f);\n\t}\n\n\tpublic static int sp2dp(Context context, float sp){\n\t\tfinal float fontScale = context.getResource().getDisplayMetrics().scaledDensity;\n\t\treturn (int)(sp*fontScale + 0.5f);\n\t}\n\n\t//以上为使用公式进行换算的\n\t//还可以使用TypedValue进行换算\n\n\tpublic static int dp2px(int dp){\n\t\treturn (int)TypedValue.applyDimension(\n\t\t\tTypedValue.COMPLEX_UNIT_DIP,\n\t\t\tdp,\n\t\t\tgetResources().getDisplayMetrics());\n\t}\n\n\tpublic static int sp2px(int sp){\n\t\treturn (int)TypeValue.applyDimension(\n\t\t\tTypedValue.COMPLEX_UNIT_SP,\n\t\t\tsp,\n\t\t\tgetResources().getDisplayMetrics());\n\t}\n\n}\n```\n\n# 2D绘图基础\n\n2d绘图即使用系统提供的Canvas对象来提供绘图方法，该章主要是复习一些常用的api。\n\n1. paint\n\nsetAntiAlias():设置抗锯齿效果\nsetColor():设置画笔的颜色\nsetARGB():设置画笔的啊a,r,g,b值\nsetAlpha():设置画笔透明度\nsetTextSize():设置字体的尺寸\nsetStyle():设置画笔的风格（空心或者实心）\nsetStrokeWidth():设置空心边框的宽度\n\n2. canvas\n\ncanvas.drawPoint(x, y, paint): 绘制点\n\ncanvas.drawLine(startX, startY, endX, endY, paint): 绘制直线\n\n```\n\tfloat[] pts = {\n\t\tstartX1, startY1, endX1, endY1,\n\t\t... ...\n\t\tstartXn, startYn, endXn, endYn\n\t};\n\tcanvas.drawLines(pts, paint);\n\t//画多条直线\n```\n\ncanvas.drawRect(left, top, right, bottom, paint): 绘制矩形\n\ncanvas.drawRoundRect(left, top, right, bottom, radiusX, radiuxY, paint):绘制圆角矩形\n\ncanvas.drawCircle(circleX, circleY, radius, paint):绘制圆\n\ncanvas.drawArc(left, top, right, bottom, startAngle, sweepAngle, useCenter, paint):绘制弧形，扇形，区别在于useCenter\n\ncanvas.drawOval(left, top, right, bottom, paint):画椭圆\n\ncanvas.drawText(text, startX, startY, paint):绘制文本\n\ncanvas.drawPosText(text, new float[]{X1, Y1, X2, Y2... ... Xn, Yn}, paint):在制定位置绘制文本\n\ncanvas.drawPath(path, paint):绘制路径\n\n# Android xml绘图\n\n1. Bitmap\n\n在xml中使用bitmap\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<bitmap xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\tandroid:src=\"@drawable/ic_launcher\"/>\n```\n\n2. Shape\n\n```\n<shape xmlns:android:\"http://schemas.android.com/apk/res/android\"\n\tandroid:shape=[\"rectangle\" | \"oval\" | \"line\" | \"ring\"]>\n\t//默认为rectangle\n\t<corners //shape = \"rectangle\" 有用\n\t\t// 半径，会被后面的单个半径属性覆盖，默认为1dp\n\t\tandroid:radius=\"integer\"\n\t\tandroid:topLeftRadius=\"integer\"\n\t\tandroid:topRightRadius=\"integer\"\n\t\tandroid:bottomLeftRadius=\"integer\"\n\t\tandroid:bottomRightRadius=\"integer\"/>\n\t<gradient //渐变\n\t\tandroid:angle=\"integer\"\n\t\tandroid:centerX=\"integer\"\n\t\tandroid:centerY=\"integer\"\n\t\tandroid:centerColor=\"integer\"\n\t\tandroid:endColor=\"color\"\n\t\tandroid:gradientRadius=\"integer\"\n\t\tandroid:startColor=\"color\"\n\t\tandroid:type=[\"linear\"| \"radius\" | \"sweep\"]\n\t\tandroid:useLevel=[\"true\" | \"false\"]/>\n\t<padding\n\t\tandroid:left=\"integer\"\n\t\tandroid:top=\"integer\"\n\t\tandroid:right=\"integer\"\n\t\tandroid:bottom=\"integer\"/>\n\t<size // 指定大小，一般用在imageview配合scaletype属性使用\n\t\tandroid:width=\"integer\"\n\t\tandroid:height=\"integer\"/>\n\t<solid // 填充颜色\n\t\tandroid:color=\"color\"/>\n\t<stroke //指定边框\n\t\tandroid:width=\"integer\"\n\t\tandroid:color=\"color\"\n\t\tandroid:dashWidth=\"integer\" //虚线宽度\n\t\tandroid:dashGap=\"integer\" // 虚线间隔宽度\n\t\t/>\n</shape>\n```\n\n3. Layer\n\nlayer中可以使用层级来进行叠加，主要是用item，item可以使用drawable，也可使用shape\n\n4. Selector\n\nSelector用于帮开发者实现静态绘图中的事件反馈，通过不同的事件设置不同的图像。\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\t//默认时的背景图片\n\t<item android:drawable=\"@drawable/x1\"/>\n\t//没有焦点时的图片\n\t<item android:state_window_focused=\"false\" android:drawable=\"@drawable/x2\"/>\n\t//非触摸模式下获得焦点并单击时的背景图片\n\t<item android:state_focuse=\"true\" android:state_pressed=\"true\" android:drawable=\"@drawable/x3\"/>\n\t//触摸模式下单击时的背景图片\n\t<item android:state_focuse=\"false\" android:state_pressed=\"true\" android:drawable=\"@drawable/x4\"/>\n\t//选中时的背景图片\n\t<item android:state_selected=\"true\" android:drawable=\"@drawable/x5\"/>\n\t//获得焦点时的背景图片\n\t<item android:state_focused=\"true\" android:drawable=\"@drawable/x6\"/>\n</selector>\n```\n\n以上可以用于制作view的触摸反馈。\n\n# android 绘图技巧\n\n之上的是基本绘图技巧，之下的是常用绘图技巧\n\n1. Canvas\n\nCanvas.save(): 将之前的所有绘制图像保存起来，之后的操作就好像在一个新的图层上面操作一样。\n\nCanvas.restore(): 用于合并图层，可以用于将save之后绘制的所有图像与save之前的图像合并\n\nCanvas.translate():调用translate(x, y)操作可以将原点(0, 0)移动到(x, y)之后的所有操作都将以(x, y)为原点执行\n\nCanvas.rotate():调用rotate(degree)之后可以将canvas调转一定的角度。\n\n2. Layer图层\n\nAndroid通过调用saveLayer()方法，saveLayerAlpha()方法将一个图层入栈，使用restore()方法,restoreToCount()方法将一个图层出栈。出栈的时候，会把图像绘制到上层Canvas上。\n\n# 画笔特效处理\n\n1. PorterDuffXferMode\n\n该模式控制的是两个图像间的混合显示模式。dst是先画的图形，src是后画的图形。\n\n2. Shader\n\nshader被称为着色器，渲染器。可以用来实现一系列的渐变、渲染效果。\n\n其中shader包括：\nBitmapShader   ---  位图shader\nLinearGradient ---  线性shader\nRadialGradient ---  光束shader\nSweepGradient  ---  梯度shader\nComposeShader  ---  混合shader\n\nshader的作用就是通过paint对画布进行指定的bitmap的填充，填充时有三种模式\n\nCLAMP  --- 拉伸的是图片最后的那一个像素，不断重复\nREPEAT --- 横向纵向不断重复\nMIRROR --- 横向不断翻转重复，纵向不断翻转重复\n\n3. PathEffect\n\npatheffect是指用各种笔触效果来绘制一个路径。\n\nCornerPathEffect:   将拐角处变的圆滑\nDiscretePathEffect:\t使用这个之后线段上会出现很多杂点\nDashPathEffect:\t\t使用这个可以绘制虚线，用一个数组来设置各个点之间的间隔，此后绘制虚线时就重复这样的间隔进行绘制，另一个参数phase可以用来绘制时数组的一个偏移量，可以通过设置值来实现路径的动态效果。\nPathDashPathEffect: 与dashpatheffect类似，不过功能更强大，可以设置点的图形，例如方形点的虚线，圆形点的虚线\nComposePathEffect   可以通过composepatheffect来组合patheffect，这个方法的功能就是将任意的两种路径特性组合起来形成一个新的效果。\n\n# SurfaceView\n\n1. surfaceview 和view的区别\n\n对view来说，android系统通过发出VSYNC信号来进行屏幕的重绘，刷新的间隔为16ms，如果在16ms内view完成了所需要执行的所有操作，那么用户在视觉上就不会产生卡顿的感觉。但是执行的操作逻辑太多，在需要频繁刷新的界面上，就会阻塞主线程，因此android提供了surfaceview。\n\nview主要适用于主动更新的情况下，而surfaceview主要适用于被动更新，例如频繁刷新\nview在主线程中对画面进行刷新，surfaceview则通常会通过一个子线程来进行页面的刷新\nview在绘图时没有使用双缓冲机制，而surfaceview在底层实现机制中就已经实现了双缓冲机制\n\n2. surfaceview的使用\n\nsurfaceview使用有一套模版可以根据模版进行操作\n\n## 创建surfaceview：\n\n创建自定义的surfaceview需要继承SurfaceView,并实现两个接口-- surfaceholder callback和 runnable\n\n```\n\tpublic class SurfaceViewTemplate extends SurfaceView implements SurfaceHolder.Callback, Runnable\n```\n\n之后需要实现这两个接口\n\n## 初始化SurfaceView\n\n自定义surfaceview的构造方法中，需要对surfaceview进行初始化，在自定义的surfaceview中，通常需要定义三个成员变量\n\n```\n\t//SurfaceHolder\n\tprivate SurfaceHolder mHolder;\n\t//用于绘图的Canvas\n\tprivate Canvas mCanvas;\n\t//子线程标识位\n\tprivate boolean mIsDrawing;\n```\n\ncanvas用于绘图，标志位用于控制子线程。\n\n## 使用SurfaceView\n\n通过surfaceholder对象的lockCanvas()方法，就可以得到当前的canvas绘图对象，接下来就可以与在view中绘制一样的操作了。\n每次调用这个方法获取到的canvas都是继续上次的对象。清屏可以使用drawColor()操作。\n\n绘制的时候，在surfaceCreated()中开启子线程进行绘制，而子线程使用一个while(mIsDrawing)的循环来不停的进行绘制。\n绘制的具体过程，使用lockCanvas()方法获得的Canvas对象进行绘制，并通过unlockCanvasAndPost(mCanvas)方法对画布内容进行提交。","slug":"Android绘图机制与处理技巧","published":1,"updated":"2019-03-12T09:26:33.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttzv00653a8ksefniyxk","content":"<p>本章用于做群英传第六章《Android绘图机制与处理技巧》的学习笔记。主要是整理自己不熟悉的知识点。</p>\n<h1 id=\"屏幕的尺寸信息\"><a href=\"#屏幕的尺寸信息\" class=\"headerlink\" title=\"屏幕的尺寸信息\"></a>屏幕的尺寸信息</h1><ol>\n<li>屏幕大小</li>\n</ol>\n<p>屏幕大小指对角线的长度，一般使用寸来度量，寸指英寸，一英寸为2.54cm</p>\n<ol start=\"2\">\n<li>分辨率</li>\n</ol>\n<p>分辨率指手机屏幕的像素点个数。1920*1080指宽有1920个像素点，高有1080个像素点</p>\n<ol start=\"3\">\n<li>ppi</li>\n</ol>\n<p>pixel per inch，每英寸像素，又称为dpi，为对角线的像素点除以屏幕大小得到。</p>\n<h1 id=\"系统屏幕密度\"><a href=\"#系统屏幕密度\" class=\"headerlink\" title=\"系统屏幕密度\"></a>系统屏幕密度</h1><p>根据dpi大小来进行设置，系统定义了几个标准的dpi值。</p>\n<p>120: ldpi<br>160: mdpi<br>240: hdpi<br>320: xhdpi<br>480: xxhdpi</p>\n<h1 id=\"独立像素密度-dp\"><a href=\"#独立像素密度-dp\" class=\"headerlink\" title=\"独立像素密度 dp\"></a>独立像素密度 dp</h1><p>在mdpi，即dpi为160时， 1dp = 1px。之后顺推即可，xxhdpi为160的3倍，即1dp = 3px</p>\n<p>dp涉及到像素工具类的使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DisplayUtil&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int px2dp(Context context, float px)&#123;</span><br><span class=\"line\">\t\tfinal float scale = context.getResource().getDisplayMetrics().density;</span><br><span class=\"line\">\t\treturn (int)(px/scale + 0.5f);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int dp2px(Context context, float dp)&#123;</span><br><span class=\"line\">\t\tfinal float scale = context.getResource().getDisplayMetrics().density;</span><br><span class=\"line\">\t\treturn (int)(dp*scale + 0.5f);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int px2sp(Context context, float px)&#123;</span><br><span class=\"line\">\t\tfinal float fontScale = context.getResource().getDisplayMetrics().scaledDensity;</span><br><span class=\"line\">\t\treturn (int)(px/fontScale + 0.5f);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int sp2dp(Context context, float sp)&#123;</span><br><span class=\"line\">\t\tfinal float fontScale = context.getResource().getDisplayMetrics().scaledDensity;</span><br><span class=\"line\">\t\treturn (int)(sp*fontScale + 0.5f);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//以上为使用公式进行换算的</span><br><span class=\"line\">\t//还可以使用TypedValue进行换算</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int dp2px(int dp)&#123;</span><br><span class=\"line\">\t\treturn (int)TypedValue.applyDimension(</span><br><span class=\"line\">\t\t\tTypedValue.COMPLEX_UNIT_DIP,</span><br><span class=\"line\">\t\t\tdp,</span><br><span class=\"line\">\t\t\tgetResources().getDisplayMetrics());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int sp2px(int sp)&#123;</span><br><span class=\"line\">\t\treturn (int)TypeValue.applyDimension(</span><br><span class=\"line\">\t\t\tTypedValue.COMPLEX_UNIT_SP,</span><br><span class=\"line\">\t\t\tsp,</span><br><span class=\"line\">\t\t\tgetResources().getDisplayMetrics());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2D绘图基础\"><a href=\"#2D绘图基础\" class=\"headerlink\" title=\"2D绘图基础\"></a>2D绘图基础</h1><p>2d绘图即使用系统提供的Canvas对象来提供绘图方法，该章主要是复习一些常用的api。</p>\n<ol>\n<li>paint</li>\n</ol>\n<p>setAntiAlias():设置抗锯齿效果<br>setColor():设置画笔的颜色<br>setARGB():设置画笔的啊a,r,g,b值<br>setAlpha():设置画笔透明度<br>setTextSize():设置字体的尺寸<br>setStyle():设置画笔的风格（空心或者实心）<br>setStrokeWidth():设置空心边框的宽度</p>\n<ol start=\"2\">\n<li>canvas</li>\n</ol>\n<p>canvas.drawPoint(x, y, paint): 绘制点</p>\n<p>canvas.drawLine(startX, startY, endX, endY, paint): 绘制直线</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float[] pts = &#123;</span><br><span class=\"line\">\tstartX1, startY1, endX1, endY1,</span><br><span class=\"line\">\t... ...</span><br><span class=\"line\">\tstartXn, startYn, endXn, endYn</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">canvas.drawLines(pts, paint);</span><br><span class=\"line\">//画多条直线</span><br></pre></td></tr></table></figure>\n<p>canvas.drawRect(left, top, right, bottom, paint): 绘制矩形</p>\n<p>canvas.drawRoundRect(left, top, right, bottom, radiusX, radiuxY, paint):绘制圆角矩形</p>\n<p>canvas.drawCircle(circleX, circleY, radius, paint):绘制圆</p>\n<p>canvas.drawArc(left, top, right, bottom, startAngle, sweepAngle, useCenter, paint):绘制弧形，扇形，区别在于useCenter</p>\n<p>canvas.drawOval(left, top, right, bottom, paint):画椭圆</p>\n<p>canvas.drawText(text, startX, startY, paint):绘制文本</p>\n<p>canvas.drawPosText(text, new float[]{X1, Y1, X2, Y2… … Xn, Yn}, paint):在制定位置绘制文本</p>\n<p>canvas.drawPath(path, paint):绘制路径</p>\n<h1 id=\"Android-xml绘图\"><a href=\"#Android-xml绘图\" class=\"headerlink\" title=\"Android xml绘图\"></a>Android xml绘图</h1><ol>\n<li>Bitmap</li>\n</ol>\n<p>在xml中使用bitmap<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">\tandroid:src=&quot;@drawable/ic_launcher&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>Shape</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;shape xmlns:android:&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">\tandroid:shape=[&quot;rectangle&quot; | &quot;oval&quot; | &quot;line&quot; | &quot;ring&quot;]&gt;</span><br><span class=\"line\">\t//默认为rectangle</span><br><span class=\"line\">\t&lt;corners //shape = &quot;rectangle&quot; 有用</span><br><span class=\"line\">\t\t// 半径，会被后面的单个半径属性覆盖，默认为1dp</span><br><span class=\"line\">\t\tandroid:radius=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:topLeftRadius=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:topRightRadius=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:bottomLeftRadius=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:bottomRightRadius=&quot;integer&quot;/&gt;</span><br><span class=\"line\">\t&lt;gradient //渐变</span><br><span class=\"line\">\t\tandroid:angle=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:centerX=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:centerY=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:centerColor=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:endColor=&quot;color&quot;</span><br><span class=\"line\">\t\tandroid:gradientRadius=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:startColor=&quot;color&quot;</span><br><span class=\"line\">\t\tandroid:type=[&quot;linear&quot;| &quot;radius&quot; | &quot;sweep&quot;]</span><br><span class=\"line\">\t\tandroid:useLevel=[&quot;true&quot; | &quot;false&quot;]/&gt;</span><br><span class=\"line\">\t&lt;padding</span><br><span class=\"line\">\t\tandroid:left=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:top=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:right=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:bottom=&quot;integer&quot;/&gt;</span><br><span class=\"line\">\t&lt;size // 指定大小，一般用在imageview配合scaletype属性使用</span><br><span class=\"line\">\t\tandroid:width=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:height=&quot;integer&quot;/&gt;</span><br><span class=\"line\">\t&lt;solid // 填充颜色</span><br><span class=\"line\">\t\tandroid:color=&quot;color&quot;/&gt;</span><br><span class=\"line\">\t&lt;stroke //指定边框</span><br><span class=\"line\">\t\tandroid:width=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:color=&quot;color&quot;</span><br><span class=\"line\">\t\tandroid:dashWidth=&quot;integer&quot; //虚线宽度</span><br><span class=\"line\">\t\tandroid:dashGap=&quot;integer&quot; // 虚线间隔宽度</span><br><span class=\"line\">\t\t/&gt;</span><br><span class=\"line\">&lt;/shape&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>Layer</li>\n</ol>\n<p>layer中可以使用层级来进行叠加，主要是用item，item可以使用drawable，也可使用shape</p>\n<ol start=\"4\">\n<li>Selector</li>\n</ol>\n<p>Selector用于帮开发者实现静态绘图中的事件反馈，通过不同的事件设置不同的图像。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class=\"line\">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class=\"line\">\t//默认时的背景图片</span><br><span class=\"line\">\t&lt;item android:drawable=&quot;@drawable/x1&quot;/&gt;</span><br><span class=\"line\">\t//没有焦点时的图片</span><br><span class=\"line\">\t&lt;item android:state_window_focused=&quot;false&quot; android:drawable=&quot;@drawable/x2&quot;/&gt;</span><br><span class=\"line\">\t//非触摸模式下获得焦点并单击时的背景图片</span><br><span class=\"line\">\t&lt;item android:state_focuse=&quot;true&quot; android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/x3&quot;/&gt;</span><br><span class=\"line\">\t//触摸模式下单击时的背景图片</span><br><span class=\"line\">\t&lt;item android:state_focuse=&quot;false&quot; android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/x4&quot;/&gt;</span><br><span class=\"line\">\t//选中时的背景图片</span><br><span class=\"line\">\t&lt;item android:state_selected=&quot;true&quot; android:drawable=&quot;@drawable/x5&quot;/&gt;</span><br><span class=\"line\">\t//获得焦点时的背景图片</span><br><span class=\"line\">\t&lt;item android:state_focused=&quot;true&quot; android:drawable=&quot;@drawable/x6&quot;/&gt;</span><br><span class=\"line\">&lt;/selector&gt;</span><br></pre></td></tr></table></figure>\n<p>以上可以用于制作view的触摸反馈。</p>\n<h1 id=\"android-绘图技巧\"><a href=\"#android-绘图技巧\" class=\"headerlink\" title=\"android 绘图技巧\"></a>android 绘图技巧</h1><p>之上的是基本绘图技巧，之下的是常用绘图技巧</p>\n<ol>\n<li>Canvas</li>\n</ol>\n<p>Canvas.save(): 将之前的所有绘制图像保存起来，之后的操作就好像在一个新的图层上面操作一样。</p>\n<p>Canvas.restore(): 用于合并图层，可以用于将save之后绘制的所有图像与save之前的图像合并</p>\n<p>Canvas.translate():调用translate(x, y)操作可以将原点(0, 0)移动到(x, y)之后的所有操作都将以(x, y)为原点执行</p>\n<p>Canvas.rotate():调用rotate(degree)之后可以将canvas调转一定的角度。</p>\n<ol start=\"2\">\n<li>Layer图层</li>\n</ol>\n<p>Android通过调用saveLayer()方法，saveLayerAlpha()方法将一个图层入栈，使用restore()方法,restoreToCount()方法将一个图层出栈。出栈的时候，会把图像绘制到上层Canvas上。</p>\n<h1 id=\"画笔特效处理\"><a href=\"#画笔特效处理\" class=\"headerlink\" title=\"画笔特效处理\"></a>画笔特效处理</h1><ol>\n<li>PorterDuffXferMode</li>\n</ol>\n<p>该模式控制的是两个图像间的混合显示模式。dst是先画的图形，src是后画的图形。</p>\n<ol start=\"2\">\n<li>Shader</li>\n</ol>\n<p>shader被称为着色器，渲染器。可以用来实现一系列的渐变、渲染效果。</p>\n<p>其中shader包括：<br>BitmapShader   —  位图shader<br>LinearGradient —  线性shader<br>RadialGradient —  光束shader<br>SweepGradient  —  梯度shader<br>ComposeShader  —  混合shader</p>\n<p>shader的作用就是通过paint对画布进行指定的bitmap的填充，填充时有三种模式</p>\n<p>CLAMP  — 拉伸的是图片最后的那一个像素，不断重复<br>REPEAT — 横向纵向不断重复<br>MIRROR — 横向不断翻转重复，纵向不断翻转重复</p>\n<ol start=\"3\">\n<li>PathEffect</li>\n</ol>\n<p>patheffect是指用各种笔触效果来绘制一个路径。</p>\n<p>CornerPathEffect:   将拐角处变的圆滑<br>DiscretePathEffect:    使用这个之后线段上会出现很多杂点<br>DashPathEffect:        使用这个可以绘制虚线，用一个数组来设置各个点之间的间隔，此后绘制虚线时就重复这样的间隔进行绘制，另一个参数phase可以用来绘制时数组的一个偏移量，可以通过设置值来实现路径的动态效果。<br>PathDashPathEffect: 与dashpatheffect类似，不过功能更强大，可以设置点的图形，例如方形点的虚线，圆形点的虚线<br>ComposePathEffect   可以通过composepatheffect来组合patheffect，这个方法的功能就是将任意的两种路径特性组合起来形成一个新的效果。</p>\n<h1 id=\"SurfaceView\"><a href=\"#SurfaceView\" class=\"headerlink\" title=\"SurfaceView\"></a>SurfaceView</h1><ol>\n<li>surfaceview 和view的区别</li>\n</ol>\n<p>对view来说，android系统通过发出VSYNC信号来进行屏幕的重绘，刷新的间隔为16ms，如果在16ms内view完成了所需要执行的所有操作，那么用户在视觉上就不会产生卡顿的感觉。但是执行的操作逻辑太多，在需要频繁刷新的界面上，就会阻塞主线程，因此android提供了surfaceview。</p>\n<p>view主要适用于主动更新的情况下，而surfaceview主要适用于被动更新，例如频繁刷新<br>view在主线程中对画面进行刷新，surfaceview则通常会通过一个子线程来进行页面的刷新<br>view在绘图时没有使用双缓冲机制，而surfaceview在底层实现机制中就已经实现了双缓冲机制</p>\n<ol start=\"2\">\n<li>surfaceview的使用</li>\n</ol>\n<p>surfaceview使用有一套模版可以根据模版进行操作</p>\n<h2 id=\"创建surfaceview：\"><a href=\"#创建surfaceview：\" class=\"headerlink\" title=\"创建surfaceview：\"></a>创建surfaceview：</h2><p>创建自定义的surfaceview需要继承SurfaceView,并实现两个接口– surfaceholder callback和 runnable</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SurfaceViewTemplate extends SurfaceView implements SurfaceHolder.Callback, Runnable</span><br></pre></td></tr></table></figure>\n<p>之后需要实现这两个接口</p>\n<h2 id=\"初始化SurfaceView\"><a href=\"#初始化SurfaceView\" class=\"headerlink\" title=\"初始化SurfaceView\"></a>初始化SurfaceView</h2><p>自定义surfaceview的构造方法中，需要对surfaceview进行初始化，在自定义的surfaceview中，通常需要定义三个成员变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//SurfaceHolder</span><br><span class=\"line\">private SurfaceHolder mHolder;</span><br><span class=\"line\">//用于绘图的Canvas</span><br><span class=\"line\">private Canvas mCanvas;</span><br><span class=\"line\">//子线程标识位</span><br><span class=\"line\">private boolean mIsDrawing;</span><br></pre></td></tr></table></figure>\n<p>canvas用于绘图，标志位用于控制子线程。</p>\n<h2 id=\"使用SurfaceView\"><a href=\"#使用SurfaceView\" class=\"headerlink\" title=\"使用SurfaceView\"></a>使用SurfaceView</h2><p>通过surfaceholder对象的lockCanvas()方法，就可以得到当前的canvas绘图对象，接下来就可以与在view中绘制一样的操作了。<br>每次调用这个方法获取到的canvas都是继续上次的对象。清屏可以使用drawColor()操作。</p>\n<p>绘制的时候，在surfaceCreated()中开启子线程进行绘制，而子线程使用一个while(mIsDrawing)的循环来不停的进行绘制。<br>绘制的具体过程，使用lockCanvas()方法获得的Canvas对象进行绘制，并通过unlockCanvasAndPost(mCanvas)方法对画布内容进行提交。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本章用于做群英传第六章《Android绘图机制与处理技巧》的学习笔记。主要是整理自己不熟悉的知识点。</p>\n<h1 id=\"屏幕的尺寸信息\"><a href=\"#屏幕的尺寸信息\" class=\"headerlink\" title=\"屏幕的尺寸信息\"></a>屏幕的尺寸信息</h1><ol>\n<li>屏幕大小</li>\n</ol>\n<p>屏幕大小指对角线的长度，一般使用寸来度量，寸指英寸，一英寸为2.54cm</p>\n<ol start=\"2\">\n<li>分辨率</li>\n</ol>\n<p>分辨率指手机屏幕的像素点个数。1920*1080指宽有1920个像素点，高有1080个像素点</p>\n<ol start=\"3\">\n<li>ppi</li>\n</ol>\n<p>pixel per inch，每英寸像素，又称为dpi，为对角线的像素点除以屏幕大小得到。</p>\n<h1 id=\"系统屏幕密度\"><a href=\"#系统屏幕密度\" class=\"headerlink\" title=\"系统屏幕密度\"></a>系统屏幕密度</h1><p>根据dpi大小来进行设置，系统定义了几个标准的dpi值。</p>\n<p>120: ldpi<br>160: mdpi<br>240: hdpi<br>320: xhdpi<br>480: xxhdpi</p>\n<h1 id=\"独立像素密度-dp\"><a href=\"#独立像素密度-dp\" class=\"headerlink\" title=\"独立像素密度 dp\"></a>独立像素密度 dp</h1><p>在mdpi，即dpi为160时， 1dp = 1px。之后顺推即可，xxhdpi为160的3倍，即1dp = 3px</p>\n<p>dp涉及到像素工具类的使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DisplayUtil&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int px2dp(Context context, float px)&#123;</span><br><span class=\"line\">\t\tfinal float scale = context.getResource().getDisplayMetrics().density;</span><br><span class=\"line\">\t\treturn (int)(px/scale + 0.5f);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int dp2px(Context context, float dp)&#123;</span><br><span class=\"line\">\t\tfinal float scale = context.getResource().getDisplayMetrics().density;</span><br><span class=\"line\">\t\treturn (int)(dp*scale + 0.5f);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int px2sp(Context context, float px)&#123;</span><br><span class=\"line\">\t\tfinal float fontScale = context.getResource().getDisplayMetrics().scaledDensity;</span><br><span class=\"line\">\t\treturn (int)(px/fontScale + 0.5f);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int sp2dp(Context context, float sp)&#123;</span><br><span class=\"line\">\t\tfinal float fontScale = context.getResource().getDisplayMetrics().scaledDensity;</span><br><span class=\"line\">\t\treturn (int)(sp*fontScale + 0.5f);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//以上为使用公式进行换算的</span><br><span class=\"line\">\t//还可以使用TypedValue进行换算</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int dp2px(int dp)&#123;</span><br><span class=\"line\">\t\treturn (int)TypedValue.applyDimension(</span><br><span class=\"line\">\t\t\tTypedValue.COMPLEX_UNIT_DIP,</span><br><span class=\"line\">\t\t\tdp,</span><br><span class=\"line\">\t\t\tgetResources().getDisplayMetrics());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static int sp2px(int sp)&#123;</span><br><span class=\"line\">\t\treturn (int)TypeValue.applyDimension(</span><br><span class=\"line\">\t\t\tTypedValue.COMPLEX_UNIT_SP,</span><br><span class=\"line\">\t\t\tsp,</span><br><span class=\"line\">\t\t\tgetResources().getDisplayMetrics());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2D绘图基础\"><a href=\"#2D绘图基础\" class=\"headerlink\" title=\"2D绘图基础\"></a>2D绘图基础</h1><p>2d绘图即使用系统提供的Canvas对象来提供绘图方法，该章主要是复习一些常用的api。</p>\n<ol>\n<li>paint</li>\n</ol>\n<p>setAntiAlias():设置抗锯齿效果<br>setColor():设置画笔的颜色<br>setARGB():设置画笔的啊a,r,g,b值<br>setAlpha():设置画笔透明度<br>setTextSize():设置字体的尺寸<br>setStyle():设置画笔的风格（空心或者实心）<br>setStrokeWidth():设置空心边框的宽度</p>\n<ol start=\"2\">\n<li>canvas</li>\n</ol>\n<p>canvas.drawPoint(x, y, paint): 绘制点</p>\n<p>canvas.drawLine(startX, startY, endX, endY, paint): 绘制直线</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float[] pts = &#123;</span><br><span class=\"line\">\tstartX1, startY1, endX1, endY1,</span><br><span class=\"line\">\t... ...</span><br><span class=\"line\">\tstartXn, startYn, endXn, endYn</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">canvas.drawLines(pts, paint);</span><br><span class=\"line\">//画多条直线</span><br></pre></td></tr></table></figure>\n<p>canvas.drawRect(left, top, right, bottom, paint): 绘制矩形</p>\n<p>canvas.drawRoundRect(left, top, right, bottom, radiusX, radiuxY, paint):绘制圆角矩形</p>\n<p>canvas.drawCircle(circleX, circleY, radius, paint):绘制圆</p>\n<p>canvas.drawArc(left, top, right, bottom, startAngle, sweepAngle, useCenter, paint):绘制弧形，扇形，区别在于useCenter</p>\n<p>canvas.drawOval(left, top, right, bottom, paint):画椭圆</p>\n<p>canvas.drawText(text, startX, startY, paint):绘制文本</p>\n<p>canvas.drawPosText(text, new float[]{X1, Y1, X2, Y2… … Xn, Yn}, paint):在制定位置绘制文本</p>\n<p>canvas.drawPath(path, paint):绘制路径</p>\n<h1 id=\"Android-xml绘图\"><a href=\"#Android-xml绘图\" class=\"headerlink\" title=\"Android xml绘图\"></a>Android xml绘图</h1><ol>\n<li>Bitmap</li>\n</ol>\n<p>在xml中使用bitmap<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">\tandroid:src=&quot;@drawable/ic_launcher&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>Shape</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;shape xmlns:android:&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">\tandroid:shape=[&quot;rectangle&quot; | &quot;oval&quot; | &quot;line&quot; | &quot;ring&quot;]&gt;</span><br><span class=\"line\">\t//默认为rectangle</span><br><span class=\"line\">\t&lt;corners //shape = &quot;rectangle&quot; 有用</span><br><span class=\"line\">\t\t// 半径，会被后面的单个半径属性覆盖，默认为1dp</span><br><span class=\"line\">\t\tandroid:radius=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:topLeftRadius=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:topRightRadius=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:bottomLeftRadius=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:bottomRightRadius=&quot;integer&quot;/&gt;</span><br><span class=\"line\">\t&lt;gradient //渐变</span><br><span class=\"line\">\t\tandroid:angle=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:centerX=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:centerY=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:centerColor=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:endColor=&quot;color&quot;</span><br><span class=\"line\">\t\tandroid:gradientRadius=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:startColor=&quot;color&quot;</span><br><span class=\"line\">\t\tandroid:type=[&quot;linear&quot;| &quot;radius&quot; | &quot;sweep&quot;]</span><br><span class=\"line\">\t\tandroid:useLevel=[&quot;true&quot; | &quot;false&quot;]/&gt;</span><br><span class=\"line\">\t&lt;padding</span><br><span class=\"line\">\t\tandroid:left=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:top=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:right=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:bottom=&quot;integer&quot;/&gt;</span><br><span class=\"line\">\t&lt;size // 指定大小，一般用在imageview配合scaletype属性使用</span><br><span class=\"line\">\t\tandroid:width=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:height=&quot;integer&quot;/&gt;</span><br><span class=\"line\">\t&lt;solid // 填充颜色</span><br><span class=\"line\">\t\tandroid:color=&quot;color&quot;/&gt;</span><br><span class=\"line\">\t&lt;stroke //指定边框</span><br><span class=\"line\">\t\tandroid:width=&quot;integer&quot;</span><br><span class=\"line\">\t\tandroid:color=&quot;color&quot;</span><br><span class=\"line\">\t\tandroid:dashWidth=&quot;integer&quot; //虚线宽度</span><br><span class=\"line\">\t\tandroid:dashGap=&quot;integer&quot; // 虚线间隔宽度</span><br><span class=\"line\">\t\t/&gt;</span><br><span class=\"line\">&lt;/shape&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>Layer</li>\n</ol>\n<p>layer中可以使用层级来进行叠加，主要是用item，item可以使用drawable，也可使用shape</p>\n<ol start=\"4\">\n<li>Selector</li>\n</ol>\n<p>Selector用于帮开发者实现静态绘图中的事件反馈，通过不同的事件设置不同的图像。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class=\"line\">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class=\"line\">\t//默认时的背景图片</span><br><span class=\"line\">\t&lt;item android:drawable=&quot;@drawable/x1&quot;/&gt;</span><br><span class=\"line\">\t//没有焦点时的图片</span><br><span class=\"line\">\t&lt;item android:state_window_focused=&quot;false&quot; android:drawable=&quot;@drawable/x2&quot;/&gt;</span><br><span class=\"line\">\t//非触摸模式下获得焦点并单击时的背景图片</span><br><span class=\"line\">\t&lt;item android:state_focuse=&quot;true&quot; android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/x3&quot;/&gt;</span><br><span class=\"line\">\t//触摸模式下单击时的背景图片</span><br><span class=\"line\">\t&lt;item android:state_focuse=&quot;false&quot; android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/x4&quot;/&gt;</span><br><span class=\"line\">\t//选中时的背景图片</span><br><span class=\"line\">\t&lt;item android:state_selected=&quot;true&quot; android:drawable=&quot;@drawable/x5&quot;/&gt;</span><br><span class=\"line\">\t//获得焦点时的背景图片</span><br><span class=\"line\">\t&lt;item android:state_focused=&quot;true&quot; android:drawable=&quot;@drawable/x6&quot;/&gt;</span><br><span class=\"line\">&lt;/selector&gt;</span><br></pre></td></tr></table></figure>\n<p>以上可以用于制作view的触摸反馈。</p>\n<h1 id=\"android-绘图技巧\"><a href=\"#android-绘图技巧\" class=\"headerlink\" title=\"android 绘图技巧\"></a>android 绘图技巧</h1><p>之上的是基本绘图技巧，之下的是常用绘图技巧</p>\n<ol>\n<li>Canvas</li>\n</ol>\n<p>Canvas.save(): 将之前的所有绘制图像保存起来，之后的操作就好像在一个新的图层上面操作一样。</p>\n<p>Canvas.restore(): 用于合并图层，可以用于将save之后绘制的所有图像与save之前的图像合并</p>\n<p>Canvas.translate():调用translate(x, y)操作可以将原点(0, 0)移动到(x, y)之后的所有操作都将以(x, y)为原点执行</p>\n<p>Canvas.rotate():调用rotate(degree)之后可以将canvas调转一定的角度。</p>\n<ol start=\"2\">\n<li>Layer图层</li>\n</ol>\n<p>Android通过调用saveLayer()方法，saveLayerAlpha()方法将一个图层入栈，使用restore()方法,restoreToCount()方法将一个图层出栈。出栈的时候，会把图像绘制到上层Canvas上。</p>\n<h1 id=\"画笔特效处理\"><a href=\"#画笔特效处理\" class=\"headerlink\" title=\"画笔特效处理\"></a>画笔特效处理</h1><ol>\n<li>PorterDuffXferMode</li>\n</ol>\n<p>该模式控制的是两个图像间的混合显示模式。dst是先画的图形，src是后画的图形。</p>\n<ol start=\"2\">\n<li>Shader</li>\n</ol>\n<p>shader被称为着色器，渲染器。可以用来实现一系列的渐变、渲染效果。</p>\n<p>其中shader包括：<br>BitmapShader   —  位图shader<br>LinearGradient —  线性shader<br>RadialGradient —  光束shader<br>SweepGradient  —  梯度shader<br>ComposeShader  —  混合shader</p>\n<p>shader的作用就是通过paint对画布进行指定的bitmap的填充，填充时有三种模式</p>\n<p>CLAMP  — 拉伸的是图片最后的那一个像素，不断重复<br>REPEAT — 横向纵向不断重复<br>MIRROR — 横向不断翻转重复，纵向不断翻转重复</p>\n<ol start=\"3\">\n<li>PathEffect</li>\n</ol>\n<p>patheffect是指用各种笔触效果来绘制一个路径。</p>\n<p>CornerPathEffect:   将拐角处变的圆滑<br>DiscretePathEffect:    使用这个之后线段上会出现很多杂点<br>DashPathEffect:        使用这个可以绘制虚线，用一个数组来设置各个点之间的间隔，此后绘制虚线时就重复这样的间隔进行绘制，另一个参数phase可以用来绘制时数组的一个偏移量，可以通过设置值来实现路径的动态效果。<br>PathDashPathEffect: 与dashpatheffect类似，不过功能更强大，可以设置点的图形，例如方形点的虚线，圆形点的虚线<br>ComposePathEffect   可以通过composepatheffect来组合patheffect，这个方法的功能就是将任意的两种路径特性组合起来形成一个新的效果。</p>\n<h1 id=\"SurfaceView\"><a href=\"#SurfaceView\" class=\"headerlink\" title=\"SurfaceView\"></a>SurfaceView</h1><ol>\n<li>surfaceview 和view的区别</li>\n</ol>\n<p>对view来说，android系统通过发出VSYNC信号来进行屏幕的重绘，刷新的间隔为16ms，如果在16ms内view完成了所需要执行的所有操作，那么用户在视觉上就不会产生卡顿的感觉。但是执行的操作逻辑太多，在需要频繁刷新的界面上，就会阻塞主线程，因此android提供了surfaceview。</p>\n<p>view主要适用于主动更新的情况下，而surfaceview主要适用于被动更新，例如频繁刷新<br>view在主线程中对画面进行刷新，surfaceview则通常会通过一个子线程来进行页面的刷新<br>view在绘图时没有使用双缓冲机制，而surfaceview在底层实现机制中就已经实现了双缓冲机制</p>\n<ol start=\"2\">\n<li>surfaceview的使用</li>\n</ol>\n<p>surfaceview使用有一套模版可以根据模版进行操作</p>\n<h2 id=\"创建surfaceview：\"><a href=\"#创建surfaceview：\" class=\"headerlink\" title=\"创建surfaceview：\"></a>创建surfaceview：</h2><p>创建自定义的surfaceview需要继承SurfaceView,并实现两个接口– surfaceholder callback和 runnable</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SurfaceViewTemplate extends SurfaceView implements SurfaceHolder.Callback, Runnable</span><br></pre></td></tr></table></figure>\n<p>之后需要实现这两个接口</p>\n<h2 id=\"初始化SurfaceView\"><a href=\"#初始化SurfaceView\" class=\"headerlink\" title=\"初始化SurfaceView\"></a>初始化SurfaceView</h2><p>自定义surfaceview的构造方法中，需要对surfaceview进行初始化，在自定义的surfaceview中，通常需要定义三个成员变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//SurfaceHolder</span><br><span class=\"line\">private SurfaceHolder mHolder;</span><br><span class=\"line\">//用于绘图的Canvas</span><br><span class=\"line\">private Canvas mCanvas;</span><br><span class=\"line\">//子线程标识位</span><br><span class=\"line\">private boolean mIsDrawing;</span><br></pre></td></tr></table></figure>\n<p>canvas用于绘图，标志位用于控制子线程。</p>\n<h2 id=\"使用SurfaceView\"><a href=\"#使用SurfaceView\" class=\"headerlink\" title=\"使用SurfaceView\"></a>使用SurfaceView</h2><p>通过surfaceholder对象的lockCanvas()方法，就可以得到当前的canvas绘图对象，接下来就可以与在view中绘制一样的操作了。<br>每次调用这个方法获取到的canvas都是继续上次的对象。清屏可以使用drawColor()操作。</p>\n<p>绘制的时候，在surfaceCreated()中开启子线程进行绘制，而子线程使用一个while(mIsDrawing)的循环来不停的进行绘制。<br>绘制的具体过程，使用lockCanvas()方法获得的Canvas对象进行绘制，并通过unlockCanvasAndPost(mCanvas)方法对画布内容进行提交。</p>\n"},{"title":"LruCache缓存源码解析","date":"2018-04-01T04:26:43.000Z","_content":"\n以前曾经在volley中使用networkimageview的时候使用过lrucache，当时以为这只是一个第三方的开源框架。昨天在网上找安卓的缓存框架的时候看到了lrucache，居然是android.util包下面的。所以这次就着源码看看是个怎么缓存的原理。\n\n# 类解释\n\n首先看一下这个类官方的解释。\n\n * A cache that holds strong references to a limited number of values. Each time\n * a value is accessed, it is moved to the head of a queue. When a value is\n * added to a full cache, the value at the end of that queue is evicted and may\n * become eligible for garbage collection.\n\n这个类是一个用于对有限的值持有强引用的缓存类。\n\n每次一个值被获取了，它将被挪到队列的头部。\n\n每当一个值被加入完全缓存（full-cache,完全缓存模式，讲一个对象完全的加载到内存中，而非只加载其映射关系。对应的还有Partial Cache，部分缓存模式，部分缓存模式多数用于加载对象的部分，用于判断对象是否曾经加载过，或者是否需要再次加载），缓存队列末尾的值将会被驱逐，丢失了强引用的关系，就会变得可以被gc清除。\n\n * <p>If your cached values hold resources that need to be explicitly released,\n * override {@link #entryRemoved}.\n\n如果希望避免部分资源被lrucache缓存，可以继承entryremoved\n\n * <p>If a cache miss should be computed on demand for the corresponding keys,\n * override {@link #create}. This simplifies the calling code, allowing it to\n * assume a value will always be returned, even when there's a cache miss.\n\n如果需要对一个响应返回一个完整的缓存，但是这个缓存目前是缺失状态，可以继承create方法，这样可以使得针对这个响应总是可以有回应，即时目前是缓存缺失的状态，也可以构造一个回应。\n\n * <p>By default, the cache size is measured in the number of entries. Override\n * {@link #sizeOf} to size the cache in different units. For example, this cache\n * is limited to 4MiB of bitmaps:\n * <pre>   {@code\n *   int cacheSize = 4 * 1024 * 1024; // 4MiB\n *   LruCache<String, Bitmap> bitmapCache = new LruCache<String, Bitmap>(cacheSize) {\n *       protected int sizeOf(String key, Bitmap value) {\n *           return value.getByteCount();\n *       }\n *   }}</pre>\n\n缓存的数量是通过对象的数量来确定的。继承sizeOf方法可以使用不同的单位来计算缓存。（该方法提供的例子是用于限制缓存，那缓存不够怎么办？一张bitmap一般有8m啊？事实上它并不会精确计算占用的内存，只能说你说a有3m，总共给30m的缓存的话，他就会放最多10个a，事实上a并不一定只有3m，当然这也没必要关心，在不同的地方自己精确赋一下就好了）\n\n * <p>This class is thread-safe. Perform multiple cache operations atomically by\n * synchronizing on the cache: <pre>   {@code\n *   synchronized (cache) {\n *     if (cache.get(key) == null) {\n *         cache.put(key, value);\n *     }\n *   }}</pre>\n\n该类是线程安全的，主要是对缓存操作的部分都加了锁。\n\n * <p>This class does not allow null to be used as a key or value. A return\n * value of null from {@link #get}, {@link #put} or {@link #remove} is\n * unambiguous: the key was not in the cache.\n\n该类不允许空指针被使用作为key或者value。\n\n * <p>This class appeared in Android 3.1 (Honeycomb MR1); it's available as part\n * of <a href=\"http://developer.android.com/sdk/compatibility-library.html\">Android's\n * Support Package</a> for earlier releases.\n\n该类在android3.1出现。\n\n# 源码探究\n\n```\n private final LinkedHashMap<K, V> map;\n```\n\n 使用了linkedHashMap的方法来存储数据。有向图就是强引用方式，key在，value在。\n\n```\n\t/** Size of this cache in units. Not necessarily the number of elements. */\n\tprivate int size;\n    private int maxSize;\n\n    private int putCount;\n    private int createCount;\n    private int evictionCount;\n    private int hitCount;\n    private int missCount;\n```\n\n```\n    /**\n     * @param maxSize for caches that do not override {@link #sizeOf}, this is\n     *     the maximum number of entries in the cache. For all other caches,\n     *     this is the maximum sum of the sizes of the entries in this cache.\n     */\n    public LruCache(int maxSize) {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize <= 0\");\n        }\n        this.maxSize = maxSize;\n        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n    }\n```\n\n构造方面需要给一个maxSize，该参数是用于在为定义sizeof的对象计算容量大小\n\n```\n    /**\n     * Sets the size of the cache.\n     *\n     * @param maxSize The new maximum size.\n     */\n    public void resize(int maxSize) {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize <= 0\");\n        }\n\n        synchronized (this) {\n            this.maxSize = maxSize;\n        }\n        trimToSize(maxSize);\n    }\n\n```\n\n重新设计maxsize\n\n```\n    /**\n     * Returns the value for {@code key} if it exists in the cache or can be\n     * created by {@code #create}. If a value was returned, it is moved to the\n     * head of the queue. This returns null if a value is not cached and cannot\n     * be created.\n     */\n    public final V get(K key) {\n        if (key == null) {\n            throw new NullPointerException(\"key == null\");\n        }\n\n        V mapValue;\n        synchronized (this) {\n            mapValue = map.get(key);\n            if (mapValue != null) {\n                hitCount++;\n                return mapValue;\n            }\n            missCount++;\n        }\n         /*\n         * Attempt to create a value. This may take a long time, and the map\n         * may be different when create() returns. If a conflicting value was\n         * added to the map while create() was working, we leave that value in\n         * the map and release the created value.\n         */\n\n        V createdValue = create(key);\n        if (createdValue == null) {\n            return null;\n        }\n\n        synchronized (this) {\n            createCount++;\n            mapValue = map.put(key, createdValue);\n\n            if (mapValue != null) {\n                // There was a conflict so undo that last put\n                map.put(key, mapValue);\n            } else {\n                size += safeSizeOf(key, createdValue);\n            }\n        }\n        if (mapValue != null) {\n            entryRemoved(false, key, createdValue, mapValue);\n            return mapValue;\n        } else {\n            trimToSize(maxSize);\n            return createdValue;\n        }\n    }\n```\n\nget的时候加锁，每次有返回的话，hitcount自增。没有返回代表是缺失缓存，misscount自增。\n\n若找不到值，会调用createvalue来创建，创建成功，createcount自增，失败就代表没有该缓存内容，直接终端。创建成功同时加入到map里面，map的size会增加。\n\n创建出来的mapvalue会执行entryremoved的检查，对有设置过不加入的参数进行操作。\n\n```\n    /**\n     * Called for entries that have been evicted or removed. This method is\n     * invoked when a value is evicted to make space, removed by a call to\n     * {@link #remove}, or replaced by a call to {@link #put}. The default\n     * implementation does nothing.\n     *\n     * <p>The method is called without synchronization: other threads may\n     * access the cache while this method is executing.\n     *\n     * @param evicted true if the entry is being removed to make space, false\n     *     if the removal was caused by a {@link #put} or {@link #remove}.\n     * @param newValue the new value for {@code key}, if it exists. If non-null,\n     *     this removal was caused by a {@link #put}. Otherwise it was caused by\n     *     an eviction or a {@link #remove}.\n     */\n    protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}\n```\n\nentryRemoved的方法准确的说法是用于吊起被驱逐和移除的对象。确保key对应的value可以是正确的，newvalue为空的话就代表是移除老的对象。\n\n```\n    /**\n     * Remove the eldest entries until the total of remaining entries is at or\n     * below the requested size.\n     *\n     * @param maxSize the maximum size of the cache before returning. May be -1\n     *            to evict even 0-sized elements.\n     */\n    public void trimToSize(int maxSize) {\n        while (true) {\n            K key;\n            V value;\n            synchronized (this) {\n                if (size < 0 || (map.isEmpty() && size != 0)) {\n                    throw new IllegalStateException(getClass().getName()\n                            + \".sizeOf() is reporting inconsistent results!\");\n                }\n\n                if (size <= maxSize) {\n                    break;\n                }\n\n                Map.Entry<K, V> toEvict = map.eldest();\n                if (toEvict == null) {\n                    break;\n                }\n\n                key = toEvict.getKey();\n                value = toEvict.getValue();\n                map.remove(key);\n                size -= safeSizeOf(key, value);\n                evictionCount++;\n            }\n\n            entryRemoved(true, key, value, null);\n        }\n    }\n```\n\ntrimToSize方法是针对目前队列中的对象，移除最老的。移除的操作就是移除了key，去掉强引用的部分。移除完之后要减去移除的大小，之后移除数自增，确保安全之后将之前的key，映射关系改为一个null，这个移除的数量并不是固定的，这是一个死循环，会移除到size小于maxsize，或者最老的是空。\n\n```\n    /**\n     * Removes the entry for {@code key} if it exists.\n     *\n     * @return the previous value mapped by {@code key}.\n     */\n    public final V remove(K key) {\n        if (key == null) {\n            throw new NullPointerException(\"key == null\");\n        }\n\n        V previous;\n        synchronized (this) {\n            previous = map.remove(key);\n            if (previous != null) {\n                size -= safeSizeOf(key, previous);\n            }\n        }\n\n        if (previous != null) {\n            entryRemoved(false, key, previous, null);\n        }\n\n        return previous;\n    }\n```\nremove操作和之前的那个操作几乎一样，移除，如果曾经存在就在此赋空。\n\n```\n    /**\n     * Clear the cache, calling {@link #entryRemoved} on each removed entry.\n     */\n    public final void evictAll() {\n        trimToSize(-1); // -1 will evict 0-sized elements\n    }\n\n```\n\n这是移除所有的元素\n\n```\n    @Override public synchronized final String toString() {\n        int accesses = hitCount + missCount;\n        int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;\n        return String.format(\"LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]\",\n                maxSize, hitCount, missCount, hitPercent);\n    }\n```\n\ntoString方法可以看到状态。\n\n```\n    /**\n     * Returns a copy of the current contents of the cache, ordered from least\n     * recently accessed to most recently accessed.\n     */\n    public synchronized final Map<K, V> snapshot() {\n        return new LinkedHashMap<K, V>(map);\n    }\n\n```\n\nsnapshot直接一个以自己map构造的对象。（这种避免返回自身的操作值得学习）\n\n# 学习心得\n\n整个LruCache的作用，说到底就是针对gc的树状搜索删除算法的一种方案。\n但是我们平时使用的时候，需要针对几个地方进行定制，一是sizeof,二是removeentry。\n\n整个缓存还是在内存中的，所以lrucache是一种内存缓存框架。\n\n# 注意点\n\nvalue最好放软应用对象，确保释放之后的第一次gc就可以回收。\n设置maxsize，可以使用\n```\nRuntime.getRuntime().maxMemory()\n```\n也可针对不同情况进行设置。","source":"_posts/LruCache缓存源码解析.md","raw":"---\ntitle: LruCache缓存源码解析\ndate: 2018-04-01 12:26:43\ntags: android\n---\n\n以前曾经在volley中使用networkimageview的时候使用过lrucache，当时以为这只是一个第三方的开源框架。昨天在网上找安卓的缓存框架的时候看到了lrucache，居然是android.util包下面的。所以这次就着源码看看是个怎么缓存的原理。\n\n# 类解释\n\n首先看一下这个类官方的解释。\n\n * A cache that holds strong references to a limited number of values. Each time\n * a value is accessed, it is moved to the head of a queue. When a value is\n * added to a full cache, the value at the end of that queue is evicted and may\n * become eligible for garbage collection.\n\n这个类是一个用于对有限的值持有强引用的缓存类。\n\n每次一个值被获取了，它将被挪到队列的头部。\n\n每当一个值被加入完全缓存（full-cache,完全缓存模式，讲一个对象完全的加载到内存中，而非只加载其映射关系。对应的还有Partial Cache，部分缓存模式，部分缓存模式多数用于加载对象的部分，用于判断对象是否曾经加载过，或者是否需要再次加载），缓存队列末尾的值将会被驱逐，丢失了强引用的关系，就会变得可以被gc清除。\n\n * <p>If your cached values hold resources that need to be explicitly released,\n * override {@link #entryRemoved}.\n\n如果希望避免部分资源被lrucache缓存，可以继承entryremoved\n\n * <p>If a cache miss should be computed on demand for the corresponding keys,\n * override {@link #create}. This simplifies the calling code, allowing it to\n * assume a value will always be returned, even when there's a cache miss.\n\n如果需要对一个响应返回一个完整的缓存，但是这个缓存目前是缺失状态，可以继承create方法，这样可以使得针对这个响应总是可以有回应，即时目前是缓存缺失的状态，也可以构造一个回应。\n\n * <p>By default, the cache size is measured in the number of entries. Override\n * {@link #sizeOf} to size the cache in different units. For example, this cache\n * is limited to 4MiB of bitmaps:\n * <pre>   {@code\n *   int cacheSize = 4 * 1024 * 1024; // 4MiB\n *   LruCache<String, Bitmap> bitmapCache = new LruCache<String, Bitmap>(cacheSize) {\n *       protected int sizeOf(String key, Bitmap value) {\n *           return value.getByteCount();\n *       }\n *   }}</pre>\n\n缓存的数量是通过对象的数量来确定的。继承sizeOf方法可以使用不同的单位来计算缓存。（该方法提供的例子是用于限制缓存，那缓存不够怎么办？一张bitmap一般有8m啊？事实上它并不会精确计算占用的内存，只能说你说a有3m，总共给30m的缓存的话，他就会放最多10个a，事实上a并不一定只有3m，当然这也没必要关心，在不同的地方自己精确赋一下就好了）\n\n * <p>This class is thread-safe. Perform multiple cache operations atomically by\n * synchronizing on the cache: <pre>   {@code\n *   synchronized (cache) {\n *     if (cache.get(key) == null) {\n *         cache.put(key, value);\n *     }\n *   }}</pre>\n\n该类是线程安全的，主要是对缓存操作的部分都加了锁。\n\n * <p>This class does not allow null to be used as a key or value. A return\n * value of null from {@link #get}, {@link #put} or {@link #remove} is\n * unambiguous: the key was not in the cache.\n\n该类不允许空指针被使用作为key或者value。\n\n * <p>This class appeared in Android 3.1 (Honeycomb MR1); it's available as part\n * of <a href=\"http://developer.android.com/sdk/compatibility-library.html\">Android's\n * Support Package</a> for earlier releases.\n\n该类在android3.1出现。\n\n# 源码探究\n\n```\n private final LinkedHashMap<K, V> map;\n```\n\n 使用了linkedHashMap的方法来存储数据。有向图就是强引用方式，key在，value在。\n\n```\n\t/** Size of this cache in units. Not necessarily the number of elements. */\n\tprivate int size;\n    private int maxSize;\n\n    private int putCount;\n    private int createCount;\n    private int evictionCount;\n    private int hitCount;\n    private int missCount;\n```\n\n```\n    /**\n     * @param maxSize for caches that do not override {@link #sizeOf}, this is\n     *     the maximum number of entries in the cache. For all other caches,\n     *     this is the maximum sum of the sizes of the entries in this cache.\n     */\n    public LruCache(int maxSize) {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize <= 0\");\n        }\n        this.maxSize = maxSize;\n        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n    }\n```\n\n构造方面需要给一个maxSize，该参数是用于在为定义sizeof的对象计算容量大小\n\n```\n    /**\n     * Sets the size of the cache.\n     *\n     * @param maxSize The new maximum size.\n     */\n    public void resize(int maxSize) {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize <= 0\");\n        }\n\n        synchronized (this) {\n            this.maxSize = maxSize;\n        }\n        trimToSize(maxSize);\n    }\n\n```\n\n重新设计maxsize\n\n```\n    /**\n     * Returns the value for {@code key} if it exists in the cache or can be\n     * created by {@code #create}. If a value was returned, it is moved to the\n     * head of the queue. This returns null if a value is not cached and cannot\n     * be created.\n     */\n    public final V get(K key) {\n        if (key == null) {\n            throw new NullPointerException(\"key == null\");\n        }\n\n        V mapValue;\n        synchronized (this) {\n            mapValue = map.get(key);\n            if (mapValue != null) {\n                hitCount++;\n                return mapValue;\n            }\n            missCount++;\n        }\n         /*\n         * Attempt to create a value. This may take a long time, and the map\n         * may be different when create() returns. If a conflicting value was\n         * added to the map while create() was working, we leave that value in\n         * the map and release the created value.\n         */\n\n        V createdValue = create(key);\n        if (createdValue == null) {\n            return null;\n        }\n\n        synchronized (this) {\n            createCount++;\n            mapValue = map.put(key, createdValue);\n\n            if (mapValue != null) {\n                // There was a conflict so undo that last put\n                map.put(key, mapValue);\n            } else {\n                size += safeSizeOf(key, createdValue);\n            }\n        }\n        if (mapValue != null) {\n            entryRemoved(false, key, createdValue, mapValue);\n            return mapValue;\n        } else {\n            trimToSize(maxSize);\n            return createdValue;\n        }\n    }\n```\n\nget的时候加锁，每次有返回的话，hitcount自增。没有返回代表是缺失缓存，misscount自增。\n\n若找不到值，会调用createvalue来创建，创建成功，createcount自增，失败就代表没有该缓存内容，直接终端。创建成功同时加入到map里面，map的size会增加。\n\n创建出来的mapvalue会执行entryremoved的检查，对有设置过不加入的参数进行操作。\n\n```\n    /**\n     * Called for entries that have been evicted or removed. This method is\n     * invoked when a value is evicted to make space, removed by a call to\n     * {@link #remove}, or replaced by a call to {@link #put}. The default\n     * implementation does nothing.\n     *\n     * <p>The method is called without synchronization: other threads may\n     * access the cache while this method is executing.\n     *\n     * @param evicted true if the entry is being removed to make space, false\n     *     if the removal was caused by a {@link #put} or {@link #remove}.\n     * @param newValue the new value for {@code key}, if it exists. If non-null,\n     *     this removal was caused by a {@link #put}. Otherwise it was caused by\n     *     an eviction or a {@link #remove}.\n     */\n    protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}\n```\n\nentryRemoved的方法准确的说法是用于吊起被驱逐和移除的对象。确保key对应的value可以是正确的，newvalue为空的话就代表是移除老的对象。\n\n```\n    /**\n     * Remove the eldest entries until the total of remaining entries is at or\n     * below the requested size.\n     *\n     * @param maxSize the maximum size of the cache before returning. May be -1\n     *            to evict even 0-sized elements.\n     */\n    public void trimToSize(int maxSize) {\n        while (true) {\n            K key;\n            V value;\n            synchronized (this) {\n                if (size < 0 || (map.isEmpty() && size != 0)) {\n                    throw new IllegalStateException(getClass().getName()\n                            + \".sizeOf() is reporting inconsistent results!\");\n                }\n\n                if (size <= maxSize) {\n                    break;\n                }\n\n                Map.Entry<K, V> toEvict = map.eldest();\n                if (toEvict == null) {\n                    break;\n                }\n\n                key = toEvict.getKey();\n                value = toEvict.getValue();\n                map.remove(key);\n                size -= safeSizeOf(key, value);\n                evictionCount++;\n            }\n\n            entryRemoved(true, key, value, null);\n        }\n    }\n```\n\ntrimToSize方法是针对目前队列中的对象，移除最老的。移除的操作就是移除了key，去掉强引用的部分。移除完之后要减去移除的大小，之后移除数自增，确保安全之后将之前的key，映射关系改为一个null，这个移除的数量并不是固定的，这是一个死循环，会移除到size小于maxsize，或者最老的是空。\n\n```\n    /**\n     * Removes the entry for {@code key} if it exists.\n     *\n     * @return the previous value mapped by {@code key}.\n     */\n    public final V remove(K key) {\n        if (key == null) {\n            throw new NullPointerException(\"key == null\");\n        }\n\n        V previous;\n        synchronized (this) {\n            previous = map.remove(key);\n            if (previous != null) {\n                size -= safeSizeOf(key, previous);\n            }\n        }\n\n        if (previous != null) {\n            entryRemoved(false, key, previous, null);\n        }\n\n        return previous;\n    }\n```\nremove操作和之前的那个操作几乎一样，移除，如果曾经存在就在此赋空。\n\n```\n    /**\n     * Clear the cache, calling {@link #entryRemoved} on each removed entry.\n     */\n    public final void evictAll() {\n        trimToSize(-1); // -1 will evict 0-sized elements\n    }\n\n```\n\n这是移除所有的元素\n\n```\n    @Override public synchronized final String toString() {\n        int accesses = hitCount + missCount;\n        int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;\n        return String.format(\"LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]\",\n                maxSize, hitCount, missCount, hitPercent);\n    }\n```\n\ntoString方法可以看到状态。\n\n```\n    /**\n     * Returns a copy of the current contents of the cache, ordered from least\n     * recently accessed to most recently accessed.\n     */\n    public synchronized final Map<K, V> snapshot() {\n        return new LinkedHashMap<K, V>(map);\n    }\n\n```\n\nsnapshot直接一个以自己map构造的对象。（这种避免返回自身的操作值得学习）\n\n# 学习心得\n\n整个LruCache的作用，说到底就是针对gc的树状搜索删除算法的一种方案。\n但是我们平时使用的时候，需要针对几个地方进行定制，一是sizeof,二是removeentry。\n\n整个缓存还是在内存中的，所以lrucache是一种内存缓存框架。\n\n# 注意点\n\nvalue最好放软应用对象，确保释放之后的第一次gc就可以回收。\n设置maxsize，可以使用\n```\nRuntime.getRuntime().maxMemory()\n```\n也可针对不同情况进行设置。","slug":"LruCache缓存源码解析","published":1,"updated":"2019-03-12T09:26:33.151Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttzy00673a8knmtnq0a9","content":"<p>以前曾经在volley中使用networkimageview的时候使用过lrucache，当时以为这只是一个第三方的开源框架。昨天在网上找安卓的缓存框架的时候看到了lrucache，居然是android.util包下面的。所以这次就着源码看看是个怎么缓存的原理。</p>\n<h1 id=\"类解释\"><a href=\"#类解释\" class=\"headerlink\" title=\"类解释\"></a>类解释</h1><p>首先看一下这个类官方的解释。</p>\n<ul>\n<li>A cache that holds strong references to a limited number of values. Each time</li>\n<li>a value is accessed, it is moved to the head of a queue. When a value is</li>\n<li>added to a full cache, the value at the end of that queue is evicted and may</li>\n<li>become eligible for garbage collection.</li>\n</ul>\n<p>这个类是一个用于对有限的值持有强引用的缓存类。</p>\n<p>每次一个值被获取了，它将被挪到队列的头部。</p>\n<p>每当一个值被加入完全缓存（full-cache,完全缓存模式，讲一个对象完全的加载到内存中，而非只加载其映射关系。对应的还有Partial Cache，部分缓存模式，部分缓存模式多数用于加载对象的部分，用于判断对象是否曾经加载过，或者是否需要再次加载），缓存队列末尾的值将会被驱逐，丢失了强引用的关系，就会变得可以被gc清除。</p>\n<ul>\n<li><p>If your cached values hold resources that need to be explicitly released,</p></li>\n<li>override {@link #entryRemoved}.</li>\n</ul>\n<p>如果希望避免部分资源被lrucache缓存，可以继承entryremoved</p>\n<ul>\n<li><p>If a cache miss should be computed on demand for the corresponding keys,</p></li>\n<li>override {@link #create}. This simplifies the calling code, allowing it to</li>\n<li>assume a value will always be returned, even when there’s a cache miss.</li>\n</ul>\n<p>如果需要对一个响应返回一个完整的缓存，但是这个缓存目前是缺失状态，可以继承create方法，这样可以使得针对这个响应总是可以有回应，即时目前是缓存缺失的状态，也可以构造一个回应。</p>\n<ul>\n<li><p>By default, the cache size is measured in the number of entries. Override</p></li>\n<li>{@link #sizeOf} to size the cache in different units. For example, this cache</li>\n<li>is limited to 4MiB of bitmaps:</li>\n<li><pre>   {@code</pre></li>\n<li>int cacheSize = 4 <em> 1024 </em> 1024; // 4MiB</li>\n<li>LruCache&lt;String, Bitmap&gt; bitmapCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {</li>\n<li>protected int sizeOf(String key, Bitmap value) {</li>\n<li>return value.getByteCount();</li>\n<li>}</li>\n<li>}}</li>\n</ul>\n<p>缓存的数量是通过对象的数量来确定的。继承sizeOf方法可以使用不同的单位来计算缓存。（该方法提供的例子是用于限制缓存，那缓存不够怎么办？一张bitmap一般有8m啊？事实上它并不会精确计算占用的内存，只能说你说a有3m，总共给30m的缓存的话，他就会放最多10个a，事实上a并不一定只有3m，当然这也没必要关心，在不同的地方自己精确赋一下就好了）</p>\n<ul>\n<li><p>This class is thread-safe. Perform multiple cache operations atomically by</p></li>\n<li>synchronizing on the cache: <pre>   {@code</pre></li>\n<li>synchronized (cache) {</li>\n<li>if (cache.get(key) == null) {</li>\n<li>cache.put(key, value);</li>\n<li>}</li>\n<li>}}</li>\n</ul>\n<p>该类是线程安全的，主要是对缓存操作的部分都加了锁。</p>\n<ul>\n<li><p>This class does not allow null to be used as a key or value. A return</p></li>\n<li>value of null from {@link #get}, {@link #put} or {@link #remove} is</li>\n<li>unambiguous: the key was not in the cache.</li>\n</ul>\n<p>该类不允许空指针被使用作为key或者value。</p>\n<ul>\n<li><p>This class appeared in Android 3.1 (Honeycomb MR1); it’s available as part</p></li>\n<li>of <a href=\"http://developer.android.com/sdk/compatibility-library.html\" target=\"_blank\" rel=\"noopener\">Android’s</a></li>\n<li>Support Package for earlier releases.</li>\n</ul>\n<p>该类在android3.1出现。</p>\n<h1 id=\"源码探究\"><a href=\"#源码探究\" class=\"headerlink\" title=\"源码探究\"></a>源码探究</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final LinkedHashMap&lt;K, V&gt; map;</span><br></pre></td></tr></table></figure>\n<p> 使用了linkedHashMap的方法来存储数据。有向图就是强引用方式，key在，value在。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** Size of this cache in units. Not necessarily the number of elements. */</span><br><span class=\"line\">private int size;</span><br><span class=\"line\">   private int maxSize;</span><br><span class=\"line\"></span><br><span class=\"line\">   private int putCount;</span><br><span class=\"line\">   private int createCount;</span><br><span class=\"line\">   private int evictionCount;</span><br><span class=\"line\">   private int hitCount;</span><br><span class=\"line\">   private int missCount;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param maxSize for caches that do not override &#123;@link #sizeOf&#125;, this is</span><br><span class=\"line\"> *     the maximum number of entries in the cache. For all other caches,</span><br><span class=\"line\"> *     this is the maximum sum of the sizes of the entries in this cache.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public LruCache(int maxSize) &#123;</span><br><span class=\"line\">    if (maxSize &lt;= 0) &#123;</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.maxSize = maxSize;</span><br><span class=\"line\">    this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>构造方面需要给一个maxSize，该参数是用于在为定义sizeof的对象计算容量大小</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Sets the size of the cache.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param maxSize The new maximum size.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void resize(int maxSize) &#123;</span><br><span class=\"line\">    if (maxSize &lt;= 0) &#123;</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    synchronized (this) &#123;</span><br><span class=\"line\">        this.maxSize = maxSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    trimToSize(maxSize);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重新设计maxsize</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Returns the value for &#123;@code key&#125; if it exists in the cache or can be</span><br><span class=\"line\"> * created by &#123;@code #create&#125;. If a value was returned, it is moved to the</span><br><span class=\"line\"> * head of the queue. This returns null if a value is not cached and cannot</span><br><span class=\"line\"> * be created.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public final V get(K key) &#123;</span><br><span class=\"line\">    if (key == null) &#123;</span><br><span class=\"line\">        throw new NullPointerException(&quot;key == null&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    V mapValue;</span><br><span class=\"line\">    synchronized (this) &#123;</span><br><span class=\"line\">        mapValue = map.get(key);</span><br><span class=\"line\">        if (mapValue != null) &#123;</span><br><span class=\"line\">            hitCount++;</span><br><span class=\"line\">            return mapValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        missCount++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     /*</span><br><span class=\"line\">     * Attempt to create a value. This may take a long time, and the map</span><br><span class=\"line\">     * may be different when create() returns. If a conflicting value was</span><br><span class=\"line\">     * added to the map while create() was working, we leave that value in</span><br><span class=\"line\">     * the map and release the created value.</span><br><span class=\"line\">     */</span><br><span class=\"line\"></span><br><span class=\"line\">    V createdValue = create(key);</span><br><span class=\"line\">    if (createdValue == null) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    synchronized (this) &#123;</span><br><span class=\"line\">        createCount++;</span><br><span class=\"line\">        mapValue = map.put(key, createdValue);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (mapValue != null) &#123;</span><br><span class=\"line\">            // There was a conflict so undo that last put</span><br><span class=\"line\">            map.put(key, mapValue);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            size += safeSizeOf(key, createdValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (mapValue != null) &#123;</span><br><span class=\"line\">        entryRemoved(false, key, createdValue, mapValue);</span><br><span class=\"line\">        return mapValue;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        trimToSize(maxSize);</span><br><span class=\"line\">        return createdValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>get的时候加锁，每次有返回的话，hitcount自增。没有返回代表是缺失缓存，misscount自增。</p>\n<p>若找不到值，会调用createvalue来创建，创建成功，createcount自增，失败就代表没有该缓存内容，直接终端。创建成功同时加入到map里面，map的size会增加。</p>\n<p>创建出来的mapvalue会执行entryremoved的检查，对有设置过不加入的参数进行操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Called for entries that have been evicted or removed. This method is</span><br><span class=\"line\"> * invoked when a value is evicted to make space, removed by a call to</span><br><span class=\"line\"> * &#123;@link #remove&#125;, or replaced by a call to &#123;@link #put&#125;. The default</span><br><span class=\"line\"> * implementation does nothing.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * &lt;p&gt;The method is called without synchronization: other threads may</span><br><span class=\"line\"> * access the cache while this method is executing.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param evicted true if the entry is being removed to make space, false</span><br><span class=\"line\"> *     if the removal was caused by a &#123;@link #put&#125; or &#123;@link #remove&#125;.</span><br><span class=\"line\"> * @param newValue the new value for &#123;@code key&#125;, if it exists. If non-null,</span><br><span class=\"line\"> *     this removal was caused by a &#123;@link #put&#125;. Otherwise it was caused by</span><br><span class=\"line\"> *     an eviction or a &#123;@link #remove&#125;.</span><br><span class=\"line\"> */</span><br><span class=\"line\">protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>entryRemoved的方法准确的说法是用于吊起被驱逐和移除的对象。确保key对应的value可以是正确的，newvalue为空的话就代表是移除老的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Remove the eldest entries until the total of remaining entries is at or</span><br><span class=\"line\"> * below the requested size.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param maxSize the maximum size of the cache before returning. May be -1</span><br><span class=\"line\"> *            to evict even 0-sized elements.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void trimToSize(int maxSize) &#123;</span><br><span class=\"line\">    while (true) &#123;</span><br><span class=\"line\">        K key;</span><br><span class=\"line\">        V value;</span><br><span class=\"line\">        synchronized (this) &#123;</span><br><span class=\"line\">            if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123;</span><br><span class=\"line\">                throw new IllegalStateException(getClass().getName()</span><br><span class=\"line\">                        + &quot;.sizeOf() is reporting inconsistent results!&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (size &lt;= maxSize) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            Map.Entry&lt;K, V&gt; toEvict = map.eldest();</span><br><span class=\"line\">            if (toEvict == null) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            key = toEvict.getKey();</span><br><span class=\"line\">            value = toEvict.getValue();</span><br><span class=\"line\">            map.remove(key);</span><br><span class=\"line\">            size -= safeSizeOf(key, value);</span><br><span class=\"line\">            evictionCount++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        entryRemoved(true, key, value, null);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>trimToSize方法是针对目前队列中的对象，移除最老的。移除的操作就是移除了key，去掉强引用的部分。移除完之后要减去移除的大小，之后移除数自增，确保安全之后将之前的key，映射关系改为一个null，这个移除的数量并不是固定的，这是一个死循环，会移除到size小于maxsize，或者最老的是空。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Removes the entry for &#123;@code key&#125; if it exists.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @return the previous value mapped by &#123;@code key&#125;.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public final V remove(K key) &#123;</span><br><span class=\"line\">    if (key == null) &#123;</span><br><span class=\"line\">        throw new NullPointerException(&quot;key == null&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    V previous;</span><br><span class=\"line\">    synchronized (this) &#123;</span><br><span class=\"line\">        previous = map.remove(key);</span><br><span class=\"line\">        if (previous != null) &#123;</span><br><span class=\"line\">            size -= safeSizeOf(key, previous);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (previous != null) &#123;</span><br><span class=\"line\">        entryRemoved(false, key, previous, null);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return previous;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>remove操作和之前的那个操作几乎一样，移除，如果曾经存在就在此赋空。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Clear the cache, calling &#123;@link #entryRemoved&#125; on each removed entry.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public final void evictAll() &#123;</span><br><span class=\"line\">    trimToSize(-1); // -1 will evict 0-sized elements</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是移除所有的元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override public synchronized final String toString() &#123;</span><br><span class=\"line\">    int accesses = hitCount + missCount;</span><br><span class=\"line\">    int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;</span><br><span class=\"line\">    return String.format(&quot;LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]&quot;,</span><br><span class=\"line\">            maxSize, hitCount, missCount, hitPercent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>toString方法可以看到状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Returns a copy of the current contents of the cache, ordered from least</span><br><span class=\"line\"> * recently accessed to most recently accessed.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public synchronized final Map&lt;K, V&gt; snapshot() &#123;</span><br><span class=\"line\">    return new LinkedHashMap&lt;K, V&gt;(map);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>snapshot直接一个以自己map构造的对象。（这种避免返回自身的操作值得学习）</p>\n<h1 id=\"学习心得\"><a href=\"#学习心得\" class=\"headerlink\" title=\"学习心得\"></a>学习心得</h1><p>整个LruCache的作用，说到底就是针对gc的树状搜索删除算法的一种方案。<br>但是我们平时使用的时候，需要针对几个地方进行定制，一是sizeof,二是removeentry。</p>\n<p>整个缓存还是在内存中的，所以lrucache是一种内存缓存框架。</p>\n<h1 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h1><p>value最好放软应用对象，确保释放之后的第一次gc就可以回收。<br>设置maxsize，可以使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runtime.getRuntime().maxMemory()</span><br></pre></td></tr></table></figure></p>\n<p>也可针对不同情况进行设置。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>以前曾经在volley中使用networkimageview的时候使用过lrucache，当时以为这只是一个第三方的开源框架。昨天在网上找安卓的缓存框架的时候看到了lrucache，居然是android.util包下面的。所以这次就着源码看看是个怎么缓存的原理。</p>\n<h1 id=\"类解释\"><a href=\"#类解释\" class=\"headerlink\" title=\"类解释\"></a>类解释</h1><p>首先看一下这个类官方的解释。</p>\n<ul>\n<li>A cache that holds strong references to a limited number of values. Each time</li>\n<li>a value is accessed, it is moved to the head of a queue. When a value is</li>\n<li>added to a full cache, the value at the end of that queue is evicted and may</li>\n<li>become eligible for garbage collection.</li>\n</ul>\n<p>这个类是一个用于对有限的值持有强引用的缓存类。</p>\n<p>每次一个值被获取了，它将被挪到队列的头部。</p>\n<p>每当一个值被加入完全缓存（full-cache,完全缓存模式，讲一个对象完全的加载到内存中，而非只加载其映射关系。对应的还有Partial Cache，部分缓存模式，部分缓存模式多数用于加载对象的部分，用于判断对象是否曾经加载过，或者是否需要再次加载），缓存队列末尾的值将会被驱逐，丢失了强引用的关系，就会变得可以被gc清除。</p>\n<ul>\n<li><p>If your cached values hold resources that need to be explicitly released,</p></li>\n<li>override {@link #entryRemoved}.</li>\n</ul>\n<p>如果希望避免部分资源被lrucache缓存，可以继承entryremoved</p>\n<ul>\n<li><p>If a cache miss should be computed on demand for the corresponding keys,</p></li>\n<li>override {@link #create}. This simplifies the calling code, allowing it to</li>\n<li>assume a value will always be returned, even when there’s a cache miss.</li>\n</ul>\n<p>如果需要对一个响应返回一个完整的缓存，但是这个缓存目前是缺失状态，可以继承create方法，这样可以使得针对这个响应总是可以有回应，即时目前是缓存缺失的状态，也可以构造一个回应。</p>\n<ul>\n<li><p>By default, the cache size is measured in the number of entries. Override</p></li>\n<li>{@link #sizeOf} to size the cache in different units. For example, this cache</li>\n<li>is limited to 4MiB of bitmaps:</li>\n<li><pre>   {@code</pre></li>\n<li>int cacheSize = 4 <em> 1024 </em> 1024; // 4MiB</li>\n<li>LruCache&lt;String, Bitmap&gt; bitmapCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {</li>\n<li>protected int sizeOf(String key, Bitmap value) {</li>\n<li>return value.getByteCount();</li>\n<li>}</li>\n<li>}}</li>\n</ul>\n<p>缓存的数量是通过对象的数量来确定的。继承sizeOf方法可以使用不同的单位来计算缓存。（该方法提供的例子是用于限制缓存，那缓存不够怎么办？一张bitmap一般有8m啊？事实上它并不会精确计算占用的内存，只能说你说a有3m，总共给30m的缓存的话，他就会放最多10个a，事实上a并不一定只有3m，当然这也没必要关心，在不同的地方自己精确赋一下就好了）</p>\n<ul>\n<li><p>This class is thread-safe. Perform multiple cache operations atomically by</p></li>\n<li>synchronizing on the cache: <pre>   {@code</pre></li>\n<li>synchronized (cache) {</li>\n<li>if (cache.get(key) == null) {</li>\n<li>cache.put(key, value);</li>\n<li>}</li>\n<li>}}</li>\n</ul>\n<p>该类是线程安全的，主要是对缓存操作的部分都加了锁。</p>\n<ul>\n<li><p>This class does not allow null to be used as a key or value. A return</p></li>\n<li>value of null from {@link #get}, {@link #put} or {@link #remove} is</li>\n<li>unambiguous: the key was not in the cache.</li>\n</ul>\n<p>该类不允许空指针被使用作为key或者value。</p>\n<ul>\n<li><p>This class appeared in Android 3.1 (Honeycomb MR1); it’s available as part</p></li>\n<li>of <a href=\"http://developer.android.com/sdk/compatibility-library.html\" target=\"_blank\" rel=\"noopener\">Android’s</a></li>\n<li>Support Package for earlier releases.</li>\n</ul>\n<p>该类在android3.1出现。</p>\n<h1 id=\"源码探究\"><a href=\"#源码探究\" class=\"headerlink\" title=\"源码探究\"></a>源码探究</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final LinkedHashMap&lt;K, V&gt; map;</span><br></pre></td></tr></table></figure>\n<p> 使用了linkedHashMap的方法来存储数据。有向图就是强引用方式，key在，value在。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** Size of this cache in units. Not necessarily the number of elements. */</span><br><span class=\"line\">private int size;</span><br><span class=\"line\">   private int maxSize;</span><br><span class=\"line\"></span><br><span class=\"line\">   private int putCount;</span><br><span class=\"line\">   private int createCount;</span><br><span class=\"line\">   private int evictionCount;</span><br><span class=\"line\">   private int hitCount;</span><br><span class=\"line\">   private int missCount;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param maxSize for caches that do not override &#123;@link #sizeOf&#125;, this is</span><br><span class=\"line\"> *     the maximum number of entries in the cache. For all other caches,</span><br><span class=\"line\"> *     this is the maximum sum of the sizes of the entries in this cache.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public LruCache(int maxSize) &#123;</span><br><span class=\"line\">    if (maxSize &lt;= 0) &#123;</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.maxSize = maxSize;</span><br><span class=\"line\">    this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>构造方面需要给一个maxSize，该参数是用于在为定义sizeof的对象计算容量大小</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Sets the size of the cache.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param maxSize The new maximum size.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void resize(int maxSize) &#123;</span><br><span class=\"line\">    if (maxSize &lt;= 0) &#123;</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    synchronized (this) &#123;</span><br><span class=\"line\">        this.maxSize = maxSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    trimToSize(maxSize);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重新设计maxsize</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Returns the value for &#123;@code key&#125; if it exists in the cache or can be</span><br><span class=\"line\"> * created by &#123;@code #create&#125;. If a value was returned, it is moved to the</span><br><span class=\"line\"> * head of the queue. This returns null if a value is not cached and cannot</span><br><span class=\"line\"> * be created.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public final V get(K key) &#123;</span><br><span class=\"line\">    if (key == null) &#123;</span><br><span class=\"line\">        throw new NullPointerException(&quot;key == null&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    V mapValue;</span><br><span class=\"line\">    synchronized (this) &#123;</span><br><span class=\"line\">        mapValue = map.get(key);</span><br><span class=\"line\">        if (mapValue != null) &#123;</span><br><span class=\"line\">            hitCount++;</span><br><span class=\"line\">            return mapValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        missCount++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     /*</span><br><span class=\"line\">     * Attempt to create a value. This may take a long time, and the map</span><br><span class=\"line\">     * may be different when create() returns. If a conflicting value was</span><br><span class=\"line\">     * added to the map while create() was working, we leave that value in</span><br><span class=\"line\">     * the map and release the created value.</span><br><span class=\"line\">     */</span><br><span class=\"line\"></span><br><span class=\"line\">    V createdValue = create(key);</span><br><span class=\"line\">    if (createdValue == null) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    synchronized (this) &#123;</span><br><span class=\"line\">        createCount++;</span><br><span class=\"line\">        mapValue = map.put(key, createdValue);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (mapValue != null) &#123;</span><br><span class=\"line\">            // There was a conflict so undo that last put</span><br><span class=\"line\">            map.put(key, mapValue);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            size += safeSizeOf(key, createdValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (mapValue != null) &#123;</span><br><span class=\"line\">        entryRemoved(false, key, createdValue, mapValue);</span><br><span class=\"line\">        return mapValue;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        trimToSize(maxSize);</span><br><span class=\"line\">        return createdValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>get的时候加锁，每次有返回的话，hitcount自增。没有返回代表是缺失缓存，misscount自增。</p>\n<p>若找不到值，会调用createvalue来创建，创建成功，createcount自增，失败就代表没有该缓存内容，直接终端。创建成功同时加入到map里面，map的size会增加。</p>\n<p>创建出来的mapvalue会执行entryremoved的检查，对有设置过不加入的参数进行操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Called for entries that have been evicted or removed. This method is</span><br><span class=\"line\"> * invoked when a value is evicted to make space, removed by a call to</span><br><span class=\"line\"> * &#123;@link #remove&#125;, or replaced by a call to &#123;@link #put&#125;. The default</span><br><span class=\"line\"> * implementation does nothing.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * &lt;p&gt;The method is called without synchronization: other threads may</span><br><span class=\"line\"> * access the cache while this method is executing.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param evicted true if the entry is being removed to make space, false</span><br><span class=\"line\"> *     if the removal was caused by a &#123;@link #put&#125; or &#123;@link #remove&#125;.</span><br><span class=\"line\"> * @param newValue the new value for &#123;@code key&#125;, if it exists. If non-null,</span><br><span class=\"line\"> *     this removal was caused by a &#123;@link #put&#125;. Otherwise it was caused by</span><br><span class=\"line\"> *     an eviction or a &#123;@link #remove&#125;.</span><br><span class=\"line\"> */</span><br><span class=\"line\">protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>entryRemoved的方法准确的说法是用于吊起被驱逐和移除的对象。确保key对应的value可以是正确的，newvalue为空的话就代表是移除老的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Remove the eldest entries until the total of remaining entries is at or</span><br><span class=\"line\"> * below the requested size.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param maxSize the maximum size of the cache before returning. May be -1</span><br><span class=\"line\"> *            to evict even 0-sized elements.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void trimToSize(int maxSize) &#123;</span><br><span class=\"line\">    while (true) &#123;</span><br><span class=\"line\">        K key;</span><br><span class=\"line\">        V value;</span><br><span class=\"line\">        synchronized (this) &#123;</span><br><span class=\"line\">            if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123;</span><br><span class=\"line\">                throw new IllegalStateException(getClass().getName()</span><br><span class=\"line\">                        + &quot;.sizeOf() is reporting inconsistent results!&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (size &lt;= maxSize) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            Map.Entry&lt;K, V&gt; toEvict = map.eldest();</span><br><span class=\"line\">            if (toEvict == null) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            key = toEvict.getKey();</span><br><span class=\"line\">            value = toEvict.getValue();</span><br><span class=\"line\">            map.remove(key);</span><br><span class=\"line\">            size -= safeSizeOf(key, value);</span><br><span class=\"line\">            evictionCount++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        entryRemoved(true, key, value, null);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>trimToSize方法是针对目前队列中的对象，移除最老的。移除的操作就是移除了key，去掉强引用的部分。移除完之后要减去移除的大小，之后移除数自增，确保安全之后将之前的key，映射关系改为一个null，这个移除的数量并不是固定的，这是一个死循环，会移除到size小于maxsize，或者最老的是空。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Removes the entry for &#123;@code key&#125; if it exists.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @return the previous value mapped by &#123;@code key&#125;.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public final V remove(K key) &#123;</span><br><span class=\"line\">    if (key == null) &#123;</span><br><span class=\"line\">        throw new NullPointerException(&quot;key == null&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    V previous;</span><br><span class=\"line\">    synchronized (this) &#123;</span><br><span class=\"line\">        previous = map.remove(key);</span><br><span class=\"line\">        if (previous != null) &#123;</span><br><span class=\"line\">            size -= safeSizeOf(key, previous);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (previous != null) &#123;</span><br><span class=\"line\">        entryRemoved(false, key, previous, null);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return previous;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>remove操作和之前的那个操作几乎一样，移除，如果曾经存在就在此赋空。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Clear the cache, calling &#123;@link #entryRemoved&#125; on each removed entry.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public final void evictAll() &#123;</span><br><span class=\"line\">    trimToSize(-1); // -1 will evict 0-sized elements</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是移除所有的元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override public synchronized final String toString() &#123;</span><br><span class=\"line\">    int accesses = hitCount + missCount;</span><br><span class=\"line\">    int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;</span><br><span class=\"line\">    return String.format(&quot;LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]&quot;,</span><br><span class=\"line\">            maxSize, hitCount, missCount, hitPercent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>toString方法可以看到状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Returns a copy of the current contents of the cache, ordered from least</span><br><span class=\"line\"> * recently accessed to most recently accessed.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public synchronized final Map&lt;K, V&gt; snapshot() &#123;</span><br><span class=\"line\">    return new LinkedHashMap&lt;K, V&gt;(map);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>snapshot直接一个以自己map构造的对象。（这种避免返回自身的操作值得学习）</p>\n<h1 id=\"学习心得\"><a href=\"#学习心得\" class=\"headerlink\" title=\"学习心得\"></a>学习心得</h1><p>整个LruCache的作用，说到底就是针对gc的树状搜索删除算法的一种方案。<br>但是我们平时使用的时候，需要针对几个地方进行定制，一是sizeof,二是removeentry。</p>\n<p>整个缓存还是在内存中的，所以lrucache是一种内存缓存框架。</p>\n<h1 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h1><p>value最好放软应用对象，确保释放之后的第一次gc就可以回收。<br>设置maxsize，可以使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runtime.getRuntime().maxMemory()</span><br></pre></td></tr></table></figure></p>\n<p>也可针对不同情况进行设置。</p>\n"},{"title":"Collection","date":"2018-02-28T15:14:41.000Z","_content":"\n面试的时候问到了Collection和Collections的差别。当时有个浅薄的印象是Collection好像是个接口类，而Collections是个实体类。\n回来翻书发现自己真是无知，回答的驴头不对马嘴。\n\n# Collection\n\njava.util.Collection是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在java库中有很多基本的实现。\n\nCollection接口最大的意义是为了各种具体的集合提供最大化的统一操作方式，其直接继承接口有List和set等等。\n\n![Collection子类](/images/数据结构/Java集合框架.jpg)\n\n\n## Collection源码解析\n\n```\n/*\n*首先，继承了Iterable类，同时指定了范型\n*/\npublic interface Collection<E> extends Iterable<E> {\n\t/*\n\t*返回集合中数组的元素数量\n\t*/\n\tint size();\n\n\t/*\n\t*集合中没有元素就返回true\n\t*/\n\tboolean isEmpty();\n\n\t/*\n\t*集合中有这个元素就返回true\n\t*/\n\tboolean contains(Object o);\n\n\t/*\n\t*返回集合元素的迭代器\n\t*/\n\tIterator<E> iterator();\n\n\t/*\n\t*返回一个包含集合中所有元素的数组，数组类型是object\n\t*这个方法是数组和集合中的桥梁\n\t*/\n\tObject[] toArray();\n\n\t/*\n\t*上个api的多态方法，将集合转为一个指定的数组，类型必须是运行中指定的类型\n\t*倘若集合的元素数量小于数组，那么数组没有元素的空间会被设为null\n\t*假如集合需要保证元素的顺序，则转换为数组时也需要保证相应的顺序\n\t*例：String[] y = x.toArray(new String[0]);\n\t*toArray(new Object[0])就等于toArray()\n\t*/\n\t<T> T[] toArray(T[] a);\n\n\t<-- 以下是修改操作 -->\n\n\t/*\n\t*首先要确保集合中没有该需要添加的元素\n\t*返回true，当集合对这次请求进行了自己的改变\n\t*返回false，当集合没有允许重复添加已有的元素\n\t*假如一个集合拒绝添加一个元素，需要抛出异常而不是返回false\n\t*/\n\tboolean add(E e);\n\n\t/*\n\t*从集合中移除一个存在的单一对象\n\t*集合中如果拥有一个或多个该元素，将会移除一个或者其中的一个元素\n\t*对该请求进行操作之后，的确拥有该元素（或者说有个元素和它equal），会移除该元素并且返回true\n\t*/\n\tboolean remove(Object o);\n\n\t<-- 以下是批量操作 -->\n\n\t/*\n\t*假如集合中包含该指定集合的所有的元素，就返回true\n\t*/\n\tboolean containsAll(Collection<?> c);\n\n\t/*\n\t*将指定集合中的所有元素添加到集合中\n\t*该操作在操作进行中时是不明确的。因此表明了该操作在添加的集合就是自身时，其实是不明确的。\n\t*/\n\tboolean addAll(Collection<? extends E> c);\n\n\t/*\n\t*移除指定集合和原有集合中同时拥有的元素，操作结束之后原有集合和指定集合将在无相同的元素\n\t*/\n\tboolean removeAll(Collection<?> c);\n\n\t/*\n\t*只保存和指定集合共同拥有的元素，即是移除所有指定集合中不包含的元素。\n\t*/\n\tboolean retainAll(Collection<?> c);\n\n\t/*\n\t*移除集合中所有的元素，集合在操作之后将为空\n\t*/\n\tvoid clear();\n\n\t<-- 以下是比较和哈希 -->\n\n\t/*\n\t*将制定的对象与集合进行平等性的比较\n\t*\n\t*当集合的接口没有添加类似equal的操作，程序员需要小心的复写Object.equal的操作。\n\t*最简单的是直接依赖Object的接口\n\t*/\n\tboolean equals(Object o);\n\n\t/*\n\t*返回集合的hash码，当集合的接口没有添hashcode的操作的时候，程序员需要注意任何类一旦复写了equal，也将复写hashcode，这是为了保证基础的对比。\n\t*\n\t*/\n\tint hashCode();\n}\n```\n\n# Collections\n\njava.util.Collections则是一个包装类（工具类/帮助类），包含各种有关集合操作的静态多态方法。不能被实例化，就像一个工具类，用于对集合中元素进行排序、搜索和线程安全等各种操作。\n\n\n```\npublic class Collections {\n\n\t//构造函数私有化，目的是为了保证无法被构造\n\tprivate Collections() {\n    }\n\n\n    /*\n    *sort排序\n    */\n    @SuppressWarnings(\"unchecked\")//使用了范型，让编译器别做反应\n    public static <T extends Comparable<? super T>> void sort(List<T> list) {\n        if (list.getClass() == ArrayList.class) {\n            Arrays.sort(((ArrayList) list).elementData, 0, list.size());//arraylist直接使用Arrays的排序\n            return;\n        }\n\n        Object[] a = list.toArray();//不是arraylist，则将其转换为array，然后使用Arrays的排序\n        Arrays.sort(a);\n        /*\n        *之后获取迭代器，通过迭代器进行参数的传递\n        */\n        ListIterator<T> i = list.listIterator();\n        for (int j=0; j<a.length; j++) {\n            i.next();\n            i.set((T)a[j]);\n        }\n    }\n\n    /*\n    *sort排序的多态方法，加上一个比较器进行排序\n    */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})//压制警告，即去除警告，rawtypes是说传参时也要传递带泛型的参数\n    public static <T> void sort(List<T> list, Comparator<? super T> c) {\n        if (list.getClass() == ArrayList.class) {\n            Arrays.sort(((ArrayList) list).elementData, 0, list.size(), (Comparator) c);\n            return;\n        }\n\n        Object[] a = list.toArray();\n        Arrays.sort(a, (Comparator)c);\n        ListIterator<T> i = list.listIterator();\n        for (int j=0; j<a.length; j++) {\n            i.next();\n            i.set((T)a[j]);\n        }\n        /*\n        *仅仅是多加了一个比较器而已\n        */\n    }\n\n    /*\n    *二分查找，在list实现randomaccess接口，或者大小小于5000时，使用索引二分查找，否则使用迭代器二分查找\n    */\n    public static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key) {\n        if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)\n            return Collections.indexedBinarySearch(list, key);\n        else\n            return Collections.iteratorBinarySearch(list, key);\n    }\n\n    /*\n    *二分查找的多态方法，支持比较器\n    */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> int binarySearch(List<? extends T> list, T key, Comparator<? super T> c) {\n        if (c==null)\n            return binarySearch((List<? extends Comparable<? super T>>) list, key);\n\n        if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)\n            return Collections.indexedBinarySearch(list, key, c);\n        else\n            return Collections.iteratorBinarySearch(list, key, c);\n    }\n\n    /*\n    *反转操作，数量小于18，或者实现randomaccess接口时，使用swap操作，否则使用迭代器进行反转替换\n    */\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    public static void reverse(List<?> list) {\n        int size = list.size();\n        if (size < REVERSE_THRESHOLD || list instanceof RandomAccess) {\n            for (int i=0, mid=size>>1, j=size-1; i<mid; i++, j--)\n                swap(list, i, j);\n        } else {\n            // instead of using a raw type here, it's possible to capture\n            // the wildcard but it will require a call to a supplementary\n            // private method\n            ListIterator fwd = list.listIterator();\n            ListIterator rev = list.listIterator(size);\n            for (int i=0, mid=list.size()>>1; i<mid; i++) {\n                Object tmp = fwd.next();\n                fwd.set(rev.previous());\n                rev.set(tmp);\n            }\n        }\n    }\n\n    /*\n    *洗牌操作\n    */\n    public static void shuffle(List<?> list) {\n        Random rnd = r;\n        if (rnd == null)\n            r = rnd = new Random(); // harmless race.\n        shuffle(list, rnd);\n    }\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    public static void shuffle(List<?> list, Random rnd) {\n        int size = list.size();\n        if (size < SHUFFLE_THRESHOLD || list instanceof RandomAccess) {\n            for (int i=size; i>1; i--)\n                swap(list, i-1, rnd.nextInt(i));\n        } else {\n            Object arr[] = list.toArray();\n\n            // Shuffle array\n            for (int i=size; i>1; i--)\n                swap(arr, i-1, rnd.nextInt(i));\n\n            // Dump array back into list\n            // instead of using a raw type here, it's possible to capture\n            // the wildcard but it will require a call to a supplementary\n            // private method\n            ListIterator it = list.listIterator();\n            for (int i=0; i<arr.length; i++) {\n                it.next();\n                it.set(arr[i]);\n            }\n        }\n    }\n\n    /*\n    *交换操作\n    */\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    public static void swap(List<?> list, int i, int j) {\n        // instead of using a raw type here, it's possible to capture\n        // the wildcard but it will require a call to a supplementary\n        // private method\n        final List l = list;\n        l.set(i, l.set(j, l.get(i)));\n    }\n\n    /*\n    *填满操作，将list填充成全是obj的list\n    */\n    public static <T> void fill(List<? super T> list, T obj) {\n        int size = list.size();\n\n        if (size < FILL_THRESHOLD || list instanceof RandomAccess) {\n            for (int i=0; i<size; i++)\n                list.set(i, obj);\n        } else {\n            ListIterator<? super T> itr = list.listIterator();\n            for (int i=0; i<size; i++) {\n                itr.next();\n                itr.set(obj);\n            }\n        }\n    }\n\n    /*\n    *复制操作，结束后dest的内容将和src的内容完全一样，不过有两点，一个是dest的长度要不小于src的长度，另一个是dest的长度大于src时，dest中多余的元素将不受影响\n    */\n    public static <T> void copy(List<? super T> dest, List<? extends T> src) {\n        int srcSize = src.size();\n        if (srcSize > dest.size())\n            throw new IndexOutOfBoundsException(\"Source does not fit in dest\");\n\n        if (srcSize < COPY_THRESHOLD ||\n            (src instanceof RandomAccess && dest instanceof RandomAccess)) {\n            for (int i=0; i<srcSize; i++)\n                dest.set(i, src.get(i));\n        } else {\n            ListIterator<? super T> di=dest.listIterator();\n            ListIterator<? extends T> si=src.listIterator();\n            for (int i=0; i<srcSize; i++) {\n                di.next();\n                di.set(si.next());\n            }\n        }\n    }\n\n    /*\n    *计算最小值，方法仍然是使用迭代器\n    */\n    public static <T extends Object & Comparable<? super T>> T min(Collection<? extends T> coll) {\n        Iterator<? extends T> i = coll.iterator();\n        T candidate = i.next();\n\n        while (i.hasNext()) {\n            T next = i.next();\n            if (next.compareTo(candidate) < 0)\n                candidate = next;\n        }\n        return candidate;\n    }\n\n    /*\n    *计算最小值的多态方法，添加了一个比较器\n    */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public static <T> T min(Collection<? extends T> coll, Comparator<? super T> comp) {\n        if (comp==null)\n            return (T)min((Collection) coll);\n\n        Iterator<? extends T> i = coll.iterator();\n        T candidate = i.next();\n\n        while (i.hasNext()) {\n            T next = i.next();\n            if (comp.compare(next, candidate) < 0)\n                candidate = next;\n        }\n        return candidate;\n    }\n\n    /*\n    *计算最大值\n    */\n    public static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll) {\n        Iterator<? extends T> i = coll.iterator();\n        T candidate = i.next();\n\n        while (i.hasNext()) {\n            T next = i.next();\n            if (next.compareTo(candidate) > 0)\n                candidate = next;\n        }\n        return candidate;\n    }\n\n    /*\n    *通过比较器计算最大值\n    */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public static <T> T max(Collection<? extends T> coll, Comparator<? super T> comp) {\n        if (comp==null)\n            return (T)max((Collection) coll);\n\n        Iterator<? extends T> i = coll.iterator();\n        T candidate = i.next();\n\n        while (i.hasNext()) {\n            T next = i.next();\n            if (comp.compare(next, candidate) > 0)\n                candidate = next;\n        }\n        return candidate;\n    }\n\n    /*\n    *旋转操作，通过distance来计算\n    */\n    public static void rotate(List<?> list, int distance) {\n        if (list instanceof RandomAccess || list.size() < ROTATE_THRESHOLD)\n            rotate1(list, distance);\n        else\n            rotate2(list, distance);\n    }\n\n    /*\n    *使用新值，替换list中原有的旧值\n    */\n    public static <T> boolean replaceAll(List<T> list, T oldVal, T newVal) {\n        boolean result = false;\n        int size = list.size();\n        if (size < REPLACEALL_THRESHOLD || list instanceof RandomAccess) {\n            if (oldVal==null) {\n                for (int i=0; i<size; i++) {\n                    if (list.get(i)==null) {\n                        list.set(i, newVal);\n                        result = true;\n                    }\n                }\n            } else {\n                for (int i=0; i<size; i++) {\n                    if (oldVal.equals(list.get(i))) {\n                        list.set(i, newVal);\n                        result = true;\n                    }\n                }\n            }\n        } else {\n            ListIterator<T> itr=list.listIterator();\n            if (oldVal==null) {\n                for (int i=0; i<size; i++) {\n                    if (itr.next()==null) {\n                        itr.set(newVal);\n                        result = true;\n                    }\n                }\n            } else {\n                for (int i=0; i<size; i++) {\n                    if (oldVal.equals(itr.next())) {\n                        itr.set(newVal);\n                        result = true;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n}\n```\n\n","source":"_posts/Collection.md","raw":"---\ntitle: Collection\ndate: 2018-02-28 23:14:41\ntags: 数据结构\n---\n\n面试的时候问到了Collection和Collections的差别。当时有个浅薄的印象是Collection好像是个接口类，而Collections是个实体类。\n回来翻书发现自己真是无知，回答的驴头不对马嘴。\n\n# Collection\n\njava.util.Collection是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在java库中有很多基本的实现。\n\nCollection接口最大的意义是为了各种具体的集合提供最大化的统一操作方式，其直接继承接口有List和set等等。\n\n![Collection子类](/images/数据结构/Java集合框架.jpg)\n\n\n## Collection源码解析\n\n```\n/*\n*首先，继承了Iterable类，同时指定了范型\n*/\npublic interface Collection<E> extends Iterable<E> {\n\t/*\n\t*返回集合中数组的元素数量\n\t*/\n\tint size();\n\n\t/*\n\t*集合中没有元素就返回true\n\t*/\n\tboolean isEmpty();\n\n\t/*\n\t*集合中有这个元素就返回true\n\t*/\n\tboolean contains(Object o);\n\n\t/*\n\t*返回集合元素的迭代器\n\t*/\n\tIterator<E> iterator();\n\n\t/*\n\t*返回一个包含集合中所有元素的数组，数组类型是object\n\t*这个方法是数组和集合中的桥梁\n\t*/\n\tObject[] toArray();\n\n\t/*\n\t*上个api的多态方法，将集合转为一个指定的数组，类型必须是运行中指定的类型\n\t*倘若集合的元素数量小于数组，那么数组没有元素的空间会被设为null\n\t*假如集合需要保证元素的顺序，则转换为数组时也需要保证相应的顺序\n\t*例：String[] y = x.toArray(new String[0]);\n\t*toArray(new Object[0])就等于toArray()\n\t*/\n\t<T> T[] toArray(T[] a);\n\n\t<-- 以下是修改操作 -->\n\n\t/*\n\t*首先要确保集合中没有该需要添加的元素\n\t*返回true，当集合对这次请求进行了自己的改变\n\t*返回false，当集合没有允许重复添加已有的元素\n\t*假如一个集合拒绝添加一个元素，需要抛出异常而不是返回false\n\t*/\n\tboolean add(E e);\n\n\t/*\n\t*从集合中移除一个存在的单一对象\n\t*集合中如果拥有一个或多个该元素，将会移除一个或者其中的一个元素\n\t*对该请求进行操作之后，的确拥有该元素（或者说有个元素和它equal），会移除该元素并且返回true\n\t*/\n\tboolean remove(Object o);\n\n\t<-- 以下是批量操作 -->\n\n\t/*\n\t*假如集合中包含该指定集合的所有的元素，就返回true\n\t*/\n\tboolean containsAll(Collection<?> c);\n\n\t/*\n\t*将指定集合中的所有元素添加到集合中\n\t*该操作在操作进行中时是不明确的。因此表明了该操作在添加的集合就是自身时，其实是不明确的。\n\t*/\n\tboolean addAll(Collection<? extends E> c);\n\n\t/*\n\t*移除指定集合和原有集合中同时拥有的元素，操作结束之后原有集合和指定集合将在无相同的元素\n\t*/\n\tboolean removeAll(Collection<?> c);\n\n\t/*\n\t*只保存和指定集合共同拥有的元素，即是移除所有指定集合中不包含的元素。\n\t*/\n\tboolean retainAll(Collection<?> c);\n\n\t/*\n\t*移除集合中所有的元素，集合在操作之后将为空\n\t*/\n\tvoid clear();\n\n\t<-- 以下是比较和哈希 -->\n\n\t/*\n\t*将制定的对象与集合进行平等性的比较\n\t*\n\t*当集合的接口没有添加类似equal的操作，程序员需要小心的复写Object.equal的操作。\n\t*最简单的是直接依赖Object的接口\n\t*/\n\tboolean equals(Object o);\n\n\t/*\n\t*返回集合的hash码，当集合的接口没有添hashcode的操作的时候，程序员需要注意任何类一旦复写了equal，也将复写hashcode，这是为了保证基础的对比。\n\t*\n\t*/\n\tint hashCode();\n}\n```\n\n# Collections\n\njava.util.Collections则是一个包装类（工具类/帮助类），包含各种有关集合操作的静态多态方法。不能被实例化，就像一个工具类，用于对集合中元素进行排序、搜索和线程安全等各种操作。\n\n\n```\npublic class Collections {\n\n\t//构造函数私有化，目的是为了保证无法被构造\n\tprivate Collections() {\n    }\n\n\n    /*\n    *sort排序\n    */\n    @SuppressWarnings(\"unchecked\")//使用了范型，让编译器别做反应\n    public static <T extends Comparable<? super T>> void sort(List<T> list) {\n        if (list.getClass() == ArrayList.class) {\n            Arrays.sort(((ArrayList) list).elementData, 0, list.size());//arraylist直接使用Arrays的排序\n            return;\n        }\n\n        Object[] a = list.toArray();//不是arraylist，则将其转换为array，然后使用Arrays的排序\n        Arrays.sort(a);\n        /*\n        *之后获取迭代器，通过迭代器进行参数的传递\n        */\n        ListIterator<T> i = list.listIterator();\n        for (int j=0; j<a.length; j++) {\n            i.next();\n            i.set((T)a[j]);\n        }\n    }\n\n    /*\n    *sort排序的多态方法，加上一个比较器进行排序\n    */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})//压制警告，即去除警告，rawtypes是说传参时也要传递带泛型的参数\n    public static <T> void sort(List<T> list, Comparator<? super T> c) {\n        if (list.getClass() == ArrayList.class) {\n            Arrays.sort(((ArrayList) list).elementData, 0, list.size(), (Comparator) c);\n            return;\n        }\n\n        Object[] a = list.toArray();\n        Arrays.sort(a, (Comparator)c);\n        ListIterator<T> i = list.listIterator();\n        for (int j=0; j<a.length; j++) {\n            i.next();\n            i.set((T)a[j]);\n        }\n        /*\n        *仅仅是多加了一个比较器而已\n        */\n    }\n\n    /*\n    *二分查找，在list实现randomaccess接口，或者大小小于5000时，使用索引二分查找，否则使用迭代器二分查找\n    */\n    public static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key) {\n        if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)\n            return Collections.indexedBinarySearch(list, key);\n        else\n            return Collections.iteratorBinarySearch(list, key);\n    }\n\n    /*\n    *二分查找的多态方法，支持比较器\n    */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> int binarySearch(List<? extends T> list, T key, Comparator<? super T> c) {\n        if (c==null)\n            return binarySearch((List<? extends Comparable<? super T>>) list, key);\n\n        if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)\n            return Collections.indexedBinarySearch(list, key, c);\n        else\n            return Collections.iteratorBinarySearch(list, key, c);\n    }\n\n    /*\n    *反转操作，数量小于18，或者实现randomaccess接口时，使用swap操作，否则使用迭代器进行反转替换\n    */\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    public static void reverse(List<?> list) {\n        int size = list.size();\n        if (size < REVERSE_THRESHOLD || list instanceof RandomAccess) {\n            for (int i=0, mid=size>>1, j=size-1; i<mid; i++, j--)\n                swap(list, i, j);\n        } else {\n            // instead of using a raw type here, it's possible to capture\n            // the wildcard but it will require a call to a supplementary\n            // private method\n            ListIterator fwd = list.listIterator();\n            ListIterator rev = list.listIterator(size);\n            for (int i=0, mid=list.size()>>1; i<mid; i++) {\n                Object tmp = fwd.next();\n                fwd.set(rev.previous());\n                rev.set(tmp);\n            }\n        }\n    }\n\n    /*\n    *洗牌操作\n    */\n    public static void shuffle(List<?> list) {\n        Random rnd = r;\n        if (rnd == null)\n            r = rnd = new Random(); // harmless race.\n        shuffle(list, rnd);\n    }\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    public static void shuffle(List<?> list, Random rnd) {\n        int size = list.size();\n        if (size < SHUFFLE_THRESHOLD || list instanceof RandomAccess) {\n            for (int i=size; i>1; i--)\n                swap(list, i-1, rnd.nextInt(i));\n        } else {\n            Object arr[] = list.toArray();\n\n            // Shuffle array\n            for (int i=size; i>1; i--)\n                swap(arr, i-1, rnd.nextInt(i));\n\n            // Dump array back into list\n            // instead of using a raw type here, it's possible to capture\n            // the wildcard but it will require a call to a supplementary\n            // private method\n            ListIterator it = list.listIterator();\n            for (int i=0; i<arr.length; i++) {\n                it.next();\n                it.set(arr[i]);\n            }\n        }\n    }\n\n    /*\n    *交换操作\n    */\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    public static void swap(List<?> list, int i, int j) {\n        // instead of using a raw type here, it's possible to capture\n        // the wildcard but it will require a call to a supplementary\n        // private method\n        final List l = list;\n        l.set(i, l.set(j, l.get(i)));\n    }\n\n    /*\n    *填满操作，将list填充成全是obj的list\n    */\n    public static <T> void fill(List<? super T> list, T obj) {\n        int size = list.size();\n\n        if (size < FILL_THRESHOLD || list instanceof RandomAccess) {\n            for (int i=0; i<size; i++)\n                list.set(i, obj);\n        } else {\n            ListIterator<? super T> itr = list.listIterator();\n            for (int i=0; i<size; i++) {\n                itr.next();\n                itr.set(obj);\n            }\n        }\n    }\n\n    /*\n    *复制操作，结束后dest的内容将和src的内容完全一样，不过有两点，一个是dest的长度要不小于src的长度，另一个是dest的长度大于src时，dest中多余的元素将不受影响\n    */\n    public static <T> void copy(List<? super T> dest, List<? extends T> src) {\n        int srcSize = src.size();\n        if (srcSize > dest.size())\n            throw new IndexOutOfBoundsException(\"Source does not fit in dest\");\n\n        if (srcSize < COPY_THRESHOLD ||\n            (src instanceof RandomAccess && dest instanceof RandomAccess)) {\n            for (int i=0; i<srcSize; i++)\n                dest.set(i, src.get(i));\n        } else {\n            ListIterator<? super T> di=dest.listIterator();\n            ListIterator<? extends T> si=src.listIterator();\n            for (int i=0; i<srcSize; i++) {\n                di.next();\n                di.set(si.next());\n            }\n        }\n    }\n\n    /*\n    *计算最小值，方法仍然是使用迭代器\n    */\n    public static <T extends Object & Comparable<? super T>> T min(Collection<? extends T> coll) {\n        Iterator<? extends T> i = coll.iterator();\n        T candidate = i.next();\n\n        while (i.hasNext()) {\n            T next = i.next();\n            if (next.compareTo(candidate) < 0)\n                candidate = next;\n        }\n        return candidate;\n    }\n\n    /*\n    *计算最小值的多态方法，添加了一个比较器\n    */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public static <T> T min(Collection<? extends T> coll, Comparator<? super T> comp) {\n        if (comp==null)\n            return (T)min((Collection) coll);\n\n        Iterator<? extends T> i = coll.iterator();\n        T candidate = i.next();\n\n        while (i.hasNext()) {\n            T next = i.next();\n            if (comp.compare(next, candidate) < 0)\n                candidate = next;\n        }\n        return candidate;\n    }\n\n    /*\n    *计算最大值\n    */\n    public static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll) {\n        Iterator<? extends T> i = coll.iterator();\n        T candidate = i.next();\n\n        while (i.hasNext()) {\n            T next = i.next();\n            if (next.compareTo(candidate) > 0)\n                candidate = next;\n        }\n        return candidate;\n    }\n\n    /*\n    *通过比较器计算最大值\n    */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public static <T> T max(Collection<? extends T> coll, Comparator<? super T> comp) {\n        if (comp==null)\n            return (T)max((Collection) coll);\n\n        Iterator<? extends T> i = coll.iterator();\n        T candidate = i.next();\n\n        while (i.hasNext()) {\n            T next = i.next();\n            if (comp.compare(next, candidate) > 0)\n                candidate = next;\n        }\n        return candidate;\n    }\n\n    /*\n    *旋转操作，通过distance来计算\n    */\n    public static void rotate(List<?> list, int distance) {\n        if (list instanceof RandomAccess || list.size() < ROTATE_THRESHOLD)\n            rotate1(list, distance);\n        else\n            rotate2(list, distance);\n    }\n\n    /*\n    *使用新值，替换list中原有的旧值\n    */\n    public static <T> boolean replaceAll(List<T> list, T oldVal, T newVal) {\n        boolean result = false;\n        int size = list.size();\n        if (size < REPLACEALL_THRESHOLD || list instanceof RandomAccess) {\n            if (oldVal==null) {\n                for (int i=0; i<size; i++) {\n                    if (list.get(i)==null) {\n                        list.set(i, newVal);\n                        result = true;\n                    }\n                }\n            } else {\n                for (int i=0; i<size; i++) {\n                    if (oldVal.equals(list.get(i))) {\n                        list.set(i, newVal);\n                        result = true;\n                    }\n                }\n            }\n        } else {\n            ListIterator<T> itr=list.listIterator();\n            if (oldVal==null) {\n                for (int i=0; i<size; i++) {\n                    if (itr.next()==null) {\n                        itr.set(newVal);\n                        result = true;\n                    }\n                }\n            } else {\n                for (int i=0; i<size; i++) {\n                    if (oldVal.equals(itr.next())) {\n                        itr.set(newVal);\n                        result = true;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n}\n```\n\n","slug":"Collection","published":1,"updated":"2019-03-12T09:26:33.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5lttzz00693a8k8o6g41hz","content":"<p>面试的时候问到了Collection和Collections的差别。当时有个浅薄的印象是Collection好像是个接口类，而Collections是个实体类。<br>回来翻书发现自己真是无知，回答的驴头不对马嘴。</p>\n<h1 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h1><p>java.util.Collection是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在java库中有很多基本的实现。</p>\n<p>Collection接口最大的意义是为了各种具体的集合提供最大化的统一操作方式，其直接继承接口有List和set等等。</p>\n<p><img src=\"/images/数据结构/Java集合框架.jpg\" alt=\"Collection子类\"></p>\n<h2 id=\"Collection源码解析\"><a href=\"#Collection源码解析\" class=\"headerlink\" title=\"Collection源码解析\"></a>Collection源码解析</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">*首先，继承了Iterable类，同时指定了范型</span><br><span class=\"line\">*/</span><br><span class=\"line\">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*返回集合中数组的元素数量</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tint size();</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*集合中没有元素就返回true</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tboolean isEmpty();</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*集合中有这个元素就返回true</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tboolean contains(Object o);</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*返回集合元素的迭代器</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tIterator&lt;E&gt; iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*返回一个包含集合中所有元素的数组，数组类型是object</span><br><span class=\"line\">\t*这个方法是数组和集合中的桥梁</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tObject[] toArray();</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*上个api的多态方法，将集合转为一个指定的数组，类型必须是运行中指定的类型</span><br><span class=\"line\">\t*倘若集合的元素数量小于数组，那么数组没有元素的空间会被设为null</span><br><span class=\"line\">\t*假如集合需要保证元素的顺序，则转换为数组时也需要保证相应的顺序</span><br><span class=\"line\">\t*例：String[] y = x.toArray(new String[0]);</span><br><span class=\"line\">\t*toArray(new Object[0])就等于toArray()</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\t&lt;T&gt; T[] toArray(T[] a);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;-- 以下是修改操作 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*首先要确保集合中没有该需要添加的元素</span><br><span class=\"line\">\t*返回true，当集合对这次请求进行了自己的改变</span><br><span class=\"line\">\t*返回false，当集合没有允许重复添加已有的元素</span><br><span class=\"line\">\t*假如一个集合拒绝添加一个元素，需要抛出异常而不是返回false</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tboolean add(E e);</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*从集合中移除一个存在的单一对象</span><br><span class=\"line\">\t*集合中如果拥有一个或多个该元素，将会移除一个或者其中的一个元素</span><br><span class=\"line\">\t*对该请求进行操作之后，的确拥有该元素（或者说有个元素和它equal），会移除该元素并且返回true</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tboolean remove(Object o);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;-- 以下是批量操作 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*假如集合中包含该指定集合的所有的元素，就返回true</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tboolean containsAll(Collection&lt;?&gt; c);</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*将指定集合中的所有元素添加到集合中</span><br><span class=\"line\">\t*该操作在操作进行中时是不明确的。因此表明了该操作在添加的集合就是自身时，其实是不明确的。</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tboolean addAll(Collection&lt;? extends E&gt; c);</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*移除指定集合和原有集合中同时拥有的元素，操作结束之后原有集合和指定集合将在无相同的元素</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tboolean removeAll(Collection&lt;?&gt; c);</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*只保存和指定集合共同拥有的元素，即是移除所有指定集合中不包含的元素。</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tboolean retainAll(Collection&lt;?&gt; c);</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*移除集合中所有的元素，集合在操作之后将为空</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tvoid clear();</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;-- 以下是比较和哈希 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*将制定的对象与集合进行平等性的比较</span><br><span class=\"line\">\t*</span><br><span class=\"line\">\t*当集合的接口没有添加类似equal的操作，程序员需要小心的复写Object.equal的操作。</span><br><span class=\"line\">\t*最简单的是直接依赖Object的接口</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tboolean equals(Object o);</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*返回集合的hash码，当集合的接口没有添hashcode的操作的时候，程序员需要注意任何类一旦复写了equal，也将复写hashcode，这是为了保证基础的对比。</span><br><span class=\"line\">\t*</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tint hashCode();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Collections\"><a href=\"#Collections\" class=\"headerlink\" title=\"Collections\"></a>Collections</h1><p>java.util.Collections则是一个包装类（工具类/帮助类），包含各种有关集合操作的静态多态方法。不能被实例化，就像一个工具类，用于对集合中元素进行排序、搜索和线程安全等各种操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Collections &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//构造函数私有化，目的是为了保证无法被构造</span><br><span class=\"line\">\tprivate Collections() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *sort排序</span><br><span class=\"line\">    */</span><br><span class=\"line\">    @SuppressWarnings(&quot;unchecked&quot;)//使用了范型，让编译器别做反应</span><br><span class=\"line\">    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123;</span><br><span class=\"line\">        if (list.getClass() == ArrayList.class) &#123;</span><br><span class=\"line\">            Arrays.sort(((ArrayList) list).elementData, 0, list.size());//arraylist直接使用Arrays的排序</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Object[] a = list.toArray();//不是arraylist，则将其转换为array，然后使用Arrays的排序</span><br><span class=\"line\">        Arrays.sort(a);</span><br><span class=\"line\">        /*</span><br><span class=\"line\">        *之后获取迭代器，通过迭代器进行参数的传递</span><br><span class=\"line\">        */</span><br><span class=\"line\">        ListIterator&lt;T&gt; i = list.listIterator();</span><br><span class=\"line\">        for (int j=0; j&lt;a.length; j++) &#123;</span><br><span class=\"line\">            i.next();</span><br><span class=\"line\">            i.set((T)a[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *sort排序的多态方法，加上一个比较器进行排序</span><br><span class=\"line\">    */</span><br><span class=\"line\">    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)//压制警告，即去除警告，rawtypes是说传参时也要传递带泛型的参数</span><br><span class=\"line\">    public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) &#123;</span><br><span class=\"line\">        if (list.getClass() == ArrayList.class) &#123;</span><br><span class=\"line\">            Arrays.sort(((ArrayList) list).elementData, 0, list.size(), (Comparator) c);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Object[] a = list.toArray();</span><br><span class=\"line\">        Arrays.sort(a, (Comparator)c);</span><br><span class=\"line\">        ListIterator&lt;T&gt; i = list.listIterator();</span><br><span class=\"line\">        for (int j=0; j&lt;a.length; j++) &#123;</span><br><span class=\"line\">            i.next();</span><br><span class=\"line\">            i.set((T)a[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        /*</span><br><span class=\"line\">        *仅仅是多加了一个比较器而已</span><br><span class=\"line\">        */</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *二分查找，在list实现randomaccess接口，或者大小小于5000时，使用索引二分查找，否则使用迭代器二分查找</span><br><span class=\"line\">    */</span><br><span class=\"line\">    public static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;</span><br><span class=\"line\">        if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class=\"line\">            return Collections.indexedBinarySearch(list, key);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            return Collections.iteratorBinarySearch(list, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *二分查找的多态方法，支持比较器</span><br><span class=\"line\">    */</span><br><span class=\"line\">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">    public static &lt;T&gt; int binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c) &#123;</span><br><span class=\"line\">        if (c==null)</span><br><span class=\"line\">            return binarySearch((List&lt;? extends Comparable&lt;? super T&gt;&gt;) list, key);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class=\"line\">            return Collections.indexedBinarySearch(list, key, c);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            return Collections.iteratorBinarySearch(list, key, c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *反转操作，数量小于18，或者实现randomaccess接口时，使用swap操作，否则使用迭代器进行反转替换</span><br><span class=\"line\">    */</span><br><span class=\"line\">    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span><br><span class=\"line\">    public static void reverse(List&lt;?&gt; list) &#123;</span><br><span class=\"line\">        int size = list.size();</span><br><span class=\"line\">        if (size &lt; REVERSE_THRESHOLD || list instanceof RandomAccess) &#123;</span><br><span class=\"line\">            for (int i=0, mid=size&gt;&gt;1, j=size-1; i&lt;mid; i++, j--)</span><br><span class=\"line\">                swap(list, i, j);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // instead of using a raw type here, it&apos;s possible to capture</span><br><span class=\"line\">            // the wildcard but it will require a call to a supplementary</span><br><span class=\"line\">            // private method</span><br><span class=\"line\">            ListIterator fwd = list.listIterator();</span><br><span class=\"line\">            ListIterator rev = list.listIterator(size);</span><br><span class=\"line\">            for (int i=0, mid=list.size()&gt;&gt;1; i&lt;mid; i++) &#123;</span><br><span class=\"line\">                Object tmp = fwd.next();</span><br><span class=\"line\">                fwd.set(rev.previous());</span><br><span class=\"line\">                rev.set(tmp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *洗牌操作</span><br><span class=\"line\">    */</span><br><span class=\"line\">    public static void shuffle(List&lt;?&gt; list) &#123;</span><br><span class=\"line\">        Random rnd = r;</span><br><span class=\"line\">        if (rnd == null)</span><br><span class=\"line\">            r = rnd = new Random(); // harmless race.</span><br><span class=\"line\">        shuffle(list, rnd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span><br><span class=\"line\">    public static void shuffle(List&lt;?&gt; list, Random rnd) &#123;</span><br><span class=\"line\">        int size = list.size();</span><br><span class=\"line\">        if (size &lt; SHUFFLE_THRESHOLD || list instanceof RandomAccess) &#123;</span><br><span class=\"line\">            for (int i=size; i&gt;1; i--)</span><br><span class=\"line\">                swap(list, i-1, rnd.nextInt(i));</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            Object arr[] = list.toArray();</span><br><span class=\"line\"></span><br><span class=\"line\">            // Shuffle array</span><br><span class=\"line\">            for (int i=size; i&gt;1; i--)</span><br><span class=\"line\">                swap(arr, i-1, rnd.nextInt(i));</span><br><span class=\"line\"></span><br><span class=\"line\">            // Dump array back into list</span><br><span class=\"line\">            // instead of using a raw type here, it&apos;s possible to capture</span><br><span class=\"line\">            // the wildcard but it will require a call to a supplementary</span><br><span class=\"line\">            // private method</span><br><span class=\"line\">            ListIterator it = list.listIterator();</span><br><span class=\"line\">            for (int i=0; i&lt;arr.length; i++) &#123;</span><br><span class=\"line\">                it.next();</span><br><span class=\"line\">                it.set(arr[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *交换操作</span><br><span class=\"line\">    */</span><br><span class=\"line\">    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span><br><span class=\"line\">    public static void swap(List&lt;?&gt; list, int i, int j) &#123;</span><br><span class=\"line\">        // instead of using a raw type here, it&apos;s possible to capture</span><br><span class=\"line\">        // the wildcard but it will require a call to a supplementary</span><br><span class=\"line\">        // private method</span><br><span class=\"line\">        final List l = list;</span><br><span class=\"line\">        l.set(i, l.set(j, l.get(i)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *填满操作，将list填充成全是obj的list</span><br><span class=\"line\">    */</span><br><span class=\"line\">    public static &lt;T&gt; void fill(List&lt;? super T&gt; list, T obj) &#123;</span><br><span class=\"line\">        int size = list.size();</span><br><span class=\"line\"></span><br><span class=\"line\">        if (size &lt; FILL_THRESHOLD || list instanceof RandomAccess) &#123;</span><br><span class=\"line\">            for (int i=0; i&lt;size; i++)</span><br><span class=\"line\">                list.set(i, obj);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            ListIterator&lt;? super T&gt; itr = list.listIterator();</span><br><span class=\"line\">            for (int i=0; i&lt;size; i++) &#123;</span><br><span class=\"line\">                itr.next();</span><br><span class=\"line\">                itr.set(obj);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *复制操作，结束后dest的内容将和src的内容完全一样，不过有两点，一个是dest的长度要不小于src的长度，另一个是dest的长度大于src时，dest中多余的元素将不受影响</span><br><span class=\"line\">    */</span><br><span class=\"line\">    public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123;</span><br><span class=\"line\">        int srcSize = src.size();</span><br><span class=\"line\">        if (srcSize &gt; dest.size())</span><br><span class=\"line\">            throw new IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (srcSize &lt; COPY_THRESHOLD ||</span><br><span class=\"line\">            (src instanceof RandomAccess &amp;&amp; dest instanceof RandomAccess)) &#123;</span><br><span class=\"line\">            for (int i=0; i&lt;srcSize; i++)</span><br><span class=\"line\">                dest.set(i, src.get(i));</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            ListIterator&lt;? super T&gt; di=dest.listIterator();</span><br><span class=\"line\">            ListIterator&lt;? extends T&gt; si=src.listIterator();</span><br><span class=\"line\">            for (int i=0; i&lt;srcSize; i++) &#123;</span><br><span class=\"line\">                di.next();</span><br><span class=\"line\">                di.set(si.next());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *计算最小值，方法仍然是使用迭代器</span><br><span class=\"line\">    */</span><br><span class=\"line\">    public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T min(Collection&lt;? extends T&gt; coll) &#123;</span><br><span class=\"line\">        Iterator&lt;? extends T&gt; i = coll.iterator();</span><br><span class=\"line\">        T candidate = i.next();</span><br><span class=\"line\"></span><br><span class=\"line\">        while (i.hasNext()) &#123;</span><br><span class=\"line\">            T next = i.next();</span><br><span class=\"line\">            if (next.compareTo(candidate) &lt; 0)</span><br><span class=\"line\">                candidate = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return candidate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *计算最小值的多态方法，添加了一个比较器</span><br><span class=\"line\">    */</span><br><span class=\"line\">    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span><br><span class=\"line\">    public static &lt;T&gt; T min(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp) &#123;</span><br><span class=\"line\">        if (comp==null)</span><br><span class=\"line\">            return (T)min((Collection) coll);</span><br><span class=\"line\"></span><br><span class=\"line\">        Iterator&lt;? extends T&gt; i = coll.iterator();</span><br><span class=\"line\">        T candidate = i.next();</span><br><span class=\"line\"></span><br><span class=\"line\">        while (i.hasNext()) &#123;</span><br><span class=\"line\">            T next = i.next();</span><br><span class=\"line\">            if (comp.compare(next, candidate) &lt; 0)</span><br><span class=\"line\">                candidate = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return candidate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *计算最大值</span><br><span class=\"line\">    */</span><br><span class=\"line\">    public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll) &#123;</span><br><span class=\"line\">        Iterator&lt;? extends T&gt; i = coll.iterator();</span><br><span class=\"line\">        T candidate = i.next();</span><br><span class=\"line\"></span><br><span class=\"line\">        while (i.hasNext()) &#123;</span><br><span class=\"line\">            T next = i.next();</span><br><span class=\"line\">            if (next.compareTo(candidate) &gt; 0)</span><br><span class=\"line\">                candidate = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return candidate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *通过比较器计算最大值</span><br><span class=\"line\">    */</span><br><span class=\"line\">    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span><br><span class=\"line\">    public static &lt;T&gt; T max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp) &#123;</span><br><span class=\"line\">        if (comp==null)</span><br><span class=\"line\">            return (T)max((Collection) coll);</span><br><span class=\"line\"></span><br><span class=\"line\">        Iterator&lt;? extends T&gt; i = coll.iterator();</span><br><span class=\"line\">        T candidate = i.next();</span><br><span class=\"line\"></span><br><span class=\"line\">        while (i.hasNext()) &#123;</span><br><span class=\"line\">            T next = i.next();</span><br><span class=\"line\">            if (comp.compare(next, candidate) &gt; 0)</span><br><span class=\"line\">                candidate = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return candidate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *旋转操作，通过distance来计算</span><br><span class=\"line\">    */</span><br><span class=\"line\">    public static void rotate(List&lt;?&gt; list, int distance) &#123;</span><br><span class=\"line\">        if (list instanceof RandomAccess || list.size() &lt; ROTATE_THRESHOLD)</span><br><span class=\"line\">            rotate1(list, distance);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            rotate2(list, distance);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *使用新值，替换list中原有的旧值</span><br><span class=\"line\">    */</span><br><span class=\"line\">    public static &lt;T&gt; boolean replaceAll(List&lt;T&gt; list, T oldVal, T newVal) &#123;</span><br><span class=\"line\">        boolean result = false;</span><br><span class=\"line\">        int size = list.size();</span><br><span class=\"line\">        if (size &lt; REPLACEALL_THRESHOLD || list instanceof RandomAccess) &#123;</span><br><span class=\"line\">            if (oldVal==null) &#123;</span><br><span class=\"line\">                for (int i=0; i&lt;size; i++) &#123;</span><br><span class=\"line\">                    if (list.get(i)==null) &#123;</span><br><span class=\"line\">                        list.set(i, newVal);</span><br><span class=\"line\">                        result = true;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                for (int i=0; i&lt;size; i++) &#123;</span><br><span class=\"line\">                    if (oldVal.equals(list.get(i))) &#123;</span><br><span class=\"line\">                        list.set(i, newVal);</span><br><span class=\"line\">                        result = true;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            ListIterator&lt;T&gt; itr=list.listIterator();</span><br><span class=\"line\">            if (oldVal==null) &#123;</span><br><span class=\"line\">                for (int i=0; i&lt;size; i++) &#123;</span><br><span class=\"line\">                    if (itr.next()==null) &#123;</span><br><span class=\"line\">                        itr.set(newVal);</span><br><span class=\"line\">                        result = true;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                for (int i=0; i&lt;size; i++) &#123;</span><br><span class=\"line\">                    if (oldVal.equals(itr.next())) &#123;</span><br><span class=\"line\">                        itr.set(newVal);</span><br><span class=\"line\">                        result = true;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>面试的时候问到了Collection和Collections的差别。当时有个浅薄的印象是Collection好像是个接口类，而Collections是个实体类。<br>回来翻书发现自己真是无知，回答的驴头不对马嘴。</p>\n<h1 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h1><p>java.util.Collection是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在java库中有很多基本的实现。</p>\n<p>Collection接口最大的意义是为了各种具体的集合提供最大化的统一操作方式，其直接继承接口有List和set等等。</p>\n<p><img src=\"/images/数据结构/Java集合框架.jpg\" alt=\"Collection子类\"></p>\n<h2 id=\"Collection源码解析\"><a href=\"#Collection源码解析\" class=\"headerlink\" title=\"Collection源码解析\"></a>Collection源码解析</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">*首先，继承了Iterable类，同时指定了范型</span><br><span class=\"line\">*/</span><br><span class=\"line\">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*返回集合中数组的元素数量</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tint size();</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*集合中没有元素就返回true</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tboolean isEmpty();</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*集合中有这个元素就返回true</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tboolean contains(Object o);</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*返回集合元素的迭代器</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tIterator&lt;E&gt; iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*返回一个包含集合中所有元素的数组，数组类型是object</span><br><span class=\"line\">\t*这个方法是数组和集合中的桥梁</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tObject[] toArray();</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*上个api的多态方法，将集合转为一个指定的数组，类型必须是运行中指定的类型</span><br><span class=\"line\">\t*倘若集合的元素数量小于数组，那么数组没有元素的空间会被设为null</span><br><span class=\"line\">\t*假如集合需要保证元素的顺序，则转换为数组时也需要保证相应的顺序</span><br><span class=\"line\">\t*例：String[] y = x.toArray(new String[0]);</span><br><span class=\"line\">\t*toArray(new Object[0])就等于toArray()</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\t&lt;T&gt; T[] toArray(T[] a);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;-- 以下是修改操作 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*首先要确保集合中没有该需要添加的元素</span><br><span class=\"line\">\t*返回true，当集合对这次请求进行了自己的改变</span><br><span class=\"line\">\t*返回false，当集合没有允许重复添加已有的元素</span><br><span class=\"line\">\t*假如一个集合拒绝添加一个元素，需要抛出异常而不是返回false</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tboolean add(E e);</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*从集合中移除一个存在的单一对象</span><br><span class=\"line\">\t*集合中如果拥有一个或多个该元素，将会移除一个或者其中的一个元素</span><br><span class=\"line\">\t*对该请求进行操作之后，的确拥有该元素（或者说有个元素和它equal），会移除该元素并且返回true</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tboolean remove(Object o);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;-- 以下是批量操作 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*假如集合中包含该指定集合的所有的元素，就返回true</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tboolean containsAll(Collection&lt;?&gt; c);</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*将指定集合中的所有元素添加到集合中</span><br><span class=\"line\">\t*该操作在操作进行中时是不明确的。因此表明了该操作在添加的集合就是自身时，其实是不明确的。</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tboolean addAll(Collection&lt;? extends E&gt; c);</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*移除指定集合和原有集合中同时拥有的元素，操作结束之后原有集合和指定集合将在无相同的元素</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tboolean removeAll(Collection&lt;?&gt; c);</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*只保存和指定集合共同拥有的元素，即是移除所有指定集合中不包含的元素。</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tboolean retainAll(Collection&lt;?&gt; c);</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*移除集合中所有的元素，集合在操作之后将为空</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tvoid clear();</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;-- 以下是比较和哈希 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*将制定的对象与集合进行平等性的比较</span><br><span class=\"line\">\t*</span><br><span class=\"line\">\t*当集合的接口没有添加类似equal的操作，程序员需要小心的复写Object.equal的操作。</span><br><span class=\"line\">\t*最简单的是直接依赖Object的接口</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tboolean equals(Object o);</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t*返回集合的hash码，当集合的接口没有添hashcode的操作的时候，程序员需要注意任何类一旦复写了equal，也将复写hashcode，这是为了保证基础的对比。</span><br><span class=\"line\">\t*</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tint hashCode();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Collections\"><a href=\"#Collections\" class=\"headerlink\" title=\"Collections\"></a>Collections</h1><p>java.util.Collections则是一个包装类（工具类/帮助类），包含各种有关集合操作的静态多态方法。不能被实例化，就像一个工具类，用于对集合中元素进行排序、搜索和线程安全等各种操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Collections &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//构造函数私有化，目的是为了保证无法被构造</span><br><span class=\"line\">\tprivate Collections() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *sort排序</span><br><span class=\"line\">    */</span><br><span class=\"line\">    @SuppressWarnings(&quot;unchecked&quot;)//使用了范型，让编译器别做反应</span><br><span class=\"line\">    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123;</span><br><span class=\"line\">        if (list.getClass() == ArrayList.class) &#123;</span><br><span class=\"line\">            Arrays.sort(((ArrayList) list).elementData, 0, list.size());//arraylist直接使用Arrays的排序</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Object[] a = list.toArray();//不是arraylist，则将其转换为array，然后使用Arrays的排序</span><br><span class=\"line\">        Arrays.sort(a);</span><br><span class=\"line\">        /*</span><br><span class=\"line\">        *之后获取迭代器，通过迭代器进行参数的传递</span><br><span class=\"line\">        */</span><br><span class=\"line\">        ListIterator&lt;T&gt; i = list.listIterator();</span><br><span class=\"line\">        for (int j=0; j&lt;a.length; j++) &#123;</span><br><span class=\"line\">            i.next();</span><br><span class=\"line\">            i.set((T)a[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *sort排序的多态方法，加上一个比较器进行排序</span><br><span class=\"line\">    */</span><br><span class=\"line\">    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)//压制警告，即去除警告，rawtypes是说传参时也要传递带泛型的参数</span><br><span class=\"line\">    public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) &#123;</span><br><span class=\"line\">        if (list.getClass() == ArrayList.class) &#123;</span><br><span class=\"line\">            Arrays.sort(((ArrayList) list).elementData, 0, list.size(), (Comparator) c);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Object[] a = list.toArray();</span><br><span class=\"line\">        Arrays.sort(a, (Comparator)c);</span><br><span class=\"line\">        ListIterator&lt;T&gt; i = list.listIterator();</span><br><span class=\"line\">        for (int j=0; j&lt;a.length; j++) &#123;</span><br><span class=\"line\">            i.next();</span><br><span class=\"line\">            i.set((T)a[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        /*</span><br><span class=\"line\">        *仅仅是多加了一个比较器而已</span><br><span class=\"line\">        */</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *二分查找，在list实现randomaccess接口，或者大小小于5000时，使用索引二分查找，否则使用迭代器二分查找</span><br><span class=\"line\">    */</span><br><span class=\"line\">    public static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;</span><br><span class=\"line\">        if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class=\"line\">            return Collections.indexedBinarySearch(list, key);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            return Collections.iteratorBinarySearch(list, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *二分查找的多态方法，支持比较器</span><br><span class=\"line\">    */</span><br><span class=\"line\">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">    public static &lt;T&gt; int binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c) &#123;</span><br><span class=\"line\">        if (c==null)</span><br><span class=\"line\">            return binarySearch((List&lt;? extends Comparable&lt;? super T&gt;&gt;) list, key);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class=\"line\">            return Collections.indexedBinarySearch(list, key, c);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            return Collections.iteratorBinarySearch(list, key, c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *反转操作，数量小于18，或者实现randomaccess接口时，使用swap操作，否则使用迭代器进行反转替换</span><br><span class=\"line\">    */</span><br><span class=\"line\">    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span><br><span class=\"line\">    public static void reverse(List&lt;?&gt; list) &#123;</span><br><span class=\"line\">        int size = list.size();</span><br><span class=\"line\">        if (size &lt; REVERSE_THRESHOLD || list instanceof RandomAccess) &#123;</span><br><span class=\"line\">            for (int i=0, mid=size&gt;&gt;1, j=size-1; i&lt;mid; i++, j--)</span><br><span class=\"line\">                swap(list, i, j);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // instead of using a raw type here, it&apos;s possible to capture</span><br><span class=\"line\">            // the wildcard but it will require a call to a supplementary</span><br><span class=\"line\">            // private method</span><br><span class=\"line\">            ListIterator fwd = list.listIterator();</span><br><span class=\"line\">            ListIterator rev = list.listIterator(size);</span><br><span class=\"line\">            for (int i=0, mid=list.size()&gt;&gt;1; i&lt;mid; i++) &#123;</span><br><span class=\"line\">                Object tmp = fwd.next();</span><br><span class=\"line\">                fwd.set(rev.previous());</span><br><span class=\"line\">                rev.set(tmp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *洗牌操作</span><br><span class=\"line\">    */</span><br><span class=\"line\">    public static void shuffle(List&lt;?&gt; list) &#123;</span><br><span class=\"line\">        Random rnd = r;</span><br><span class=\"line\">        if (rnd == null)</span><br><span class=\"line\">            r = rnd = new Random(); // harmless race.</span><br><span class=\"line\">        shuffle(list, rnd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span><br><span class=\"line\">    public static void shuffle(List&lt;?&gt; list, Random rnd) &#123;</span><br><span class=\"line\">        int size = list.size();</span><br><span class=\"line\">        if (size &lt; SHUFFLE_THRESHOLD || list instanceof RandomAccess) &#123;</span><br><span class=\"line\">            for (int i=size; i&gt;1; i--)</span><br><span class=\"line\">                swap(list, i-1, rnd.nextInt(i));</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            Object arr[] = list.toArray();</span><br><span class=\"line\"></span><br><span class=\"line\">            // Shuffle array</span><br><span class=\"line\">            for (int i=size; i&gt;1; i--)</span><br><span class=\"line\">                swap(arr, i-1, rnd.nextInt(i));</span><br><span class=\"line\"></span><br><span class=\"line\">            // Dump array back into list</span><br><span class=\"line\">            // instead of using a raw type here, it&apos;s possible to capture</span><br><span class=\"line\">            // the wildcard but it will require a call to a supplementary</span><br><span class=\"line\">            // private method</span><br><span class=\"line\">            ListIterator it = list.listIterator();</span><br><span class=\"line\">            for (int i=0; i&lt;arr.length; i++) &#123;</span><br><span class=\"line\">                it.next();</span><br><span class=\"line\">                it.set(arr[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *交换操作</span><br><span class=\"line\">    */</span><br><span class=\"line\">    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span><br><span class=\"line\">    public static void swap(List&lt;?&gt; list, int i, int j) &#123;</span><br><span class=\"line\">        // instead of using a raw type here, it&apos;s possible to capture</span><br><span class=\"line\">        // the wildcard but it will require a call to a supplementary</span><br><span class=\"line\">        // private method</span><br><span class=\"line\">        final List l = list;</span><br><span class=\"line\">        l.set(i, l.set(j, l.get(i)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *填满操作，将list填充成全是obj的list</span><br><span class=\"line\">    */</span><br><span class=\"line\">    public static &lt;T&gt; void fill(List&lt;? super T&gt; list, T obj) &#123;</span><br><span class=\"line\">        int size = list.size();</span><br><span class=\"line\"></span><br><span class=\"line\">        if (size &lt; FILL_THRESHOLD || list instanceof RandomAccess) &#123;</span><br><span class=\"line\">            for (int i=0; i&lt;size; i++)</span><br><span class=\"line\">                list.set(i, obj);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            ListIterator&lt;? super T&gt; itr = list.listIterator();</span><br><span class=\"line\">            for (int i=0; i&lt;size; i++) &#123;</span><br><span class=\"line\">                itr.next();</span><br><span class=\"line\">                itr.set(obj);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *复制操作，结束后dest的内容将和src的内容完全一样，不过有两点，一个是dest的长度要不小于src的长度，另一个是dest的长度大于src时，dest中多余的元素将不受影响</span><br><span class=\"line\">    */</span><br><span class=\"line\">    public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123;</span><br><span class=\"line\">        int srcSize = src.size();</span><br><span class=\"line\">        if (srcSize &gt; dest.size())</span><br><span class=\"line\">            throw new IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (srcSize &lt; COPY_THRESHOLD ||</span><br><span class=\"line\">            (src instanceof RandomAccess &amp;&amp; dest instanceof RandomAccess)) &#123;</span><br><span class=\"line\">            for (int i=0; i&lt;srcSize; i++)</span><br><span class=\"line\">                dest.set(i, src.get(i));</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            ListIterator&lt;? super T&gt; di=dest.listIterator();</span><br><span class=\"line\">            ListIterator&lt;? extends T&gt; si=src.listIterator();</span><br><span class=\"line\">            for (int i=0; i&lt;srcSize; i++) &#123;</span><br><span class=\"line\">                di.next();</span><br><span class=\"line\">                di.set(si.next());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *计算最小值，方法仍然是使用迭代器</span><br><span class=\"line\">    */</span><br><span class=\"line\">    public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T min(Collection&lt;? extends T&gt; coll) &#123;</span><br><span class=\"line\">        Iterator&lt;? extends T&gt; i = coll.iterator();</span><br><span class=\"line\">        T candidate = i.next();</span><br><span class=\"line\"></span><br><span class=\"line\">        while (i.hasNext()) &#123;</span><br><span class=\"line\">            T next = i.next();</span><br><span class=\"line\">            if (next.compareTo(candidate) &lt; 0)</span><br><span class=\"line\">                candidate = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return candidate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *计算最小值的多态方法，添加了一个比较器</span><br><span class=\"line\">    */</span><br><span class=\"line\">    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span><br><span class=\"line\">    public static &lt;T&gt; T min(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp) &#123;</span><br><span class=\"line\">        if (comp==null)</span><br><span class=\"line\">            return (T)min((Collection) coll);</span><br><span class=\"line\"></span><br><span class=\"line\">        Iterator&lt;? extends T&gt; i = coll.iterator();</span><br><span class=\"line\">        T candidate = i.next();</span><br><span class=\"line\"></span><br><span class=\"line\">        while (i.hasNext()) &#123;</span><br><span class=\"line\">            T next = i.next();</span><br><span class=\"line\">            if (comp.compare(next, candidate) &lt; 0)</span><br><span class=\"line\">                candidate = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return candidate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *计算最大值</span><br><span class=\"line\">    */</span><br><span class=\"line\">    public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll) &#123;</span><br><span class=\"line\">        Iterator&lt;? extends T&gt; i = coll.iterator();</span><br><span class=\"line\">        T candidate = i.next();</span><br><span class=\"line\"></span><br><span class=\"line\">        while (i.hasNext()) &#123;</span><br><span class=\"line\">            T next = i.next();</span><br><span class=\"line\">            if (next.compareTo(candidate) &gt; 0)</span><br><span class=\"line\">                candidate = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return candidate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *通过比较器计算最大值</span><br><span class=\"line\">    */</span><br><span class=\"line\">    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span><br><span class=\"line\">    public static &lt;T&gt; T max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp) &#123;</span><br><span class=\"line\">        if (comp==null)</span><br><span class=\"line\">            return (T)max((Collection) coll);</span><br><span class=\"line\"></span><br><span class=\"line\">        Iterator&lt;? extends T&gt; i = coll.iterator();</span><br><span class=\"line\">        T candidate = i.next();</span><br><span class=\"line\"></span><br><span class=\"line\">        while (i.hasNext()) &#123;</span><br><span class=\"line\">            T next = i.next();</span><br><span class=\"line\">            if (comp.compare(next, candidate) &gt; 0)</span><br><span class=\"line\">                candidate = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return candidate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *旋转操作，通过distance来计算</span><br><span class=\"line\">    */</span><br><span class=\"line\">    public static void rotate(List&lt;?&gt; list, int distance) &#123;</span><br><span class=\"line\">        if (list instanceof RandomAccess || list.size() &lt; ROTATE_THRESHOLD)</span><br><span class=\"line\">            rotate1(list, distance);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            rotate2(list, distance);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *使用新值，替换list中原有的旧值</span><br><span class=\"line\">    */</span><br><span class=\"line\">    public static &lt;T&gt; boolean replaceAll(List&lt;T&gt; list, T oldVal, T newVal) &#123;</span><br><span class=\"line\">        boolean result = false;</span><br><span class=\"line\">        int size = list.size();</span><br><span class=\"line\">        if (size &lt; REPLACEALL_THRESHOLD || list instanceof RandomAccess) &#123;</span><br><span class=\"line\">            if (oldVal==null) &#123;</span><br><span class=\"line\">                for (int i=0; i&lt;size; i++) &#123;</span><br><span class=\"line\">                    if (list.get(i)==null) &#123;</span><br><span class=\"line\">                        list.set(i, newVal);</span><br><span class=\"line\">                        result = true;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                for (int i=0; i&lt;size; i++) &#123;</span><br><span class=\"line\">                    if (oldVal.equals(list.get(i))) &#123;</span><br><span class=\"line\">                        list.set(i, newVal);</span><br><span class=\"line\">                        result = true;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            ListIterator&lt;T&gt; itr=list.listIterator();</span><br><span class=\"line\">            if (oldVal==null) &#123;</span><br><span class=\"line\">                for (int i=0; i&lt;size; i++) &#123;</span><br><span class=\"line\">                    if (itr.next()==null) &#123;</span><br><span class=\"line\">                        itr.set(newVal);</span><br><span class=\"line\">                        result = true;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                for (int i=0; i&lt;size; i++) &#123;</span><br><span class=\"line\">                    if (oldVal.equals(itr.next())) &#123;</span><br><span class=\"line\">                        itr.set(newVal);</span><br><span class=\"line\">                        result = true;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"android自动化打包脚本搭建","date":"2018-11-06T09:25:39.000Z","_content":"\n从之前分析学习安卓的打包流程，然后参考各式方案，再结合项目需求，定下了一套目前来讲比较好的打包方法。\n\n# 原理\n\n安卓打包流程如下\n![打包流程](/images/android/androidpackageimage.png)\n\n通过apkbuilder构建之后就形成了未签名的apk包，然后通过jarsinger进行签名之后，就会生成签名的apk包。\n\n换言之，在jarsinger签名之前的任何步骤，进行的操作，都需要重新经过apkbuilder，否则就不会生效，类似于R文件的生成，假如在apkbuilder之后重新想塞入一些资源，那么R文件是读不出来这些文件的。同时如果资源文件的错位，或许会导致之后索引产生一系列问题。最大的问题是，假如改了apkbuilder涉及的文件，会导致签名校验失败。\n\n因此只能通过不参与签名校验的文件进行操作，唯一可以改的就是META-INF目录。\n\n所以将需要放置的文件放到META-INF目录之后在进行对齐即可。\n\n# 项目变更\n\n由于市场的要求，我们的app在不同的平台上有不同的名字，比如在baidu上面，就是“好搭盒子”，而在小米和搜狗市场上面，叫“好搭盒子-穿衣搭配”，在其余的市场上面，叫\"好搭盒子-教你穿衣搭配\"。\n\n虽然看起来只是名字的改变，但是如果通过打包想法来讲，改名字需要改manifest，这样就会导致签名验证失败，因此无法通过manifest改名字。\n\n我的想法和行动是仍旧构建变体，分三个，一个是shortname变体，一个是middlename变体，另一个是longname变体，其实还有一种，是测试时候的dev变体（因为测试人员需要知道我给他的是debug包，通过名字知道是最直接的）\n\n因此通过输入渠道的变化，构造不同的变体，但是对于已有构建好的就不需要重复构建了。\n\n# 打包脚本\n\n```\n# coding=utf-8\nimport zipfile\nimport shutil\nimport os\nimport sys\nimport requests\nimport json\nimport urllib2\nimport subprocess\nimport pwd\nimport os\nimport re\n\nfindline = u\"(versionCode\\s+:.+)\"\nfindversion = u\"([0-9]+)\"\nfindversionname = u\"(?<= versionName      : \\\").+?(?=\\\")\"\ndepgradlefilepath = \"dependencies.gradle\"\nBRANCH = \"dev\"\n\n\ndef release(channelName):\n    channelName = channelName\n    print 'start build ' + channelName\n\n    apk = './app/build/outputs/apk/dev/release/app-dev-release.apk'\n    hasApk = os.path.exists(apk)\n    path = './release_apks/dev/'\n    clean_code = subprocess.check_call(\"./gradlew clean\", shell=True)\n    if clean_code != 0:\n        print \"clean failed\"\n        sys.exit()\n    if channelName == 'long':\n        apk = './app/build/outputs/apk/longname/release/app-longname-release.apk'\n        path = './release_apks/long/'\n        if os.path.exists(\"release_apks/long\"):\n            shutil.rmtree(\"release_apks/long\")\n        print \"delete exist release_apks/long success\"\n        os.mkdir(\"release_apks/long\")\n        assemble_release_code = subprocess.check_call(\"./gradlew assembleLongnameRelease\",\n                                                      shell=True)\n    elif channelName == 'short':\n        apk = './app/build/outputs/apk/shortname/release/app-shortname-release.apk'\n        path = './release_apks/short/'\n        if os.path.exists(\"release_apks/short\"):\n            shutil.rmtree(\"release_apks/short\")\n        print \"delete exist release_apks/short success\"\n        os.mkdir(\"release_apks/short\")\n        assemble_release_code = subprocess.check_call(\"./gradlew assembleShortnameRelease\",\n                                                      shell=True)\n    elif channelName == 'middle':\n        apk = './app/build/outputs/apk/middlename/release/app-middlename-release.apk'\n        path = './release_apks/middle/'\n        if os.path.exists(\"release_apks/middle\"):\n            shutil.rmtree(\"release_apks/middle\")\n        print \"delete exist release_apks/middle success\"\n        os.mkdir(\"release_apks/middle\")\n        assemble_release_code = subprocess.check_call(\"./gradlew assembleMiddlenameRelease\",\n                                                      shell=True)\n    else:\n        if os.path.exists(\"release_apks/dev\"):\n            shutil.rmtree(\"release_apks/dev\")\n        print \"delete exist release_apks/dev success\"\n        os.mkdir(\"release_apks/dev\")\n        assemble_release_code = subprocess.check_call(\"./gradlew assembleDevRelease\", shell=True)\n\n    if assemble_release_code != 0:\n        print \"assembleRelease failed\"\n        sys.exit()\n\n    emptyFile = 'xxx.txt'\n    f = open(emptyFile, 'w')\n    f.close()\n\n    if channelName == 'long':\n        with open('channelNameLong.txt', 'r') as f:\n            contens = f.read()\n        lines = contens.split('\\n')\n    elif channelName == 'short':\n        with open('channelNameShort.txt', 'r') as f:\n            contens = f.read()\n        lines = contens.split('\\n')\n    elif channelName == 'middle':\n        with open('channelNameMiddle.txt', 'r') as f:\n            contens = f.read()\n        lines = contens.split('\\n')\n    else:\n        with open('devChannel.txt', 'r') as f:\n            contens = f.read()\n        lines = contens.split('\\n')\n\n    if not os.path.exists(path):\n        os.mkdir(path)\n    else:\n        for f in os.listdir(path):\n            if not f.endswith('.gitignore'):\n                os.remove(path + f)\n\n    for line in lines:\n        print line\n        channel = 'channel_' + line\n        destfile = path + '%s.apk' % channel\n        shutil.copyfile(apk, destfile)\n        zipped = zipfile.ZipFile(destfile, 'a', zipfile.ZIP_DEFLATED)\n        channelFile = \"META-INF/{channelname}\".format(channelname=channel)\n        zipped.write(emptyFile, channelFile)\n        zipped.close()\n    os.remove('./xxx.txt')\n\n    for f in os.listdir(path):\n        if f.endswith('.apk'):\n            os.system('zipalign -f -v 4 ' + path + f + ' ' + path + 'temp-' + f)\n            os.remove(path + f)\n\n    for f in os.listdir(path):\n        if f.startswith('temp-'):\n            os.system('zipalign -f -v 4 ' + path + f + ' ' + path + f.replace('temp-', ''))\n            os.remove(path + f)\n\n\ndef versionCodePlusPlus(msg):\n    gitstash = subprocess.check_call(\"git stash\", shell=True)\n    if gitstash != 0:\n        print \"git stash fail\"\n        sys.exit()\n    print \"git stash success\"\n    gitcheckout = subprocess.check_call(\"git checkout \" + BRANCH, shell=True)\n    if gitcheckout != 0:\n        print \"git checkout dev fail\"\n        sys.exit()\n    print \"git checkout dev success\"\n    gitfetchall = subprocess.check_call(\"git fetch --all\", shell=True)\n    if gitfetchall != 0:\n        print \"git fetch all fail\"\n        sys.exit()\n    gitresetall = subprocess.check_call(\"git reset --hard origin/\" + BRANCH, shell=True)\n    if gitresetall != 0:\n        print \"git reset hard origin dev fail\"\n        sys.exit()\n    gitpull = subprocess.check_call(\"git pull\", shell=True)\n    if gitpull != 0:\n        print \"git pull fail\"\n        sys.exit()\n    print \"git pull success\"\n\n    originContent = open(depgradlefilepath).read()\n    originVersionCodeLine = re.search(findline, originContent).group(0)\n    originVersionCodeString = re.search(findversion, originVersionCodeLine).group(0)\n    versionname = re.search(findversionname, originContent).group(0)\n    originVersionCode = int(originVersionCodeString)\n    finalVersionCode = originVersionCode + 1\n    finalVersionCodeLine = \"versionCode      : \" + str(finalVersionCode) + \",\"\n    finalContent = originContent.replace(originVersionCodeLine, finalVersionCodeLine, 1)\n    open(depgradlefilepath, 'w').write(finalContent)\n    gitadd = subprocess.check_call(\"git add .\", shell=True)\n    if gitadd != 0:\n        print \"git add failed\"\n        sys.exit()\n    gitCommit = subprocess.check_call(\n        u\"git commit -m \\\"build/auto increase versionCode = \" + str(\n            finalVersionCode) + \",\" + msg + \"\\\"\",\n        shell=True)\n    if gitCommit != 0:\n        print \"gitCommit failed\"\n        sys.exit()\n    gitPush = subprocess.check_call(\n        \"git push origin \" + BRANCH, shell=True\n    )\n    if gitPush != 0:\n        print \"gitpush failed\"\n        sys.exit()\n\n    gitpull = subprocess.check_call(\"git pull\", shell=True)\n    if gitpull != 0:\n        print \"git pull fail\"\n        sys.exit()\n    print \"git pull success\"\n    return finalVersionCode, versionname\n\n\nif __name__ == '__main__':\n    if os.path.exists(\"release_apks\"):\n        shutil.rmtree(\"release_apks\")\n        print \"delete exist release_apks success\"\n    os.mkdir(\"release_apks\")\n\n    if os.path.exists(\"app/build\"):\n        shutil.rmtree(\"app/build\")\n    print \"delete exist release_apks success\"\n    channel = 'dev'\n    if len(sys.argv) >= 2:\n        channel = sys.argv[1]\n    versionCodePlusPlus(channel)\n    release(channel)\n\n```\n\n其中做了一个额外的动作，就是versioncode++这个操作，这个主要也是项目需要，每次build的包，需要有迹可溯，因此每次build都会使versioncode+1，并且进行提交。\n\n上面是打包的流程，还有个全渠道打包的执行文件就比较简单了\n\n```\n# coding=utf-8\nfrom release import release, versionCodePlusPlus,BRANCH,findline,findversion,findversionname,depgradlefilepath\nimport os\nimport shutil\nimport subprocess\n\n\nFLAVOR_FILE = 'all_channels.txt'\nif __name__ == '__main__':\n    if os.path.exists(\"release_apks\"):\n        shutil.rmtree(\"release_apks\")\n        print \"delete exist release_apks success\"\n    if os.path.exists(\"app/build\"):\n        shutil.rmtree(\"app/build\")\n    print \"delete exist release_apks success\"\n    os.mkdir(\"release_apks\")\n\n    versionCodePlusPlus('short')\n    release('short')\n    versionCodePlusPlus('middle')\n    release('middle')\n    versionCodePlusPlus('long')\n    release('long')\n\n```\n\n因为也不算涉及到公司机密，以上都是很常规的操作，留下来做个备注防止以后采坑","source":"_posts/android自动化打包脚本搭建.md","raw":"---\ntitle: android自动化打包脚本搭建\ndate: 2018-11-06 17:25:39\ntags: android\n---\n\n从之前分析学习安卓的打包流程，然后参考各式方案，再结合项目需求，定下了一套目前来讲比较好的打包方法。\n\n# 原理\n\n安卓打包流程如下\n![打包流程](/images/android/androidpackageimage.png)\n\n通过apkbuilder构建之后就形成了未签名的apk包，然后通过jarsinger进行签名之后，就会生成签名的apk包。\n\n换言之，在jarsinger签名之前的任何步骤，进行的操作，都需要重新经过apkbuilder，否则就不会生效，类似于R文件的生成，假如在apkbuilder之后重新想塞入一些资源，那么R文件是读不出来这些文件的。同时如果资源文件的错位，或许会导致之后索引产生一系列问题。最大的问题是，假如改了apkbuilder涉及的文件，会导致签名校验失败。\n\n因此只能通过不参与签名校验的文件进行操作，唯一可以改的就是META-INF目录。\n\n所以将需要放置的文件放到META-INF目录之后在进行对齐即可。\n\n# 项目变更\n\n由于市场的要求，我们的app在不同的平台上有不同的名字，比如在baidu上面，就是“好搭盒子”，而在小米和搜狗市场上面，叫“好搭盒子-穿衣搭配”，在其余的市场上面，叫\"好搭盒子-教你穿衣搭配\"。\n\n虽然看起来只是名字的改变，但是如果通过打包想法来讲，改名字需要改manifest，这样就会导致签名验证失败，因此无法通过manifest改名字。\n\n我的想法和行动是仍旧构建变体，分三个，一个是shortname变体，一个是middlename变体，另一个是longname变体，其实还有一种，是测试时候的dev变体（因为测试人员需要知道我给他的是debug包，通过名字知道是最直接的）\n\n因此通过输入渠道的变化，构造不同的变体，但是对于已有构建好的就不需要重复构建了。\n\n# 打包脚本\n\n```\n# coding=utf-8\nimport zipfile\nimport shutil\nimport os\nimport sys\nimport requests\nimport json\nimport urllib2\nimport subprocess\nimport pwd\nimport os\nimport re\n\nfindline = u\"(versionCode\\s+:.+)\"\nfindversion = u\"([0-9]+)\"\nfindversionname = u\"(?<= versionName      : \\\").+?(?=\\\")\"\ndepgradlefilepath = \"dependencies.gradle\"\nBRANCH = \"dev\"\n\n\ndef release(channelName):\n    channelName = channelName\n    print 'start build ' + channelName\n\n    apk = './app/build/outputs/apk/dev/release/app-dev-release.apk'\n    hasApk = os.path.exists(apk)\n    path = './release_apks/dev/'\n    clean_code = subprocess.check_call(\"./gradlew clean\", shell=True)\n    if clean_code != 0:\n        print \"clean failed\"\n        sys.exit()\n    if channelName == 'long':\n        apk = './app/build/outputs/apk/longname/release/app-longname-release.apk'\n        path = './release_apks/long/'\n        if os.path.exists(\"release_apks/long\"):\n            shutil.rmtree(\"release_apks/long\")\n        print \"delete exist release_apks/long success\"\n        os.mkdir(\"release_apks/long\")\n        assemble_release_code = subprocess.check_call(\"./gradlew assembleLongnameRelease\",\n                                                      shell=True)\n    elif channelName == 'short':\n        apk = './app/build/outputs/apk/shortname/release/app-shortname-release.apk'\n        path = './release_apks/short/'\n        if os.path.exists(\"release_apks/short\"):\n            shutil.rmtree(\"release_apks/short\")\n        print \"delete exist release_apks/short success\"\n        os.mkdir(\"release_apks/short\")\n        assemble_release_code = subprocess.check_call(\"./gradlew assembleShortnameRelease\",\n                                                      shell=True)\n    elif channelName == 'middle':\n        apk = './app/build/outputs/apk/middlename/release/app-middlename-release.apk'\n        path = './release_apks/middle/'\n        if os.path.exists(\"release_apks/middle\"):\n            shutil.rmtree(\"release_apks/middle\")\n        print \"delete exist release_apks/middle success\"\n        os.mkdir(\"release_apks/middle\")\n        assemble_release_code = subprocess.check_call(\"./gradlew assembleMiddlenameRelease\",\n                                                      shell=True)\n    else:\n        if os.path.exists(\"release_apks/dev\"):\n            shutil.rmtree(\"release_apks/dev\")\n        print \"delete exist release_apks/dev success\"\n        os.mkdir(\"release_apks/dev\")\n        assemble_release_code = subprocess.check_call(\"./gradlew assembleDevRelease\", shell=True)\n\n    if assemble_release_code != 0:\n        print \"assembleRelease failed\"\n        sys.exit()\n\n    emptyFile = 'xxx.txt'\n    f = open(emptyFile, 'w')\n    f.close()\n\n    if channelName == 'long':\n        with open('channelNameLong.txt', 'r') as f:\n            contens = f.read()\n        lines = contens.split('\\n')\n    elif channelName == 'short':\n        with open('channelNameShort.txt', 'r') as f:\n            contens = f.read()\n        lines = contens.split('\\n')\n    elif channelName == 'middle':\n        with open('channelNameMiddle.txt', 'r') as f:\n            contens = f.read()\n        lines = contens.split('\\n')\n    else:\n        with open('devChannel.txt', 'r') as f:\n            contens = f.read()\n        lines = contens.split('\\n')\n\n    if not os.path.exists(path):\n        os.mkdir(path)\n    else:\n        for f in os.listdir(path):\n            if not f.endswith('.gitignore'):\n                os.remove(path + f)\n\n    for line in lines:\n        print line\n        channel = 'channel_' + line\n        destfile = path + '%s.apk' % channel\n        shutil.copyfile(apk, destfile)\n        zipped = zipfile.ZipFile(destfile, 'a', zipfile.ZIP_DEFLATED)\n        channelFile = \"META-INF/{channelname}\".format(channelname=channel)\n        zipped.write(emptyFile, channelFile)\n        zipped.close()\n    os.remove('./xxx.txt')\n\n    for f in os.listdir(path):\n        if f.endswith('.apk'):\n            os.system('zipalign -f -v 4 ' + path + f + ' ' + path + 'temp-' + f)\n            os.remove(path + f)\n\n    for f in os.listdir(path):\n        if f.startswith('temp-'):\n            os.system('zipalign -f -v 4 ' + path + f + ' ' + path + f.replace('temp-', ''))\n            os.remove(path + f)\n\n\ndef versionCodePlusPlus(msg):\n    gitstash = subprocess.check_call(\"git stash\", shell=True)\n    if gitstash != 0:\n        print \"git stash fail\"\n        sys.exit()\n    print \"git stash success\"\n    gitcheckout = subprocess.check_call(\"git checkout \" + BRANCH, shell=True)\n    if gitcheckout != 0:\n        print \"git checkout dev fail\"\n        sys.exit()\n    print \"git checkout dev success\"\n    gitfetchall = subprocess.check_call(\"git fetch --all\", shell=True)\n    if gitfetchall != 0:\n        print \"git fetch all fail\"\n        sys.exit()\n    gitresetall = subprocess.check_call(\"git reset --hard origin/\" + BRANCH, shell=True)\n    if gitresetall != 0:\n        print \"git reset hard origin dev fail\"\n        sys.exit()\n    gitpull = subprocess.check_call(\"git pull\", shell=True)\n    if gitpull != 0:\n        print \"git pull fail\"\n        sys.exit()\n    print \"git pull success\"\n\n    originContent = open(depgradlefilepath).read()\n    originVersionCodeLine = re.search(findline, originContent).group(0)\n    originVersionCodeString = re.search(findversion, originVersionCodeLine).group(0)\n    versionname = re.search(findversionname, originContent).group(0)\n    originVersionCode = int(originVersionCodeString)\n    finalVersionCode = originVersionCode + 1\n    finalVersionCodeLine = \"versionCode      : \" + str(finalVersionCode) + \",\"\n    finalContent = originContent.replace(originVersionCodeLine, finalVersionCodeLine, 1)\n    open(depgradlefilepath, 'w').write(finalContent)\n    gitadd = subprocess.check_call(\"git add .\", shell=True)\n    if gitadd != 0:\n        print \"git add failed\"\n        sys.exit()\n    gitCommit = subprocess.check_call(\n        u\"git commit -m \\\"build/auto increase versionCode = \" + str(\n            finalVersionCode) + \",\" + msg + \"\\\"\",\n        shell=True)\n    if gitCommit != 0:\n        print \"gitCommit failed\"\n        sys.exit()\n    gitPush = subprocess.check_call(\n        \"git push origin \" + BRANCH, shell=True\n    )\n    if gitPush != 0:\n        print \"gitpush failed\"\n        sys.exit()\n\n    gitpull = subprocess.check_call(\"git pull\", shell=True)\n    if gitpull != 0:\n        print \"git pull fail\"\n        sys.exit()\n    print \"git pull success\"\n    return finalVersionCode, versionname\n\n\nif __name__ == '__main__':\n    if os.path.exists(\"release_apks\"):\n        shutil.rmtree(\"release_apks\")\n        print \"delete exist release_apks success\"\n    os.mkdir(\"release_apks\")\n\n    if os.path.exists(\"app/build\"):\n        shutil.rmtree(\"app/build\")\n    print \"delete exist release_apks success\"\n    channel = 'dev'\n    if len(sys.argv) >= 2:\n        channel = sys.argv[1]\n    versionCodePlusPlus(channel)\n    release(channel)\n\n```\n\n其中做了一个额外的动作，就是versioncode++这个操作，这个主要也是项目需要，每次build的包，需要有迹可溯，因此每次build都会使versioncode+1，并且进行提交。\n\n上面是打包的流程，还有个全渠道打包的执行文件就比较简单了\n\n```\n# coding=utf-8\nfrom release import release, versionCodePlusPlus,BRANCH,findline,findversion,findversionname,depgradlefilepath\nimport os\nimport shutil\nimport subprocess\n\n\nFLAVOR_FILE = 'all_channels.txt'\nif __name__ == '__main__':\n    if os.path.exists(\"release_apks\"):\n        shutil.rmtree(\"release_apks\")\n        print \"delete exist release_apks success\"\n    if os.path.exists(\"app/build\"):\n        shutil.rmtree(\"app/build\")\n    print \"delete exist release_apks success\"\n    os.mkdir(\"release_apks\")\n\n    versionCodePlusPlus('short')\n    release('short')\n    versionCodePlusPlus('middle')\n    release('middle')\n    versionCodePlusPlus('long')\n    release('long')\n\n```\n\n因为也不算涉及到公司机密，以上都是很常规的操作，留下来做个备注防止以后采坑","slug":"android自动化打包脚本搭建","published":1,"updated":"2019-03-12T09:26:33.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltu00006b3a8kvsa71kn6","content":"<p>从之前分析学习安卓的打包流程，然后参考各式方案，再结合项目需求，定下了一套目前来讲比较好的打包方法。</p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>安卓打包流程如下<br><img src=\"/images/android/androidpackageimage.png\" alt=\"打包流程\"></p>\n<p>通过apkbuilder构建之后就形成了未签名的apk包，然后通过jarsinger进行签名之后，就会生成签名的apk包。</p>\n<p>换言之，在jarsinger签名之前的任何步骤，进行的操作，都需要重新经过apkbuilder，否则就不会生效，类似于R文件的生成，假如在apkbuilder之后重新想塞入一些资源，那么R文件是读不出来这些文件的。同时如果资源文件的错位，或许会导致之后索引产生一系列问题。最大的问题是，假如改了apkbuilder涉及的文件，会导致签名校验失败。</p>\n<p>因此只能通过不参与签名校验的文件进行操作，唯一可以改的就是META-INF目录。</p>\n<p>所以将需要放置的文件放到META-INF目录之后在进行对齐即可。</p>\n<h1 id=\"项目变更\"><a href=\"#项目变更\" class=\"headerlink\" title=\"项目变更\"></a>项目变更</h1><p>由于市场的要求，我们的app在不同的平台上有不同的名字，比如在baidu上面，就是“好搭盒子”，而在小米和搜狗市场上面，叫“好搭盒子-穿衣搭配”，在其余的市场上面，叫”好搭盒子-教你穿衣搭配”。</p>\n<p>虽然看起来只是名字的改变，但是如果通过打包想法来讲，改名字需要改manifest，这样就会导致签名验证失败，因此无法通过manifest改名字。</p>\n<p>我的想法和行动是仍旧构建变体，分三个，一个是shortname变体，一个是middlename变体，另一个是longname变体，其实还有一种，是测试时候的dev变体（因为测试人员需要知道我给他的是debug包，通过名字知道是最直接的）</p>\n<p>因此通过输入渠道的变化，构造不同的变体，但是对于已有构建好的就不需要重复构建了。</p>\n<h1 id=\"打包脚本\"><a href=\"#打包脚本\" class=\"headerlink\" title=\"打包脚本\"></a>打包脚本</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># coding=utf-8</span><br><span class=\"line\">import zipfile</span><br><span class=\"line\">import shutil</span><br><span class=\"line\">import os</span><br><span class=\"line\">import sys</span><br><span class=\"line\">import requests</span><br><span class=\"line\">import json</span><br><span class=\"line\">import urllib2</span><br><span class=\"line\">import subprocess</span><br><span class=\"line\">import pwd</span><br><span class=\"line\">import os</span><br><span class=\"line\">import re</span><br><span class=\"line\"></span><br><span class=\"line\">findline = u&quot;(versionCode\\s+:.+)&quot;</span><br><span class=\"line\">findversion = u&quot;([0-9]+)&quot;</span><br><span class=\"line\">findversionname = u&quot;(?&lt;= versionName      : \\&quot;).+?(?=\\&quot;)&quot;</span><br><span class=\"line\">depgradlefilepath = &quot;dependencies.gradle&quot;</span><br><span class=\"line\">BRANCH = &quot;dev&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def release(channelName):</span><br><span class=\"line\">    channelName = channelName</span><br><span class=\"line\">    print &apos;start build &apos; + channelName</span><br><span class=\"line\"></span><br><span class=\"line\">    apk = &apos;./app/build/outputs/apk/dev/release/app-dev-release.apk&apos;</span><br><span class=\"line\">    hasApk = os.path.exists(apk)</span><br><span class=\"line\">    path = &apos;./release_apks/dev/&apos;</span><br><span class=\"line\">    clean_code = subprocess.check_call(&quot;./gradlew clean&quot;, shell=True)</span><br><span class=\"line\">    if clean_code != 0:</span><br><span class=\"line\">        print &quot;clean failed&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    if channelName == &apos;long&apos;:</span><br><span class=\"line\">        apk = &apos;./app/build/outputs/apk/longname/release/app-longname-release.apk&apos;</span><br><span class=\"line\">        path = &apos;./release_apks/long/&apos;</span><br><span class=\"line\">        if os.path.exists(&quot;release_apks/long&quot;):</span><br><span class=\"line\">            shutil.rmtree(&quot;release_apks/long&quot;)</span><br><span class=\"line\">        print &quot;delete exist release_apks/long success&quot;</span><br><span class=\"line\">        os.mkdir(&quot;release_apks/long&quot;)</span><br><span class=\"line\">        assemble_release_code = subprocess.check_call(&quot;./gradlew assembleLongnameRelease&quot;,</span><br><span class=\"line\">                                                      shell=True)</span><br><span class=\"line\">    elif channelName == &apos;short&apos;:</span><br><span class=\"line\">        apk = &apos;./app/build/outputs/apk/shortname/release/app-shortname-release.apk&apos;</span><br><span class=\"line\">        path = &apos;./release_apks/short/&apos;</span><br><span class=\"line\">        if os.path.exists(&quot;release_apks/short&quot;):</span><br><span class=\"line\">            shutil.rmtree(&quot;release_apks/short&quot;)</span><br><span class=\"line\">        print &quot;delete exist release_apks/short success&quot;</span><br><span class=\"line\">        os.mkdir(&quot;release_apks/short&quot;)</span><br><span class=\"line\">        assemble_release_code = subprocess.check_call(&quot;./gradlew assembleShortnameRelease&quot;,</span><br><span class=\"line\">                                                      shell=True)</span><br><span class=\"line\">    elif channelName == &apos;middle&apos;:</span><br><span class=\"line\">        apk = &apos;./app/build/outputs/apk/middlename/release/app-middlename-release.apk&apos;</span><br><span class=\"line\">        path = &apos;./release_apks/middle/&apos;</span><br><span class=\"line\">        if os.path.exists(&quot;release_apks/middle&quot;):</span><br><span class=\"line\">            shutil.rmtree(&quot;release_apks/middle&quot;)</span><br><span class=\"line\">        print &quot;delete exist release_apks/middle success&quot;</span><br><span class=\"line\">        os.mkdir(&quot;release_apks/middle&quot;)</span><br><span class=\"line\">        assemble_release_code = subprocess.check_call(&quot;./gradlew assembleMiddlenameRelease&quot;,</span><br><span class=\"line\">                                                      shell=True)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        if os.path.exists(&quot;release_apks/dev&quot;):</span><br><span class=\"line\">            shutil.rmtree(&quot;release_apks/dev&quot;)</span><br><span class=\"line\">        print &quot;delete exist release_apks/dev success&quot;</span><br><span class=\"line\">        os.mkdir(&quot;release_apks/dev&quot;)</span><br><span class=\"line\">        assemble_release_code = subprocess.check_call(&quot;./gradlew assembleDevRelease&quot;, shell=True)</span><br><span class=\"line\"></span><br><span class=\"line\">    if assemble_release_code != 0:</span><br><span class=\"line\">        print &quot;assembleRelease failed&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\"></span><br><span class=\"line\">    emptyFile = &apos;xxx.txt&apos;</span><br><span class=\"line\">    f = open(emptyFile, &apos;w&apos;)</span><br><span class=\"line\">    f.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    if channelName == &apos;long&apos;:</span><br><span class=\"line\">        with open(&apos;channelNameLong.txt&apos;, &apos;r&apos;) as f:</span><br><span class=\"line\">            contens = f.read()</span><br><span class=\"line\">        lines = contens.split(&apos;\\n&apos;)</span><br><span class=\"line\">    elif channelName == &apos;short&apos;:</span><br><span class=\"line\">        with open(&apos;channelNameShort.txt&apos;, &apos;r&apos;) as f:</span><br><span class=\"line\">            contens = f.read()</span><br><span class=\"line\">        lines = contens.split(&apos;\\n&apos;)</span><br><span class=\"line\">    elif channelName == &apos;middle&apos;:</span><br><span class=\"line\">        with open(&apos;channelNameMiddle.txt&apos;, &apos;r&apos;) as f:</span><br><span class=\"line\">            contens = f.read()</span><br><span class=\"line\">        lines = contens.split(&apos;\\n&apos;)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        with open(&apos;devChannel.txt&apos;, &apos;r&apos;) as f:</span><br><span class=\"line\">            contens = f.read()</span><br><span class=\"line\">        lines = contens.split(&apos;\\n&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    if not os.path.exists(path):</span><br><span class=\"line\">        os.mkdir(path)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        for f in os.listdir(path):</span><br><span class=\"line\">            if not f.endswith(&apos;.gitignore&apos;):</span><br><span class=\"line\">                os.remove(path + f)</span><br><span class=\"line\"></span><br><span class=\"line\">    for line in lines:</span><br><span class=\"line\">        print line</span><br><span class=\"line\">        channel = &apos;channel_&apos; + line</span><br><span class=\"line\">        destfile = path + &apos;%s.apk&apos; % channel</span><br><span class=\"line\">        shutil.copyfile(apk, destfile)</span><br><span class=\"line\">        zipped = zipfile.ZipFile(destfile, &apos;a&apos;, zipfile.ZIP_DEFLATED)</span><br><span class=\"line\">        channelFile = &quot;META-INF/&#123;channelname&#125;&quot;.format(channelname=channel)</span><br><span class=\"line\">        zipped.write(emptyFile, channelFile)</span><br><span class=\"line\">        zipped.close()</span><br><span class=\"line\">    os.remove(&apos;./xxx.txt&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    for f in os.listdir(path):</span><br><span class=\"line\">        if f.endswith(&apos;.apk&apos;):</span><br><span class=\"line\">            os.system(&apos;zipalign -f -v 4 &apos; + path + f + &apos; &apos; + path + &apos;temp-&apos; + f)</span><br><span class=\"line\">            os.remove(path + f)</span><br><span class=\"line\"></span><br><span class=\"line\">    for f in os.listdir(path):</span><br><span class=\"line\">        if f.startswith(&apos;temp-&apos;):</span><br><span class=\"line\">            os.system(&apos;zipalign -f -v 4 &apos; + path + f + &apos; &apos; + path + f.replace(&apos;temp-&apos;, &apos;&apos;))</span><br><span class=\"line\">            os.remove(path + f)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def versionCodePlusPlus(msg):</span><br><span class=\"line\">    gitstash = subprocess.check_call(&quot;git stash&quot;, shell=True)</span><br><span class=\"line\">    if gitstash != 0:</span><br><span class=\"line\">        print &quot;git stash fail&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    print &quot;git stash success&quot;</span><br><span class=\"line\">    gitcheckout = subprocess.check_call(&quot;git checkout &quot; + BRANCH, shell=True)</span><br><span class=\"line\">    if gitcheckout != 0:</span><br><span class=\"line\">        print &quot;git checkout dev fail&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    print &quot;git checkout dev success&quot;</span><br><span class=\"line\">    gitfetchall = subprocess.check_call(&quot;git fetch --all&quot;, shell=True)</span><br><span class=\"line\">    if gitfetchall != 0:</span><br><span class=\"line\">        print &quot;git fetch all fail&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    gitresetall = subprocess.check_call(&quot;git reset --hard origin/&quot; + BRANCH, shell=True)</span><br><span class=\"line\">    if gitresetall != 0:</span><br><span class=\"line\">        print &quot;git reset hard origin dev fail&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    gitpull = subprocess.check_call(&quot;git pull&quot;, shell=True)</span><br><span class=\"line\">    if gitpull != 0:</span><br><span class=\"line\">        print &quot;git pull fail&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    print &quot;git pull success&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    originContent = open(depgradlefilepath).read()</span><br><span class=\"line\">    originVersionCodeLine = re.search(findline, originContent).group(0)</span><br><span class=\"line\">    originVersionCodeString = re.search(findversion, originVersionCodeLine).group(0)</span><br><span class=\"line\">    versionname = re.search(findversionname, originContent).group(0)</span><br><span class=\"line\">    originVersionCode = int(originVersionCodeString)</span><br><span class=\"line\">    finalVersionCode = originVersionCode + 1</span><br><span class=\"line\">    finalVersionCodeLine = &quot;versionCode      : &quot; + str(finalVersionCode) + &quot;,&quot;</span><br><span class=\"line\">    finalContent = originContent.replace(originVersionCodeLine, finalVersionCodeLine, 1)</span><br><span class=\"line\">    open(depgradlefilepath, &apos;w&apos;).write(finalContent)</span><br><span class=\"line\">    gitadd = subprocess.check_call(&quot;git add .&quot;, shell=True)</span><br><span class=\"line\">    if gitadd != 0:</span><br><span class=\"line\">        print &quot;git add failed&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    gitCommit = subprocess.check_call(</span><br><span class=\"line\">        u&quot;git commit -m \\&quot;build/auto increase versionCode = &quot; + str(</span><br><span class=\"line\">            finalVersionCode) + &quot;,&quot; + msg + &quot;\\&quot;&quot;,</span><br><span class=\"line\">        shell=True)</span><br><span class=\"line\">    if gitCommit != 0:</span><br><span class=\"line\">        print &quot;gitCommit failed&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    gitPush = subprocess.check_call(</span><br><span class=\"line\">        &quot;git push origin &quot; + BRANCH, shell=True</span><br><span class=\"line\">    )</span><br><span class=\"line\">    if gitPush != 0:</span><br><span class=\"line\">        print &quot;gitpush failed&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\"></span><br><span class=\"line\">    gitpull = subprocess.check_call(&quot;git pull&quot;, shell=True)</span><br><span class=\"line\">    if gitpull != 0:</span><br><span class=\"line\">        print &quot;git pull fail&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    print &quot;git pull success&quot;</span><br><span class=\"line\">    return finalVersionCode, versionname</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    if os.path.exists(&quot;release_apks&quot;):</span><br><span class=\"line\">        shutil.rmtree(&quot;release_apks&quot;)</span><br><span class=\"line\">        print &quot;delete exist release_apks success&quot;</span><br><span class=\"line\">    os.mkdir(&quot;release_apks&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">    if os.path.exists(&quot;app/build&quot;):</span><br><span class=\"line\">        shutil.rmtree(&quot;app/build&quot;)</span><br><span class=\"line\">    print &quot;delete exist release_apks success&quot;</span><br><span class=\"line\">    channel = &apos;dev&apos;</span><br><span class=\"line\">    if len(sys.argv) &gt;= 2:</span><br><span class=\"line\">        channel = sys.argv[1]</span><br><span class=\"line\">    versionCodePlusPlus(channel)</span><br><span class=\"line\">    release(channel)</span><br></pre></td></tr></table></figure>\n<p>其中做了一个额外的动作，就是versioncode++这个操作，这个主要也是项目需要，每次build的包，需要有迹可溯，因此每次build都会使versioncode+1，并且进行提交。</p>\n<p>上面是打包的流程，还有个全渠道打包的执行文件就比较简单了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># coding=utf-8</span><br><span class=\"line\">from release import release, versionCodePlusPlus,BRANCH,findline,findversion,findversionname,depgradlefilepath</span><br><span class=\"line\">import os</span><br><span class=\"line\">import shutil</span><br><span class=\"line\">import subprocess</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">FLAVOR_FILE = &apos;all_channels.txt&apos;</span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    if os.path.exists(&quot;release_apks&quot;):</span><br><span class=\"line\">        shutil.rmtree(&quot;release_apks&quot;)</span><br><span class=\"line\">        print &quot;delete exist release_apks success&quot;</span><br><span class=\"line\">    if os.path.exists(&quot;app/build&quot;):</span><br><span class=\"line\">        shutil.rmtree(&quot;app/build&quot;)</span><br><span class=\"line\">    print &quot;delete exist release_apks success&quot;</span><br><span class=\"line\">    os.mkdir(&quot;release_apks&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">    versionCodePlusPlus(&apos;short&apos;)</span><br><span class=\"line\">    release(&apos;short&apos;)</span><br><span class=\"line\">    versionCodePlusPlus(&apos;middle&apos;)</span><br><span class=\"line\">    release(&apos;middle&apos;)</span><br><span class=\"line\">    versionCodePlusPlus(&apos;long&apos;)</span><br><span class=\"line\">    release(&apos;long&apos;)</span><br></pre></td></tr></table></figure>\n<p>因为也不算涉及到公司机密，以上都是很常规的操作，留下来做个备注防止以后采坑</p>\n","site":{"data":{}},"excerpt":"","more":"<p>从之前分析学习安卓的打包流程，然后参考各式方案，再结合项目需求，定下了一套目前来讲比较好的打包方法。</p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>安卓打包流程如下<br><img src=\"/images/android/androidpackageimage.png\" alt=\"打包流程\"></p>\n<p>通过apkbuilder构建之后就形成了未签名的apk包，然后通过jarsinger进行签名之后，就会生成签名的apk包。</p>\n<p>换言之，在jarsinger签名之前的任何步骤，进行的操作，都需要重新经过apkbuilder，否则就不会生效，类似于R文件的生成，假如在apkbuilder之后重新想塞入一些资源，那么R文件是读不出来这些文件的。同时如果资源文件的错位，或许会导致之后索引产生一系列问题。最大的问题是，假如改了apkbuilder涉及的文件，会导致签名校验失败。</p>\n<p>因此只能通过不参与签名校验的文件进行操作，唯一可以改的就是META-INF目录。</p>\n<p>所以将需要放置的文件放到META-INF目录之后在进行对齐即可。</p>\n<h1 id=\"项目变更\"><a href=\"#项目变更\" class=\"headerlink\" title=\"项目变更\"></a>项目变更</h1><p>由于市场的要求，我们的app在不同的平台上有不同的名字，比如在baidu上面，就是“好搭盒子”，而在小米和搜狗市场上面，叫“好搭盒子-穿衣搭配”，在其余的市场上面，叫”好搭盒子-教你穿衣搭配”。</p>\n<p>虽然看起来只是名字的改变，但是如果通过打包想法来讲，改名字需要改manifest，这样就会导致签名验证失败，因此无法通过manifest改名字。</p>\n<p>我的想法和行动是仍旧构建变体，分三个，一个是shortname变体，一个是middlename变体，另一个是longname变体，其实还有一种，是测试时候的dev变体（因为测试人员需要知道我给他的是debug包，通过名字知道是最直接的）</p>\n<p>因此通过输入渠道的变化，构造不同的变体，但是对于已有构建好的就不需要重复构建了。</p>\n<h1 id=\"打包脚本\"><a href=\"#打包脚本\" class=\"headerlink\" title=\"打包脚本\"></a>打包脚本</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># coding=utf-8</span><br><span class=\"line\">import zipfile</span><br><span class=\"line\">import shutil</span><br><span class=\"line\">import os</span><br><span class=\"line\">import sys</span><br><span class=\"line\">import requests</span><br><span class=\"line\">import json</span><br><span class=\"line\">import urllib2</span><br><span class=\"line\">import subprocess</span><br><span class=\"line\">import pwd</span><br><span class=\"line\">import os</span><br><span class=\"line\">import re</span><br><span class=\"line\"></span><br><span class=\"line\">findline = u&quot;(versionCode\\s+:.+)&quot;</span><br><span class=\"line\">findversion = u&quot;([0-9]+)&quot;</span><br><span class=\"line\">findversionname = u&quot;(?&lt;= versionName      : \\&quot;).+?(?=\\&quot;)&quot;</span><br><span class=\"line\">depgradlefilepath = &quot;dependencies.gradle&quot;</span><br><span class=\"line\">BRANCH = &quot;dev&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def release(channelName):</span><br><span class=\"line\">    channelName = channelName</span><br><span class=\"line\">    print &apos;start build &apos; + channelName</span><br><span class=\"line\"></span><br><span class=\"line\">    apk = &apos;./app/build/outputs/apk/dev/release/app-dev-release.apk&apos;</span><br><span class=\"line\">    hasApk = os.path.exists(apk)</span><br><span class=\"line\">    path = &apos;./release_apks/dev/&apos;</span><br><span class=\"line\">    clean_code = subprocess.check_call(&quot;./gradlew clean&quot;, shell=True)</span><br><span class=\"line\">    if clean_code != 0:</span><br><span class=\"line\">        print &quot;clean failed&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    if channelName == &apos;long&apos;:</span><br><span class=\"line\">        apk = &apos;./app/build/outputs/apk/longname/release/app-longname-release.apk&apos;</span><br><span class=\"line\">        path = &apos;./release_apks/long/&apos;</span><br><span class=\"line\">        if os.path.exists(&quot;release_apks/long&quot;):</span><br><span class=\"line\">            shutil.rmtree(&quot;release_apks/long&quot;)</span><br><span class=\"line\">        print &quot;delete exist release_apks/long success&quot;</span><br><span class=\"line\">        os.mkdir(&quot;release_apks/long&quot;)</span><br><span class=\"line\">        assemble_release_code = subprocess.check_call(&quot;./gradlew assembleLongnameRelease&quot;,</span><br><span class=\"line\">                                                      shell=True)</span><br><span class=\"line\">    elif channelName == &apos;short&apos;:</span><br><span class=\"line\">        apk = &apos;./app/build/outputs/apk/shortname/release/app-shortname-release.apk&apos;</span><br><span class=\"line\">        path = &apos;./release_apks/short/&apos;</span><br><span class=\"line\">        if os.path.exists(&quot;release_apks/short&quot;):</span><br><span class=\"line\">            shutil.rmtree(&quot;release_apks/short&quot;)</span><br><span class=\"line\">        print &quot;delete exist release_apks/short success&quot;</span><br><span class=\"line\">        os.mkdir(&quot;release_apks/short&quot;)</span><br><span class=\"line\">        assemble_release_code = subprocess.check_call(&quot;./gradlew assembleShortnameRelease&quot;,</span><br><span class=\"line\">                                                      shell=True)</span><br><span class=\"line\">    elif channelName == &apos;middle&apos;:</span><br><span class=\"line\">        apk = &apos;./app/build/outputs/apk/middlename/release/app-middlename-release.apk&apos;</span><br><span class=\"line\">        path = &apos;./release_apks/middle/&apos;</span><br><span class=\"line\">        if os.path.exists(&quot;release_apks/middle&quot;):</span><br><span class=\"line\">            shutil.rmtree(&quot;release_apks/middle&quot;)</span><br><span class=\"line\">        print &quot;delete exist release_apks/middle success&quot;</span><br><span class=\"line\">        os.mkdir(&quot;release_apks/middle&quot;)</span><br><span class=\"line\">        assemble_release_code = subprocess.check_call(&quot;./gradlew assembleMiddlenameRelease&quot;,</span><br><span class=\"line\">                                                      shell=True)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        if os.path.exists(&quot;release_apks/dev&quot;):</span><br><span class=\"line\">            shutil.rmtree(&quot;release_apks/dev&quot;)</span><br><span class=\"line\">        print &quot;delete exist release_apks/dev success&quot;</span><br><span class=\"line\">        os.mkdir(&quot;release_apks/dev&quot;)</span><br><span class=\"line\">        assemble_release_code = subprocess.check_call(&quot;./gradlew assembleDevRelease&quot;, shell=True)</span><br><span class=\"line\"></span><br><span class=\"line\">    if assemble_release_code != 0:</span><br><span class=\"line\">        print &quot;assembleRelease failed&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\"></span><br><span class=\"line\">    emptyFile = &apos;xxx.txt&apos;</span><br><span class=\"line\">    f = open(emptyFile, &apos;w&apos;)</span><br><span class=\"line\">    f.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    if channelName == &apos;long&apos;:</span><br><span class=\"line\">        with open(&apos;channelNameLong.txt&apos;, &apos;r&apos;) as f:</span><br><span class=\"line\">            contens = f.read()</span><br><span class=\"line\">        lines = contens.split(&apos;\\n&apos;)</span><br><span class=\"line\">    elif channelName == &apos;short&apos;:</span><br><span class=\"line\">        with open(&apos;channelNameShort.txt&apos;, &apos;r&apos;) as f:</span><br><span class=\"line\">            contens = f.read()</span><br><span class=\"line\">        lines = contens.split(&apos;\\n&apos;)</span><br><span class=\"line\">    elif channelName == &apos;middle&apos;:</span><br><span class=\"line\">        with open(&apos;channelNameMiddle.txt&apos;, &apos;r&apos;) as f:</span><br><span class=\"line\">            contens = f.read()</span><br><span class=\"line\">        lines = contens.split(&apos;\\n&apos;)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        with open(&apos;devChannel.txt&apos;, &apos;r&apos;) as f:</span><br><span class=\"line\">            contens = f.read()</span><br><span class=\"line\">        lines = contens.split(&apos;\\n&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    if not os.path.exists(path):</span><br><span class=\"line\">        os.mkdir(path)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        for f in os.listdir(path):</span><br><span class=\"line\">            if not f.endswith(&apos;.gitignore&apos;):</span><br><span class=\"line\">                os.remove(path + f)</span><br><span class=\"line\"></span><br><span class=\"line\">    for line in lines:</span><br><span class=\"line\">        print line</span><br><span class=\"line\">        channel = &apos;channel_&apos; + line</span><br><span class=\"line\">        destfile = path + &apos;%s.apk&apos; % channel</span><br><span class=\"line\">        shutil.copyfile(apk, destfile)</span><br><span class=\"line\">        zipped = zipfile.ZipFile(destfile, &apos;a&apos;, zipfile.ZIP_DEFLATED)</span><br><span class=\"line\">        channelFile = &quot;META-INF/&#123;channelname&#125;&quot;.format(channelname=channel)</span><br><span class=\"line\">        zipped.write(emptyFile, channelFile)</span><br><span class=\"line\">        zipped.close()</span><br><span class=\"line\">    os.remove(&apos;./xxx.txt&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    for f in os.listdir(path):</span><br><span class=\"line\">        if f.endswith(&apos;.apk&apos;):</span><br><span class=\"line\">            os.system(&apos;zipalign -f -v 4 &apos; + path + f + &apos; &apos; + path + &apos;temp-&apos; + f)</span><br><span class=\"line\">            os.remove(path + f)</span><br><span class=\"line\"></span><br><span class=\"line\">    for f in os.listdir(path):</span><br><span class=\"line\">        if f.startswith(&apos;temp-&apos;):</span><br><span class=\"line\">            os.system(&apos;zipalign -f -v 4 &apos; + path + f + &apos; &apos; + path + f.replace(&apos;temp-&apos;, &apos;&apos;))</span><br><span class=\"line\">            os.remove(path + f)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def versionCodePlusPlus(msg):</span><br><span class=\"line\">    gitstash = subprocess.check_call(&quot;git stash&quot;, shell=True)</span><br><span class=\"line\">    if gitstash != 0:</span><br><span class=\"line\">        print &quot;git stash fail&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    print &quot;git stash success&quot;</span><br><span class=\"line\">    gitcheckout = subprocess.check_call(&quot;git checkout &quot; + BRANCH, shell=True)</span><br><span class=\"line\">    if gitcheckout != 0:</span><br><span class=\"line\">        print &quot;git checkout dev fail&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    print &quot;git checkout dev success&quot;</span><br><span class=\"line\">    gitfetchall = subprocess.check_call(&quot;git fetch --all&quot;, shell=True)</span><br><span class=\"line\">    if gitfetchall != 0:</span><br><span class=\"line\">        print &quot;git fetch all fail&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    gitresetall = subprocess.check_call(&quot;git reset --hard origin/&quot; + BRANCH, shell=True)</span><br><span class=\"line\">    if gitresetall != 0:</span><br><span class=\"line\">        print &quot;git reset hard origin dev fail&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    gitpull = subprocess.check_call(&quot;git pull&quot;, shell=True)</span><br><span class=\"line\">    if gitpull != 0:</span><br><span class=\"line\">        print &quot;git pull fail&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    print &quot;git pull success&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    originContent = open(depgradlefilepath).read()</span><br><span class=\"line\">    originVersionCodeLine = re.search(findline, originContent).group(0)</span><br><span class=\"line\">    originVersionCodeString = re.search(findversion, originVersionCodeLine).group(0)</span><br><span class=\"line\">    versionname = re.search(findversionname, originContent).group(0)</span><br><span class=\"line\">    originVersionCode = int(originVersionCodeString)</span><br><span class=\"line\">    finalVersionCode = originVersionCode + 1</span><br><span class=\"line\">    finalVersionCodeLine = &quot;versionCode      : &quot; + str(finalVersionCode) + &quot;,&quot;</span><br><span class=\"line\">    finalContent = originContent.replace(originVersionCodeLine, finalVersionCodeLine, 1)</span><br><span class=\"line\">    open(depgradlefilepath, &apos;w&apos;).write(finalContent)</span><br><span class=\"line\">    gitadd = subprocess.check_call(&quot;git add .&quot;, shell=True)</span><br><span class=\"line\">    if gitadd != 0:</span><br><span class=\"line\">        print &quot;git add failed&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    gitCommit = subprocess.check_call(</span><br><span class=\"line\">        u&quot;git commit -m \\&quot;build/auto increase versionCode = &quot; + str(</span><br><span class=\"line\">            finalVersionCode) + &quot;,&quot; + msg + &quot;\\&quot;&quot;,</span><br><span class=\"line\">        shell=True)</span><br><span class=\"line\">    if gitCommit != 0:</span><br><span class=\"line\">        print &quot;gitCommit failed&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    gitPush = subprocess.check_call(</span><br><span class=\"line\">        &quot;git push origin &quot; + BRANCH, shell=True</span><br><span class=\"line\">    )</span><br><span class=\"line\">    if gitPush != 0:</span><br><span class=\"line\">        print &quot;gitpush failed&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\"></span><br><span class=\"line\">    gitpull = subprocess.check_call(&quot;git pull&quot;, shell=True)</span><br><span class=\"line\">    if gitpull != 0:</span><br><span class=\"line\">        print &quot;git pull fail&quot;</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    print &quot;git pull success&quot;</span><br><span class=\"line\">    return finalVersionCode, versionname</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    if os.path.exists(&quot;release_apks&quot;):</span><br><span class=\"line\">        shutil.rmtree(&quot;release_apks&quot;)</span><br><span class=\"line\">        print &quot;delete exist release_apks success&quot;</span><br><span class=\"line\">    os.mkdir(&quot;release_apks&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">    if os.path.exists(&quot;app/build&quot;):</span><br><span class=\"line\">        shutil.rmtree(&quot;app/build&quot;)</span><br><span class=\"line\">    print &quot;delete exist release_apks success&quot;</span><br><span class=\"line\">    channel = &apos;dev&apos;</span><br><span class=\"line\">    if len(sys.argv) &gt;= 2:</span><br><span class=\"line\">        channel = sys.argv[1]</span><br><span class=\"line\">    versionCodePlusPlus(channel)</span><br><span class=\"line\">    release(channel)</span><br></pre></td></tr></table></figure>\n<p>其中做了一个额外的动作，就是versioncode++这个操作，这个主要也是项目需要，每次build的包，需要有迹可溯，因此每次build都会使versioncode+1，并且进行提交。</p>\n<p>上面是打包的流程，还有个全渠道打包的执行文件就比较简单了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># coding=utf-8</span><br><span class=\"line\">from release import release, versionCodePlusPlus,BRANCH,findline,findversion,findversionname,depgradlefilepath</span><br><span class=\"line\">import os</span><br><span class=\"line\">import shutil</span><br><span class=\"line\">import subprocess</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">FLAVOR_FILE = &apos;all_channels.txt&apos;</span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    if os.path.exists(&quot;release_apks&quot;):</span><br><span class=\"line\">        shutil.rmtree(&quot;release_apks&quot;)</span><br><span class=\"line\">        print &quot;delete exist release_apks success&quot;</span><br><span class=\"line\">    if os.path.exists(&quot;app/build&quot;):</span><br><span class=\"line\">        shutil.rmtree(&quot;app/build&quot;)</span><br><span class=\"line\">    print &quot;delete exist release_apks success&quot;</span><br><span class=\"line\">    os.mkdir(&quot;release_apks&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">    versionCodePlusPlus(&apos;short&apos;)</span><br><span class=\"line\">    release(&apos;short&apos;)</span><br><span class=\"line\">    versionCodePlusPlus(&apos;middle&apos;)</span><br><span class=\"line\">    release(&apos;middle&apos;)</span><br><span class=\"line\">    versionCodePlusPlus(&apos;long&apos;)</span><br><span class=\"line\">    release(&apos;long&apos;)</span><br></pre></td></tr></table></figure>\n<p>因为也不算涉及到公司机密，以上都是很常规的操作，留下来做个备注防止以后采坑</p>\n"},{"title":"jvm内存模型","date":"2019-01-02T15:48:21.000Z","_content":"\n![JVM内存模型示意图](/images/android/jvm内存模型.jpg)\n\n## 内存计数器（PC寄存器）\n\n由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，\n\n因此，为了能够使得每个线程都在线程切换后能够恢复在切　换　之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，\n\n否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，\n\n因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。\n\n内存计数器是context的一部分\n\n## java 栈\n\nJava栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、\n\n指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、\n\n方法返回地址(Return Address)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。　\n\n```\n经常有人把Java 内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗\n\n糙，Java 内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序\n\n员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”在后\n\n面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变\n\n量表部分。\n\n局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、\n\nfloat、long、double）、对象引用（reference 类型，它不等同于对象本身，根据不同的虚拟\n\n机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或\n\n者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。\n\n其中64 位长度的long 和double 类型的数据会占用2 个局部变量空间（Slot），其余\n\n的数据类型只占用1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个\n\n方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间\n\n不会改变局部变量表的大小。\n```\n\n## 本地方法栈\n\n本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的\n\n```\n本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其\n\n区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则\n\n是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语\n\n言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至\n\n有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。\n\n与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError\n\n异常。\n\n```\n\n## java 堆\n\nJava中的堆是用来存储对象本身的以及数组（数组引用是存放在Java栈中的）。堆是被所有线程共享的，在JVM中只有一个堆。\n\n```\n对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的\n\n一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的\n\n唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚\n\n拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着JIT 编译器\n\n的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙\n\n的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。\n\nJava 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（Garbage\n\nCollected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在\n\n收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；\n\n再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配\n\n的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local\n\nAllocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，\n\n存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配\n\n内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java 堆中的上述各个区域的\n\n分配和回收等细节将会是下一章的主题。\n\n根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要\n\n逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小\n\n的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx\n\n和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出\n\nOutOfMemoryError 异常。\n```\n\n## 方法区\n\n与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。\n\n在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。\n\n在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，\n\n对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。\n\n```\n方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存\n\n储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽\n\n然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-\n\nHeap（非堆），目的应该是与Java 堆区分开来。\n\n对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区\n\n称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚\n\n拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而\n\n已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。即\n\n使是HotSpot 虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”\n\n至Native Memory 来实现方法区的规划了。\n\nJava 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内\n\n存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾\n\n收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一\n\n样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸\n\n载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件\n\n相当苛刻，但是这部分区域的回收确实是有必要的。在Sun 公司的BUG 列表中，曾出\n\n现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导\n\n致内存泄漏。\n\n根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出\n\nOutOfMemoryError 异常。\n```\n\n## 静态区\n\n静态区也称为运行常量池，static出来的对象都是静态的。该区域存放类和接口的常量，\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/jvm内存模型.md","raw":"---\ntitle: jvm内存模型\ndate: 2019-01-02 23:48:21\ntags: java\n---\n\n![JVM内存模型示意图](/images/android/jvm内存模型.jpg)\n\n## 内存计数器（PC寄存器）\n\n由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，\n\n因此，为了能够使得每个线程都在线程切换后能够恢复在切　换　之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，\n\n否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，\n\n因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。\n\n内存计数器是context的一部分\n\n## java 栈\n\nJava栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、\n\n指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、\n\n方法返回地址(Return Address)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。　\n\n```\n经常有人把Java 内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗\n\n糙，Java 内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序\n\n员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”在后\n\n面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变\n\n量表部分。\n\n局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、\n\nfloat、long、double）、对象引用（reference 类型，它不等同于对象本身，根据不同的虚拟\n\n机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或\n\n者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。\n\n其中64 位长度的long 和double 类型的数据会占用2 个局部变量空间（Slot），其余\n\n的数据类型只占用1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个\n\n方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间\n\n不会改变局部变量表的大小。\n```\n\n## 本地方法栈\n\n本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的\n\n```\n本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其\n\n区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则\n\n是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语\n\n言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至\n\n有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。\n\n与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError\n\n异常。\n\n```\n\n## java 堆\n\nJava中的堆是用来存储对象本身的以及数组（数组引用是存放在Java栈中的）。堆是被所有线程共享的，在JVM中只有一个堆。\n\n```\n对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的\n\n一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的\n\n唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚\n\n拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着JIT 编译器\n\n的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙\n\n的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。\n\nJava 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（Garbage\n\nCollected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在\n\n收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；\n\n再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配\n\n的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local\n\nAllocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，\n\n存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配\n\n内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java 堆中的上述各个区域的\n\n分配和回收等细节将会是下一章的主题。\n\n根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要\n\n逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小\n\n的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx\n\n和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出\n\nOutOfMemoryError 异常。\n```\n\n## 方法区\n\n与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。\n\n在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。\n\n在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，\n\n对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。\n\n```\n方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存\n\n储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽\n\n然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-\n\nHeap（非堆），目的应该是与Java 堆区分开来。\n\n对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区\n\n称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚\n\n拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而\n\n已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。即\n\n使是HotSpot 虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”\n\n至Native Memory 来实现方法区的规划了。\n\nJava 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内\n\n存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾\n\n收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一\n\n样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸\n\n载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件\n\n相当苛刻，但是这部分区域的回收确实是有必要的。在Sun 公司的BUG 列表中，曾出\n\n现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导\n\n致内存泄漏。\n\n根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出\n\nOutOfMemoryError 异常。\n```\n\n## 静态区\n\n静态区也称为运行常量池，static出来的对象都是静态的。该区域存放类和接口的常量，\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"jvm内存模型","published":1,"updated":"2019-03-12T09:26:33.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltu01006e3a8kmrbduaxs","content":"<p><img src=\"/images/android/jvm内存模型.jpg\" alt=\"JVM内存模型示意图\"></p>\n<h2 id=\"内存计数器（PC寄存器）\"><a href=\"#内存计数器（PC寄存器）\" class=\"headerlink\" title=\"内存计数器（PC寄存器）\"></a>内存计数器（PC寄存器）</h2><p>由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，</p>\n<p>因此，为了能够使得每个线程都在线程切换后能够恢复在切　换　之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，</p>\n<p>否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，</p>\n<p>因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。</p>\n<p>内存计数器是context的一部分</p>\n<h2 id=\"java-栈\"><a href=\"#java-栈\" class=\"headerlink\" title=\"java 栈\"></a>java 栈</h2><p>Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、</p>\n<p>指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、</p>\n<p>方法返回地址(Return Address)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。　</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">经常有人把Java 内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗</span><br><span class=\"line\"></span><br><span class=\"line\">糙，Java 内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序</span><br><span class=\"line\"></span><br><span class=\"line\">员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”在后</span><br><span class=\"line\"></span><br><span class=\"line\">面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变</span><br><span class=\"line\"></span><br><span class=\"line\">量表部分。</span><br><span class=\"line\"></span><br><span class=\"line\">局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、</span><br><span class=\"line\"></span><br><span class=\"line\">float、long、double）、对象引用（reference 类型，它不等同于对象本身，根据不同的虚拟</span><br><span class=\"line\"></span><br><span class=\"line\">机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或</span><br><span class=\"line\"></span><br><span class=\"line\">者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。</span><br><span class=\"line\"></span><br><span class=\"line\">其中64 位长度的long 和double 类型的数据会占用2 个局部变量空间（Slot），其余</span><br><span class=\"line\"></span><br><span class=\"line\">的数据类型只占用1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个</span><br><span class=\"line\"></span><br><span class=\"line\">方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间</span><br><span class=\"line\"></span><br><span class=\"line\">不会改变局部变量表的大小。</span><br></pre></td></tr></table></figure>\n<h2 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h2><p>本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其</span><br><span class=\"line\"></span><br><span class=\"line\">区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则</span><br><span class=\"line\"></span><br><span class=\"line\">是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语</span><br><span class=\"line\"></span><br><span class=\"line\">言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至</span><br><span class=\"line\"></span><br><span class=\"line\">有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。</span><br><span class=\"line\"></span><br><span class=\"line\">与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError</span><br><span class=\"line\"></span><br><span class=\"line\">异常。</span><br></pre></td></tr></table></figure>\n<h2 id=\"java-堆\"><a href=\"#java-堆\" class=\"headerlink\" title=\"java 堆\"></a>java 堆</h2><p>Java中的堆是用来存储对象本身的以及数组（数组引用是存放在Java栈中的）。堆是被所有线程共享的，在JVM中只有一个堆。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的</span><br><span class=\"line\"></span><br><span class=\"line\">一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的</span><br><span class=\"line\"></span><br><span class=\"line\">唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚</span><br><span class=\"line\"></span><br><span class=\"line\">拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着JIT 编译器</span><br><span class=\"line\"></span><br><span class=\"line\">的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙</span><br><span class=\"line\"></span><br><span class=\"line\">的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</span><br><span class=\"line\"></span><br><span class=\"line\">Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（Garbage</span><br><span class=\"line\"></span><br><span class=\"line\">Collected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在</span><br><span class=\"line\"></span><br><span class=\"line\">收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；</span><br><span class=\"line\"></span><br><span class=\"line\">再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配</span><br><span class=\"line\"></span><br><span class=\"line\">的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local</span><br><span class=\"line\"></span><br><span class=\"line\">Allocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，</span><br><span class=\"line\"></span><br><span class=\"line\">存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配</span><br><span class=\"line\"></span><br><span class=\"line\">内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java 堆中的上述各个区域的</span><br><span class=\"line\"></span><br><span class=\"line\">分配和回收等细节将会是下一章的主题。</span><br><span class=\"line\"></span><br><span class=\"line\">根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要</span><br><span class=\"line\"></span><br><span class=\"line\">逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小</span><br><span class=\"line\"></span><br><span class=\"line\">的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx</span><br><span class=\"line\"></span><br><span class=\"line\">和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出</span><br><span class=\"line\"></span><br><span class=\"line\">OutOfMemoryError 异常。</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><p>与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。</p>\n<p>在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。</p>\n<p>在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，</p>\n<p>对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存</span><br><span class=\"line\"></span><br><span class=\"line\">储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽</span><br><span class=\"line\"></span><br><span class=\"line\">然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-</span><br><span class=\"line\"></span><br><span class=\"line\">Heap（非堆），目的应该是与Java 堆区分开来。</span><br><span class=\"line\"></span><br><span class=\"line\">对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区</span><br><span class=\"line\"></span><br><span class=\"line\">称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚</span><br><span class=\"line\"></span><br><span class=\"line\">拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而</span><br><span class=\"line\"></span><br><span class=\"line\">已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。即</span><br><span class=\"line\"></span><br><span class=\"line\">使是HotSpot 虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”</span><br><span class=\"line\"></span><br><span class=\"line\">至Native Memory 来实现方法区的规划了。</span><br><span class=\"line\"></span><br><span class=\"line\">Java 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内</span><br><span class=\"line\"></span><br><span class=\"line\">存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾</span><br><span class=\"line\"></span><br><span class=\"line\">收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一</span><br><span class=\"line\"></span><br><span class=\"line\">样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸</span><br><span class=\"line\"></span><br><span class=\"line\">载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件</span><br><span class=\"line\"></span><br><span class=\"line\">相当苛刻，但是这部分区域的回收确实是有必要的。在Sun 公司的BUG 列表中，曾出</span><br><span class=\"line\"></span><br><span class=\"line\">现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导</span><br><span class=\"line\"></span><br><span class=\"line\">致内存泄漏。</span><br><span class=\"line\"></span><br><span class=\"line\">根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出</span><br><span class=\"line\"></span><br><span class=\"line\">OutOfMemoryError 异常。</span><br></pre></td></tr></table></figure>\n<h2 id=\"静态区\"><a href=\"#静态区\" class=\"headerlink\" title=\"静态区\"></a>静态区</h2><p>静态区也称为运行常量池，static出来的对象都是静态的。该区域存放类和接口的常量，</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/android/jvm内存模型.jpg\" alt=\"JVM内存模型示意图\"></p>\n<h2 id=\"内存计数器（PC寄存器）\"><a href=\"#内存计数器（PC寄存器）\" class=\"headerlink\" title=\"内存计数器（PC寄存器）\"></a>内存计数器（PC寄存器）</h2><p>由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，</p>\n<p>因此，为了能够使得每个线程都在线程切换后能够恢复在切　换　之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，</p>\n<p>否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，</p>\n<p>因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。</p>\n<p>内存计数器是context的一部分</p>\n<h2 id=\"java-栈\"><a href=\"#java-栈\" class=\"headerlink\" title=\"java 栈\"></a>java 栈</h2><p>Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、</p>\n<p>指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、</p>\n<p>方法返回地址(Return Address)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。　</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">经常有人把Java 内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗</span><br><span class=\"line\"></span><br><span class=\"line\">糙，Java 内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序</span><br><span class=\"line\"></span><br><span class=\"line\">员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”在后</span><br><span class=\"line\"></span><br><span class=\"line\">面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变</span><br><span class=\"line\"></span><br><span class=\"line\">量表部分。</span><br><span class=\"line\"></span><br><span class=\"line\">局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、</span><br><span class=\"line\"></span><br><span class=\"line\">float、long、double）、对象引用（reference 类型，它不等同于对象本身，根据不同的虚拟</span><br><span class=\"line\"></span><br><span class=\"line\">机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或</span><br><span class=\"line\"></span><br><span class=\"line\">者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。</span><br><span class=\"line\"></span><br><span class=\"line\">其中64 位长度的long 和double 类型的数据会占用2 个局部变量空间（Slot），其余</span><br><span class=\"line\"></span><br><span class=\"line\">的数据类型只占用1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个</span><br><span class=\"line\"></span><br><span class=\"line\">方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间</span><br><span class=\"line\"></span><br><span class=\"line\">不会改变局部变量表的大小。</span><br></pre></td></tr></table></figure>\n<h2 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h2><p>本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其</span><br><span class=\"line\"></span><br><span class=\"line\">区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则</span><br><span class=\"line\"></span><br><span class=\"line\">是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语</span><br><span class=\"line\"></span><br><span class=\"line\">言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至</span><br><span class=\"line\"></span><br><span class=\"line\">有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。</span><br><span class=\"line\"></span><br><span class=\"line\">与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError</span><br><span class=\"line\"></span><br><span class=\"line\">异常。</span><br></pre></td></tr></table></figure>\n<h2 id=\"java-堆\"><a href=\"#java-堆\" class=\"headerlink\" title=\"java 堆\"></a>java 堆</h2><p>Java中的堆是用来存储对象本身的以及数组（数组引用是存放在Java栈中的）。堆是被所有线程共享的，在JVM中只有一个堆。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的</span><br><span class=\"line\"></span><br><span class=\"line\">一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的</span><br><span class=\"line\"></span><br><span class=\"line\">唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚</span><br><span class=\"line\"></span><br><span class=\"line\">拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着JIT 编译器</span><br><span class=\"line\"></span><br><span class=\"line\">的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙</span><br><span class=\"line\"></span><br><span class=\"line\">的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</span><br><span class=\"line\"></span><br><span class=\"line\">Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（Garbage</span><br><span class=\"line\"></span><br><span class=\"line\">Collected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在</span><br><span class=\"line\"></span><br><span class=\"line\">收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；</span><br><span class=\"line\"></span><br><span class=\"line\">再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配</span><br><span class=\"line\"></span><br><span class=\"line\">的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local</span><br><span class=\"line\"></span><br><span class=\"line\">Allocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，</span><br><span class=\"line\"></span><br><span class=\"line\">存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配</span><br><span class=\"line\"></span><br><span class=\"line\">内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java 堆中的上述各个区域的</span><br><span class=\"line\"></span><br><span class=\"line\">分配和回收等细节将会是下一章的主题。</span><br><span class=\"line\"></span><br><span class=\"line\">根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要</span><br><span class=\"line\"></span><br><span class=\"line\">逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小</span><br><span class=\"line\"></span><br><span class=\"line\">的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx</span><br><span class=\"line\"></span><br><span class=\"line\">和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出</span><br><span class=\"line\"></span><br><span class=\"line\">OutOfMemoryError 异常。</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><p>与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。</p>\n<p>在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。</p>\n<p>在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，</p>\n<p>对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存</span><br><span class=\"line\"></span><br><span class=\"line\">储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽</span><br><span class=\"line\"></span><br><span class=\"line\">然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-</span><br><span class=\"line\"></span><br><span class=\"line\">Heap（非堆），目的应该是与Java 堆区分开来。</span><br><span class=\"line\"></span><br><span class=\"line\">对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区</span><br><span class=\"line\"></span><br><span class=\"line\">称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚</span><br><span class=\"line\"></span><br><span class=\"line\">拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而</span><br><span class=\"line\"></span><br><span class=\"line\">已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。即</span><br><span class=\"line\"></span><br><span class=\"line\">使是HotSpot 虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”</span><br><span class=\"line\"></span><br><span class=\"line\">至Native Memory 来实现方法区的规划了。</span><br><span class=\"line\"></span><br><span class=\"line\">Java 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内</span><br><span class=\"line\"></span><br><span class=\"line\">存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾</span><br><span class=\"line\"></span><br><span class=\"line\">收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一</span><br><span class=\"line\"></span><br><span class=\"line\">样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸</span><br><span class=\"line\"></span><br><span class=\"line\">载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件</span><br><span class=\"line\"></span><br><span class=\"line\">相当苛刻，但是这部分区域的回收确实是有必要的。在Sun 公司的BUG 列表中，曾出</span><br><span class=\"line\"></span><br><span class=\"line\">现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导</span><br><span class=\"line\"></span><br><span class=\"line\">致内存泄漏。</span><br><span class=\"line\"></span><br><span class=\"line\">根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出</span><br><span class=\"line\"></span><br><span class=\"line\">OutOfMemoryError 异常。</span><br></pre></td></tr></table></figure>\n<h2 id=\"静态区\"><a href=\"#静态区\" class=\"headerlink\" title=\"静态区\"></a>静态区</h2><p>静态区也称为运行常量池，static出来的对象都是静态的。该区域存放类和接口的常量，</p>\n"},{"title":"mongodb安装、常用操作记录","date":"2018-05-29T10:07:21.000Z","_content":"\n由于阿里云服务器切成了centos，故需要重新部署数据库，之前部署的sqlite是在是太low了，拿不出手，这次搞mongodb。\n\n# 安装\n\n```\ncurl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.6.tgz    # 下载\ntar -zxvf mongodb-linux-x86_64-3.0.6.tgz                                   # 解压\n\nmv  mongodb-linux-x86_64-3.0.6/ /usr/local/mongodb                         # 将解压包拷贝到指定目录\n```\n\n# 环境变量设置\n\n```\nexport PATH=<mongodb-install-directory>/bin:$PATH\n```\n\n# 创建数据库目录\n\n```\ncd /\nmkdir -p /data/db\n``` \n\n# 命令行中运行 MongoDB 服务\n\n```\nmongod\n```\n\n如果环境变量没设需要到相关目录下执行\n\n# 管理shell\n\n```\nmongo\n```\n\n环境变量问题同上。\n\n# 基础知识\n\nsql -> mongodb -> 意义\n\ndatabase -> databse -> 数据库\n\ntable -> collection -> 数据库表/集合\n\nrow -> document -> 数据记录行/文档\n\ncolumn -> field -> 数据字段/域\n\nindex -> index -> 索引\n\ntable joins  -> null -> 表连接\n\nprimary key -> primary key -> 主键，mongodb自动将_id设为主键\n\n# 基础操作\n\n## 展示所有的数据库\n\n```\nshow dbs\n```\n\n## 显示当前使用的数据库\n\n```\ndb\n```\n\n## 切换数据库\n\n```\nuse db1\n```\n\n即可切换到db1数据库\n\n### 数据库命名规则\n\n1 不能是空字符串（\"\")。\n2 不得含有' '（空格)、.、$、/、\\和\\0 (空字符)。\n3 应全部小写。\n4 最多64字节。\n\n下列有特殊意义的数据库名字需要保留\n\n1 admin： 从权限的角度来看，这是\"root\"数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。\n\n2 local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合\n\n3 config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。\n\n### 文档命名规则\n\n1 键不能含有\\0 (空字符)。这个字符用来表示键的结尾。\n2 .和$有特别的意义，只有在特定环境下才能使用。\n3 以下划线\"_\"开头的键是保留的(不是严格要求的)\n\n\n几个注意点\n\n1 文档中的键/值对是有序的。\n2 文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。\n3 MongoDB区分类型和大小写。\n4 MongoDB的文档不能有重复的键。\n5 文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符\n\n### 集合命名规则\n\n1 集合名不能是空字符串\"\"。\n2 集合名不能含有\\0字符（空字符)，这个字符表示集合名的结尾。\n3 集合名不能以\"system.\"开头，这是为系统集合保留的前缀。\n4 用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。\n\ncapped collections\n\ncapped collections就是具有固定大小的collections。类似于队列，通过插入顺序来判断过期现象。\n\n```\ndb.createCollection(\"mycoll\", {capped:true, size:100000})\n```\n\n在capped collection中，你能添加新的对象。\n能进行更新，然而，对象不会增加存储空间。如果增加，更新就会失败 。\n数据库不允许进行删除。使用drop()方法删除collection所有的行。\n注意: 删除之后，你必须显式的重新创建这个collection。\n在32bit机器中，capped collection最大存储为1e9( 1X109)个字节。\n\n\n### 元数据\n\n数据库的信息是存储在集合中。它们使用了系统的命名空间：\n\n```\ndbname.system.*\n```\n\ndbname.system.namespaces -> 列出所有名字空间。\n\ndbname.system.indexes -> 列出所有索引。\n\ndbname.system.profile -> 包含数据库概要(profile)信息。\n\ndbname.system.users\t-> 列出所有可访问数据库的用户。\n\ndbname.local.sources -> 包含复制对端（slave）的服务器信息和状态。\n\n对于修改系统集合中的对象有如下限制。\n\n在{{system.indexes}}插入数据，可以创建索引。但除此之外该表信息是不可变的(特殊的drop index命令将自动更新相关信息)。\n\n{{system.users}}是可修改的。 {{system.profile}}是可删除的。\n\n### MongoDB 数据类型\n\nString -> 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。\n\nInteger -> 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。\n\nBoolean -> 布尔值。用于存储布尔值（真/假）。\n\nDouble -> 双精度浮点值。用于存储浮点值。\n\nMin/Max keys -> 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。\n\nArray -> 用于将数组或列表或多个值存储为一个键。\n\nTimestamp -> 时间戳。记录文档修改或添加的具体时间。\n\nObject -> 用于内嵌文档。\n\nNull -> 用于创建空值。\n\nSymbol -> 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。\n\nDate -> 日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。\n\nObject ID -> 对象 ID。用于创建文档的 ID。\n\nBinary Data -> 二进制数据。用于存储二进制数据。\n\nCode -> 代码类型。用于在文档中存储 JavaScript 代码。\n\nRegular expression -> 正则表达式类型。用于存储正则表达式。\n\n#### ObjectId\n\n1 前 4 个字节表示创建 unix时间戳,格林尼治时间 UTC 时间，比北京时间晚了 8 个小时\n2 接下来的 3 个字节是机器标识码\n3 紧接的两个字节由进程 id 组成 PID\n4 最后三个字节是随机数\n\n#### 字符串\n\nBSON 字符串都是 UTF-8 编码。\n\n#### 时间戳\n\nBSON 有一个特殊的时间戳类型用于 MongoDB 内部使用，与普通的 日期 类型不相关。 时间戳值是一个 64 位的值。其中：\n\n前32位是一个 time_t 值（与Unix新纪元相差的秒数）\n后32位是在某秒中操作的一个递增的序数\n在单个 mongod 实例中，时间戳值通常是唯一的。\n\n#### 日期\n\n```\n> Date()\nSun Mar 04 2018 15:02:59 GMT+0000 (UTC)   \n```\n\n# 数据库连接\n\n## 使用默认端口来连接 MongoDB 的服务。\n\n```\nmongodb://localhost\n```\n\n## 通过 shell 连接 MongoDB 服务：\n\n```\n$ ./mongo\nMongoDB shell version: 3.0.6\nconnecting to: test\n...\n```\n\n# 创建数据库\n\n```\nuse DATABASE_NAME\n```\n\n# 删除数据库\n\n```\ndb.dropDatabase()\n```\n\n\n\n# 创建集合\n\n```\ndb.createCollection(name, options)\n```\n\nname: 要创建的集合名称\noptions: 可选参数, 指定有关内存大小及索引的选项\n\noptions可选：\ncapped -> 为true则是固定集合，需要同时指定size\nautoIndexId -> 为true自动在 _id 字段创建索引。默认为 false。\nsize -> （可选）为固定集合指定一个最大值（以字节计）。如果 capped 为 true，也需要指定该字段。\nmax -> （可选）指定固定集合中包含文档的最大数量。\n\n\n# 删除集合\n\n```\ndb.collection.drop()\n```\n\n# 插入文档\n\n```\ndb.COLLECTION_NAME.insert(document)\n```\n\n```\n>db.col.insert({title: 'MongoDB 教程', \n    description: 'MongoDB 是一个 Nosql 数据库',\n    by: '菜鸟教程',\n    url: 'http://www.runoob.com',\n    tags: ['mongodb', 'database', 'NoSQL'],\n    likes: 100\n})\n```\n\n```\n> document=({title: 'MongoDB 教程', \n    description: 'MongoDB 是一个 Nosql 数据库',\n    by: '菜鸟教程',\n    url: 'http://www.runoob.com',\n    tags: ['mongodb', 'database', 'NoSQL'],\n    likes: 100\n});\n> db.col.insert(document)\n```\n\n# 更新文档\n\n## update\n\n```\ndb.collection.update(\n   <query>,\n   <update>,\n   {\n     upsert: <boolean>,\n     multi: <boolean>,\n     writeConcern: <document>\n   }\n)\n```\n\n1 query : update的查询条件，类似sql update查询内where后面的。\n2 update : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sqlupdate查询内set后面的\n3 upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。\n4 multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。\n5 writeConcern :可选，抛出异常的级别。\n\ntip : 3.2之后可用下面方法\n```\ndb.test_collection.updateOne({\"name\":\"abc\"},{$set:{\"age\":\"28\"}})\n```\n\n```\ndb.test_collection.updateMany({\"age\":{$gt:\"10\"}},{$set:{\"status\":\"xyz\"}})\n```\n\n## save\n\n```\ndb.collection.save(\n   <document>,\n   {\n     writeConcern: <document>\n   }\n)\n```\n\n1 document : 文档数据。\n2 writeConcern :可选，抛出异常的级别。\n\n1 WriteConcern.NONE:没有异常抛出\n2 WriteConcern.NORMAL:仅抛出网络错误异常，没有服务器错误异常\n3 WriteConcern.SAFE:抛出网络错误异常、服务器错误异常；并等待服务器完成写操作。\n4 WriteConcern.MAJORITY: 抛出网络错误异常、服务器错误异常；并等待一个主服务器完成写操作。\n5 WriteConcern.FSYNC_SAFE: 抛出网络错误异常、服务器错误异常；写操作等待服务器将数据刷新到磁盘。\n6 WriteConcern.JOURNAL_SAFE:抛出网络错误异常、服务器错误异常；写操作等待服务器提交到磁盘的日志文件。\n7 WriteConcern.REPLICAS_SAFE:抛出网络错误异常、服务器错误异常；等待至少2台服务器完成写操作。\n\n# 删除文档\n\n```\ndb.collection.remove(\n   <query>,\n   <justOne>\n)\n```\n\n2.6以后\n\n```\ndb.collection.remove(\n   <query>,\n   {\n     justOne: <boolean>,\n     writeConcern: <document>\n   }\n)\n```\n\nquery :（可选）删除的文档的条件。\njustOne : （可选）如果设为 true 或 1，则只删除一个文档。\nwriteConcern :（可选）抛出异常的级别。\n\n\n想只删除找到的第一条\n\n```\ndb.COLLECTION_NAME.remove(DELETION_CRITERIA,1)\n```\n\n想删除所有\n```\ndb.col.remove({})\n```\n\n# 查询文档\n\n```\ndb.collection.find(query, projection)\n```\n\n1 query ：可选，使用查询操作符指定查询条件\n2 projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。\n\n```\ndb.col.find().pretty()\n```\n\n格式化显示\n\n## where 操作\n\n### 等于\n\n```\ndb.col.find({\"by\":\"菜鸟教程\"}).pretty()\n```\n\n等同于\n\n```\nwhere by = '菜鸟教程'\n```\n\n### 小于\n\n```\ndb.col.find({\"likes\":{$lt:50}}).pretty()\n```\n\n等同于\n\n```\nwhere likes < 50\n```\n\n### 小于等于\n\n```\ndb.col.find({\"likes\":{$lte:50}}).pretty()\n```\n\n等同于\n\n```\nwhere likes <= 50\n```\n\n### 大于\n\n```\ndb.col.find({\"likes\":{$gt:50}}).pretty()\n```\n\n等同于\n\n```\nwhere likes > 50\n```\n\n### 大于或等于\n\n```\ndb.col.find({\"likes\":{$gt:50}}).pretty()\n```\n\n等同于\n\n```\nwhere likes > 50\n```\n\n### 不等于\n\n```\ndb.col.find({\"likes\":{$ne:50}}).pretty()\n```\n\n等同于\n\n```\nwhere likes != 50\n```\n\n## and操作\n\n```\ndb.col.find({key1:value1, key2:value2}).pretty()\n```\n\n```\ndb.col.find({\"by\":\"菜鸟教程\", \"title\":\"MongoDB 教程\"}).pretty()\n```\n\n等同于\n\n```\nWHERE by='菜鸟教程' AND title='MongoDB 教程'\n```\n\n## or操作\n\n```\ndb.col.find(\n   {\n      $or: [\n         {key1: value1}, {key2:value2}\n      ]\n   }\n).pretty()\n```\n\n```\ndb.col.find({$or:[{\"by\":\"菜鸟教程\"},{\"title\": \"MongoDB 教程\"}]}).pretty()\n```\n\n## and 和 or 同时\n\n```\ndb.col.find({\"likes\": {$gt:50}, $or: [{\"by\": \"菜鸟教程\"},{\"title\": \"MongoDB 教程\"}]}).pretty()\t\n```\n\n# type操作符\n\n1 -> double\n2 -> string\n3 -> object\n4 -> array\n5 -> binary data\n6 -> Undefined(deprecated)\n7 -> object id\n8 -> boolean\n9 -> date\n10 -> null\n11 -> regular expression\n\n13 -> javascript\n14 -> symbol\n15 -> javascript with scope\n16 -> 32-bit integer\n17 -> timestamp\n18 -> 64-bit integer\n\n255 -> min key(query with -1)\n127 -> max key\n\n\n需要查找title 类型为string的，如下\n```\ndb.col.find({\"title\" : {$type : 2}})\n```\n\n# limit 和 skip\n\n```\n>db.COLLECTION_NAME.find().limit(NUMBER)\n```\nlimit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。\n\n```\n>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)\n```\nskip方法同样接受一个数字参数作为跳过的记录条数。\n\n# sort\n\n在MongoDB中使用使用sort()方法对数据进行排序，sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。\n\n```\n>db.COLLECTION_NAME.find().sort({KEY:1})\n```\n# 索引\n\nMongoDB使用 ensureIndex() 方法来创建索引。\n\n```\n>db.COLLECTION_NAME.ensureIndex({KEY:1})\n```\n\n语法中 Key 值为你要创建的索引字段，1为指定按升序创建索引，如果你想按降序来创建索引指定为-1即可。\n\n# 聚合\n\n主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。\n\n```\n>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)\n```\n\n$sum -> 计算总和 -> db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$sum : \"$likes\"}}}])\n\n$avg -> 计算平均值 -> db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$avg : \"$likes\"}}}])\n\n$min -> 获取集合中所有文档对应值最小值 -> db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$min : \"$likes\"}}}])\n\n$max -> 获取集合中所有文档对应值得最大值 -> db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$max : \"$likes\"}}}])\n\n$push -> 在结果文档中插入值到一个数组中 -> db.mycol.aggregate([{$group : {_id : \"$by_user\", url : {$push: \"$url\"}}}])\n\n$addToSet -> 在结果文档中插入值到一个数组中，但不创建副本 -> db.mycol.aggregate([{$group : {_id : \"$by_user\", url : {$addToSet : \"$url\"}}}])\n\n$first -> 根据资源文档的排序获取第一个文档数据 -> db.mycol.aggregate([{$group : {_id : \"$by_user\", first_url : {$first : \"$url\"}}}])\n\n$last -> 根据资源文档的排序获取最后一个文档数据 -> db.mycol.aggregate([{$group : {_id : \"$by_user\", last_url : {$last : \"$url\"}}}])\n\n# 复制\n\nMongoDB复制是将数据同步在多个服务器的过程。\n\n复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。\n\n复制还允许您从硬件故障和服务中断中恢复数据。\n\n## 含义\n\n1 保障数据的安全性\n2 数据高可用性 (24*7)\n3 灾难恢复\n4 无需停机维护（如备份，重建索引，压缩）\n5 分布式读取数据\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/mongodb安装、常用操作记录.md","raw":"---\ntitle: mongodb安装、常用操作记录\ndate: 2018-05-29 18:07:21\ntags: sql\n---\n\n由于阿里云服务器切成了centos，故需要重新部署数据库，之前部署的sqlite是在是太low了，拿不出手，这次搞mongodb。\n\n# 安装\n\n```\ncurl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.6.tgz    # 下载\ntar -zxvf mongodb-linux-x86_64-3.0.6.tgz                                   # 解压\n\nmv  mongodb-linux-x86_64-3.0.6/ /usr/local/mongodb                         # 将解压包拷贝到指定目录\n```\n\n# 环境变量设置\n\n```\nexport PATH=<mongodb-install-directory>/bin:$PATH\n```\n\n# 创建数据库目录\n\n```\ncd /\nmkdir -p /data/db\n``` \n\n# 命令行中运行 MongoDB 服务\n\n```\nmongod\n```\n\n如果环境变量没设需要到相关目录下执行\n\n# 管理shell\n\n```\nmongo\n```\n\n环境变量问题同上。\n\n# 基础知识\n\nsql -> mongodb -> 意义\n\ndatabase -> databse -> 数据库\n\ntable -> collection -> 数据库表/集合\n\nrow -> document -> 数据记录行/文档\n\ncolumn -> field -> 数据字段/域\n\nindex -> index -> 索引\n\ntable joins  -> null -> 表连接\n\nprimary key -> primary key -> 主键，mongodb自动将_id设为主键\n\n# 基础操作\n\n## 展示所有的数据库\n\n```\nshow dbs\n```\n\n## 显示当前使用的数据库\n\n```\ndb\n```\n\n## 切换数据库\n\n```\nuse db1\n```\n\n即可切换到db1数据库\n\n### 数据库命名规则\n\n1 不能是空字符串（\"\")。\n2 不得含有' '（空格)、.、$、/、\\和\\0 (空字符)。\n3 应全部小写。\n4 最多64字节。\n\n下列有特殊意义的数据库名字需要保留\n\n1 admin： 从权限的角度来看，这是\"root\"数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。\n\n2 local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合\n\n3 config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。\n\n### 文档命名规则\n\n1 键不能含有\\0 (空字符)。这个字符用来表示键的结尾。\n2 .和$有特别的意义，只有在特定环境下才能使用。\n3 以下划线\"_\"开头的键是保留的(不是严格要求的)\n\n\n几个注意点\n\n1 文档中的键/值对是有序的。\n2 文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。\n3 MongoDB区分类型和大小写。\n4 MongoDB的文档不能有重复的键。\n5 文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符\n\n### 集合命名规则\n\n1 集合名不能是空字符串\"\"。\n2 集合名不能含有\\0字符（空字符)，这个字符表示集合名的结尾。\n3 集合名不能以\"system.\"开头，这是为系统集合保留的前缀。\n4 用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。\n\ncapped collections\n\ncapped collections就是具有固定大小的collections。类似于队列，通过插入顺序来判断过期现象。\n\n```\ndb.createCollection(\"mycoll\", {capped:true, size:100000})\n```\n\n在capped collection中，你能添加新的对象。\n能进行更新，然而，对象不会增加存储空间。如果增加，更新就会失败 。\n数据库不允许进行删除。使用drop()方法删除collection所有的行。\n注意: 删除之后，你必须显式的重新创建这个collection。\n在32bit机器中，capped collection最大存储为1e9( 1X109)个字节。\n\n\n### 元数据\n\n数据库的信息是存储在集合中。它们使用了系统的命名空间：\n\n```\ndbname.system.*\n```\n\ndbname.system.namespaces -> 列出所有名字空间。\n\ndbname.system.indexes -> 列出所有索引。\n\ndbname.system.profile -> 包含数据库概要(profile)信息。\n\ndbname.system.users\t-> 列出所有可访问数据库的用户。\n\ndbname.local.sources -> 包含复制对端（slave）的服务器信息和状态。\n\n对于修改系统集合中的对象有如下限制。\n\n在{{system.indexes}}插入数据，可以创建索引。但除此之外该表信息是不可变的(特殊的drop index命令将自动更新相关信息)。\n\n{{system.users}}是可修改的。 {{system.profile}}是可删除的。\n\n### MongoDB 数据类型\n\nString -> 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。\n\nInteger -> 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。\n\nBoolean -> 布尔值。用于存储布尔值（真/假）。\n\nDouble -> 双精度浮点值。用于存储浮点值。\n\nMin/Max keys -> 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。\n\nArray -> 用于将数组或列表或多个值存储为一个键。\n\nTimestamp -> 时间戳。记录文档修改或添加的具体时间。\n\nObject -> 用于内嵌文档。\n\nNull -> 用于创建空值。\n\nSymbol -> 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。\n\nDate -> 日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。\n\nObject ID -> 对象 ID。用于创建文档的 ID。\n\nBinary Data -> 二进制数据。用于存储二进制数据。\n\nCode -> 代码类型。用于在文档中存储 JavaScript 代码。\n\nRegular expression -> 正则表达式类型。用于存储正则表达式。\n\n#### ObjectId\n\n1 前 4 个字节表示创建 unix时间戳,格林尼治时间 UTC 时间，比北京时间晚了 8 个小时\n2 接下来的 3 个字节是机器标识码\n3 紧接的两个字节由进程 id 组成 PID\n4 最后三个字节是随机数\n\n#### 字符串\n\nBSON 字符串都是 UTF-8 编码。\n\n#### 时间戳\n\nBSON 有一个特殊的时间戳类型用于 MongoDB 内部使用，与普通的 日期 类型不相关。 时间戳值是一个 64 位的值。其中：\n\n前32位是一个 time_t 值（与Unix新纪元相差的秒数）\n后32位是在某秒中操作的一个递增的序数\n在单个 mongod 实例中，时间戳值通常是唯一的。\n\n#### 日期\n\n```\n> Date()\nSun Mar 04 2018 15:02:59 GMT+0000 (UTC)   \n```\n\n# 数据库连接\n\n## 使用默认端口来连接 MongoDB 的服务。\n\n```\nmongodb://localhost\n```\n\n## 通过 shell 连接 MongoDB 服务：\n\n```\n$ ./mongo\nMongoDB shell version: 3.0.6\nconnecting to: test\n...\n```\n\n# 创建数据库\n\n```\nuse DATABASE_NAME\n```\n\n# 删除数据库\n\n```\ndb.dropDatabase()\n```\n\n\n\n# 创建集合\n\n```\ndb.createCollection(name, options)\n```\n\nname: 要创建的集合名称\noptions: 可选参数, 指定有关内存大小及索引的选项\n\noptions可选：\ncapped -> 为true则是固定集合，需要同时指定size\nautoIndexId -> 为true自动在 _id 字段创建索引。默认为 false。\nsize -> （可选）为固定集合指定一个最大值（以字节计）。如果 capped 为 true，也需要指定该字段。\nmax -> （可选）指定固定集合中包含文档的最大数量。\n\n\n# 删除集合\n\n```\ndb.collection.drop()\n```\n\n# 插入文档\n\n```\ndb.COLLECTION_NAME.insert(document)\n```\n\n```\n>db.col.insert({title: 'MongoDB 教程', \n    description: 'MongoDB 是一个 Nosql 数据库',\n    by: '菜鸟教程',\n    url: 'http://www.runoob.com',\n    tags: ['mongodb', 'database', 'NoSQL'],\n    likes: 100\n})\n```\n\n```\n> document=({title: 'MongoDB 教程', \n    description: 'MongoDB 是一个 Nosql 数据库',\n    by: '菜鸟教程',\n    url: 'http://www.runoob.com',\n    tags: ['mongodb', 'database', 'NoSQL'],\n    likes: 100\n});\n> db.col.insert(document)\n```\n\n# 更新文档\n\n## update\n\n```\ndb.collection.update(\n   <query>,\n   <update>,\n   {\n     upsert: <boolean>,\n     multi: <boolean>,\n     writeConcern: <document>\n   }\n)\n```\n\n1 query : update的查询条件，类似sql update查询内where后面的。\n2 update : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sqlupdate查询内set后面的\n3 upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。\n4 multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。\n5 writeConcern :可选，抛出异常的级别。\n\ntip : 3.2之后可用下面方法\n```\ndb.test_collection.updateOne({\"name\":\"abc\"},{$set:{\"age\":\"28\"}})\n```\n\n```\ndb.test_collection.updateMany({\"age\":{$gt:\"10\"}},{$set:{\"status\":\"xyz\"}})\n```\n\n## save\n\n```\ndb.collection.save(\n   <document>,\n   {\n     writeConcern: <document>\n   }\n)\n```\n\n1 document : 文档数据。\n2 writeConcern :可选，抛出异常的级别。\n\n1 WriteConcern.NONE:没有异常抛出\n2 WriteConcern.NORMAL:仅抛出网络错误异常，没有服务器错误异常\n3 WriteConcern.SAFE:抛出网络错误异常、服务器错误异常；并等待服务器完成写操作。\n4 WriteConcern.MAJORITY: 抛出网络错误异常、服务器错误异常；并等待一个主服务器完成写操作。\n5 WriteConcern.FSYNC_SAFE: 抛出网络错误异常、服务器错误异常；写操作等待服务器将数据刷新到磁盘。\n6 WriteConcern.JOURNAL_SAFE:抛出网络错误异常、服务器错误异常；写操作等待服务器提交到磁盘的日志文件。\n7 WriteConcern.REPLICAS_SAFE:抛出网络错误异常、服务器错误异常；等待至少2台服务器完成写操作。\n\n# 删除文档\n\n```\ndb.collection.remove(\n   <query>,\n   <justOne>\n)\n```\n\n2.6以后\n\n```\ndb.collection.remove(\n   <query>,\n   {\n     justOne: <boolean>,\n     writeConcern: <document>\n   }\n)\n```\n\nquery :（可选）删除的文档的条件。\njustOne : （可选）如果设为 true 或 1，则只删除一个文档。\nwriteConcern :（可选）抛出异常的级别。\n\n\n想只删除找到的第一条\n\n```\ndb.COLLECTION_NAME.remove(DELETION_CRITERIA,1)\n```\n\n想删除所有\n```\ndb.col.remove({})\n```\n\n# 查询文档\n\n```\ndb.collection.find(query, projection)\n```\n\n1 query ：可选，使用查询操作符指定查询条件\n2 projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。\n\n```\ndb.col.find().pretty()\n```\n\n格式化显示\n\n## where 操作\n\n### 等于\n\n```\ndb.col.find({\"by\":\"菜鸟教程\"}).pretty()\n```\n\n等同于\n\n```\nwhere by = '菜鸟教程'\n```\n\n### 小于\n\n```\ndb.col.find({\"likes\":{$lt:50}}).pretty()\n```\n\n等同于\n\n```\nwhere likes < 50\n```\n\n### 小于等于\n\n```\ndb.col.find({\"likes\":{$lte:50}}).pretty()\n```\n\n等同于\n\n```\nwhere likes <= 50\n```\n\n### 大于\n\n```\ndb.col.find({\"likes\":{$gt:50}}).pretty()\n```\n\n等同于\n\n```\nwhere likes > 50\n```\n\n### 大于或等于\n\n```\ndb.col.find({\"likes\":{$gt:50}}).pretty()\n```\n\n等同于\n\n```\nwhere likes > 50\n```\n\n### 不等于\n\n```\ndb.col.find({\"likes\":{$ne:50}}).pretty()\n```\n\n等同于\n\n```\nwhere likes != 50\n```\n\n## and操作\n\n```\ndb.col.find({key1:value1, key2:value2}).pretty()\n```\n\n```\ndb.col.find({\"by\":\"菜鸟教程\", \"title\":\"MongoDB 教程\"}).pretty()\n```\n\n等同于\n\n```\nWHERE by='菜鸟教程' AND title='MongoDB 教程'\n```\n\n## or操作\n\n```\ndb.col.find(\n   {\n      $or: [\n         {key1: value1}, {key2:value2}\n      ]\n   }\n).pretty()\n```\n\n```\ndb.col.find({$or:[{\"by\":\"菜鸟教程\"},{\"title\": \"MongoDB 教程\"}]}).pretty()\n```\n\n## and 和 or 同时\n\n```\ndb.col.find({\"likes\": {$gt:50}, $or: [{\"by\": \"菜鸟教程\"},{\"title\": \"MongoDB 教程\"}]}).pretty()\t\n```\n\n# type操作符\n\n1 -> double\n2 -> string\n3 -> object\n4 -> array\n5 -> binary data\n6 -> Undefined(deprecated)\n7 -> object id\n8 -> boolean\n9 -> date\n10 -> null\n11 -> regular expression\n\n13 -> javascript\n14 -> symbol\n15 -> javascript with scope\n16 -> 32-bit integer\n17 -> timestamp\n18 -> 64-bit integer\n\n255 -> min key(query with -1)\n127 -> max key\n\n\n需要查找title 类型为string的，如下\n```\ndb.col.find({\"title\" : {$type : 2}})\n```\n\n# limit 和 skip\n\n```\n>db.COLLECTION_NAME.find().limit(NUMBER)\n```\nlimit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。\n\n```\n>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)\n```\nskip方法同样接受一个数字参数作为跳过的记录条数。\n\n# sort\n\n在MongoDB中使用使用sort()方法对数据进行排序，sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。\n\n```\n>db.COLLECTION_NAME.find().sort({KEY:1})\n```\n# 索引\n\nMongoDB使用 ensureIndex() 方法来创建索引。\n\n```\n>db.COLLECTION_NAME.ensureIndex({KEY:1})\n```\n\n语法中 Key 值为你要创建的索引字段，1为指定按升序创建索引，如果你想按降序来创建索引指定为-1即可。\n\n# 聚合\n\n主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。\n\n```\n>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)\n```\n\n$sum -> 计算总和 -> db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$sum : \"$likes\"}}}])\n\n$avg -> 计算平均值 -> db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$avg : \"$likes\"}}}])\n\n$min -> 获取集合中所有文档对应值最小值 -> db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$min : \"$likes\"}}}])\n\n$max -> 获取集合中所有文档对应值得最大值 -> db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$max : \"$likes\"}}}])\n\n$push -> 在结果文档中插入值到一个数组中 -> db.mycol.aggregate([{$group : {_id : \"$by_user\", url : {$push: \"$url\"}}}])\n\n$addToSet -> 在结果文档中插入值到一个数组中，但不创建副本 -> db.mycol.aggregate([{$group : {_id : \"$by_user\", url : {$addToSet : \"$url\"}}}])\n\n$first -> 根据资源文档的排序获取第一个文档数据 -> db.mycol.aggregate([{$group : {_id : \"$by_user\", first_url : {$first : \"$url\"}}}])\n\n$last -> 根据资源文档的排序获取最后一个文档数据 -> db.mycol.aggregate([{$group : {_id : \"$by_user\", last_url : {$last : \"$url\"}}}])\n\n# 复制\n\nMongoDB复制是将数据同步在多个服务器的过程。\n\n复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。\n\n复制还允许您从硬件故障和服务中断中恢复数据。\n\n## 含义\n\n1 保障数据的安全性\n2 数据高可用性 (24*7)\n3 灾难恢复\n4 无需停机维护（如备份，重建索引，压缩）\n5 分布式读取数据\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"mongodb安装、常用操作记录","published":1,"updated":"2019-03-12T09:26:33.160Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltu02006g3a8kp87ivt63","content":"<p>由于阿里云服务器切成了centos，故需要重新部署数据库，之前部署的sqlite是在是太low了，拿不出手，这次搞mongodb。</p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.6.tgz    # 下载</span><br><span class=\"line\">tar -zxvf mongodb-linux-x86_64-3.0.6.tgz                                   # 解压</span><br><span class=\"line\"></span><br><span class=\"line\">mv  mongodb-linux-x86_64-3.0.6/ /usr/local/mongodb                         # 将解压包拷贝到指定目录</span><br></pre></td></tr></table></figure>\n<h1 id=\"环境变量设置\"><a href=\"#环境变量设置\" class=\"headerlink\" title=\"环境变量设置\"></a>环境变量设置</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=&lt;mongodb-install-directory&gt;/bin:$PATH</span><br></pre></td></tr></table></figure>\n<h1 id=\"创建数据库目录\"><a href=\"#创建数据库目录\" class=\"headerlink\" title=\"创建数据库目录\"></a>创建数据库目录</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /</span><br><span class=\"line\">mkdir -p /data/db</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\"># 命令行中运行 MongoDB 服务</span><br></pre></td></tr></table></figure>\n<p>mongod<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">如果环境变量没设需要到相关目录下执行</span><br><span class=\"line\"></span><br><span class=\"line\"># 管理shell</span><br></pre></td></tr></table></figure></p>\n<p>mongo<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">环境变量问题同上。</span><br><span class=\"line\"></span><br><span class=\"line\"># 基础知识</span><br><span class=\"line\"></span><br><span class=\"line\">sql -&gt; mongodb -&gt; 意义</span><br><span class=\"line\"></span><br><span class=\"line\">database -&gt; databse -&gt; 数据库</span><br><span class=\"line\"></span><br><span class=\"line\">table -&gt; collection -&gt; 数据库表/集合</span><br><span class=\"line\"></span><br><span class=\"line\">row -&gt; document -&gt; 数据记录行/文档</span><br><span class=\"line\"></span><br><span class=\"line\">column -&gt; field -&gt; 数据字段/域</span><br><span class=\"line\"></span><br><span class=\"line\">index -&gt; index -&gt; 索引</span><br><span class=\"line\"></span><br><span class=\"line\">table joins  -&gt; null -&gt; 表连接</span><br><span class=\"line\"></span><br><span class=\"line\">primary key -&gt; primary key -&gt; 主键，mongodb自动将_id设为主键</span><br><span class=\"line\"></span><br><span class=\"line\"># 基础操作</span><br><span class=\"line\"></span><br><span class=\"line\">## 展示所有的数据库</span><br></pre></td></tr></table></figure></p>\n<p>show dbs<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 显示当前使用的数据库</span><br></pre></td></tr></table></figure></p>\n<p>db<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 切换数据库</span><br></pre></td></tr></table></figure></p>\n<p>use db1<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">即可切换到db1数据库</span><br><span class=\"line\"></span><br><span class=\"line\">### 数据库命名规则</span><br><span class=\"line\"></span><br><span class=\"line\">1 不能是空字符串（&quot;&quot;)。</span><br><span class=\"line\">2 不得含有&apos; &apos;（空格)、.、$、/、\\和\\0 (空字符)。</span><br><span class=\"line\">3 应全部小写。</span><br><span class=\"line\">4 最多64字节。</span><br><span class=\"line\"></span><br><span class=\"line\">下列有特殊意义的数据库名字需要保留</span><br><span class=\"line\"></span><br><span class=\"line\">1 admin： 从权限的角度来看，这是&quot;root&quot;数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</span><br><span class=\"line\"></span><br><span class=\"line\">2 local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</span><br><span class=\"line\"></span><br><span class=\"line\">3 config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</span><br><span class=\"line\"></span><br><span class=\"line\">### 文档命名规则</span><br><span class=\"line\"></span><br><span class=\"line\">1 键不能含有\\0 (空字符)。这个字符用来表示键的结尾。</span><br><span class=\"line\">2 .和$有特别的意义，只有在特定环境下才能使用。</span><br><span class=\"line\">3 以下划线&quot;_&quot;开头的键是保留的(不是严格要求的)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">几个注意点</span><br><span class=\"line\"></span><br><span class=\"line\">1 文档中的键/值对是有序的。</span><br><span class=\"line\">2 文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</span><br><span class=\"line\">3 MongoDB区分类型和大小写。</span><br><span class=\"line\">4 MongoDB的文档不能有重复的键。</span><br><span class=\"line\">5 文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符</span><br><span class=\"line\"></span><br><span class=\"line\">### 集合命名规则</span><br><span class=\"line\"></span><br><span class=\"line\">1 集合名不能是空字符串&quot;&quot;。</span><br><span class=\"line\">2 集合名不能含有\\0字符（空字符)，这个字符表示集合名的结尾。</span><br><span class=\"line\">3 集合名不能以&quot;system.&quot;开头，这是为系统集合保留的前缀。</span><br><span class=\"line\">4 用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。</span><br><span class=\"line\"></span><br><span class=\"line\">capped collections</span><br><span class=\"line\"></span><br><span class=\"line\">capped collections就是具有固定大小的collections。类似于队列，通过插入顺序来判断过期现象。</span><br></pre></td></tr></table></figure></p>\n<p>db.createCollection(“mycoll”, {capped:true, size:100000})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在capped collection中，你能添加新的对象。</span><br><span class=\"line\">能进行更新，然而，对象不会增加存储空间。如果增加，更新就会失败 。</span><br><span class=\"line\">数据库不允许进行删除。使用drop()方法删除collection所有的行。</span><br><span class=\"line\">注意: 删除之后，你必须显式的重新创建这个collection。</span><br><span class=\"line\">在32bit机器中，capped collection最大存储为1e9( 1X109)个字节。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 元数据</span><br><span class=\"line\"></span><br><span class=\"line\">数据库的信息是存储在集合中。它们使用了系统的命名空间：</span><br></pre></td></tr></table></figure></p>\n<p>dbname.system.*<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">dbname.system.namespaces -&gt; 列出所有名字空间。</span><br><span class=\"line\"></span><br><span class=\"line\">dbname.system.indexes -&gt; 列出所有索引。</span><br><span class=\"line\"></span><br><span class=\"line\">dbname.system.profile -&gt; 包含数据库概要(profile)信息。</span><br><span class=\"line\"></span><br><span class=\"line\">dbname.system.users\t-&gt; 列出所有可访问数据库的用户。</span><br><span class=\"line\"></span><br><span class=\"line\">dbname.local.sources -&gt; 包含复制对端（slave）的服务器信息和状态。</span><br><span class=\"line\"></span><br><span class=\"line\">对于修改系统集合中的对象有如下限制。</span><br><span class=\"line\"></span><br><span class=\"line\">在&#123;&#123;system.indexes&#125;&#125;插入数据，可以创建索引。但除此之外该表信息是不可变的(特殊的drop index命令将自动更新相关信息)。</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&#123;system.users&#125;&#125;是可修改的。 &#123;&#123;system.profile&#125;&#125;是可删除的。</span><br><span class=\"line\"></span><br><span class=\"line\">### MongoDB 数据类型</span><br><span class=\"line\"></span><br><span class=\"line\">String -&gt; 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。</span><br><span class=\"line\"></span><br><span class=\"line\">Integer -&gt; 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。</span><br><span class=\"line\"></span><br><span class=\"line\">Boolean -&gt; 布尔值。用于存储布尔值（真/假）。</span><br><span class=\"line\"></span><br><span class=\"line\">Double -&gt; 双精度浮点值。用于存储浮点值。</span><br><span class=\"line\"></span><br><span class=\"line\">Min/Max keys -&gt; 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。</span><br><span class=\"line\"></span><br><span class=\"line\">Array -&gt; 用于将数组或列表或多个值存储为一个键。</span><br><span class=\"line\"></span><br><span class=\"line\">Timestamp -&gt; 时间戳。记录文档修改或添加的具体时间。</span><br><span class=\"line\"></span><br><span class=\"line\">Object -&gt; 用于内嵌文档。</span><br><span class=\"line\"></span><br><span class=\"line\">Null -&gt; 用于创建空值。</span><br><span class=\"line\"></span><br><span class=\"line\">Symbol -&gt; 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</span><br><span class=\"line\"></span><br><span class=\"line\">Date -&gt; 日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</span><br><span class=\"line\"></span><br><span class=\"line\">Object ID -&gt; 对象 ID。用于创建文档的 ID。</span><br><span class=\"line\"></span><br><span class=\"line\">Binary Data -&gt; 二进制数据。用于存储二进制数据。</span><br><span class=\"line\"></span><br><span class=\"line\">Code -&gt; 代码类型。用于在文档中存储 JavaScript 代码。</span><br><span class=\"line\"></span><br><span class=\"line\">Regular expression -&gt; 正则表达式类型。用于存储正则表达式。</span><br><span class=\"line\"></span><br><span class=\"line\">#### ObjectId</span><br><span class=\"line\"></span><br><span class=\"line\">1 前 4 个字节表示创建 unix时间戳,格林尼治时间 UTC 时间，比北京时间晚了 8 个小时</span><br><span class=\"line\">2 接下来的 3 个字节是机器标识码</span><br><span class=\"line\">3 紧接的两个字节由进程 id 组成 PID</span><br><span class=\"line\">4 最后三个字节是随机数</span><br><span class=\"line\"></span><br><span class=\"line\">#### 字符串</span><br><span class=\"line\"></span><br><span class=\"line\">BSON 字符串都是 UTF-8 编码。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 时间戳</span><br><span class=\"line\"></span><br><span class=\"line\">BSON 有一个特殊的时间戳类型用于 MongoDB 内部使用，与普通的 日期 类型不相关。 时间戳值是一个 64 位的值。其中：</span><br><span class=\"line\"></span><br><span class=\"line\">前32位是一个 time_t 值（与Unix新纪元相差的秒数）</span><br><span class=\"line\">后32位是在某秒中操作的一个递增的序数</span><br><span class=\"line\">在单个 mongod 实例中，时间戳值通常是唯一的。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 日期</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Date()<br>Sun Mar 04 2018 15:02:59 GMT+0000 (UTC)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 数据库连接</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用默认端口来连接 MongoDB 的服务。</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>mongodb://localhost<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 通过 shell 连接 MongoDB 服务：</span><br></pre></td></tr></table></figure></p>\n<p>$ ./mongo<br>MongoDB shell version: 3.0.6<br>connecting to: test<br>…<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 创建数据库</span><br></pre></td></tr></table></figure></p>\n<p>use DATABASE_NAME<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 删除数据库</span><br></pre></td></tr></table></figure></p>\n<p>db.dropDatabase()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 创建集合</span><br></pre></td></tr></table></figure></p>\n<p>db.createCollection(name, options)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">name: 要创建的集合名称</span><br><span class=\"line\">options: 可选参数, 指定有关内存大小及索引的选项</span><br><span class=\"line\"></span><br><span class=\"line\">options可选：</span><br><span class=\"line\">capped -&gt; 为true则是固定集合，需要同时指定size</span><br><span class=\"line\">autoIndexId -&gt; 为true自动在 _id 字段创建索引。默认为 false。</span><br><span class=\"line\">size -&gt; （可选）为固定集合指定一个最大值（以字节计）。如果 capped 为 true，也需要指定该字段。</span><br><span class=\"line\">max -&gt; （可选）指定固定集合中包含文档的最大数量。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 删除集合</span><br></pre></td></tr></table></figure></p>\n<p>db.collection.drop()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 插入文档</span><br></pre></td></tr></table></figure></p>\n<p>db.COLLECTION_NAME.insert(document)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>db.col.insert({title: ‘MongoDB 教程’,<br>    description: ‘MongoDB 是一个 Nosql 数据库’,<br>    by: ‘菜鸟教程’,<br>    url: ‘<a href=\"http://www.runoob.com&#39;\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com&#39;</a>,<br>    tags: [‘mongodb’, ‘database’, ‘NoSQL’],<br>    likes: 100<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>document=({title: ‘MongoDB 教程’,<br>    description: ‘MongoDB 是一个 Nosql 数据库’,<br>    by: ‘菜鸟教程’,<br>    url: ‘<a href=\"http://www.runoob.com&#39;\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com&#39;</a>,<br>    tags: [‘mongodb’, ‘database’, ‘NoSQL’],<br>    likes: 100<br>});<br>db.col.insert(document)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 更新文档</span><br><span class=\"line\"></span><br><span class=\"line\">## update</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>db.collection.update(<br>   <query>,<br>   <update>,<br>   {<br>     upsert: <boolean>,<br>     multi: <boolean>,<br>     writeConcern: <document><br>   }<br>)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">1 query : update的查询条件，类似sql update查询内where后面的。</span><br><span class=\"line\">2 update : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sqlupdate查询内set后面的</span><br><span class=\"line\">3 upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</span><br><span class=\"line\">4 multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</span><br><span class=\"line\">5 writeConcern :可选，抛出异常的级别。</span><br><span class=\"line\"></span><br><span class=\"line\">tip : 3.2之后可用下面方法</span><br></pre></td></tr></table></figure></document></boolean></boolean></update></query></p>\n<p>db.test_collection.updateOne({“name”:”abc”},{$set:{“age”:”28”}})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>db.test_collection.updateMany({“age”:{$gt:”10”}},{$set:{“status”:”xyz”}})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## save</span><br></pre></td></tr></table></figure></p>\n<p>db.collection.save(<br>   <document>,<br>   {<br>     writeConcern: <document><br>   }<br>)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">1 document : 文档数据。</span><br><span class=\"line\">2 writeConcern :可选，抛出异常的级别。</span><br><span class=\"line\"></span><br><span class=\"line\">1 WriteConcern.NONE:没有异常抛出</span><br><span class=\"line\">2 WriteConcern.NORMAL:仅抛出网络错误异常，没有服务器错误异常</span><br><span class=\"line\">3 WriteConcern.SAFE:抛出网络错误异常、服务器错误异常；并等待服务器完成写操作。</span><br><span class=\"line\">4 WriteConcern.MAJORITY: 抛出网络错误异常、服务器错误异常；并等待一个主服务器完成写操作。</span><br><span class=\"line\">5 WriteConcern.FSYNC_SAFE: 抛出网络错误异常、服务器错误异常；写操作等待服务器将数据刷新到磁盘。</span><br><span class=\"line\">6 WriteConcern.JOURNAL_SAFE:抛出网络错误异常、服务器错误异常；写操作等待服务器提交到磁盘的日志文件。</span><br><span class=\"line\">7 WriteConcern.REPLICAS_SAFE:抛出网络错误异常、服务器错误异常；等待至少2台服务器完成写操作。</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除文档</span><br></pre></td></tr></table></figure></document></document></p>\n<p>db.collection.remove(<br>   <query>,<br>   <justone><br>)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2.6以后</span><br></pre></td></tr></table></figure></justone></query></p>\n<p>db.collection.remove(<br>   <query>,<br>   {<br>     justOne: <boolean>,<br>     writeConcern: <document><br>   }<br>)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">query :（可选）删除的文档的条件。</span><br><span class=\"line\">justOne : （可选）如果设为 true 或 1，则只删除一个文档。</span><br><span class=\"line\">writeConcern :（可选）抛出异常的级别。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">想只删除找到的第一条</span><br></pre></td></tr></table></figure></document></boolean></query></p>\n<p>db.COLLECTION_NAME.remove(DELETION_CRITERIA,1)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">想删除所有</span><br></pre></td></tr></table></figure></p>\n<p>db.col.remove({})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 查询文档</span><br></pre></td></tr></table></figure></p>\n<p>db.collection.find(query, projection)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">1 query ：可选，使用查询操作符指定查询条件</span><br><span class=\"line\">2 projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find().pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">格式化显示</span><br><span class=\"line\"></span><br><span class=\"line\">## where 操作</span><br><span class=\"line\"></span><br><span class=\"line\">### 等于</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({“by”:”菜鸟教程”}).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">等同于</span><br></pre></td></tr></table></figure></p>\n<p>where by = ‘菜鸟教程’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 小于</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({“likes”:{$lt:50}}).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">等同于</span><br></pre></td></tr></table></figure></p>\n<p>where likes &lt; 50<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 小于等于</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({“likes”:{$lte:50}}).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">等同于</span><br></pre></td></tr></table></figure></p>\n<p>where likes &lt;= 50<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 大于</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({“likes”:{$gt:50}}).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">等同于</span><br></pre></td></tr></table></figure></p>\n<p>where likes &gt; 50<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 大于或等于</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({“likes”:{$gt:50}}).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">等同于</span><br></pre></td></tr></table></figure></p>\n<p>where likes &gt; 50<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 不等于</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({“likes”:{$ne:50}}).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">等同于</span><br></pre></td></tr></table></figure></p>\n<p>where likes != 50<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## and操作</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({key1:value1, key2:value2}).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({“by”:”菜鸟教程”, “title”:”MongoDB 教程”}).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">等同于</span><br></pre></td></tr></table></figure></p>\n<p>WHERE by=’菜鸟教程’ AND title=’MongoDB 教程’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## or操作</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find(<br>   {<br>      $or: [<br>         {key1: value1}, {key2:value2}<br>      ]<br>   }<br>).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({$or:[{“by”:”菜鸟教程”},{“title”: “MongoDB 教程”}]}).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## and 和 or 同时</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({“likes”: {$gt:50}, $or: [{“by”: “菜鸟教程”},{“title”: “MongoDB 教程”}]}).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># type操作符</span><br><span class=\"line\"></span><br><span class=\"line\">1 -&gt; double</span><br><span class=\"line\">2 -&gt; string</span><br><span class=\"line\">3 -&gt; object</span><br><span class=\"line\">4 -&gt; array</span><br><span class=\"line\">5 -&gt; binary data</span><br><span class=\"line\">6 -&gt; Undefined(deprecated)</span><br><span class=\"line\">7 -&gt; object id</span><br><span class=\"line\">8 -&gt; boolean</span><br><span class=\"line\">9 -&gt; date</span><br><span class=\"line\">10 -&gt; null</span><br><span class=\"line\">11 -&gt; regular expression</span><br><span class=\"line\"></span><br><span class=\"line\">13 -&gt; javascript</span><br><span class=\"line\">14 -&gt; symbol</span><br><span class=\"line\">15 -&gt; javascript with scope</span><br><span class=\"line\">16 -&gt; 32-bit integer</span><br><span class=\"line\">17 -&gt; timestamp</span><br><span class=\"line\">18 -&gt; 64-bit integer</span><br><span class=\"line\"></span><br><span class=\"line\">255 -&gt; min key(query with -1)</span><br><span class=\"line\">127 -&gt; max key</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">需要查找title 类型为string的，如下</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({“title” : {$type : 2}})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># limit 和 skip</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>db.COLLECTION_NAME.find().limit(NUMBER)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">limit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">skip方法同样接受一个数字参数作为跳过的记录条数。</span><br><span class=\"line\"></span><br><span class=\"line\"># sort</span><br><span class=\"line\"></span><br><span class=\"line\">在MongoDB中使用使用sort()方法对数据进行排序，sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>db.COLLECTION_NAME.find().sort({KEY:1})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 索引</span><br><span class=\"line\"></span><br><span class=\"line\">MongoDB使用 ensureIndex() 方法来创建索引。</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>db.COLLECTION_NAME.ensureIndex({KEY:1})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">语法中 Key 值为你要创建的索引字段，1为指定按升序创建索引，如果你想按降序来创建索引指定为-1即可。</span><br><span class=\"line\"></span><br><span class=\"line\"># 聚合</span><br><span class=\"line\"></span><br><span class=\"line\">主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)<br><code>`</code></p>\n</blockquote>\n<p>$sum -&gt; 计算总和 -&gt; db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])</p>\n<p>$avg -&gt; 计算平均值 -&gt; db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])</p>\n<p>$min -&gt; 获取集合中所有文档对应值最小值 -&gt; db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])</p>\n<p>$max -&gt; 获取集合中所有文档对应值得最大值 -&gt; db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}])</p>\n<p>$push -&gt; 在结果文档中插入值到一个数组中 -&gt; db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])</p>\n<p>$addToSet -&gt; 在结果文档中插入值到一个数组中，但不创建副本 -&gt; db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])</p>\n<p>$first -&gt; 根据资源文档的排序获取第一个文档数据 -&gt; db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])</p>\n<p>$last -&gt; 根据资源文档的排序获取最后一个文档数据 -&gt; db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}])</p>\n<h1 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h1><p>MongoDB复制是将数据同步在多个服务器的过程。</p>\n<p>复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。</p>\n<p>复制还允许您从硬件故障和服务中断中恢复数据。</p>\n<h2 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h2><p>1 保障数据的安全性<br>2 数据高可用性 (24*7)<br>3 灾难恢复<br>4 无需停机维护（如备份，重建索引，压缩）<br>5 分布式读取数据</p>\n","site":{"data":{}},"excerpt":"","more":"<p>由于阿里云服务器切成了centos，故需要重新部署数据库，之前部署的sqlite是在是太low了，拿不出手，这次搞mongodb。</p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.6.tgz    # 下载</span><br><span class=\"line\">tar -zxvf mongodb-linux-x86_64-3.0.6.tgz                                   # 解压</span><br><span class=\"line\"></span><br><span class=\"line\">mv  mongodb-linux-x86_64-3.0.6/ /usr/local/mongodb                         # 将解压包拷贝到指定目录</span><br></pre></td></tr></table></figure>\n<h1 id=\"环境变量设置\"><a href=\"#环境变量设置\" class=\"headerlink\" title=\"环境变量设置\"></a>环境变量设置</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=&lt;mongodb-install-directory&gt;/bin:$PATH</span><br></pre></td></tr></table></figure>\n<h1 id=\"创建数据库目录\"><a href=\"#创建数据库目录\" class=\"headerlink\" title=\"创建数据库目录\"></a>创建数据库目录</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /</span><br><span class=\"line\">mkdir -p /data/db</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\"># 命令行中运行 MongoDB 服务</span><br></pre></td></tr></table></figure>\n<p>mongod<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">如果环境变量没设需要到相关目录下执行</span><br><span class=\"line\"></span><br><span class=\"line\"># 管理shell</span><br></pre></td></tr></table></figure></p>\n<p>mongo<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">环境变量问题同上。</span><br><span class=\"line\"></span><br><span class=\"line\"># 基础知识</span><br><span class=\"line\"></span><br><span class=\"line\">sql -&gt; mongodb -&gt; 意义</span><br><span class=\"line\"></span><br><span class=\"line\">database -&gt; databse -&gt; 数据库</span><br><span class=\"line\"></span><br><span class=\"line\">table -&gt; collection -&gt; 数据库表/集合</span><br><span class=\"line\"></span><br><span class=\"line\">row -&gt; document -&gt; 数据记录行/文档</span><br><span class=\"line\"></span><br><span class=\"line\">column -&gt; field -&gt; 数据字段/域</span><br><span class=\"line\"></span><br><span class=\"line\">index -&gt; index -&gt; 索引</span><br><span class=\"line\"></span><br><span class=\"line\">table joins  -&gt; null -&gt; 表连接</span><br><span class=\"line\"></span><br><span class=\"line\">primary key -&gt; primary key -&gt; 主键，mongodb自动将_id设为主键</span><br><span class=\"line\"></span><br><span class=\"line\"># 基础操作</span><br><span class=\"line\"></span><br><span class=\"line\">## 展示所有的数据库</span><br></pre></td></tr></table></figure></p>\n<p>show dbs<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 显示当前使用的数据库</span><br></pre></td></tr></table></figure></p>\n<p>db<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 切换数据库</span><br></pre></td></tr></table></figure></p>\n<p>use db1<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">即可切换到db1数据库</span><br><span class=\"line\"></span><br><span class=\"line\">### 数据库命名规则</span><br><span class=\"line\"></span><br><span class=\"line\">1 不能是空字符串（&quot;&quot;)。</span><br><span class=\"line\">2 不得含有&apos; &apos;（空格)、.、$、/、\\和\\0 (空字符)。</span><br><span class=\"line\">3 应全部小写。</span><br><span class=\"line\">4 最多64字节。</span><br><span class=\"line\"></span><br><span class=\"line\">下列有特殊意义的数据库名字需要保留</span><br><span class=\"line\"></span><br><span class=\"line\">1 admin： 从权限的角度来看，这是&quot;root&quot;数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</span><br><span class=\"line\"></span><br><span class=\"line\">2 local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</span><br><span class=\"line\"></span><br><span class=\"line\">3 config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</span><br><span class=\"line\"></span><br><span class=\"line\">### 文档命名规则</span><br><span class=\"line\"></span><br><span class=\"line\">1 键不能含有\\0 (空字符)。这个字符用来表示键的结尾。</span><br><span class=\"line\">2 .和$有特别的意义，只有在特定环境下才能使用。</span><br><span class=\"line\">3 以下划线&quot;_&quot;开头的键是保留的(不是严格要求的)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">几个注意点</span><br><span class=\"line\"></span><br><span class=\"line\">1 文档中的键/值对是有序的。</span><br><span class=\"line\">2 文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</span><br><span class=\"line\">3 MongoDB区分类型和大小写。</span><br><span class=\"line\">4 MongoDB的文档不能有重复的键。</span><br><span class=\"line\">5 文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符</span><br><span class=\"line\"></span><br><span class=\"line\">### 集合命名规则</span><br><span class=\"line\"></span><br><span class=\"line\">1 集合名不能是空字符串&quot;&quot;。</span><br><span class=\"line\">2 集合名不能含有\\0字符（空字符)，这个字符表示集合名的结尾。</span><br><span class=\"line\">3 集合名不能以&quot;system.&quot;开头，这是为系统集合保留的前缀。</span><br><span class=\"line\">4 用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。</span><br><span class=\"line\"></span><br><span class=\"line\">capped collections</span><br><span class=\"line\"></span><br><span class=\"line\">capped collections就是具有固定大小的collections。类似于队列，通过插入顺序来判断过期现象。</span><br></pre></td></tr></table></figure></p>\n<p>db.createCollection(“mycoll”, {capped:true, size:100000})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在capped collection中，你能添加新的对象。</span><br><span class=\"line\">能进行更新，然而，对象不会增加存储空间。如果增加，更新就会失败 。</span><br><span class=\"line\">数据库不允许进行删除。使用drop()方法删除collection所有的行。</span><br><span class=\"line\">注意: 删除之后，你必须显式的重新创建这个collection。</span><br><span class=\"line\">在32bit机器中，capped collection最大存储为1e9( 1X109)个字节。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 元数据</span><br><span class=\"line\"></span><br><span class=\"line\">数据库的信息是存储在集合中。它们使用了系统的命名空间：</span><br></pre></td></tr></table></figure></p>\n<p>dbname.system.*<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">dbname.system.namespaces -&gt; 列出所有名字空间。</span><br><span class=\"line\"></span><br><span class=\"line\">dbname.system.indexes -&gt; 列出所有索引。</span><br><span class=\"line\"></span><br><span class=\"line\">dbname.system.profile -&gt; 包含数据库概要(profile)信息。</span><br><span class=\"line\"></span><br><span class=\"line\">dbname.system.users\t-&gt; 列出所有可访问数据库的用户。</span><br><span class=\"line\"></span><br><span class=\"line\">dbname.local.sources -&gt; 包含复制对端（slave）的服务器信息和状态。</span><br><span class=\"line\"></span><br><span class=\"line\">对于修改系统集合中的对象有如下限制。</span><br><span class=\"line\"></span><br><span class=\"line\">在&#123;&#123;system.indexes&#125;&#125;插入数据，可以创建索引。但除此之外该表信息是不可变的(特殊的drop index命令将自动更新相关信息)。</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&#123;system.users&#125;&#125;是可修改的。 &#123;&#123;system.profile&#125;&#125;是可删除的。</span><br><span class=\"line\"></span><br><span class=\"line\">### MongoDB 数据类型</span><br><span class=\"line\"></span><br><span class=\"line\">String -&gt; 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。</span><br><span class=\"line\"></span><br><span class=\"line\">Integer -&gt; 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。</span><br><span class=\"line\"></span><br><span class=\"line\">Boolean -&gt; 布尔值。用于存储布尔值（真/假）。</span><br><span class=\"line\"></span><br><span class=\"line\">Double -&gt; 双精度浮点值。用于存储浮点值。</span><br><span class=\"line\"></span><br><span class=\"line\">Min/Max keys -&gt; 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。</span><br><span class=\"line\"></span><br><span class=\"line\">Array -&gt; 用于将数组或列表或多个值存储为一个键。</span><br><span class=\"line\"></span><br><span class=\"line\">Timestamp -&gt; 时间戳。记录文档修改或添加的具体时间。</span><br><span class=\"line\"></span><br><span class=\"line\">Object -&gt; 用于内嵌文档。</span><br><span class=\"line\"></span><br><span class=\"line\">Null -&gt; 用于创建空值。</span><br><span class=\"line\"></span><br><span class=\"line\">Symbol -&gt; 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</span><br><span class=\"line\"></span><br><span class=\"line\">Date -&gt; 日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</span><br><span class=\"line\"></span><br><span class=\"line\">Object ID -&gt; 对象 ID。用于创建文档的 ID。</span><br><span class=\"line\"></span><br><span class=\"line\">Binary Data -&gt; 二进制数据。用于存储二进制数据。</span><br><span class=\"line\"></span><br><span class=\"line\">Code -&gt; 代码类型。用于在文档中存储 JavaScript 代码。</span><br><span class=\"line\"></span><br><span class=\"line\">Regular expression -&gt; 正则表达式类型。用于存储正则表达式。</span><br><span class=\"line\"></span><br><span class=\"line\">#### ObjectId</span><br><span class=\"line\"></span><br><span class=\"line\">1 前 4 个字节表示创建 unix时间戳,格林尼治时间 UTC 时间，比北京时间晚了 8 个小时</span><br><span class=\"line\">2 接下来的 3 个字节是机器标识码</span><br><span class=\"line\">3 紧接的两个字节由进程 id 组成 PID</span><br><span class=\"line\">4 最后三个字节是随机数</span><br><span class=\"line\"></span><br><span class=\"line\">#### 字符串</span><br><span class=\"line\"></span><br><span class=\"line\">BSON 字符串都是 UTF-8 编码。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 时间戳</span><br><span class=\"line\"></span><br><span class=\"line\">BSON 有一个特殊的时间戳类型用于 MongoDB 内部使用，与普通的 日期 类型不相关。 时间戳值是一个 64 位的值。其中：</span><br><span class=\"line\"></span><br><span class=\"line\">前32位是一个 time_t 值（与Unix新纪元相差的秒数）</span><br><span class=\"line\">后32位是在某秒中操作的一个递增的序数</span><br><span class=\"line\">在单个 mongod 实例中，时间戳值通常是唯一的。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 日期</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Date()<br>Sun Mar 04 2018 15:02:59 GMT+0000 (UTC)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 数据库连接</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用默认端口来连接 MongoDB 的服务。</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>mongodb://localhost<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 通过 shell 连接 MongoDB 服务：</span><br></pre></td></tr></table></figure></p>\n<p>$ ./mongo<br>MongoDB shell version: 3.0.6<br>connecting to: test<br>…<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 创建数据库</span><br></pre></td></tr></table></figure></p>\n<p>use DATABASE_NAME<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 删除数据库</span><br></pre></td></tr></table></figure></p>\n<p>db.dropDatabase()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 创建集合</span><br></pre></td></tr></table></figure></p>\n<p>db.createCollection(name, options)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">name: 要创建的集合名称</span><br><span class=\"line\">options: 可选参数, 指定有关内存大小及索引的选项</span><br><span class=\"line\"></span><br><span class=\"line\">options可选：</span><br><span class=\"line\">capped -&gt; 为true则是固定集合，需要同时指定size</span><br><span class=\"line\">autoIndexId -&gt; 为true自动在 _id 字段创建索引。默认为 false。</span><br><span class=\"line\">size -&gt; （可选）为固定集合指定一个最大值（以字节计）。如果 capped 为 true，也需要指定该字段。</span><br><span class=\"line\">max -&gt; （可选）指定固定集合中包含文档的最大数量。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 删除集合</span><br></pre></td></tr></table></figure></p>\n<p>db.collection.drop()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 插入文档</span><br></pre></td></tr></table></figure></p>\n<p>db.COLLECTION_NAME.insert(document)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>db.col.insert({title: ‘MongoDB 教程’,<br>    description: ‘MongoDB 是一个 Nosql 数据库’,<br>    by: ‘菜鸟教程’,<br>    url: ‘<a href=\"http://www.runoob.com&#39;\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com&#39;</a>,<br>    tags: [‘mongodb’, ‘database’, ‘NoSQL’],<br>    likes: 100<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>document=({title: ‘MongoDB 教程’,<br>    description: ‘MongoDB 是一个 Nosql 数据库’,<br>    by: ‘菜鸟教程’,<br>    url: ‘<a href=\"http://www.runoob.com&#39;\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com&#39;</a>,<br>    tags: [‘mongodb’, ‘database’, ‘NoSQL’],<br>    likes: 100<br>});<br>db.col.insert(document)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 更新文档</span><br><span class=\"line\"></span><br><span class=\"line\">## update</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>db.collection.update(<br>   <query>,<br>   <update>,<br>   {<br>     upsert: <boolean>,<br>     multi: <boolean>,<br>     writeConcern: <document><br>   }<br>)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">1 query : update的查询条件，类似sql update查询内where后面的。</span><br><span class=\"line\">2 update : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sqlupdate查询内set后面的</span><br><span class=\"line\">3 upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</span><br><span class=\"line\">4 multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</span><br><span class=\"line\">5 writeConcern :可选，抛出异常的级别。</span><br><span class=\"line\"></span><br><span class=\"line\">tip : 3.2之后可用下面方法</span><br></pre></td></tr></table></figure></document></boolean></boolean></update></query></p>\n<p>db.test_collection.updateOne({“name”:”abc”},{$set:{“age”:”28”}})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>db.test_collection.updateMany({“age”:{$gt:”10”}},{$set:{“status”:”xyz”}})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## save</span><br></pre></td></tr></table></figure></p>\n<p>db.collection.save(<br>   <document>,<br>   {<br>     writeConcern: <document><br>   }<br>)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">1 document : 文档数据。</span><br><span class=\"line\">2 writeConcern :可选，抛出异常的级别。</span><br><span class=\"line\"></span><br><span class=\"line\">1 WriteConcern.NONE:没有异常抛出</span><br><span class=\"line\">2 WriteConcern.NORMAL:仅抛出网络错误异常，没有服务器错误异常</span><br><span class=\"line\">3 WriteConcern.SAFE:抛出网络错误异常、服务器错误异常；并等待服务器完成写操作。</span><br><span class=\"line\">4 WriteConcern.MAJORITY: 抛出网络错误异常、服务器错误异常；并等待一个主服务器完成写操作。</span><br><span class=\"line\">5 WriteConcern.FSYNC_SAFE: 抛出网络错误异常、服务器错误异常；写操作等待服务器将数据刷新到磁盘。</span><br><span class=\"line\">6 WriteConcern.JOURNAL_SAFE:抛出网络错误异常、服务器错误异常；写操作等待服务器提交到磁盘的日志文件。</span><br><span class=\"line\">7 WriteConcern.REPLICAS_SAFE:抛出网络错误异常、服务器错误异常；等待至少2台服务器完成写操作。</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除文档</span><br></pre></td></tr></table></figure></document></document></p>\n<p>db.collection.remove(<br>   <query>,<br>   <justone><br>)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2.6以后</span><br></pre></td></tr></table></figure></justone></query></p>\n<p>db.collection.remove(<br>   <query>,<br>   {<br>     justOne: <boolean>,<br>     writeConcern: <document><br>   }<br>)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">query :（可选）删除的文档的条件。</span><br><span class=\"line\">justOne : （可选）如果设为 true 或 1，则只删除一个文档。</span><br><span class=\"line\">writeConcern :（可选）抛出异常的级别。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">想只删除找到的第一条</span><br></pre></td></tr></table></figure></document></boolean></query></p>\n<p>db.COLLECTION_NAME.remove(DELETION_CRITERIA,1)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">想删除所有</span><br></pre></td></tr></table></figure></p>\n<p>db.col.remove({})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 查询文档</span><br></pre></td></tr></table></figure></p>\n<p>db.collection.find(query, projection)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">1 query ：可选，使用查询操作符指定查询条件</span><br><span class=\"line\">2 projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find().pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">格式化显示</span><br><span class=\"line\"></span><br><span class=\"line\">## where 操作</span><br><span class=\"line\"></span><br><span class=\"line\">### 等于</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({“by”:”菜鸟教程”}).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">等同于</span><br></pre></td></tr></table></figure></p>\n<p>where by = ‘菜鸟教程’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 小于</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({“likes”:{$lt:50}}).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">等同于</span><br></pre></td></tr></table></figure></p>\n<p>where likes &lt; 50<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 小于等于</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({“likes”:{$lte:50}}).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">等同于</span><br></pre></td></tr></table></figure></p>\n<p>where likes &lt;= 50<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 大于</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({“likes”:{$gt:50}}).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">等同于</span><br></pre></td></tr></table></figure></p>\n<p>where likes &gt; 50<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 大于或等于</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({“likes”:{$gt:50}}).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">等同于</span><br></pre></td></tr></table></figure></p>\n<p>where likes &gt; 50<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 不等于</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({“likes”:{$ne:50}}).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">等同于</span><br></pre></td></tr></table></figure></p>\n<p>where likes != 50<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## and操作</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({key1:value1, key2:value2}).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({“by”:”菜鸟教程”, “title”:”MongoDB 教程”}).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">等同于</span><br></pre></td></tr></table></figure></p>\n<p>WHERE by=’菜鸟教程’ AND title=’MongoDB 教程’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## or操作</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find(<br>   {<br>      $or: [<br>         {key1: value1}, {key2:value2}<br>      ]<br>   }<br>).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({$or:[{“by”:”菜鸟教程”},{“title”: “MongoDB 教程”}]}).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## and 和 or 同时</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({“likes”: {$gt:50}, $or: [{“by”: “菜鸟教程”},{“title”: “MongoDB 教程”}]}).pretty()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># type操作符</span><br><span class=\"line\"></span><br><span class=\"line\">1 -&gt; double</span><br><span class=\"line\">2 -&gt; string</span><br><span class=\"line\">3 -&gt; object</span><br><span class=\"line\">4 -&gt; array</span><br><span class=\"line\">5 -&gt; binary data</span><br><span class=\"line\">6 -&gt; Undefined(deprecated)</span><br><span class=\"line\">7 -&gt; object id</span><br><span class=\"line\">8 -&gt; boolean</span><br><span class=\"line\">9 -&gt; date</span><br><span class=\"line\">10 -&gt; null</span><br><span class=\"line\">11 -&gt; regular expression</span><br><span class=\"line\"></span><br><span class=\"line\">13 -&gt; javascript</span><br><span class=\"line\">14 -&gt; symbol</span><br><span class=\"line\">15 -&gt; javascript with scope</span><br><span class=\"line\">16 -&gt; 32-bit integer</span><br><span class=\"line\">17 -&gt; timestamp</span><br><span class=\"line\">18 -&gt; 64-bit integer</span><br><span class=\"line\"></span><br><span class=\"line\">255 -&gt; min key(query with -1)</span><br><span class=\"line\">127 -&gt; max key</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">需要查找title 类型为string的，如下</span><br></pre></td></tr></table></figure></p>\n<p>db.col.find({“title” : {$type : 2}})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># limit 和 skip</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>db.COLLECTION_NAME.find().limit(NUMBER)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">limit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">skip方法同样接受一个数字参数作为跳过的记录条数。</span><br><span class=\"line\"></span><br><span class=\"line\"># sort</span><br><span class=\"line\"></span><br><span class=\"line\">在MongoDB中使用使用sort()方法对数据进行排序，sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>db.COLLECTION_NAME.find().sort({KEY:1})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 索引</span><br><span class=\"line\"></span><br><span class=\"line\">MongoDB使用 ensureIndex() 方法来创建索引。</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>db.COLLECTION_NAME.ensureIndex({KEY:1})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">语法中 Key 值为你要创建的索引字段，1为指定按升序创建索引，如果你想按降序来创建索引指定为-1即可。</span><br><span class=\"line\"></span><br><span class=\"line\"># 聚合</span><br><span class=\"line\"></span><br><span class=\"line\">主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)<br><code>`</code></p>\n</blockquote>\n<p>$sum -&gt; 计算总和 -&gt; db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])</p>\n<p>$avg -&gt; 计算平均值 -&gt; db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])</p>\n<p>$min -&gt; 获取集合中所有文档对应值最小值 -&gt; db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])</p>\n<p>$max -&gt; 获取集合中所有文档对应值得最大值 -&gt; db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}])</p>\n<p>$push -&gt; 在结果文档中插入值到一个数组中 -&gt; db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])</p>\n<p>$addToSet -&gt; 在结果文档中插入值到一个数组中，但不创建副本 -&gt; db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])</p>\n<p>$first -&gt; 根据资源文档的排序获取第一个文档数据 -&gt; db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])</p>\n<p>$last -&gt; 根据资源文档的排序获取最后一个文档数据 -&gt; db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}])</p>\n<h1 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h1><p>MongoDB复制是将数据同步在多个服务器的过程。</p>\n<p>复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。</p>\n<p>复制还允许您从硬件故障和服务中断中恢复数据。</p>\n<h2 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h2><p>1 保障数据的安全性<br>2 数据高可用性 (24*7)<br>3 灾难恢复<br>4 无需停机维护（如备份，重建索引，压缩）<br>5 分布式读取数据</p>\n"},{"title":"okio学习","date":"2018-12-11T06:36:35.000Z","_content":"\n# io\n\nio是java使用进行读取和写入的方式，i是input，o是output，走向是以内存为基准，内存中读数据是输入流，内存中往外写是输出流。\n\nio又分为字节流和字符流。字节流是直接对文件进行读写，是不中断的操作，不关闭字节流的话，操作仍然可以成功。而字符流是将文件的读写进行在缓冲区，当关闭的时候才会进行操作。\n\n字节流使用stream结尾，字符流使用reader和writer结尾。\n\n## 缓冲区\n\n缓冲区是一段内存区域，由于频繁的操作资源，会导致性能很低，而将数据存储到内存区域之后，之后的可以直接从区域中读取数据，读取内存数据的速度比较快，这样可以提升性能。\n\n字符流由于所有的数据都是暂存在内存中，如果想要清空缓存区，需要使用到flush操作，flush操作可以强制清空缓存区，因此会将缓存区的数据全部取出进行操作后清空。\n\n## 字节流和字符流优缺点\n\n- 字节流优点\n\n字节流的优点是使用到了缓存区，通过内存的使用加快了效率。字节流多用于处理图片，处理成为二进制字节。\n\n- 字符流优点\n\n字符流的优点是操作比较方便，提供了一些方便的例如readline这种功能。字符流多用于处理文字。\n\n# nio\n\nnio使用了缓存区、通道、管道来实现多线程io通信的问题\n\n## 通道\n\n通道的存在大大提升了对buffer区域的操作空间，获取buffer的操作不再是由buffer提供，而是由channel进行代理提供，类似于stream对象，但是channel是由selector管理的。selector提供了可以监听多个通道的功能，因此单线程中使用selector可以监听多个channel，而stream则需要每个开一个线程才能达到不阻塞的行为。这样就解决了需要多线程io的问题\n\n## 管道\n\n两个线程之间进行单项数据连接，会建立一个管道，数据被写到sink通道，读取的时候从source通道读取。\n\n### 管道的原理\n\n管道写函数时，通过将字节复制到VFS索引节点指向的物理内存而写入数据，管道读函数则通过复制物理内存中的字节而读出数据。缓冲区不需要很大，一般为4k大小，它被设计为环形的结构，以便能够循环利用，当管道没有信息的时候，从管道中读取的进程会等待，知道另一端的进程放入信息。当管道被放满信息的时候，放入信息的进程会等待，直到另一端的进程取出信息。\n\n## selector\n\nselector又被称为多路复用器，用于检查一个NIO channel的状态是否处于可读和可写。\n\n与selector一起使用的channel必须是非阻塞模式的，filechannel和selector就不能一起使用\n\n### selector原理\n\nchannel通过注册，使得selector可以统一管理多个channel，这样一个线程只需要通过一个selector就可以管理多个channel。注册是使用注册表的方式来进行。\n\n### selector多路复用的机制\n\n介于cpu目前多任务越来越快，因此selector效率也越来越高，多个任务同时触发，每个任务的阻塞设置超时时间，因此可以比较好的实现多路复用的机制\n\n# okio\n\nokio和nio的原理差不多，加上了buffer,信道，但是进行了优化，另外由于okio是设计用于网络请求的，所以加上了超时机制\n\n## sink构造\n\nsink是okio的信道,用于写入\n\n```\nprivate static Sink sink(final OutputStream out, final Timeout timeout) {\n    if (out == null) throw new IllegalArgumentException(\"out == null\");\n    if (timeout == null) throw new IllegalArgumentException(\"timeout == null\");\n\n    return new Sink() {\n      @Override public void write(Buffer source, long byteCount) throws IOException {\n        checkOffsetAndCount(source.size, 0, byteCount);\n        while (byteCount > 0) {\n          timeout.throwIfReached();\n          Segment head = source.head;\n          int toCopy = (int) Math.min(byteCount, head.limit - head.pos);\n          out.write(head.data, head.pos, toCopy);\n\n          head.pos += toCopy;\n          byteCount -= toCopy;\n          source.size -= toCopy;\n\n          if (head.pos == head.limit) {\n            source.head = head.pop();\n            SegmentPool.recycle(head);\n          }\n        }\n      }\n\n      @Override public void flush() throws IOException {\n        out.flush();\n      }\n\n      @Override public void close() throws IOException {\n        out.close();\n      }\n\n      @Override public Timeout timeout() {\n        return timeout;\n      }\n\n      @Override public String toString() {\n        return \"sink(\" + out + \")\";\n      }\n    };\n  }\n```\n\nsource是用于读取的信道\n\n```\nprivate static Source source(final InputStream in, final Timeout timeout) {\n    if (in == null) throw new IllegalArgumentException(\"in == null\");\n    if (timeout == null) throw new IllegalArgumentException(\"timeout == null\");\n\n    return new Source() {\n      @Override public long read(Buffer sink, long byteCount) throws IOException {\n        if (byteCount < 0) throw new IllegalArgumentException(\"byteCount < 0: \" + byteCount);\n        if (byteCount == 0) return 0;\n        try {\n          timeout.throwIfReached();\n          Segment tail = sink.writableSegment(1);\n          int maxToCopy = (int) Math.min(byteCount, Segment.SIZE - tail.limit);\n          int bytesRead = in.read(tail.data, tail.limit, maxToCopy);\n          if (bytesRead == -1) return -1;\n          tail.limit += bytesRead;\n          sink.size += bytesRead;\n          return bytesRead;\n        } catch (AssertionError e) {\n          if (isAndroidGetsocknameError(e)) throw new IOException(e);\n          throw e;\n        }\n      }\n\n      @Override public void close() throws IOException {\n        in.close();\n      }\n\n      @Override public Timeout timeout() {\n        return timeout;\n      }\n\n      @Override public String toString() {\n        return \"source(\" + in + \")\";\n      }\n    };\n  }\n```\n这种信道机制都是队列模式，关于超时判定永远在最先，超时是不在乎io的速度，而只关注io开始时是否超时，而这种读取和写入的方法都基本是一层while搞定。\n\n从source和sink可以看出来，okio通过Segment来做数据的处理单元，这是一种双链表结构。写入的时候将依照节点顺序写入，读的时候也是从缓存池里面取出头节点进行读取。\n\n```\nfinal class SegmentPool {\n  /** The maximum number of bytes to pool. */\n  // TODO: Is 64 KiB a good maximum size? Do we ever have that many idle segments?\n  static final long MAX_SIZE = 64 * 1024; // 64 KiB.\n\n  /** Singly-linked list of segments. */\n  static @Nullable Segment next;\n\n  /** Total bytes in this pool. */\n  static long byteCount;\n\n  private SegmentPool() {\n  }\n\n  static Segment take() {\n    synchronized (SegmentPool.class) {\n      if (next != null) {\n        Segment result = next;\n        next = result.next;\n        result.next = null;\n        byteCount -= Segment.SIZE;\n        return result;\n      }\n    }\n    return new Segment(); // Pool is empty. Don't zero-fill while holding a lock.\n  }\n\n  static void recycle(Segment segment) {\n    if (segment.next != null || segment.prev != null) throw new IllegalArgumentException();\n    if (segment.shared) return; // This segment cannot be recycled.\n    synchronized (SegmentPool.class) {\n      if (byteCount + Segment.SIZE > MAX_SIZE) return; // Pool is full.\n      byteCount += Segment.SIZE;\n      segment.next = next;\n      segment.pos = segment.limit = 0;\n      next = segment;\n    }\n  }\n}\n```\n\n整个缓存池并不知道能不能说是一个池，说是一个管理类感觉更好点，读取的时候通过sink.writableSegment(1)来获取,这是通过操作sink的buffer来做的处理\n\n```\nSegment writableSegment(int minimumCapacity) {\n    if (minimumCapacity < 1 || minimumCapacity > Segment.SIZE) throw new IllegalArgumentException();\n\n    if (head == null) {\n      head = SegmentPool.take(); // Acquire a first segment.\n      return head.next = head.prev = head;\n    }\n\n    Segment tail = head.prev;\n    if (tail.limit + minimumCapacity > Segment.SIZE || !tail.owner) {\n      tail = tail.push(SegmentPool.take()); // Append a new empty segment to fill up.\n    }\n    return tail;\n  }\n```\n\n这里比较抽象，有部分的操作是进行链表的判空等，空链表做了一些处理，最终返回的是可处理的队列的尾部（其实是指向队列头的引用，不过由于是push方式，所以头在底下，因此叫做尾部）\n\n获取了尾部之后就开始通过io进行读取，这就是读取的过程。\n\n相对于io来讲，这部分由于使用了自己的缓存，缓存直接取出来使用，对比拷贝效率更高效一些。\n\n## 总结一下\n\nokio在最终的写入和读出上面，都使用的原生io机制，但是okio维护了自己的buffer，这个buffer相对于原生来讲不需要在source时进行拷贝，也就是直接使用引用，效果更快。另外okio是针对网络相关的，所以okio增加了超时机制也是比原生更有优势的地方。","source":"_posts/okio学习.md","raw":"---\ntitle: okio学习\ndate: 2018-12-11 14:36:35\ntags: android \n---\n\n# io\n\nio是java使用进行读取和写入的方式，i是input，o是output，走向是以内存为基准，内存中读数据是输入流，内存中往外写是输出流。\n\nio又分为字节流和字符流。字节流是直接对文件进行读写，是不中断的操作，不关闭字节流的话，操作仍然可以成功。而字符流是将文件的读写进行在缓冲区，当关闭的时候才会进行操作。\n\n字节流使用stream结尾，字符流使用reader和writer结尾。\n\n## 缓冲区\n\n缓冲区是一段内存区域，由于频繁的操作资源，会导致性能很低，而将数据存储到内存区域之后，之后的可以直接从区域中读取数据，读取内存数据的速度比较快，这样可以提升性能。\n\n字符流由于所有的数据都是暂存在内存中，如果想要清空缓存区，需要使用到flush操作，flush操作可以强制清空缓存区，因此会将缓存区的数据全部取出进行操作后清空。\n\n## 字节流和字符流优缺点\n\n- 字节流优点\n\n字节流的优点是使用到了缓存区，通过内存的使用加快了效率。字节流多用于处理图片，处理成为二进制字节。\n\n- 字符流优点\n\n字符流的优点是操作比较方便，提供了一些方便的例如readline这种功能。字符流多用于处理文字。\n\n# nio\n\nnio使用了缓存区、通道、管道来实现多线程io通信的问题\n\n## 通道\n\n通道的存在大大提升了对buffer区域的操作空间，获取buffer的操作不再是由buffer提供，而是由channel进行代理提供，类似于stream对象，但是channel是由selector管理的。selector提供了可以监听多个通道的功能，因此单线程中使用selector可以监听多个channel，而stream则需要每个开一个线程才能达到不阻塞的行为。这样就解决了需要多线程io的问题\n\n## 管道\n\n两个线程之间进行单项数据连接，会建立一个管道，数据被写到sink通道，读取的时候从source通道读取。\n\n### 管道的原理\n\n管道写函数时，通过将字节复制到VFS索引节点指向的物理内存而写入数据，管道读函数则通过复制物理内存中的字节而读出数据。缓冲区不需要很大，一般为4k大小，它被设计为环形的结构，以便能够循环利用，当管道没有信息的时候，从管道中读取的进程会等待，知道另一端的进程放入信息。当管道被放满信息的时候，放入信息的进程会等待，直到另一端的进程取出信息。\n\n## selector\n\nselector又被称为多路复用器，用于检查一个NIO channel的状态是否处于可读和可写。\n\n与selector一起使用的channel必须是非阻塞模式的，filechannel和selector就不能一起使用\n\n### selector原理\n\nchannel通过注册，使得selector可以统一管理多个channel，这样一个线程只需要通过一个selector就可以管理多个channel。注册是使用注册表的方式来进行。\n\n### selector多路复用的机制\n\n介于cpu目前多任务越来越快，因此selector效率也越来越高，多个任务同时触发，每个任务的阻塞设置超时时间，因此可以比较好的实现多路复用的机制\n\n# okio\n\nokio和nio的原理差不多，加上了buffer,信道，但是进行了优化，另外由于okio是设计用于网络请求的，所以加上了超时机制\n\n## sink构造\n\nsink是okio的信道,用于写入\n\n```\nprivate static Sink sink(final OutputStream out, final Timeout timeout) {\n    if (out == null) throw new IllegalArgumentException(\"out == null\");\n    if (timeout == null) throw new IllegalArgumentException(\"timeout == null\");\n\n    return new Sink() {\n      @Override public void write(Buffer source, long byteCount) throws IOException {\n        checkOffsetAndCount(source.size, 0, byteCount);\n        while (byteCount > 0) {\n          timeout.throwIfReached();\n          Segment head = source.head;\n          int toCopy = (int) Math.min(byteCount, head.limit - head.pos);\n          out.write(head.data, head.pos, toCopy);\n\n          head.pos += toCopy;\n          byteCount -= toCopy;\n          source.size -= toCopy;\n\n          if (head.pos == head.limit) {\n            source.head = head.pop();\n            SegmentPool.recycle(head);\n          }\n        }\n      }\n\n      @Override public void flush() throws IOException {\n        out.flush();\n      }\n\n      @Override public void close() throws IOException {\n        out.close();\n      }\n\n      @Override public Timeout timeout() {\n        return timeout;\n      }\n\n      @Override public String toString() {\n        return \"sink(\" + out + \")\";\n      }\n    };\n  }\n```\n\nsource是用于读取的信道\n\n```\nprivate static Source source(final InputStream in, final Timeout timeout) {\n    if (in == null) throw new IllegalArgumentException(\"in == null\");\n    if (timeout == null) throw new IllegalArgumentException(\"timeout == null\");\n\n    return new Source() {\n      @Override public long read(Buffer sink, long byteCount) throws IOException {\n        if (byteCount < 0) throw new IllegalArgumentException(\"byteCount < 0: \" + byteCount);\n        if (byteCount == 0) return 0;\n        try {\n          timeout.throwIfReached();\n          Segment tail = sink.writableSegment(1);\n          int maxToCopy = (int) Math.min(byteCount, Segment.SIZE - tail.limit);\n          int bytesRead = in.read(tail.data, tail.limit, maxToCopy);\n          if (bytesRead == -1) return -1;\n          tail.limit += bytesRead;\n          sink.size += bytesRead;\n          return bytesRead;\n        } catch (AssertionError e) {\n          if (isAndroidGetsocknameError(e)) throw new IOException(e);\n          throw e;\n        }\n      }\n\n      @Override public void close() throws IOException {\n        in.close();\n      }\n\n      @Override public Timeout timeout() {\n        return timeout;\n      }\n\n      @Override public String toString() {\n        return \"source(\" + in + \")\";\n      }\n    };\n  }\n```\n这种信道机制都是队列模式，关于超时判定永远在最先，超时是不在乎io的速度，而只关注io开始时是否超时，而这种读取和写入的方法都基本是一层while搞定。\n\n从source和sink可以看出来，okio通过Segment来做数据的处理单元，这是一种双链表结构。写入的时候将依照节点顺序写入，读的时候也是从缓存池里面取出头节点进行读取。\n\n```\nfinal class SegmentPool {\n  /** The maximum number of bytes to pool. */\n  // TODO: Is 64 KiB a good maximum size? Do we ever have that many idle segments?\n  static final long MAX_SIZE = 64 * 1024; // 64 KiB.\n\n  /** Singly-linked list of segments. */\n  static @Nullable Segment next;\n\n  /** Total bytes in this pool. */\n  static long byteCount;\n\n  private SegmentPool() {\n  }\n\n  static Segment take() {\n    synchronized (SegmentPool.class) {\n      if (next != null) {\n        Segment result = next;\n        next = result.next;\n        result.next = null;\n        byteCount -= Segment.SIZE;\n        return result;\n      }\n    }\n    return new Segment(); // Pool is empty. Don't zero-fill while holding a lock.\n  }\n\n  static void recycle(Segment segment) {\n    if (segment.next != null || segment.prev != null) throw new IllegalArgumentException();\n    if (segment.shared) return; // This segment cannot be recycled.\n    synchronized (SegmentPool.class) {\n      if (byteCount + Segment.SIZE > MAX_SIZE) return; // Pool is full.\n      byteCount += Segment.SIZE;\n      segment.next = next;\n      segment.pos = segment.limit = 0;\n      next = segment;\n    }\n  }\n}\n```\n\n整个缓存池并不知道能不能说是一个池，说是一个管理类感觉更好点，读取的时候通过sink.writableSegment(1)来获取,这是通过操作sink的buffer来做的处理\n\n```\nSegment writableSegment(int minimumCapacity) {\n    if (minimumCapacity < 1 || minimumCapacity > Segment.SIZE) throw new IllegalArgumentException();\n\n    if (head == null) {\n      head = SegmentPool.take(); // Acquire a first segment.\n      return head.next = head.prev = head;\n    }\n\n    Segment tail = head.prev;\n    if (tail.limit + minimumCapacity > Segment.SIZE || !tail.owner) {\n      tail = tail.push(SegmentPool.take()); // Append a new empty segment to fill up.\n    }\n    return tail;\n  }\n```\n\n这里比较抽象，有部分的操作是进行链表的判空等，空链表做了一些处理，最终返回的是可处理的队列的尾部（其实是指向队列头的引用，不过由于是push方式，所以头在底下，因此叫做尾部）\n\n获取了尾部之后就开始通过io进行读取，这就是读取的过程。\n\n相对于io来讲，这部分由于使用了自己的缓存，缓存直接取出来使用，对比拷贝效率更高效一些。\n\n## 总结一下\n\nokio在最终的写入和读出上面，都使用的原生io机制，但是okio维护了自己的buffer，这个buffer相对于原生来讲不需要在source时进行拷贝，也就是直接使用引用，效果更快。另外okio是针对网络相关的，所以okio增加了超时机制也是比原生更有优势的地方。","slug":"okio学习","published":1,"updated":"2019-03-12T09:26:33.161Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltu02006i3a8k4zimvtt7","content":"<h1 id=\"io\"><a href=\"#io\" class=\"headerlink\" title=\"io\"></a>io</h1><p>io是java使用进行读取和写入的方式，i是input，o是output，走向是以内存为基准，内存中读数据是输入流，内存中往外写是输出流。</p>\n<p>io又分为字节流和字符流。字节流是直接对文件进行读写，是不中断的操作，不关闭字节流的话，操作仍然可以成功。而字符流是将文件的读写进行在缓冲区，当关闭的时候才会进行操作。</p>\n<p>字节流使用stream结尾，字符流使用reader和writer结尾。</p>\n<h2 id=\"缓冲区\"><a href=\"#缓冲区\" class=\"headerlink\" title=\"缓冲区\"></a>缓冲区</h2><p>缓冲区是一段内存区域，由于频繁的操作资源，会导致性能很低，而将数据存储到内存区域之后，之后的可以直接从区域中读取数据，读取内存数据的速度比较快，这样可以提升性能。</p>\n<p>字符流由于所有的数据都是暂存在内存中，如果想要清空缓存区，需要使用到flush操作，flush操作可以强制清空缓存区，因此会将缓存区的数据全部取出进行操作后清空。</p>\n<h2 id=\"字节流和字符流优缺点\"><a href=\"#字节流和字符流优缺点\" class=\"headerlink\" title=\"字节流和字符流优缺点\"></a>字节流和字符流优缺点</h2><ul>\n<li>字节流优点</li>\n</ul>\n<p>字节流的优点是使用到了缓存区，通过内存的使用加快了效率。字节流多用于处理图片，处理成为二进制字节。</p>\n<ul>\n<li>字符流优点</li>\n</ul>\n<p>字符流的优点是操作比较方便，提供了一些方便的例如readline这种功能。字符流多用于处理文字。</p>\n<h1 id=\"nio\"><a href=\"#nio\" class=\"headerlink\" title=\"nio\"></a>nio</h1><p>nio使用了缓存区、通道、管道来实现多线程io通信的问题</p>\n<h2 id=\"通道\"><a href=\"#通道\" class=\"headerlink\" title=\"通道\"></a>通道</h2><p>通道的存在大大提升了对buffer区域的操作空间，获取buffer的操作不再是由buffer提供，而是由channel进行代理提供，类似于stream对象，但是channel是由selector管理的。selector提供了可以监听多个通道的功能，因此单线程中使用selector可以监听多个channel，而stream则需要每个开一个线程才能达到不阻塞的行为。这样就解决了需要多线程io的问题</p>\n<h2 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h2><p>两个线程之间进行单项数据连接，会建立一个管道，数据被写到sink通道，读取的时候从source通道读取。</p>\n<h3 id=\"管道的原理\"><a href=\"#管道的原理\" class=\"headerlink\" title=\"管道的原理\"></a>管道的原理</h3><p>管道写函数时，通过将字节复制到VFS索引节点指向的物理内存而写入数据，管道读函数则通过复制物理内存中的字节而读出数据。缓冲区不需要很大，一般为4k大小，它被设计为环形的结构，以便能够循环利用，当管道没有信息的时候，从管道中读取的进程会等待，知道另一端的进程放入信息。当管道被放满信息的时候，放入信息的进程会等待，直到另一端的进程取出信息。</p>\n<h2 id=\"selector\"><a href=\"#selector\" class=\"headerlink\" title=\"selector\"></a>selector</h2><p>selector又被称为多路复用器，用于检查一个NIO channel的状态是否处于可读和可写。</p>\n<p>与selector一起使用的channel必须是非阻塞模式的，filechannel和selector就不能一起使用</p>\n<h3 id=\"selector原理\"><a href=\"#selector原理\" class=\"headerlink\" title=\"selector原理\"></a>selector原理</h3><p>channel通过注册，使得selector可以统一管理多个channel，这样一个线程只需要通过一个selector就可以管理多个channel。注册是使用注册表的方式来进行。</p>\n<h3 id=\"selector多路复用的机制\"><a href=\"#selector多路复用的机制\" class=\"headerlink\" title=\"selector多路复用的机制\"></a>selector多路复用的机制</h3><p>介于cpu目前多任务越来越快，因此selector效率也越来越高，多个任务同时触发，每个任务的阻塞设置超时时间，因此可以比较好的实现多路复用的机制</p>\n<h1 id=\"okio\"><a href=\"#okio\" class=\"headerlink\" title=\"okio\"></a>okio</h1><p>okio和nio的原理差不多，加上了buffer,信道，但是进行了优化，另外由于okio是设计用于网络请求的，所以加上了超时机制</p>\n<h2 id=\"sink构造\"><a href=\"#sink构造\" class=\"headerlink\" title=\"sink构造\"></a>sink构造</h2><p>sink是okio的信道,用于写入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static Sink sink(final OutputStream out, final Timeout timeout) &#123;</span><br><span class=\"line\">    if (out == null) throw new IllegalArgumentException(&quot;out == null&quot;);</span><br><span class=\"line\">    if (timeout == null) throw new IllegalArgumentException(&quot;timeout == null&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return new Sink() &#123;</span><br><span class=\"line\">      @Override public void write(Buffer source, long byteCount) throws IOException &#123;</span><br><span class=\"line\">        checkOffsetAndCount(source.size, 0, byteCount);</span><br><span class=\"line\">        while (byteCount &gt; 0) &#123;</span><br><span class=\"line\">          timeout.throwIfReached();</span><br><span class=\"line\">          Segment head = source.head;</span><br><span class=\"line\">          int toCopy = (int) Math.min(byteCount, head.limit - head.pos);</span><br><span class=\"line\">          out.write(head.data, head.pos, toCopy);</span><br><span class=\"line\"></span><br><span class=\"line\">          head.pos += toCopy;</span><br><span class=\"line\">          byteCount -= toCopy;</span><br><span class=\"line\">          source.size -= toCopy;</span><br><span class=\"line\"></span><br><span class=\"line\">          if (head.pos == head.limit) &#123;</span><br><span class=\"line\">            source.head = head.pop();</span><br><span class=\"line\">            SegmentPool.recycle(head);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override public void flush() throws IOException &#123;</span><br><span class=\"line\">        out.flush();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override public void close() throws IOException &#123;</span><br><span class=\"line\">        out.close();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override public Timeout timeout() &#123;</span><br><span class=\"line\">        return timeout;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override public String toString() &#123;</span><br><span class=\"line\">        return &quot;sink(&quot; + out + &quot;)&quot;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>source是用于读取的信道</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static Source source(final InputStream in, final Timeout timeout) &#123;</span><br><span class=\"line\">    if (in == null) throw new IllegalArgumentException(&quot;in == null&quot;);</span><br><span class=\"line\">    if (timeout == null) throw new IllegalArgumentException(&quot;timeout == null&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return new Source() &#123;</span><br><span class=\"line\">      @Override public long read(Buffer sink, long byteCount) throws IOException &#123;</span><br><span class=\"line\">        if (byteCount &lt; 0) throw new IllegalArgumentException(&quot;byteCount &lt; 0: &quot; + byteCount);</span><br><span class=\"line\">        if (byteCount == 0) return 0;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">          timeout.throwIfReached();</span><br><span class=\"line\">          Segment tail = sink.writableSegment(1);</span><br><span class=\"line\">          int maxToCopy = (int) Math.min(byteCount, Segment.SIZE - tail.limit);</span><br><span class=\"line\">          int bytesRead = in.read(tail.data, tail.limit, maxToCopy);</span><br><span class=\"line\">          if (bytesRead == -1) return -1;</span><br><span class=\"line\">          tail.limit += bytesRead;</span><br><span class=\"line\">          sink.size += bytesRead;</span><br><span class=\"line\">          return bytesRead;</span><br><span class=\"line\">        &#125; catch (AssertionError e) &#123;</span><br><span class=\"line\">          if (isAndroidGetsocknameError(e)) throw new IOException(e);</span><br><span class=\"line\">          throw e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override public void close() throws IOException &#123;</span><br><span class=\"line\">        in.close();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override public Timeout timeout() &#123;</span><br><span class=\"line\">        return timeout;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override public String toString() &#123;</span><br><span class=\"line\">        return &quot;source(&quot; + in + &quot;)&quot;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这种信道机制都是队列模式，关于超时判定永远在最先，超时是不在乎io的速度，而只关注io开始时是否超时，而这种读取和写入的方法都基本是一层while搞定。</p>\n<p>从source和sink可以看出来，okio通过Segment来做数据的处理单元，这是一种双链表结构。写入的时候将依照节点顺序写入，读的时候也是从缓存池里面取出头节点进行读取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final class SegmentPool &#123;</span><br><span class=\"line\">  /** The maximum number of bytes to pool. */</span><br><span class=\"line\">  // TODO: Is 64 KiB a good maximum size? Do we ever have that many idle segments?</span><br><span class=\"line\">  static final long MAX_SIZE = 64 * 1024; // 64 KiB.</span><br><span class=\"line\"></span><br><span class=\"line\">  /** Singly-linked list of segments. */</span><br><span class=\"line\">  static @Nullable Segment next;</span><br><span class=\"line\"></span><br><span class=\"line\">  /** Total bytes in this pool. */</span><br><span class=\"line\">  static long byteCount;</span><br><span class=\"line\"></span><br><span class=\"line\">  private SegmentPool() &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static Segment take() &#123;</span><br><span class=\"line\">    synchronized (SegmentPool.class) &#123;</span><br><span class=\"line\">      if (next != null) &#123;</span><br><span class=\"line\">        Segment result = next;</span><br><span class=\"line\">        next = result.next;</span><br><span class=\"line\">        result.next = null;</span><br><span class=\"line\">        byteCount -= Segment.SIZE;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return new Segment(); // Pool is empty. Don&apos;t zero-fill while holding a lock.</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static void recycle(Segment segment) &#123;</span><br><span class=\"line\">    if (segment.next != null || segment.prev != null) throw new IllegalArgumentException();</span><br><span class=\"line\">    if (segment.shared) return; // This segment cannot be recycled.</span><br><span class=\"line\">    synchronized (SegmentPool.class) &#123;</span><br><span class=\"line\">      if (byteCount + Segment.SIZE &gt; MAX_SIZE) return; // Pool is full.</span><br><span class=\"line\">      byteCount += Segment.SIZE;</span><br><span class=\"line\">      segment.next = next;</span><br><span class=\"line\">      segment.pos = segment.limit = 0;</span><br><span class=\"line\">      next = segment;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个缓存池并不知道能不能说是一个池，说是一个管理类感觉更好点，读取的时候通过sink.writableSegment(1)来获取,这是通过操作sink的buffer来做的处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Segment writableSegment(int minimumCapacity) &#123;</span><br><span class=\"line\">    if (minimumCapacity &lt; 1 || minimumCapacity &gt; Segment.SIZE) throw new IllegalArgumentException();</span><br><span class=\"line\"></span><br><span class=\"line\">    if (head == null) &#123;</span><br><span class=\"line\">      head = SegmentPool.take(); // Acquire a first segment.</span><br><span class=\"line\">      return head.next = head.prev = head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Segment tail = head.prev;</span><br><span class=\"line\">    if (tail.limit + minimumCapacity &gt; Segment.SIZE || !tail.owner) &#123;</span><br><span class=\"line\">      tail = tail.push(SegmentPool.take()); // Append a new empty segment to fill up.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return tail;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这里比较抽象，有部分的操作是进行链表的判空等，空链表做了一些处理，最终返回的是可处理的队列的尾部（其实是指向队列头的引用，不过由于是push方式，所以头在底下，因此叫做尾部）</p>\n<p>获取了尾部之后就开始通过io进行读取，这就是读取的过程。</p>\n<p>相对于io来讲，这部分由于使用了自己的缓存，缓存直接取出来使用，对比拷贝效率更高效一些。</p>\n<h2 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h2><p>okio在最终的写入和读出上面，都使用的原生io机制，但是okio维护了自己的buffer，这个buffer相对于原生来讲不需要在source时进行拷贝，也就是直接使用引用，效果更快。另外okio是针对网络相关的，所以okio增加了超时机制也是比原生更有优势的地方。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"io\"><a href=\"#io\" class=\"headerlink\" title=\"io\"></a>io</h1><p>io是java使用进行读取和写入的方式，i是input，o是output，走向是以内存为基准，内存中读数据是输入流，内存中往外写是输出流。</p>\n<p>io又分为字节流和字符流。字节流是直接对文件进行读写，是不中断的操作，不关闭字节流的话，操作仍然可以成功。而字符流是将文件的读写进行在缓冲区，当关闭的时候才会进行操作。</p>\n<p>字节流使用stream结尾，字符流使用reader和writer结尾。</p>\n<h2 id=\"缓冲区\"><a href=\"#缓冲区\" class=\"headerlink\" title=\"缓冲区\"></a>缓冲区</h2><p>缓冲区是一段内存区域，由于频繁的操作资源，会导致性能很低，而将数据存储到内存区域之后，之后的可以直接从区域中读取数据，读取内存数据的速度比较快，这样可以提升性能。</p>\n<p>字符流由于所有的数据都是暂存在内存中，如果想要清空缓存区，需要使用到flush操作，flush操作可以强制清空缓存区，因此会将缓存区的数据全部取出进行操作后清空。</p>\n<h2 id=\"字节流和字符流优缺点\"><a href=\"#字节流和字符流优缺点\" class=\"headerlink\" title=\"字节流和字符流优缺点\"></a>字节流和字符流优缺点</h2><ul>\n<li>字节流优点</li>\n</ul>\n<p>字节流的优点是使用到了缓存区，通过内存的使用加快了效率。字节流多用于处理图片，处理成为二进制字节。</p>\n<ul>\n<li>字符流优点</li>\n</ul>\n<p>字符流的优点是操作比较方便，提供了一些方便的例如readline这种功能。字符流多用于处理文字。</p>\n<h1 id=\"nio\"><a href=\"#nio\" class=\"headerlink\" title=\"nio\"></a>nio</h1><p>nio使用了缓存区、通道、管道来实现多线程io通信的问题</p>\n<h2 id=\"通道\"><a href=\"#通道\" class=\"headerlink\" title=\"通道\"></a>通道</h2><p>通道的存在大大提升了对buffer区域的操作空间，获取buffer的操作不再是由buffer提供，而是由channel进行代理提供，类似于stream对象，但是channel是由selector管理的。selector提供了可以监听多个通道的功能，因此单线程中使用selector可以监听多个channel，而stream则需要每个开一个线程才能达到不阻塞的行为。这样就解决了需要多线程io的问题</p>\n<h2 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h2><p>两个线程之间进行单项数据连接，会建立一个管道，数据被写到sink通道，读取的时候从source通道读取。</p>\n<h3 id=\"管道的原理\"><a href=\"#管道的原理\" class=\"headerlink\" title=\"管道的原理\"></a>管道的原理</h3><p>管道写函数时，通过将字节复制到VFS索引节点指向的物理内存而写入数据，管道读函数则通过复制物理内存中的字节而读出数据。缓冲区不需要很大，一般为4k大小，它被设计为环形的结构，以便能够循环利用，当管道没有信息的时候，从管道中读取的进程会等待，知道另一端的进程放入信息。当管道被放满信息的时候，放入信息的进程会等待，直到另一端的进程取出信息。</p>\n<h2 id=\"selector\"><a href=\"#selector\" class=\"headerlink\" title=\"selector\"></a>selector</h2><p>selector又被称为多路复用器，用于检查一个NIO channel的状态是否处于可读和可写。</p>\n<p>与selector一起使用的channel必须是非阻塞模式的，filechannel和selector就不能一起使用</p>\n<h3 id=\"selector原理\"><a href=\"#selector原理\" class=\"headerlink\" title=\"selector原理\"></a>selector原理</h3><p>channel通过注册，使得selector可以统一管理多个channel，这样一个线程只需要通过一个selector就可以管理多个channel。注册是使用注册表的方式来进行。</p>\n<h3 id=\"selector多路复用的机制\"><a href=\"#selector多路复用的机制\" class=\"headerlink\" title=\"selector多路复用的机制\"></a>selector多路复用的机制</h3><p>介于cpu目前多任务越来越快，因此selector效率也越来越高，多个任务同时触发，每个任务的阻塞设置超时时间，因此可以比较好的实现多路复用的机制</p>\n<h1 id=\"okio\"><a href=\"#okio\" class=\"headerlink\" title=\"okio\"></a>okio</h1><p>okio和nio的原理差不多，加上了buffer,信道，但是进行了优化，另外由于okio是设计用于网络请求的，所以加上了超时机制</p>\n<h2 id=\"sink构造\"><a href=\"#sink构造\" class=\"headerlink\" title=\"sink构造\"></a>sink构造</h2><p>sink是okio的信道,用于写入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static Sink sink(final OutputStream out, final Timeout timeout) &#123;</span><br><span class=\"line\">    if (out == null) throw new IllegalArgumentException(&quot;out == null&quot;);</span><br><span class=\"line\">    if (timeout == null) throw new IllegalArgumentException(&quot;timeout == null&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return new Sink() &#123;</span><br><span class=\"line\">      @Override public void write(Buffer source, long byteCount) throws IOException &#123;</span><br><span class=\"line\">        checkOffsetAndCount(source.size, 0, byteCount);</span><br><span class=\"line\">        while (byteCount &gt; 0) &#123;</span><br><span class=\"line\">          timeout.throwIfReached();</span><br><span class=\"line\">          Segment head = source.head;</span><br><span class=\"line\">          int toCopy = (int) Math.min(byteCount, head.limit - head.pos);</span><br><span class=\"line\">          out.write(head.data, head.pos, toCopy);</span><br><span class=\"line\"></span><br><span class=\"line\">          head.pos += toCopy;</span><br><span class=\"line\">          byteCount -= toCopy;</span><br><span class=\"line\">          source.size -= toCopy;</span><br><span class=\"line\"></span><br><span class=\"line\">          if (head.pos == head.limit) &#123;</span><br><span class=\"line\">            source.head = head.pop();</span><br><span class=\"line\">            SegmentPool.recycle(head);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override public void flush() throws IOException &#123;</span><br><span class=\"line\">        out.flush();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override public void close() throws IOException &#123;</span><br><span class=\"line\">        out.close();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override public Timeout timeout() &#123;</span><br><span class=\"line\">        return timeout;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override public String toString() &#123;</span><br><span class=\"line\">        return &quot;sink(&quot; + out + &quot;)&quot;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>source是用于读取的信道</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static Source source(final InputStream in, final Timeout timeout) &#123;</span><br><span class=\"line\">    if (in == null) throw new IllegalArgumentException(&quot;in == null&quot;);</span><br><span class=\"line\">    if (timeout == null) throw new IllegalArgumentException(&quot;timeout == null&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return new Source() &#123;</span><br><span class=\"line\">      @Override public long read(Buffer sink, long byteCount) throws IOException &#123;</span><br><span class=\"line\">        if (byteCount &lt; 0) throw new IllegalArgumentException(&quot;byteCount &lt; 0: &quot; + byteCount);</span><br><span class=\"line\">        if (byteCount == 0) return 0;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">          timeout.throwIfReached();</span><br><span class=\"line\">          Segment tail = sink.writableSegment(1);</span><br><span class=\"line\">          int maxToCopy = (int) Math.min(byteCount, Segment.SIZE - tail.limit);</span><br><span class=\"line\">          int bytesRead = in.read(tail.data, tail.limit, maxToCopy);</span><br><span class=\"line\">          if (bytesRead == -1) return -1;</span><br><span class=\"line\">          tail.limit += bytesRead;</span><br><span class=\"line\">          sink.size += bytesRead;</span><br><span class=\"line\">          return bytesRead;</span><br><span class=\"line\">        &#125; catch (AssertionError e) &#123;</span><br><span class=\"line\">          if (isAndroidGetsocknameError(e)) throw new IOException(e);</span><br><span class=\"line\">          throw e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override public void close() throws IOException &#123;</span><br><span class=\"line\">        in.close();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override public Timeout timeout() &#123;</span><br><span class=\"line\">        return timeout;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override public String toString() &#123;</span><br><span class=\"line\">        return &quot;source(&quot; + in + &quot;)&quot;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这种信道机制都是队列模式，关于超时判定永远在最先，超时是不在乎io的速度，而只关注io开始时是否超时，而这种读取和写入的方法都基本是一层while搞定。</p>\n<p>从source和sink可以看出来，okio通过Segment来做数据的处理单元，这是一种双链表结构。写入的时候将依照节点顺序写入，读的时候也是从缓存池里面取出头节点进行读取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final class SegmentPool &#123;</span><br><span class=\"line\">  /** The maximum number of bytes to pool. */</span><br><span class=\"line\">  // TODO: Is 64 KiB a good maximum size? Do we ever have that many idle segments?</span><br><span class=\"line\">  static final long MAX_SIZE = 64 * 1024; // 64 KiB.</span><br><span class=\"line\"></span><br><span class=\"line\">  /** Singly-linked list of segments. */</span><br><span class=\"line\">  static @Nullable Segment next;</span><br><span class=\"line\"></span><br><span class=\"line\">  /** Total bytes in this pool. */</span><br><span class=\"line\">  static long byteCount;</span><br><span class=\"line\"></span><br><span class=\"line\">  private SegmentPool() &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static Segment take() &#123;</span><br><span class=\"line\">    synchronized (SegmentPool.class) &#123;</span><br><span class=\"line\">      if (next != null) &#123;</span><br><span class=\"line\">        Segment result = next;</span><br><span class=\"line\">        next = result.next;</span><br><span class=\"line\">        result.next = null;</span><br><span class=\"line\">        byteCount -= Segment.SIZE;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return new Segment(); // Pool is empty. Don&apos;t zero-fill while holding a lock.</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static void recycle(Segment segment) &#123;</span><br><span class=\"line\">    if (segment.next != null || segment.prev != null) throw new IllegalArgumentException();</span><br><span class=\"line\">    if (segment.shared) return; // This segment cannot be recycled.</span><br><span class=\"line\">    synchronized (SegmentPool.class) &#123;</span><br><span class=\"line\">      if (byteCount + Segment.SIZE &gt; MAX_SIZE) return; // Pool is full.</span><br><span class=\"line\">      byteCount += Segment.SIZE;</span><br><span class=\"line\">      segment.next = next;</span><br><span class=\"line\">      segment.pos = segment.limit = 0;</span><br><span class=\"line\">      next = segment;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个缓存池并不知道能不能说是一个池，说是一个管理类感觉更好点，读取的时候通过sink.writableSegment(1)来获取,这是通过操作sink的buffer来做的处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Segment writableSegment(int minimumCapacity) &#123;</span><br><span class=\"line\">    if (minimumCapacity &lt; 1 || minimumCapacity &gt; Segment.SIZE) throw new IllegalArgumentException();</span><br><span class=\"line\"></span><br><span class=\"line\">    if (head == null) &#123;</span><br><span class=\"line\">      head = SegmentPool.take(); // Acquire a first segment.</span><br><span class=\"line\">      return head.next = head.prev = head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Segment tail = head.prev;</span><br><span class=\"line\">    if (tail.limit + minimumCapacity &gt; Segment.SIZE || !tail.owner) &#123;</span><br><span class=\"line\">      tail = tail.push(SegmentPool.take()); // Append a new empty segment to fill up.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return tail;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这里比较抽象，有部分的操作是进行链表的判空等，空链表做了一些处理，最终返回的是可处理的队列的尾部（其实是指向队列头的引用，不过由于是push方式，所以头在底下，因此叫做尾部）</p>\n<p>获取了尾部之后就开始通过io进行读取，这就是读取的过程。</p>\n<p>相对于io来讲，这部分由于使用了自己的缓存，缓存直接取出来使用，对比拷贝效率更高效一些。</p>\n<h2 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h2><p>okio在最终的写入和读出上面，都使用的原生io机制，但是okio维护了自己的buffer，这个buffer相对于原生来讲不需要在source时进行拷贝，也就是直接使用引用，效果更快。另外okio是针对网络相关的，所以okio增加了超时机制也是比原生更有优势的地方。</p>\n"},{"title":"rxjava操作符笔记","date":"2018-02-15T11:43:10.000Z","_content":"\n对rxjava的操作符进行一些笔记。\n\n# creating observables(创建observable)\n\n- create\n\n最基本的创建操作\n\n```\nOObservable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(ObservableEmitter<String> emitter) throws Exception {\n                //上游操作发射\n            }\n        }).subscribe(new Subject<String>() {\n            @Override\n            public boolean hasObservers() {\n                return false;\n            }\n\n            @Override\n            public boolean hasThrowable() {\n                return false;\n            }\n\n            @Override\n            public boolean hasComplete() {\n                return false;\n            }\n\n            @Override\n            public Throwable getThrowable() {\n                return null;\n            }\n\n            @Override\n            protected void subscribeActual(Observer<? super String> observer) {\n\n            }\n\n            @Override\n            public void onSubscribe(Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(String s) {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n```\n\n- just\n\njust就是对create的简写\n\n```\nObservable.just('1','2').subscribe(new Consumer<Character>() {\n            @Override\n            public void accept(Character character) throws Exception {\n                \n            }\n        });\n```\n\n- from\n\nfrom可以接受一个创建了的列表作为输入,可以接受不少的类型，列表，迭代器,future,publisher等等\n\n```\nList<String> source = new ArrayList();\n        source.add(\"1\");\n        source.add(\"2\");\n        Observable.fromArray(source).subscribe(new Consumer<List<String>>() {\n            @Override\n            public void accept(List<String> strings) throws Exception {\n                \n            }\n        });\n```\n\n- defer\n\ndefer是当观察者订阅被观察者的时候，才会开始创建一个observable，其余操作和from，just差不多。\n\n- empty/never/throw\n\nempty是生成一个空的观察对象，never是生成一个不会向下游发送执行命令的对象，throw会生成一个不会向下游发送执行命令，但是会以一个error终止的对象。\n\n- interval\n\ninterval是起到了定时器功能，根据给定的时间间隔上游来发送数据。\n\n```\nObservable.interval(10, TimeUnit.SECONDS).just(\"1\",\"2\").subscribe(new Consumer<String>() {\n            @Override\n            public void accept(String s) throws Exception {\n                \n            }\n        });\n```\n\n- range\n\n创建在一个范围之类的数据类型，上游依次发送这个范围内的数据。\n\n- repeat\n\n多次重复的发送一个数据。\n\n- start\n\n创建发射一个函数的返回值的observable\n\n- timer\n\n创建在一个指定的延时之后发射单个数据的observable\n\n# transforming observables(转换observable)\n\n- map\n\n将一个对象转换为另一个对象。\n\n```\n\tObservable.just(1,2,3).map(new Function<Integer, String>() {\n            @Override\n            public String apply(Integer integer) throws Exception {\n                return integer.toString();\n            }\n        }).subscribe(new Consumer<String>() {\n            @Override\n            public void accept(String s) throws Exception {\n                \n            }\n        });\n    //简单的例子，将发射为int的字节转换成为string类型的observable\n```\n\n- flatmap\n\nflatmap是一个一对多的转换对象。\n\n```\n\tObservable.just(1,2,3,4).flatMap(new Function<Integer, ObservableSource<? extends String>>() {\n            @Override\n            public ObservableSource<? extends String> apply(Integer integer) throws Exception {\n                return Observable.just(integer+\"\");\n            }\n        }).subscribe(new Consumer<String>() {\n            @Override\n            public void accept(String s) throws Exception {\n\n            }\n        });\n```\n\n- groupby\n\ngroup是一个分组行为，根据指定的规则将上游进行分组归类，然后发送至下游时会夹带分组信息\n\n- buffer\n\n缓存，定期的从observable收集数据到一个集合，然后打包发送，而不是一次发送一个\n\n- scan\n\n扫描，对observable发射的每一项数据应用一个函数，然后按照顺序发射这些值\n\n- window\n\n定期将来自observable的数据拆分成一个个的observable窗口，然后发射这些窗口，而不是每次发射一项，类似于buffer， 不过window发射的是observable\n\n# filtering observables(过滤observable)\n\n- Debounce\n\n过滤掉了由Observable发射的速率过快的数据；如果在一个指定的时间间隔过去了仍旧没有发射一个，那么它将发射最后的那个。通常我们用来结合RxBinding(Jake Wharton大神使用RxJava封装的Android UI组件)使用，防止button重复点击。\n\n- Distinct\n\ndistinct()的过滤规则是只允许还没有发射过的数据通过，所有重复的数据项都只会发射一次。 \n\n- ElementAt\n\n获取原始序列第n个元素，并作为唯一发射源进行发射\n\n- Filter\n\n用来过滤观察序列中我们不想要的值，只返回满足条件的值\n\n```\nObservable.from(communities)\n        .filter(new Func1<Community, Boolean>() {\n            @Override\n            public Boolean call(Community community) {\n                return community.houses.size()>10;\n            }\n        }).subscribe(new Action1<Community>() {\n    @Override\n    public void call(Community community) {\n        System.out.println(community.name);\n    }\n});\n```\n\n- First\n\n它是的Observable只发送观测序列中的第一个数据项。\n\n- last\n\nlast()只发射观测序列中的最后一个数据项。 \n\n- skip\n\n忽略掉原始序列前n个元素\n\n- skiplast\n\n忽略掉原始序列最后n个元素\n\n- take\n\n发送原始序列中的前n个元素\n```\nObservable.from(communities)\n        .take(10)\n        .subscribe(new Action1<Community>() {\n            @Override\n            public void call(Community community) {\n                System.out.println(community.name);\n            }\n        });\n```\n\n- takelast\n\n发送原始序列中的最后n个元素\n\n# combing observables(组合observable\n\n- zip\n\nzip(Observable, Observable, Func2)用来合并两个Observable发射的数据项，根据Func2函数生成一个新的值并发射出去。当其中一个Observable发送数据结束或者出现异常后，另一个Observable也将停在发射数据。\n\n- merge\n\nmerge(Observable, Observable)将两个Observable发射的事件序列组合并成一个事件序列，就像是一个Observable发射的一样。你可以简单的将它理解为两个Obsrvable合并成了一个Observable，合并后的数据是无序的。\n\n- startwith\n\nstartWith(T)用于在源Observable发射的数据前插入数据。使用startWith(Iterable<T>)我们还可以在源Observable发射的数据前插入Iterable。\n\n- combinelatest\n\ncombineLatest(Observable, Observable, Func2)用于将两个Observale最近发射的数据已经Func2函数的规则进展组合\n\n- join\n\njoin(Observable, Func1, Func1, Func2)我们先介绍下join操作符的4个参数：\nObservable：源Observable需要组合的Observable,这里我们姑且称之为目标Observable；\nFunc1：接收从源Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了源Obsrvable发射出来的数据的有效期；\nFunc1：接收目标Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了目标Obsrvable发射出来的数据的有效期；\nFunc2：接收从源Observable和目标Observable发射出来的数据，并将这两个数据组合后返回。所以Join操作符的语法结构大致是这样的：onservableA.join(observableB, 控制observableA发射数据有效期的函数， 控制observableB发射数据有效期的函数，两个observable发射数据的合并规则)join操作符的效果类似于排列组合，把第一个数据源A作为基座窗口，他根据自己的节奏不断发射数据元素，第二个数据源B，每发射一个数据，我们都把它和第一个数据源A中已经发射的数据进行一对一匹配；举例来说，如果某一时刻B发射了一个数据“B”,此时A已经发射了0，1，2，3共四个数据，那么我们的合并操作就会把“B”依次与0,1,2,3配对，得到四组数据： [0, B][1, B] [2, B] [3, B]\n\n- switchonnext\n\nswitchOnNext(Observable<? extends Observable<? extends T>>用来将一个发射多个小Observable的源Observable转化为一个Observable，然后发射这多个小Observable所发射的数据。如果一个小的Observable正在发射数据的时候，源Observable又发射出一个新的小Observable，则前一个Observable发射的数据会被抛弃，直接发射新 的小Observable所发射的数据。\n\n# error handling operators(处理错误)\n\n- catch\n\n- retry\n\n# 补充\n\n- takeUtil\n\nobservable.takeUtil(condition),当condition == true时终止，且包含临界条件的item\n\n- takeWhile\n\nobservable.takeWhile(condition),当condition == false时终止，不包含临界条件的item\n\n- concat\n\nConcat操作符将多个Observable结合成一个Observable并发射数据，并且严格按照先后顺序发射数据，前一个Observable的数据没有发射完，是不能发射后面Observable的数据的。\nConcat配合first()可以实现按顺序进行发射数据，有就立即停下，例如从内存缓存，本地缓存，网络请求三者中进行读取数据的操作。\n\n\n","source":"_posts/rxjava操作符笔记.md","raw":"---\ntitle: rxjava操作符笔记\ndate: 2018-02-15 19:43:10\ntags: android\n---\n\n对rxjava的操作符进行一些笔记。\n\n# creating observables(创建observable)\n\n- create\n\n最基本的创建操作\n\n```\nOObservable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(ObservableEmitter<String> emitter) throws Exception {\n                //上游操作发射\n            }\n        }).subscribe(new Subject<String>() {\n            @Override\n            public boolean hasObservers() {\n                return false;\n            }\n\n            @Override\n            public boolean hasThrowable() {\n                return false;\n            }\n\n            @Override\n            public boolean hasComplete() {\n                return false;\n            }\n\n            @Override\n            public Throwable getThrowable() {\n                return null;\n            }\n\n            @Override\n            protected void subscribeActual(Observer<? super String> observer) {\n\n            }\n\n            @Override\n            public void onSubscribe(Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(String s) {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n```\n\n- just\n\njust就是对create的简写\n\n```\nObservable.just('1','2').subscribe(new Consumer<Character>() {\n            @Override\n            public void accept(Character character) throws Exception {\n                \n            }\n        });\n```\n\n- from\n\nfrom可以接受一个创建了的列表作为输入,可以接受不少的类型，列表，迭代器,future,publisher等等\n\n```\nList<String> source = new ArrayList();\n        source.add(\"1\");\n        source.add(\"2\");\n        Observable.fromArray(source).subscribe(new Consumer<List<String>>() {\n            @Override\n            public void accept(List<String> strings) throws Exception {\n                \n            }\n        });\n```\n\n- defer\n\ndefer是当观察者订阅被观察者的时候，才会开始创建一个observable，其余操作和from，just差不多。\n\n- empty/never/throw\n\nempty是生成一个空的观察对象，never是生成一个不会向下游发送执行命令的对象，throw会生成一个不会向下游发送执行命令，但是会以一个error终止的对象。\n\n- interval\n\ninterval是起到了定时器功能，根据给定的时间间隔上游来发送数据。\n\n```\nObservable.interval(10, TimeUnit.SECONDS).just(\"1\",\"2\").subscribe(new Consumer<String>() {\n            @Override\n            public void accept(String s) throws Exception {\n                \n            }\n        });\n```\n\n- range\n\n创建在一个范围之类的数据类型，上游依次发送这个范围内的数据。\n\n- repeat\n\n多次重复的发送一个数据。\n\n- start\n\n创建发射一个函数的返回值的observable\n\n- timer\n\n创建在一个指定的延时之后发射单个数据的observable\n\n# transforming observables(转换observable)\n\n- map\n\n将一个对象转换为另一个对象。\n\n```\n\tObservable.just(1,2,3).map(new Function<Integer, String>() {\n            @Override\n            public String apply(Integer integer) throws Exception {\n                return integer.toString();\n            }\n        }).subscribe(new Consumer<String>() {\n            @Override\n            public void accept(String s) throws Exception {\n                \n            }\n        });\n    //简单的例子，将发射为int的字节转换成为string类型的observable\n```\n\n- flatmap\n\nflatmap是一个一对多的转换对象。\n\n```\n\tObservable.just(1,2,3,4).flatMap(new Function<Integer, ObservableSource<? extends String>>() {\n            @Override\n            public ObservableSource<? extends String> apply(Integer integer) throws Exception {\n                return Observable.just(integer+\"\");\n            }\n        }).subscribe(new Consumer<String>() {\n            @Override\n            public void accept(String s) throws Exception {\n\n            }\n        });\n```\n\n- groupby\n\ngroup是一个分组行为，根据指定的规则将上游进行分组归类，然后发送至下游时会夹带分组信息\n\n- buffer\n\n缓存，定期的从observable收集数据到一个集合，然后打包发送，而不是一次发送一个\n\n- scan\n\n扫描，对observable发射的每一项数据应用一个函数，然后按照顺序发射这些值\n\n- window\n\n定期将来自observable的数据拆分成一个个的observable窗口，然后发射这些窗口，而不是每次发射一项，类似于buffer， 不过window发射的是observable\n\n# filtering observables(过滤observable)\n\n- Debounce\n\n过滤掉了由Observable发射的速率过快的数据；如果在一个指定的时间间隔过去了仍旧没有发射一个，那么它将发射最后的那个。通常我们用来结合RxBinding(Jake Wharton大神使用RxJava封装的Android UI组件)使用，防止button重复点击。\n\n- Distinct\n\ndistinct()的过滤规则是只允许还没有发射过的数据通过，所有重复的数据项都只会发射一次。 \n\n- ElementAt\n\n获取原始序列第n个元素，并作为唯一发射源进行发射\n\n- Filter\n\n用来过滤观察序列中我们不想要的值，只返回满足条件的值\n\n```\nObservable.from(communities)\n        .filter(new Func1<Community, Boolean>() {\n            @Override\n            public Boolean call(Community community) {\n                return community.houses.size()>10;\n            }\n        }).subscribe(new Action1<Community>() {\n    @Override\n    public void call(Community community) {\n        System.out.println(community.name);\n    }\n});\n```\n\n- First\n\n它是的Observable只发送观测序列中的第一个数据项。\n\n- last\n\nlast()只发射观测序列中的最后一个数据项。 \n\n- skip\n\n忽略掉原始序列前n个元素\n\n- skiplast\n\n忽略掉原始序列最后n个元素\n\n- take\n\n发送原始序列中的前n个元素\n```\nObservable.from(communities)\n        .take(10)\n        .subscribe(new Action1<Community>() {\n            @Override\n            public void call(Community community) {\n                System.out.println(community.name);\n            }\n        });\n```\n\n- takelast\n\n发送原始序列中的最后n个元素\n\n# combing observables(组合observable\n\n- zip\n\nzip(Observable, Observable, Func2)用来合并两个Observable发射的数据项，根据Func2函数生成一个新的值并发射出去。当其中一个Observable发送数据结束或者出现异常后，另一个Observable也将停在发射数据。\n\n- merge\n\nmerge(Observable, Observable)将两个Observable发射的事件序列组合并成一个事件序列，就像是一个Observable发射的一样。你可以简单的将它理解为两个Obsrvable合并成了一个Observable，合并后的数据是无序的。\n\n- startwith\n\nstartWith(T)用于在源Observable发射的数据前插入数据。使用startWith(Iterable<T>)我们还可以在源Observable发射的数据前插入Iterable。\n\n- combinelatest\n\ncombineLatest(Observable, Observable, Func2)用于将两个Observale最近发射的数据已经Func2函数的规则进展组合\n\n- join\n\njoin(Observable, Func1, Func1, Func2)我们先介绍下join操作符的4个参数：\nObservable：源Observable需要组合的Observable,这里我们姑且称之为目标Observable；\nFunc1：接收从源Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了源Obsrvable发射出来的数据的有效期；\nFunc1：接收目标Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了目标Obsrvable发射出来的数据的有效期；\nFunc2：接收从源Observable和目标Observable发射出来的数据，并将这两个数据组合后返回。所以Join操作符的语法结构大致是这样的：onservableA.join(observableB, 控制observableA发射数据有效期的函数， 控制observableB发射数据有效期的函数，两个observable发射数据的合并规则)join操作符的效果类似于排列组合，把第一个数据源A作为基座窗口，他根据自己的节奏不断发射数据元素，第二个数据源B，每发射一个数据，我们都把它和第一个数据源A中已经发射的数据进行一对一匹配；举例来说，如果某一时刻B发射了一个数据“B”,此时A已经发射了0，1，2，3共四个数据，那么我们的合并操作就会把“B”依次与0,1,2,3配对，得到四组数据： [0, B][1, B] [2, B] [3, B]\n\n- switchonnext\n\nswitchOnNext(Observable<? extends Observable<? extends T>>用来将一个发射多个小Observable的源Observable转化为一个Observable，然后发射这多个小Observable所发射的数据。如果一个小的Observable正在发射数据的时候，源Observable又发射出一个新的小Observable，则前一个Observable发射的数据会被抛弃，直接发射新 的小Observable所发射的数据。\n\n# error handling operators(处理错误)\n\n- catch\n\n- retry\n\n# 补充\n\n- takeUtil\n\nobservable.takeUtil(condition),当condition == true时终止，且包含临界条件的item\n\n- takeWhile\n\nobservable.takeWhile(condition),当condition == false时终止，不包含临界条件的item\n\n- concat\n\nConcat操作符将多个Observable结合成一个Observable并发射数据，并且严格按照先后顺序发射数据，前一个Observable的数据没有发射完，是不能发射后面Observable的数据的。\nConcat配合first()可以实现按顺序进行发射数据，有就立即停下，例如从内存缓存，本地缓存，网络请求三者中进行读取数据的操作。\n\n\n","slug":"rxjava操作符笔记","published":1,"updated":"2019-03-12T09:26:33.162Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltu03006l3a8kxzwtpa2c","content":"<p>对rxjava的操作符进行一些笔记。</p>\n<h1 id=\"creating-observables-创建observable\"><a href=\"#creating-observables-创建observable\" class=\"headerlink\" title=\"creating observables(创建observable)\"></a>creating observables(创建observable)</h1><ul>\n<li>create</li>\n</ul>\n<p>最基本的创建操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OObservable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123;</span><br><span class=\"line\">                //上游操作发射</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).subscribe(new Subject&lt;String&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public boolean hasObservers() &#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public boolean hasThrowable() &#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public boolean hasComplete() &#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public Throwable getThrowable() &#123;</span><br><span class=\"line\">                return null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            protected void subscribeActual(Observer&lt;? super String&gt; observer) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onSubscribe(Disposable d) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onNext(String s) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onError(Throwable e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onComplete() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>just</li>\n</ul>\n<p>just就是对create的简写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.just(&apos;1&apos;,&apos;2&apos;).subscribe(new Consumer&lt;Character&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(Character character) throws Exception &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>from</li>\n</ul>\n<p>from可以接受一个创建了的列表作为输入,可以接受不少的类型，列表，迭代器,future,publisher等等</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; source = new ArrayList();</span><br><span class=\"line\">        source.add(&quot;1&quot;);</span><br><span class=\"line\">        source.add(&quot;2&quot;);</span><br><span class=\"line\">        Observable.fromArray(source).subscribe(new Consumer&lt;List&lt;String&gt;&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>defer</li>\n</ul>\n<p>defer是当观察者订阅被观察者的时候，才会开始创建一个observable，其余操作和from，just差不多。</p>\n<ul>\n<li>empty/never/throw</li>\n</ul>\n<p>empty是生成一个空的观察对象，never是生成一个不会向下游发送执行命令的对象，throw会生成一个不会向下游发送执行命令，但是会以一个error终止的对象。</p>\n<ul>\n<li>interval</li>\n</ul>\n<p>interval是起到了定时器功能，根据给定的时间间隔上游来发送数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.interval(10, TimeUnit.SECONDS).just(&quot;1&quot;,&quot;2&quot;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(String s) throws Exception &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>range</li>\n</ul>\n<p>创建在一个范围之类的数据类型，上游依次发送这个范围内的数据。</p>\n<ul>\n<li>repeat</li>\n</ul>\n<p>多次重复的发送一个数据。</p>\n<ul>\n<li>start</li>\n</ul>\n<p>创建发射一个函数的返回值的observable</p>\n<ul>\n<li>timer</li>\n</ul>\n<p>创建在一个指定的延时之后发射单个数据的observable</p>\n<h1 id=\"transforming-observables-转换observable\"><a href=\"#transforming-observables-转换observable\" class=\"headerlink\" title=\"transforming observables(转换observable)\"></a>transforming observables(转换observable)</h1><ul>\n<li>map</li>\n</ul>\n<p>将一个对象转换为另一个对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.just(1,2,3).map(new Function&lt;Integer, String&gt;() &#123;</span><br><span class=\"line\">           @Override</span><br><span class=\"line\">           public String apply(Integer integer) throws Exception &#123;</span><br><span class=\"line\">               return integer.toString();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class=\"line\">           @Override</span><br><span class=\"line\">           public void accept(String s) throws Exception &#123;</span><br><span class=\"line\">               </span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\">   //简单的例子，将发射为int的字节转换成为string类型的observable</span><br></pre></td></tr></table></figure>\n<ul>\n<li>flatmap</li>\n</ul>\n<p>flatmap是一个一对多的转换对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.just(1,2,3,4).flatMap(new Function&lt;Integer, ObservableSource&lt;? extends String&gt;&gt;() &#123;</span><br><span class=\"line\">           @Override</span><br><span class=\"line\">           public ObservableSource&lt;? extends String&gt; apply(Integer integer) throws Exception &#123;</span><br><span class=\"line\">               return Observable.just(integer+&quot;&quot;);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class=\"line\">           @Override</span><br><span class=\"line\">           public void accept(String s) throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>groupby</li>\n</ul>\n<p>group是一个分组行为，根据指定的规则将上游进行分组归类，然后发送至下游时会夹带分组信息</p>\n<ul>\n<li>buffer</li>\n</ul>\n<p>缓存，定期的从observable收集数据到一个集合，然后打包发送，而不是一次发送一个</p>\n<ul>\n<li>scan</li>\n</ul>\n<p>扫描，对observable发射的每一项数据应用一个函数，然后按照顺序发射这些值</p>\n<ul>\n<li>window</li>\n</ul>\n<p>定期将来自observable的数据拆分成一个个的observable窗口，然后发射这些窗口，而不是每次发射一项，类似于buffer， 不过window发射的是observable</p>\n<h1 id=\"filtering-observables-过滤observable\"><a href=\"#filtering-observables-过滤observable\" class=\"headerlink\" title=\"filtering observables(过滤observable)\"></a>filtering observables(过滤observable)</h1><ul>\n<li>Debounce</li>\n</ul>\n<p>过滤掉了由Observable发射的速率过快的数据；如果在一个指定的时间间隔过去了仍旧没有发射一个，那么它将发射最后的那个。通常我们用来结合RxBinding(Jake Wharton大神使用RxJava封装的Android UI组件)使用，防止button重复点击。</p>\n<ul>\n<li>Distinct</li>\n</ul>\n<p>distinct()的过滤规则是只允许还没有发射过的数据通过，所有重复的数据项都只会发射一次。 </p>\n<ul>\n<li>ElementAt</li>\n</ul>\n<p>获取原始序列第n个元素，并作为唯一发射源进行发射</p>\n<ul>\n<li>Filter</li>\n</ul>\n<p>用来过滤观察序列中我们不想要的值，只返回满足条件的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.from(communities)</span><br><span class=\"line\">        .filter(new Func1&lt;Community, Boolean&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public Boolean call(Community community) &#123;</span><br><span class=\"line\">                return community.houses.size()&gt;10;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).subscribe(new Action1&lt;Community&gt;() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void call(Community community) &#123;</span><br><span class=\"line\">        System.out.println(community.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>First</li>\n</ul>\n<p>它是的Observable只发送观测序列中的第一个数据项。</p>\n<ul>\n<li>last</li>\n</ul>\n<p>last()只发射观测序列中的最后一个数据项。 </p>\n<ul>\n<li>skip</li>\n</ul>\n<p>忽略掉原始序列前n个元素</p>\n<ul>\n<li>skiplast</li>\n</ul>\n<p>忽略掉原始序列最后n个元素</p>\n<ul>\n<li>take</li>\n</ul>\n<p>发送原始序列中的前n个元素<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.from(communities)</span><br><span class=\"line\">        .take(10)</span><br><span class=\"line\">        .subscribe(new Action1&lt;Community&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void call(Community community) &#123;</span><br><span class=\"line\">                System.out.println(community.name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>takelast</li>\n</ul>\n<p>发送原始序列中的最后n个元素</p>\n<h1 id=\"combing-observables-组合observable\"><a href=\"#combing-observables-组合observable\" class=\"headerlink\" title=\"combing observables(组合observable\"></a>combing observables(组合observable</h1><ul>\n<li>zip</li>\n</ul>\n<p>zip(Observable, Observable, Func2)用来合并两个Observable发射的数据项，根据Func2函数生成一个新的值并发射出去。当其中一个Observable发送数据结束或者出现异常后，另一个Observable也将停在发射数据。</p>\n<ul>\n<li>merge</li>\n</ul>\n<p>merge(Observable, Observable)将两个Observable发射的事件序列组合并成一个事件序列，就像是一个Observable发射的一样。你可以简单的将它理解为两个Obsrvable合并成了一个Observable，合并后的数据是无序的。</p>\n<ul>\n<li>startwith</li>\n</ul>\n<p>startWith(T)用于在源Observable发射的数据前插入数据。使用startWith(Iterable<t>)我们还可以在源Observable发射的数据前插入Iterable。</t></p>\n<ul>\n<li>combinelatest</li>\n</ul>\n<p>combineLatest(Observable, Observable, Func2)用于将两个Observale最近发射的数据已经Func2函数的规则进展组合</p>\n<ul>\n<li>join</li>\n</ul>\n<p>join(Observable, Func1, Func1, Func2)我们先介绍下join操作符的4个参数：<br>Observable：源Observable需要组合的Observable,这里我们姑且称之为目标Observable；<br>Func1：接收从源Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了源Obsrvable发射出来的数据的有效期；<br>Func1：接收目标Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了目标Obsrvable发射出来的数据的有效期；<br>Func2：接收从源Observable和目标Observable发射出来的数据，并将这两个数据组合后返回。所以Join操作符的语法结构大致是这样的：onservableA.join(observableB, 控制observableA发射数据有效期的函数， 控制observableB发射数据有效期的函数，两个observable发射数据的合并规则)join操作符的效果类似于排列组合，把第一个数据源A作为基座窗口，他根据自己的节奏不断发射数据元素，第二个数据源B，每发射一个数据，我们都把它和第一个数据源A中已经发射的数据进行一对一匹配；举例来说，如果某一时刻B发射了一个数据“B”,此时A已经发射了0，1，2，3共四个数据，那么我们的合并操作就会把“B”依次与0,1,2,3配对，得到四组数据： [0, B][1, B] [2, B] [3, B]</p>\n<ul>\n<li>switchonnext</li>\n</ul>\n<p>switchOnNext(Observable&lt;? extends Observable&lt;? extends T&gt;&gt;用来将一个发射多个小Observable的源Observable转化为一个Observable，然后发射这多个小Observable所发射的数据。如果一个小的Observable正在发射数据的时候，源Observable又发射出一个新的小Observable，则前一个Observable发射的数据会被抛弃，直接发射新 的小Observable所发射的数据。</p>\n<h1 id=\"error-handling-operators-处理错误\"><a href=\"#error-handling-operators-处理错误\" class=\"headerlink\" title=\"error handling operators(处理错误)\"></a>error handling operators(处理错误)</h1><ul>\n<li><p>catch</p>\n</li>\n<li><p>retry</p>\n</li>\n</ul>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><ul>\n<li>takeUtil</li>\n</ul>\n<p>observable.takeUtil(condition),当condition == true时终止，且包含临界条件的item</p>\n<ul>\n<li>takeWhile</li>\n</ul>\n<p>observable.takeWhile(condition),当condition == false时终止，不包含临界条件的item</p>\n<ul>\n<li>concat</li>\n</ul>\n<p>Concat操作符将多个Observable结合成一个Observable并发射数据，并且严格按照先后顺序发射数据，前一个Observable的数据没有发射完，是不能发射后面Observable的数据的。<br>Concat配合first()可以实现按顺序进行发射数据，有就立即停下，例如从内存缓存，本地缓存，网络请求三者中进行读取数据的操作。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>对rxjava的操作符进行一些笔记。</p>\n<h1 id=\"creating-observables-创建observable\"><a href=\"#creating-observables-创建observable\" class=\"headerlink\" title=\"creating observables(创建observable)\"></a>creating observables(创建observable)</h1><ul>\n<li>create</li>\n</ul>\n<p>最基本的创建操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OObservable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123;</span><br><span class=\"line\">                //上游操作发射</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).subscribe(new Subject&lt;String&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public boolean hasObservers() &#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public boolean hasThrowable() &#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public boolean hasComplete() &#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public Throwable getThrowable() &#123;</span><br><span class=\"line\">                return null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            protected void subscribeActual(Observer&lt;? super String&gt; observer) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onSubscribe(Disposable d) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onNext(String s) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onError(Throwable e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onComplete() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>just</li>\n</ul>\n<p>just就是对create的简写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.just(&apos;1&apos;,&apos;2&apos;).subscribe(new Consumer&lt;Character&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(Character character) throws Exception &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>from</li>\n</ul>\n<p>from可以接受一个创建了的列表作为输入,可以接受不少的类型，列表，迭代器,future,publisher等等</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; source = new ArrayList();</span><br><span class=\"line\">        source.add(&quot;1&quot;);</span><br><span class=\"line\">        source.add(&quot;2&quot;);</span><br><span class=\"line\">        Observable.fromArray(source).subscribe(new Consumer&lt;List&lt;String&gt;&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>defer</li>\n</ul>\n<p>defer是当观察者订阅被观察者的时候，才会开始创建一个observable，其余操作和from，just差不多。</p>\n<ul>\n<li>empty/never/throw</li>\n</ul>\n<p>empty是生成一个空的观察对象，never是生成一个不会向下游发送执行命令的对象，throw会生成一个不会向下游发送执行命令，但是会以一个error终止的对象。</p>\n<ul>\n<li>interval</li>\n</ul>\n<p>interval是起到了定时器功能，根据给定的时间间隔上游来发送数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.interval(10, TimeUnit.SECONDS).just(&quot;1&quot;,&quot;2&quot;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(String s) throws Exception &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>range</li>\n</ul>\n<p>创建在一个范围之类的数据类型，上游依次发送这个范围内的数据。</p>\n<ul>\n<li>repeat</li>\n</ul>\n<p>多次重复的发送一个数据。</p>\n<ul>\n<li>start</li>\n</ul>\n<p>创建发射一个函数的返回值的observable</p>\n<ul>\n<li>timer</li>\n</ul>\n<p>创建在一个指定的延时之后发射单个数据的observable</p>\n<h1 id=\"transforming-observables-转换observable\"><a href=\"#transforming-observables-转换observable\" class=\"headerlink\" title=\"transforming observables(转换observable)\"></a>transforming observables(转换observable)</h1><ul>\n<li>map</li>\n</ul>\n<p>将一个对象转换为另一个对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.just(1,2,3).map(new Function&lt;Integer, String&gt;() &#123;</span><br><span class=\"line\">           @Override</span><br><span class=\"line\">           public String apply(Integer integer) throws Exception &#123;</span><br><span class=\"line\">               return integer.toString();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class=\"line\">           @Override</span><br><span class=\"line\">           public void accept(String s) throws Exception &#123;</span><br><span class=\"line\">               </span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\">   //简单的例子，将发射为int的字节转换成为string类型的observable</span><br></pre></td></tr></table></figure>\n<ul>\n<li>flatmap</li>\n</ul>\n<p>flatmap是一个一对多的转换对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.just(1,2,3,4).flatMap(new Function&lt;Integer, ObservableSource&lt;? extends String&gt;&gt;() &#123;</span><br><span class=\"line\">           @Override</span><br><span class=\"line\">           public ObservableSource&lt;? extends String&gt; apply(Integer integer) throws Exception &#123;</span><br><span class=\"line\">               return Observable.just(integer+&quot;&quot;);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class=\"line\">           @Override</span><br><span class=\"line\">           public void accept(String s) throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>groupby</li>\n</ul>\n<p>group是一个分组行为，根据指定的规则将上游进行分组归类，然后发送至下游时会夹带分组信息</p>\n<ul>\n<li>buffer</li>\n</ul>\n<p>缓存，定期的从observable收集数据到一个集合，然后打包发送，而不是一次发送一个</p>\n<ul>\n<li>scan</li>\n</ul>\n<p>扫描，对observable发射的每一项数据应用一个函数，然后按照顺序发射这些值</p>\n<ul>\n<li>window</li>\n</ul>\n<p>定期将来自observable的数据拆分成一个个的observable窗口，然后发射这些窗口，而不是每次发射一项，类似于buffer， 不过window发射的是observable</p>\n<h1 id=\"filtering-observables-过滤observable\"><a href=\"#filtering-observables-过滤observable\" class=\"headerlink\" title=\"filtering observables(过滤observable)\"></a>filtering observables(过滤observable)</h1><ul>\n<li>Debounce</li>\n</ul>\n<p>过滤掉了由Observable发射的速率过快的数据；如果在一个指定的时间间隔过去了仍旧没有发射一个，那么它将发射最后的那个。通常我们用来结合RxBinding(Jake Wharton大神使用RxJava封装的Android UI组件)使用，防止button重复点击。</p>\n<ul>\n<li>Distinct</li>\n</ul>\n<p>distinct()的过滤规则是只允许还没有发射过的数据通过，所有重复的数据项都只会发射一次。 </p>\n<ul>\n<li>ElementAt</li>\n</ul>\n<p>获取原始序列第n个元素，并作为唯一发射源进行发射</p>\n<ul>\n<li>Filter</li>\n</ul>\n<p>用来过滤观察序列中我们不想要的值，只返回满足条件的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.from(communities)</span><br><span class=\"line\">        .filter(new Func1&lt;Community, Boolean&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public Boolean call(Community community) &#123;</span><br><span class=\"line\">                return community.houses.size()&gt;10;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).subscribe(new Action1&lt;Community&gt;() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void call(Community community) &#123;</span><br><span class=\"line\">        System.out.println(community.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>First</li>\n</ul>\n<p>它是的Observable只发送观测序列中的第一个数据项。</p>\n<ul>\n<li>last</li>\n</ul>\n<p>last()只发射观测序列中的最后一个数据项。 </p>\n<ul>\n<li>skip</li>\n</ul>\n<p>忽略掉原始序列前n个元素</p>\n<ul>\n<li>skiplast</li>\n</ul>\n<p>忽略掉原始序列最后n个元素</p>\n<ul>\n<li>take</li>\n</ul>\n<p>发送原始序列中的前n个元素<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.from(communities)</span><br><span class=\"line\">        .take(10)</span><br><span class=\"line\">        .subscribe(new Action1&lt;Community&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void call(Community community) &#123;</span><br><span class=\"line\">                System.out.println(community.name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>takelast</li>\n</ul>\n<p>发送原始序列中的最后n个元素</p>\n<h1 id=\"combing-observables-组合observable\"><a href=\"#combing-observables-组合observable\" class=\"headerlink\" title=\"combing observables(组合observable\"></a>combing observables(组合observable</h1><ul>\n<li>zip</li>\n</ul>\n<p>zip(Observable, Observable, Func2)用来合并两个Observable发射的数据项，根据Func2函数生成一个新的值并发射出去。当其中一个Observable发送数据结束或者出现异常后，另一个Observable也将停在发射数据。</p>\n<ul>\n<li>merge</li>\n</ul>\n<p>merge(Observable, Observable)将两个Observable发射的事件序列组合并成一个事件序列，就像是一个Observable发射的一样。你可以简单的将它理解为两个Obsrvable合并成了一个Observable，合并后的数据是无序的。</p>\n<ul>\n<li>startwith</li>\n</ul>\n<p>startWith(T)用于在源Observable发射的数据前插入数据。使用startWith(Iterable<t>)我们还可以在源Observable发射的数据前插入Iterable。</t></p>\n<ul>\n<li>combinelatest</li>\n</ul>\n<p>combineLatest(Observable, Observable, Func2)用于将两个Observale最近发射的数据已经Func2函数的规则进展组合</p>\n<ul>\n<li>join</li>\n</ul>\n<p>join(Observable, Func1, Func1, Func2)我们先介绍下join操作符的4个参数：<br>Observable：源Observable需要组合的Observable,这里我们姑且称之为目标Observable；<br>Func1：接收从源Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了源Obsrvable发射出来的数据的有效期；<br>Func1：接收目标Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了目标Obsrvable发射出来的数据的有效期；<br>Func2：接收从源Observable和目标Observable发射出来的数据，并将这两个数据组合后返回。所以Join操作符的语法结构大致是这样的：onservableA.join(observableB, 控制observableA发射数据有效期的函数， 控制observableB发射数据有效期的函数，两个observable发射数据的合并规则)join操作符的效果类似于排列组合，把第一个数据源A作为基座窗口，他根据自己的节奏不断发射数据元素，第二个数据源B，每发射一个数据，我们都把它和第一个数据源A中已经发射的数据进行一对一匹配；举例来说，如果某一时刻B发射了一个数据“B”,此时A已经发射了0，1，2，3共四个数据，那么我们的合并操作就会把“B”依次与0,1,2,3配对，得到四组数据： [0, B][1, B] [2, B] [3, B]</p>\n<ul>\n<li>switchonnext</li>\n</ul>\n<p>switchOnNext(Observable&lt;? extends Observable&lt;? extends T&gt;&gt;用来将一个发射多个小Observable的源Observable转化为一个Observable，然后发射这多个小Observable所发射的数据。如果一个小的Observable正在发射数据的时候，源Observable又发射出一个新的小Observable，则前一个Observable发射的数据会被抛弃，直接发射新 的小Observable所发射的数据。</p>\n<h1 id=\"error-handling-operators-处理错误\"><a href=\"#error-handling-operators-处理错误\" class=\"headerlink\" title=\"error handling operators(处理错误)\"></a>error handling operators(处理错误)</h1><ul>\n<li><p>catch</p>\n</li>\n<li><p>retry</p>\n</li>\n</ul>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><ul>\n<li>takeUtil</li>\n</ul>\n<p>observable.takeUtil(condition),当condition == true时终止，且包含临界条件的item</p>\n<ul>\n<li>takeWhile</li>\n</ul>\n<p>observable.takeWhile(condition),当condition == false时终止，不包含临界条件的item</p>\n<ul>\n<li>concat</li>\n</ul>\n<p>Concat操作符将多个Observable结合成一个Observable并发射数据，并且严格按照先后顺序发射数据，前一个Observable的数据没有发射完，是不能发射后面Observable的数据的。<br>Concat配合first()可以实现按顺序进行发射数据，有就立即停下，例如从内存缓存，本地缓存，网络请求三者中进行读取数据的操作。</p>\n"},{"title":"threadlocal学习","date":"2019-01-07T05:36:26.000Z","_content":"\n# 作用\n\nthreadlocal是java.lang包下面的，其作用通过类注释可以看出来\n\n```\n/**\n * This class provides thread-local variables.  These variables differ from\n * their normal counterparts in that each thread that accesses one (via its\n * {@code get} or {@code set} method) has its own, independently initialized\n * copy of the variable.  {@code ThreadLocal} instances are typically private\n * static fields in classes that wish to associate state with a thread (e.g.,\n * a user ID or Transaction ID).\n *\n * <p>For example, the class below generates unique identifiers local to each\n * thread.\n * A thread's id is assigned the first time it invokes {@code ThreadId.get()}\n * and remains unchanged on subsequent calls.\n * <pre>\n * import java.util.concurrent.atomic.AtomicInteger;\n *\n * public class ThreadId {\n *     // Atomic integer containing the next thread ID to be assigned\n *     private static final AtomicInteger nextId = new AtomicInteger(0);\n *\n *     // Thread local variable containing each thread's ID\n *     private static final ThreadLocal&lt;Integer&gt; threadId =\n *         new ThreadLocal&lt;Integer&gt;() {\n *             &#64;Override protected Integer initialValue() {\n *                 return nextId.getAndIncrement();\n *         }\n *     };\n *\n *     // Returns the current thread's unique ID, assigning it if necessary\n *     public static int get() {\n *         return threadId.get();\n *     }\n * }\n * </pre>\n * <p>Each thread holds an implicit reference to its copy of a thread-local\n * variable as long as the thread is alive and the {@code ThreadLocal}\n * instance is accessible; after a thread goes away, all of its copies of\n * thread-local instances are subject to garbage collection (unless other\n * references to these copies exist).\n *\n * @author  Josh Bloch and Doug Lea\n * @since   1.2\n */\n```\n翻译一下：\n这个类提供了一个本地线程变量，这些变量在不同线程中有不同的副本，都是独立的原始变量的拷贝。其实例是希望与线程连接状态的独立的field。\n\n因此就是在不同的thread中保留不同的值的类型。\n\n# api\n\n```\n\t/**\n     * Creates a thread local variable.\n     * @see #withInitial(java.util.function.Supplier)\n     */\n    public ThreadLocal() {\n    }\n\n    /**\n     * Returns the value in the current thread's copy of this\n     * thread-local variable.  If the variable has no value for the\n     * current thread, it is first initialized to the value returned\n     * by an invocation of the {@link #initialValue} method.\n     *\n     * @return the current thread's value of this thread-local\n     */\n    public T get() {\n    \t...\n    }\n\n    /**\n     * Sets the current thread's copy of this thread-local variable\n     * to the specified value.  Most subclasses will have no need to\n     * override this method, relying solely on the {@link #initialValue}\n     * method to set the values of thread-locals.\n     *\n     * @param value the value to be stored in the current thread's copy of\n     *        this thread-local.\n     */\n    public void set(T value) {\n    \t...\n    }\n\n    /**\n     * Removes the current thread's value for this thread-local\n     * variable.  If this thread-local variable is subsequently\n     * {@linkplain #get read} by the current thread, its value will be\n     * reinitialized by invoking its {@link #initialValue} method,\n     * unless its value is {@linkplain #set set} by the current thread\n     * in the interim.  This may result in multiple invocations of the\n     * {@code initialValue} method in the current thread.\n     *\n     * @since 1.5\n     */\n     public void remove() {\n     \t...\n     }\n```\n\npublic 的接口就这几个。\n\n# set\n\n```\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n\n    /**\n     * Get the map associated with a ThreadLocal. Overridden in\n     * InheritableThreadLocal.\n     *\n     * @param  t the current thread\n     * @return the map\n     */\n    ThreadLocalMap getMap(Thread t) {\n        return t.threadLocals;\n    }\n\n    /**\n     * Create the map associated with a ThreadLocal. Overridden in\n     * InheritableThreadLocal.\n     *\n     * @param t the current thread\n     * @param firstValue value for the initial entry of the map\n     */\n    void createMap(Thread t, T firstValue) {\n        t.threadLocals = new ThreadLocalMap(this, firstValue);\n    }\n```\n\nset的时候会获取当前的map，如果没有就会创建，有的话就会调用map的set\n\n其中有个概念，是threadlocalmap，既然是map，看看键值对是什么\n\n```\nprivate void set(ThreadLocal<?> key, Object value)\n```\n\n也就是用threadlocal作为key，其余的作为value进行存储的。\n\n## 总结一下set\n\n1.每个thread中有一个threadlocalmap\n2.threadlocalmap是以threadlocal为key，目标值为value的map结构\n3.当希望存储这个threadlocal的时候，会先从线程中取出这个threadlocalmap，然后以这个threadlocal为key，将目标值传入进去。\n4.如果当前线程没有threadlocalmap的话，会主动创建一个塞进去。\n\n# get\n\n```\n/**\n     * Returns the value in the current thread's copy of this\n     * thread-local variable.  If the variable has no value for the\n     * current thread, it is first initialized to the value returned\n     * by an invocation of the {@link #initialValue} method.\n     *\n     * @return the current thread's value of this thread-local\n     */\n    public T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        return setInitialValue();\n    }\n\n\tprivate Entry getEntry(ThreadLocal<?> key) {\n            int i = key.threadLocalHashCode & (table.length - 1);\n            Entry e = table[i];\n            if (e != null && e.get() == key)\n                return e;\n            else\n                return getEntryAfterMiss(key, i, e);\n    }\n\n    private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n            Entry[] tab = table;\n            int len = tab.length;\n\n            while (e != null) {\n                ThreadLocal<?> k = e.get();\n                if (k == key)\n                    return e;\n                if (k == null)\n                    expungeStaleEntry(i);\n                else\n                    i = nextIndex(i, len);\n                e = tab[i];\n            }\n            return null;\n        }    \n\n    private int expungeStaleEntry(int staleSlot) {\n            Entry[] tab = table;\n            int len = tab.length;\n\n            // expunge entry at staleSlot\n            tab[staleSlot].value = null;\n            tab[staleSlot] = null;\n            size--;\n\n            // Rehash until we encounter null\n            Entry e;\n            int i;\n            for (i = nextIndex(staleSlot, len);\n                 (e = tab[i]) != null;\n                 i = nextIndex(i, len)) {\n                ThreadLocal<?> k = e.get();\n                if (k == null) {\n                    e.value = null;\n                    tab[i] = null;\n                    size--;\n                } else {\n                    int h = k.threadLocalHashCode & (len - 1);\n                    if (h != i) {\n                        tab[i] = null;\n\n                        // Unlike Knuth 6.4 Algorithm R, we must scan until\n                        // null because multiple entries could have been stale.\n                        while (tab[h] != null)\n                            h = nextIndex(h, len);\n                        tab[h] = e;\n                    }\n                }\n            }\n            return i;\n        }  \n        \n    private static int nextIndex(int i, int len) {\n            return ((i + 1 < len) ? i + 1 : 0);\n        }      \n```\n\n从流程上面其实就是一个map寻址操作，有个注意点，由于threadlocalmap的entry，是一个weakreference，所以有可能会出现获取的时候发现为null，此时需要擦除这个值。不过源码中擦除不单单这个值，把别的空的也同时擦除了。\n\n# remove\n\n```\npublic void remove() {\n         ThreadLocalMap m = getMap(Thread.currentThread());\n         if (m != null)\n             m.remove(this);\n     }\n```\n擦除了这个key\n\n\n# Q&A\n\n## ThreadLocalMap里Entry为何声明为WeakReference？\n\n引用关系是这样的\n\nThreadLocalRef持有对ThreadLocal的引用，同时map的entry也持有对threadlocal的引用，而map的引用是在Current Thread手里，这样就会造成当清除ThreadLocalRef的时候出现泄漏的情况。\n\n将entry声明为weakreference，这样在上述这种情况时，就不会产生泄漏现象，但是value仍然存在，只是索引不到，map仍然持有这个对象。\n\nthreadlocalmap针对这个问题，特意在get和set、remove的时候，执行了擦除所有key为null的值。\n\n## threadlocalmap避免出现内存泄漏的情况\n\n1.尽量避免使用static修饰，会拉伸threadlocal声明周期\n2.分配使用了threadlocal后，如果不需要了，记得要使用remove操作擦除这块数据。","source":"_posts/threadlocal学习.md","raw":"---\ntitle: threadlocal学习\ndate: 2019-01-07 13:36:26\ntags: java\n---\n\n# 作用\n\nthreadlocal是java.lang包下面的，其作用通过类注释可以看出来\n\n```\n/**\n * This class provides thread-local variables.  These variables differ from\n * their normal counterparts in that each thread that accesses one (via its\n * {@code get} or {@code set} method) has its own, independently initialized\n * copy of the variable.  {@code ThreadLocal} instances are typically private\n * static fields in classes that wish to associate state with a thread (e.g.,\n * a user ID or Transaction ID).\n *\n * <p>For example, the class below generates unique identifiers local to each\n * thread.\n * A thread's id is assigned the first time it invokes {@code ThreadId.get()}\n * and remains unchanged on subsequent calls.\n * <pre>\n * import java.util.concurrent.atomic.AtomicInteger;\n *\n * public class ThreadId {\n *     // Atomic integer containing the next thread ID to be assigned\n *     private static final AtomicInteger nextId = new AtomicInteger(0);\n *\n *     // Thread local variable containing each thread's ID\n *     private static final ThreadLocal&lt;Integer&gt; threadId =\n *         new ThreadLocal&lt;Integer&gt;() {\n *             &#64;Override protected Integer initialValue() {\n *                 return nextId.getAndIncrement();\n *         }\n *     };\n *\n *     // Returns the current thread's unique ID, assigning it if necessary\n *     public static int get() {\n *         return threadId.get();\n *     }\n * }\n * </pre>\n * <p>Each thread holds an implicit reference to its copy of a thread-local\n * variable as long as the thread is alive and the {@code ThreadLocal}\n * instance is accessible; after a thread goes away, all of its copies of\n * thread-local instances are subject to garbage collection (unless other\n * references to these copies exist).\n *\n * @author  Josh Bloch and Doug Lea\n * @since   1.2\n */\n```\n翻译一下：\n这个类提供了一个本地线程变量，这些变量在不同线程中有不同的副本，都是独立的原始变量的拷贝。其实例是希望与线程连接状态的独立的field。\n\n因此就是在不同的thread中保留不同的值的类型。\n\n# api\n\n```\n\t/**\n     * Creates a thread local variable.\n     * @see #withInitial(java.util.function.Supplier)\n     */\n    public ThreadLocal() {\n    }\n\n    /**\n     * Returns the value in the current thread's copy of this\n     * thread-local variable.  If the variable has no value for the\n     * current thread, it is first initialized to the value returned\n     * by an invocation of the {@link #initialValue} method.\n     *\n     * @return the current thread's value of this thread-local\n     */\n    public T get() {\n    \t...\n    }\n\n    /**\n     * Sets the current thread's copy of this thread-local variable\n     * to the specified value.  Most subclasses will have no need to\n     * override this method, relying solely on the {@link #initialValue}\n     * method to set the values of thread-locals.\n     *\n     * @param value the value to be stored in the current thread's copy of\n     *        this thread-local.\n     */\n    public void set(T value) {\n    \t...\n    }\n\n    /**\n     * Removes the current thread's value for this thread-local\n     * variable.  If this thread-local variable is subsequently\n     * {@linkplain #get read} by the current thread, its value will be\n     * reinitialized by invoking its {@link #initialValue} method,\n     * unless its value is {@linkplain #set set} by the current thread\n     * in the interim.  This may result in multiple invocations of the\n     * {@code initialValue} method in the current thread.\n     *\n     * @since 1.5\n     */\n     public void remove() {\n     \t...\n     }\n```\n\npublic 的接口就这几个。\n\n# set\n\n```\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n\n    /**\n     * Get the map associated with a ThreadLocal. Overridden in\n     * InheritableThreadLocal.\n     *\n     * @param  t the current thread\n     * @return the map\n     */\n    ThreadLocalMap getMap(Thread t) {\n        return t.threadLocals;\n    }\n\n    /**\n     * Create the map associated with a ThreadLocal. Overridden in\n     * InheritableThreadLocal.\n     *\n     * @param t the current thread\n     * @param firstValue value for the initial entry of the map\n     */\n    void createMap(Thread t, T firstValue) {\n        t.threadLocals = new ThreadLocalMap(this, firstValue);\n    }\n```\n\nset的时候会获取当前的map，如果没有就会创建，有的话就会调用map的set\n\n其中有个概念，是threadlocalmap，既然是map，看看键值对是什么\n\n```\nprivate void set(ThreadLocal<?> key, Object value)\n```\n\n也就是用threadlocal作为key，其余的作为value进行存储的。\n\n## 总结一下set\n\n1.每个thread中有一个threadlocalmap\n2.threadlocalmap是以threadlocal为key，目标值为value的map结构\n3.当希望存储这个threadlocal的时候，会先从线程中取出这个threadlocalmap，然后以这个threadlocal为key，将目标值传入进去。\n4.如果当前线程没有threadlocalmap的话，会主动创建一个塞进去。\n\n# get\n\n```\n/**\n     * Returns the value in the current thread's copy of this\n     * thread-local variable.  If the variable has no value for the\n     * current thread, it is first initialized to the value returned\n     * by an invocation of the {@link #initialValue} method.\n     *\n     * @return the current thread's value of this thread-local\n     */\n    public T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        return setInitialValue();\n    }\n\n\tprivate Entry getEntry(ThreadLocal<?> key) {\n            int i = key.threadLocalHashCode & (table.length - 1);\n            Entry e = table[i];\n            if (e != null && e.get() == key)\n                return e;\n            else\n                return getEntryAfterMiss(key, i, e);\n    }\n\n    private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n            Entry[] tab = table;\n            int len = tab.length;\n\n            while (e != null) {\n                ThreadLocal<?> k = e.get();\n                if (k == key)\n                    return e;\n                if (k == null)\n                    expungeStaleEntry(i);\n                else\n                    i = nextIndex(i, len);\n                e = tab[i];\n            }\n            return null;\n        }    \n\n    private int expungeStaleEntry(int staleSlot) {\n            Entry[] tab = table;\n            int len = tab.length;\n\n            // expunge entry at staleSlot\n            tab[staleSlot].value = null;\n            tab[staleSlot] = null;\n            size--;\n\n            // Rehash until we encounter null\n            Entry e;\n            int i;\n            for (i = nextIndex(staleSlot, len);\n                 (e = tab[i]) != null;\n                 i = nextIndex(i, len)) {\n                ThreadLocal<?> k = e.get();\n                if (k == null) {\n                    e.value = null;\n                    tab[i] = null;\n                    size--;\n                } else {\n                    int h = k.threadLocalHashCode & (len - 1);\n                    if (h != i) {\n                        tab[i] = null;\n\n                        // Unlike Knuth 6.4 Algorithm R, we must scan until\n                        // null because multiple entries could have been stale.\n                        while (tab[h] != null)\n                            h = nextIndex(h, len);\n                        tab[h] = e;\n                    }\n                }\n            }\n            return i;\n        }  \n        \n    private static int nextIndex(int i, int len) {\n            return ((i + 1 < len) ? i + 1 : 0);\n        }      \n```\n\n从流程上面其实就是一个map寻址操作，有个注意点，由于threadlocalmap的entry，是一个weakreference，所以有可能会出现获取的时候发现为null，此时需要擦除这个值。不过源码中擦除不单单这个值，把别的空的也同时擦除了。\n\n# remove\n\n```\npublic void remove() {\n         ThreadLocalMap m = getMap(Thread.currentThread());\n         if (m != null)\n             m.remove(this);\n     }\n```\n擦除了这个key\n\n\n# Q&A\n\n## ThreadLocalMap里Entry为何声明为WeakReference？\n\n引用关系是这样的\n\nThreadLocalRef持有对ThreadLocal的引用，同时map的entry也持有对threadlocal的引用，而map的引用是在Current Thread手里，这样就会造成当清除ThreadLocalRef的时候出现泄漏的情况。\n\n将entry声明为weakreference，这样在上述这种情况时，就不会产生泄漏现象，但是value仍然存在，只是索引不到，map仍然持有这个对象。\n\nthreadlocalmap针对这个问题，特意在get和set、remove的时候，执行了擦除所有key为null的值。\n\n## threadlocalmap避免出现内存泄漏的情况\n\n1.尽量避免使用static修饰，会拉伸threadlocal声明周期\n2.分配使用了threadlocal后，如果不需要了，记得要使用remove操作擦除这块数据。","slug":"threadlocal学习","published":1,"updated":"2019-03-12T09:26:33.162Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltu04006n3a8kg913fj6t","content":"<h1 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h1><p>threadlocal是java.lang包下面的，其作用通过类注释可以看出来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * This class provides thread-local variables.  These variables differ from</span><br><span class=\"line\"> * their normal counterparts in that each thread that accesses one (via its</span><br><span class=\"line\"> * &#123;@code get&#125; or &#123;@code set&#125; method) has its own, independently initialized</span><br><span class=\"line\"> * copy of the variable.  &#123;@code ThreadLocal&#125; instances are typically private</span><br><span class=\"line\"> * static fields in classes that wish to associate state with a thread (e.g.,</span><br><span class=\"line\"> * a user ID or Transaction ID).</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * &lt;p&gt;For example, the class below generates unique identifiers local to each</span><br><span class=\"line\"> * thread.</span><br><span class=\"line\"> * A thread&apos;s id is assigned the first time it invokes &#123;@code ThreadId.get()&#125;</span><br><span class=\"line\"> * and remains unchanged on subsequent calls.</span><br><span class=\"line\"> * &lt;pre&gt;</span><br><span class=\"line\"> * import java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * public class ThreadId &#123;</span><br><span class=\"line\"> *     // Atomic integer containing the next thread ID to be assigned</span><br><span class=\"line\"> *     private static final AtomicInteger nextId = new AtomicInteger(0);</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *     // Thread local variable containing each thread&apos;s ID</span><br><span class=\"line\"> *     private static final ThreadLocal&amp;lt;Integer&amp;gt; threadId =</span><br><span class=\"line\"> *         new ThreadLocal&amp;lt;Integer&amp;gt;() &#123;</span><br><span class=\"line\"> *             &amp;#64;Override protected Integer initialValue() &#123;</span><br><span class=\"line\"> *                 return nextId.getAndIncrement();</span><br><span class=\"line\"> *         &#125;</span><br><span class=\"line\"> *     &#125;;</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *     // Returns the current thread&apos;s unique ID, assigning it if necessary</span><br><span class=\"line\"> *     public static int get() &#123;</span><br><span class=\"line\"> *         return threadId.get();</span><br><span class=\"line\"> *     &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> * &lt;/pre&gt;</span><br><span class=\"line\"> * &lt;p&gt;Each thread holds an implicit reference to its copy of a thread-local</span><br><span class=\"line\"> * variable as long as the thread is alive and the &#123;@code ThreadLocal&#125;</span><br><span class=\"line\"> * instance is accessible; after a thread goes away, all of its copies of</span><br><span class=\"line\"> * thread-local instances are subject to garbage collection (unless other</span><br><span class=\"line\"> * references to these copies exist).</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author  Josh Bloch and Doug Lea</span><br><span class=\"line\"> * @since   1.2</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n<p>翻译一下：<br>这个类提供了一个本地线程变量，这些变量在不同线程中有不同的副本，都是独立的原始变量的拷贝。其实例是希望与线程连接状态的独立的field。</p>\n<p>因此就是在不同的thread中保留不同的值的类型。</p>\n<h1 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">    * Creates a thread local variable.</span><br><span class=\"line\">    * @see #withInitial(java.util.function.Supplier)</span><br><span class=\"line\">    */</span><br><span class=\"line\">   public ThreadLocal() &#123;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   /**</span><br><span class=\"line\">    * Returns the value in the current thread&apos;s copy of this</span><br><span class=\"line\">    * thread-local variable.  If the variable has no value for the</span><br><span class=\"line\">    * current thread, it is first initialized to the value returned</span><br><span class=\"line\">    * by an invocation of the &#123;@link #initialValue&#125; method.</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @return the current thread&apos;s value of this thread-local</span><br><span class=\"line\">    */</span><br><span class=\"line\">   public T get() &#123;</span><br><span class=\"line\">   \t...</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   /**</span><br><span class=\"line\">    * Sets the current thread&apos;s copy of this thread-local variable</span><br><span class=\"line\">    * to the specified value.  Most subclasses will have no need to</span><br><span class=\"line\">    * override this method, relying solely on the &#123;@link #initialValue&#125;</span><br><span class=\"line\">    * method to set the values of thread-locals.</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @param value the value to be stored in the current thread&apos;s copy of</span><br><span class=\"line\">    *        this thread-local.</span><br><span class=\"line\">    */</span><br><span class=\"line\">   public void set(T value) &#123;</span><br><span class=\"line\">   \t...</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   /**</span><br><span class=\"line\">    * Removes the current thread&apos;s value for this thread-local</span><br><span class=\"line\">    * variable.  If this thread-local variable is subsequently</span><br><span class=\"line\">    * &#123;@linkplain #get read&#125; by the current thread, its value will be</span><br><span class=\"line\">    * reinitialized by invoking its &#123;@link #initialValue&#125; method,</span><br><span class=\"line\">    * unless its value is &#123;@linkplain #set set&#125; by the current thread</span><br><span class=\"line\">    * in the interim.  This may result in multiple invocations of the</span><br><span class=\"line\">    * &#123;@code initialValue&#125; method in the current thread.</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @since 1.5</span><br><span class=\"line\">    */</span><br><span class=\"line\">    public void remove() &#123;</span><br><span class=\"line\">    \t...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>public 的接口就这几个。</p>\n<h1 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void set(T value) &#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">        if (map != null)</span><br><span class=\"line\">            map.set(this, value);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            createMap(t, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Get the map associated with a ThreadLocal. Overridden in</span><br><span class=\"line\">     * InheritableThreadLocal.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param  t the current thread</span><br><span class=\"line\">     * @return the map</span><br><span class=\"line\">     */</span><br><span class=\"line\">    ThreadLocalMap getMap(Thread t) &#123;</span><br><span class=\"line\">        return t.threadLocals;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Create the map associated with a ThreadLocal. Overridden in</span><br><span class=\"line\">     * InheritableThreadLocal.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param t the current thread</span><br><span class=\"line\">     * @param firstValue value for the initial entry of the map</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void createMap(Thread t, T firstValue) &#123;</span><br><span class=\"line\">        t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>set的时候会获取当前的map，如果没有就会创建，有的话就会调用map的set</p>\n<p>其中有个概念，是threadlocalmap，既然是map，看看键值对是什么</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void set(ThreadLocal&lt;?&gt; key, Object value)</span><br></pre></td></tr></table></figure>\n<p>也就是用threadlocal作为key，其余的作为value进行存储的。</p>\n<h2 id=\"总结一下set\"><a href=\"#总结一下set\" class=\"headerlink\" title=\"总结一下set\"></a>总结一下set</h2><p>1.每个thread中有一个threadlocalmap<br>2.threadlocalmap是以threadlocal为key，目标值为value的map结构<br>3.当希望存储这个threadlocal的时候，会先从线程中取出这个threadlocalmap，然后以这个threadlocal为key，将目标值传入进去。<br>4.如果当前线程没有threadlocalmap的话，会主动创建一个塞进去。</p>\n<h1 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * Returns the value in the current thread&apos;s copy of this</span><br><span class=\"line\">     * thread-local variable.  If the variable has no value for the</span><br><span class=\"line\">     * current thread, it is first initialized to the value returned</span><br><span class=\"line\">     * by an invocation of the &#123;@link #initialValue&#125; method.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return the current thread&apos;s value of this thread-local</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public T get() &#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">        if (map != null) &#123;</span><br><span class=\"line\">            ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class=\"line\">            if (e != null) &#123;</span><br><span class=\"line\">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">                T result = (T)e.value;</span><br><span class=\"line\">                return result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return setInitialValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class=\"line\">            int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class=\"line\">            Entry e = table[i];</span><br><span class=\"line\">            if (e != null &amp;&amp; e.get() == key)</span><br><span class=\"line\">                return e;</span><br><span class=\"line\">            else</span><br><span class=\"line\">                return getEntryAfterMiss(key, i, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class=\"line\">            Entry[] tab = table;</span><br><span class=\"line\">            int len = tab.length;</span><br><span class=\"line\"></span><br><span class=\"line\">            while (e != null) &#123;</span><br><span class=\"line\">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">                if (k == key)</span><br><span class=\"line\">                    return e;</span><br><span class=\"line\">                if (k == null)</span><br><span class=\"line\">                    expungeStaleEntry(i);</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    i = nextIndex(i, len);</span><br><span class=\"line\">                e = tab[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">    private int expungeStaleEntry(int staleSlot) &#123;</span><br><span class=\"line\">            Entry[] tab = table;</span><br><span class=\"line\">            int len = tab.length;</span><br><span class=\"line\"></span><br><span class=\"line\">            // expunge entry at staleSlot</span><br><span class=\"line\">            tab[staleSlot].value = null;</span><br><span class=\"line\">            tab[staleSlot] = null;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\"></span><br><span class=\"line\">            // Rehash until we encounter null</span><br><span class=\"line\">            Entry e;</span><br><span class=\"line\">            int i;</span><br><span class=\"line\">            for (i = nextIndex(staleSlot, len);</span><br><span class=\"line\">                 (e = tab[i]) != null;</span><br><span class=\"line\">                 i = nextIndex(i, len)) &#123;</span><br><span class=\"line\">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">                if (k == null) &#123;</span><br><span class=\"line\">                    e.value = null;</span><br><span class=\"line\">                    tab[i] = null;</span><br><span class=\"line\">                    size--;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    int h = k.threadLocalHashCode &amp; (len - 1);</span><br><span class=\"line\">                    if (h != i) &#123;</span><br><span class=\"line\">                        tab[i] = null;</span><br><span class=\"line\"></span><br><span class=\"line\">                        // Unlike Knuth 6.4 Algorithm R, we must scan until</span><br><span class=\"line\">                        // null because multiple entries could have been stale.</span><br><span class=\"line\">                        while (tab[h] != null)</span><br><span class=\"line\">                            h = nextIndex(h, len);</span><br><span class=\"line\">                        tab[h] = e;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return i;</span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        </span><br><span class=\"line\">    private static int nextIndex(int i, int len) &#123;</span><br><span class=\"line\">            return ((i + 1 &lt; len) ? i + 1 : 0);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>从流程上面其实就是一个map寻址操作，有个注意点，由于threadlocalmap的entry，是一个weakreference，所以有可能会出现获取的时候发现为null，此时需要擦除这个值。不过源码中擦除不单单这个值，把别的空的也同时擦除了。</p>\n<h1 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void remove() &#123;</span><br><span class=\"line\">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class=\"line\">         if (m != null)</span><br><span class=\"line\">             m.remove(this);</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<p>擦除了这个key</p>\n<h1 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h1><h2 id=\"ThreadLocalMap里Entry为何声明为WeakReference？\"><a href=\"#ThreadLocalMap里Entry为何声明为WeakReference？\" class=\"headerlink\" title=\"ThreadLocalMap里Entry为何声明为WeakReference？\"></a>ThreadLocalMap里Entry为何声明为WeakReference？</h2><p>引用关系是这样的</p>\n<p>ThreadLocalRef持有对ThreadLocal的引用，同时map的entry也持有对threadlocal的引用，而map的引用是在Current Thread手里，这样就会造成当清除ThreadLocalRef的时候出现泄漏的情况。</p>\n<p>将entry声明为weakreference，这样在上述这种情况时，就不会产生泄漏现象，但是value仍然存在，只是索引不到，map仍然持有这个对象。</p>\n<p>threadlocalmap针对这个问题，特意在get和set、remove的时候，执行了擦除所有key为null的值。</p>\n<h2 id=\"threadlocalmap避免出现内存泄漏的情况\"><a href=\"#threadlocalmap避免出现内存泄漏的情况\" class=\"headerlink\" title=\"threadlocalmap避免出现内存泄漏的情况\"></a>threadlocalmap避免出现内存泄漏的情况</h2><p>1.尽量避免使用static修饰，会拉伸threadlocal声明周期<br>2.分配使用了threadlocal后，如果不需要了，记得要使用remove操作擦除这块数据。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h1><p>threadlocal是java.lang包下面的，其作用通过类注释可以看出来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * This class provides thread-local variables.  These variables differ from</span><br><span class=\"line\"> * their normal counterparts in that each thread that accesses one (via its</span><br><span class=\"line\"> * &#123;@code get&#125; or &#123;@code set&#125; method) has its own, independently initialized</span><br><span class=\"line\"> * copy of the variable.  &#123;@code ThreadLocal&#125; instances are typically private</span><br><span class=\"line\"> * static fields in classes that wish to associate state with a thread (e.g.,</span><br><span class=\"line\"> * a user ID or Transaction ID).</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * &lt;p&gt;For example, the class below generates unique identifiers local to each</span><br><span class=\"line\"> * thread.</span><br><span class=\"line\"> * A thread&apos;s id is assigned the first time it invokes &#123;@code ThreadId.get()&#125;</span><br><span class=\"line\"> * and remains unchanged on subsequent calls.</span><br><span class=\"line\"> * &lt;pre&gt;</span><br><span class=\"line\"> * import java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * public class ThreadId &#123;</span><br><span class=\"line\"> *     // Atomic integer containing the next thread ID to be assigned</span><br><span class=\"line\"> *     private static final AtomicInteger nextId = new AtomicInteger(0);</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *     // Thread local variable containing each thread&apos;s ID</span><br><span class=\"line\"> *     private static final ThreadLocal&amp;lt;Integer&amp;gt; threadId =</span><br><span class=\"line\"> *         new ThreadLocal&amp;lt;Integer&amp;gt;() &#123;</span><br><span class=\"line\"> *             &amp;#64;Override protected Integer initialValue() &#123;</span><br><span class=\"line\"> *                 return nextId.getAndIncrement();</span><br><span class=\"line\"> *         &#125;</span><br><span class=\"line\"> *     &#125;;</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *     // Returns the current thread&apos;s unique ID, assigning it if necessary</span><br><span class=\"line\"> *     public static int get() &#123;</span><br><span class=\"line\"> *         return threadId.get();</span><br><span class=\"line\"> *     &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> * &lt;/pre&gt;</span><br><span class=\"line\"> * &lt;p&gt;Each thread holds an implicit reference to its copy of a thread-local</span><br><span class=\"line\"> * variable as long as the thread is alive and the &#123;@code ThreadLocal&#125;</span><br><span class=\"line\"> * instance is accessible; after a thread goes away, all of its copies of</span><br><span class=\"line\"> * thread-local instances are subject to garbage collection (unless other</span><br><span class=\"line\"> * references to these copies exist).</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author  Josh Bloch and Doug Lea</span><br><span class=\"line\"> * @since   1.2</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n<p>翻译一下：<br>这个类提供了一个本地线程变量，这些变量在不同线程中有不同的副本，都是独立的原始变量的拷贝。其实例是希望与线程连接状态的独立的field。</p>\n<p>因此就是在不同的thread中保留不同的值的类型。</p>\n<h1 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">    * Creates a thread local variable.</span><br><span class=\"line\">    * @see #withInitial(java.util.function.Supplier)</span><br><span class=\"line\">    */</span><br><span class=\"line\">   public ThreadLocal() &#123;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   /**</span><br><span class=\"line\">    * Returns the value in the current thread&apos;s copy of this</span><br><span class=\"line\">    * thread-local variable.  If the variable has no value for the</span><br><span class=\"line\">    * current thread, it is first initialized to the value returned</span><br><span class=\"line\">    * by an invocation of the &#123;@link #initialValue&#125; method.</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @return the current thread&apos;s value of this thread-local</span><br><span class=\"line\">    */</span><br><span class=\"line\">   public T get() &#123;</span><br><span class=\"line\">   \t...</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   /**</span><br><span class=\"line\">    * Sets the current thread&apos;s copy of this thread-local variable</span><br><span class=\"line\">    * to the specified value.  Most subclasses will have no need to</span><br><span class=\"line\">    * override this method, relying solely on the &#123;@link #initialValue&#125;</span><br><span class=\"line\">    * method to set the values of thread-locals.</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @param value the value to be stored in the current thread&apos;s copy of</span><br><span class=\"line\">    *        this thread-local.</span><br><span class=\"line\">    */</span><br><span class=\"line\">   public void set(T value) &#123;</span><br><span class=\"line\">   \t...</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   /**</span><br><span class=\"line\">    * Removes the current thread&apos;s value for this thread-local</span><br><span class=\"line\">    * variable.  If this thread-local variable is subsequently</span><br><span class=\"line\">    * &#123;@linkplain #get read&#125; by the current thread, its value will be</span><br><span class=\"line\">    * reinitialized by invoking its &#123;@link #initialValue&#125; method,</span><br><span class=\"line\">    * unless its value is &#123;@linkplain #set set&#125; by the current thread</span><br><span class=\"line\">    * in the interim.  This may result in multiple invocations of the</span><br><span class=\"line\">    * &#123;@code initialValue&#125; method in the current thread.</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @since 1.5</span><br><span class=\"line\">    */</span><br><span class=\"line\">    public void remove() &#123;</span><br><span class=\"line\">    \t...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>public 的接口就这几个。</p>\n<h1 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void set(T value) &#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">        if (map != null)</span><br><span class=\"line\">            map.set(this, value);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            createMap(t, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Get the map associated with a ThreadLocal. Overridden in</span><br><span class=\"line\">     * InheritableThreadLocal.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param  t the current thread</span><br><span class=\"line\">     * @return the map</span><br><span class=\"line\">     */</span><br><span class=\"line\">    ThreadLocalMap getMap(Thread t) &#123;</span><br><span class=\"line\">        return t.threadLocals;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Create the map associated with a ThreadLocal. Overridden in</span><br><span class=\"line\">     * InheritableThreadLocal.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param t the current thread</span><br><span class=\"line\">     * @param firstValue value for the initial entry of the map</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void createMap(Thread t, T firstValue) &#123;</span><br><span class=\"line\">        t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>set的时候会获取当前的map，如果没有就会创建，有的话就会调用map的set</p>\n<p>其中有个概念，是threadlocalmap，既然是map，看看键值对是什么</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void set(ThreadLocal&lt;?&gt; key, Object value)</span><br></pre></td></tr></table></figure>\n<p>也就是用threadlocal作为key，其余的作为value进行存储的。</p>\n<h2 id=\"总结一下set\"><a href=\"#总结一下set\" class=\"headerlink\" title=\"总结一下set\"></a>总结一下set</h2><p>1.每个thread中有一个threadlocalmap<br>2.threadlocalmap是以threadlocal为key，目标值为value的map结构<br>3.当希望存储这个threadlocal的时候，会先从线程中取出这个threadlocalmap，然后以这个threadlocal为key，将目标值传入进去。<br>4.如果当前线程没有threadlocalmap的话，会主动创建一个塞进去。</p>\n<h1 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * Returns the value in the current thread&apos;s copy of this</span><br><span class=\"line\">     * thread-local variable.  If the variable has no value for the</span><br><span class=\"line\">     * current thread, it is first initialized to the value returned</span><br><span class=\"line\">     * by an invocation of the &#123;@link #initialValue&#125; method.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return the current thread&apos;s value of this thread-local</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public T get() &#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">        if (map != null) &#123;</span><br><span class=\"line\">            ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class=\"line\">            if (e != null) &#123;</span><br><span class=\"line\">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">                T result = (T)e.value;</span><br><span class=\"line\">                return result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return setInitialValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class=\"line\">            int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class=\"line\">            Entry e = table[i];</span><br><span class=\"line\">            if (e != null &amp;&amp; e.get() == key)</span><br><span class=\"line\">                return e;</span><br><span class=\"line\">            else</span><br><span class=\"line\">                return getEntryAfterMiss(key, i, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class=\"line\">            Entry[] tab = table;</span><br><span class=\"line\">            int len = tab.length;</span><br><span class=\"line\"></span><br><span class=\"line\">            while (e != null) &#123;</span><br><span class=\"line\">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">                if (k == key)</span><br><span class=\"line\">                    return e;</span><br><span class=\"line\">                if (k == null)</span><br><span class=\"line\">                    expungeStaleEntry(i);</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    i = nextIndex(i, len);</span><br><span class=\"line\">                e = tab[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">    private int expungeStaleEntry(int staleSlot) &#123;</span><br><span class=\"line\">            Entry[] tab = table;</span><br><span class=\"line\">            int len = tab.length;</span><br><span class=\"line\"></span><br><span class=\"line\">            // expunge entry at staleSlot</span><br><span class=\"line\">            tab[staleSlot].value = null;</span><br><span class=\"line\">            tab[staleSlot] = null;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\"></span><br><span class=\"line\">            // Rehash until we encounter null</span><br><span class=\"line\">            Entry e;</span><br><span class=\"line\">            int i;</span><br><span class=\"line\">            for (i = nextIndex(staleSlot, len);</span><br><span class=\"line\">                 (e = tab[i]) != null;</span><br><span class=\"line\">                 i = nextIndex(i, len)) &#123;</span><br><span class=\"line\">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">                if (k == null) &#123;</span><br><span class=\"line\">                    e.value = null;</span><br><span class=\"line\">                    tab[i] = null;</span><br><span class=\"line\">                    size--;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    int h = k.threadLocalHashCode &amp; (len - 1);</span><br><span class=\"line\">                    if (h != i) &#123;</span><br><span class=\"line\">                        tab[i] = null;</span><br><span class=\"line\"></span><br><span class=\"line\">                        // Unlike Knuth 6.4 Algorithm R, we must scan until</span><br><span class=\"line\">                        // null because multiple entries could have been stale.</span><br><span class=\"line\">                        while (tab[h] != null)</span><br><span class=\"line\">                            h = nextIndex(h, len);</span><br><span class=\"line\">                        tab[h] = e;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return i;</span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        </span><br><span class=\"line\">    private static int nextIndex(int i, int len) &#123;</span><br><span class=\"line\">            return ((i + 1 &lt; len) ? i + 1 : 0);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>从流程上面其实就是一个map寻址操作，有个注意点，由于threadlocalmap的entry，是一个weakreference，所以有可能会出现获取的时候发现为null，此时需要擦除这个值。不过源码中擦除不单单这个值，把别的空的也同时擦除了。</p>\n<h1 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void remove() &#123;</span><br><span class=\"line\">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class=\"line\">         if (m != null)</span><br><span class=\"line\">             m.remove(this);</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<p>擦除了这个key</p>\n<h1 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h1><h2 id=\"ThreadLocalMap里Entry为何声明为WeakReference？\"><a href=\"#ThreadLocalMap里Entry为何声明为WeakReference？\" class=\"headerlink\" title=\"ThreadLocalMap里Entry为何声明为WeakReference？\"></a>ThreadLocalMap里Entry为何声明为WeakReference？</h2><p>引用关系是这样的</p>\n<p>ThreadLocalRef持有对ThreadLocal的引用，同时map的entry也持有对threadlocal的引用，而map的引用是在Current Thread手里，这样就会造成当清除ThreadLocalRef的时候出现泄漏的情况。</p>\n<p>将entry声明为weakreference，这样在上述这种情况时，就不会产生泄漏现象，但是value仍然存在，只是索引不到，map仍然持有这个对象。</p>\n<p>threadlocalmap针对这个问题，特意在get和set、remove的时候，执行了擦除所有key为null的值。</p>\n<h2 id=\"threadlocalmap避免出现内存泄漏的情况\"><a href=\"#threadlocalmap避免出现内存泄漏的情况\" class=\"headerlink\" title=\"threadlocalmap避免出现内存泄漏的情况\"></a>threadlocalmap避免出现内存泄漏的情况</h2><p>1.尽量避免使用static修饰，会拉伸threadlocal声明周期<br>2.分配使用了threadlocal后，如果不需要了，记得要使用remove操作擦除这块数据。</p>\n"},{"title":"tinker机制学习","date":"2019-01-28T05:06:52.000Z","_content":"\n# tinker作用\n\ntinker一般可以用作热修复，其作为热修复java方案的代表，日常工作也经常用到。\n\n其原理是参考自instant run 的方案，通过生成patch包，不过是通过网络下发，然后在本地进行处理。\n\n# instant run\n\n基于提升平时打包的速度，instant run 需要\n\n- 只对代码改变部分做构建和部署\n- 不重新安装应用\n- 不重启应用\n- 不重启activity\n\n从其官方图中可以看出，针对上面四个需求，生成了三种插拔机制。\n\n![swap](/images/android/instantRunSwapImage.webp)\n\n- 热插拔：代码改变被应用、投射到app上面，不需要重启应用，不需要重建activity\n- 温插拔：activity需要被重启才能看到所需更改\n- 冷插拔：app需要被重启（不需要重新安装）\n\n## 原理\n\n![原理](/images/android/instantRunApkMarker.webp)\n\n从这个图可以看出来，APK的生成分为两个部分。\n第一个部分是通过aapt生成res，第二部分是通过javaC生成dex文件\n\n不涉及instantrun的话，编译也就上述几个步骤。打包的话会有签名和对齐动作。\n\n打开instant run 开关，会有所变化\n\n![打开instant run的编译效果](/images/android/instantRunOpenApkMarker.webp)\n\n打开开关后，会新增一个appserver.class类编译进dex，同时会有一个新的application类。\n\n新的application类注入了一个新的自定义类加载器，同时该application类会启动我们所需的新注入的\nappserver，该application是原生application类的一个代理类。这样instantrun就跑起来了。\n\n（该appserver主要是检测app是否在前台，以及是否是对应与android studio的appserver）\n\n### 热插拔\n\n热插拔主要体现在一个ui不变化，即时响应。\n\n其步骤：\n1. 首先通过gradle生成增量dex文件\n\n```\nGradle Incremental Build\n```\n\ngradle会通过增量编译脚本，将dex文件最小化的进行更改\n2. 更改完的dex文件会发送到appserver中，发送到appserver\n\n3. appserver接收到dex后，会重写类文件。\nappserver是保持活跃的，所以一旦有新的dex发来，就会立即执行处理任务。这里就体现了热插拔的效果。\n\ninstant run 热插拔的局限性：只能适用于简单改变，类似于方法上面的修改，或者变量值修改。\n\n### 温插拔\n\n温插拔体现在activity需要被重启才能看到修改\n\n从上面的app构建图可以看出来，资源文件这种在activity创建时加载的内容，需要重启activity才能重新加载。\n\n其步骤和热插拔几乎相同，唯一不同是修改了资源文件之后会走这步，发送的是资源文件的增量包，同时附带一个重启栈顶activity的指令\n\n温插拔的局限性：只能适用于资源文件的更改，不包括manifest，架构，结构的变化。\n\n### 冷插拔\n\n基于art虚拟机的模式，工程会被拆分成10个部分，每个部分拥有自己的dex文件，然后所有的类会根据包名被分配给对应的dex文件。\n\n结构更改产生的变化，此时带来dex的变化，这个变化不是增量变化，而是单纯的变化，这种变化需要重新替换dex文件\n\n替换dex需要自定义类加载器选择性的加载新的dex，因此必须要重启app才能走到这一步。\n\n冷插拔在art虚拟机上面是有效的，但是dalvik中则不行 api-21以上才有效。\n\n## 注意点\n\ninstant run 只能在主进程运行，多进程模式下，所有的温插拔都会变为冷插拔。\n不可以多台部署，只可以通过gradle生成增量包，jack编译器不行。\n\n# tinker\n\n## applicationlike\n\ntinker 目前的版本已经支持反射模式修改application，不需要像以前那样傻乎乎的继承一个applicationlike。\n\n而applicationlike是干嘛的？\n\n从上面分析instantrun知道了，在开启instantrun之后，build的过程在dex生成过程中增加了application和appserver。\n添加的自定义application主要是做了一个自定义类加载器的作用。\n\n我们来看一下tinker中是如何做的。\n\n```\npublic abstract class ApplicationLike implements ApplicationLifeCycle {\n    private final Application application;\n    private final Intent      tinkerResultIntent;\n    private final long        applicationStartElapsedTime;\n    private final long        applicationStartMillisTime;\n    private final int         tinkerFlags;\n    private final boolean     tinkerLoadVerifyFlag;\n\n    public ApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,\n                           long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) {\n        this.application = application;\n        this.tinkerFlags = tinkerFlags;\n        this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;\n        this.applicationStartElapsedTime = applicationStartElapsedTime;\n        this.applicationStartMillisTime = applicationStartMillisTime;\n        this.tinkerResultIntent = tinkerResultIntent;\n    }\n\n    ...\n}\n```\n\n```\npublic interface ApplicationLifeCycle {\n\n    /**\n     * Same as {@link Application#onCreate()}.\n     */\n    void onCreate();\n\n    /**\n     * Same as {@link Application#onLowMemory()}.\n     */\n    void onLowMemory();\n\n    /**\n     * Same as {@link Application#onTrimMemory(int level)}.\n     * @param level\n     */\n    void onTrimMemory(int level);\n\n    /**\n     * Same as {@link Application#onTerminate()}.\n     */\n    void onTerminate();\n\n    /**\n     * Same as {@link Application#onConfigurationChanged(Configuration newconfig)}.\n     */\n    void onConfigurationChanged(Configuration newConfig);\n\n    /**\n     * Same as {@link Application#attachBaseContext(Context context)}.\n     */\n    void onBaseContextAttached(Context base);\n}\n```\n\n从这里可以看出，这个applicationlike并不是一个application，而是一个代理类，application通过构造器构造的方式添加的。\n\n其生命周期略过不表，毕竟我也没怎么在这里面改过东西。。\n\n我从项目里面没找到tinkerapplication，从网上抄下来了。。\n\n```\npublic abstract class TinkerApplication extends Application {\n    ...\n\n    private ApplicationLike applicationLike = null;\n    /**\n     * current build.\n     */\n    protected TinkerApplication(int tinkerFlags) {\n        this(tinkerFlags, \"com.tencent.tinker.loader.app.DefaultApplicationLike\", TinkerLoader.class.getName(), false);\n    }\n\n    /**\n     * @param delegateClassName The fully-qualified name of the {@link ApplicationLifeCycle} class\n     *                          that will act as the delegate for application lifecycle callbacks.\n     */\n    protected TinkerApplication(int tinkerFlags, String delegateClassName,\n                                String loaderClassName, boolean tinkerLoadVerifyFlag) {\n        this.tinkerFlags = tinkerFlags;\n        this.delegateClassName = delegateClassName;\n        this.loaderClassName = loaderClassName;\n        this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;\n\n    }\n\n    protected TinkerApplication(int tinkerFlags, String delegateClassName) {\n        this(tinkerFlags, delegateClassName, TinkerLoader.class.getName(), false);\n    }\n\n    private ApplicationLike createDelegate() {\n        try {\n            // 通过反射创建ApplicationLike对象\n            Class<?> delegateClass = Class.forName(delegateClassName, false, getClassLoader());\n            Constructor<?> constructor = delegateClass.getConstructor(Application.class, int.class, boolean.class,\n                long.class, long.class, Intent.class);\n            return (ApplicationLike) constructor.newInstance(this, tinkerFlags, tinkerLoadVerifyFlag,\n                applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);\n        } catch (Throwable e) {\n            throw new TinkerRuntimeException(\"createDelegate failed\", e);\n        }\n    }\n\n    private synchronized void ensureDelegate() {\n        if (applicationLike == null) {\n            applicationLike = createDelegate();\n        }\n    }\n\n\n    private void onBaseContextAttached(Context base) {\n        applicationStartElapsedTime = SystemClock.elapsedRealtime();\n        applicationStartMillisTime = System.currentTimeMillis();\n        //先调用了tinker进行patch等操作\n        loadTinker();\n       //再创建ApplicationLike对象\n        ensureDelegate();\n       //最后再执行ApplicationLike的生命周期\n        applicationLike.onBaseContextAttached(base);\n        ...\n    }\n\n    @Override\n    protected void attachBaseContext(Context base) {\n        super.attachBaseContext(base);\n        Thread.setDefaultUncaughtExceptionHandler(new TinkerUncaughtHandler(this));\n        onBaseContextAttached(base);\n    }\n\n    private void loadTinker() {\n        //disable tinker, not need to install\n        if (tinkerFlags == TINKER_DISABLE) {\n            return;\n        }\n        tinkerResultIntent = new Intent();\n        try {\n            //反射调用TinkLoader的tryLoad方法\n            Class<?> tinkerLoadClass = Class.forName(loaderClassName, false, getClassLoader());\n\n            Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class, int.class, boolean.class);\n            Constructor<?> constructor = tinkerLoadClass.getConstructor();\n            tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this, tinkerFlags, tinkerLoadVerifyFlag);\n        } catch (Throwable e) {\n            //has exception, put exception error code\n            ShareIntentUtil.setIntentReturnCode(tinkerResultIntent, ShareConstants.ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION);\n            tinkerResultIntent.putExtra(INTENT_PATCH_EXCEPTION, e);\n        }\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        ensureDelegate();\n        applicationLike.onCreate();\n    }\n\n    @Override\n    public void onTerminate() {\n        super.onTerminate();\n        if (applicationLike != null) {\n            applicationLike.onTerminate();\n        }\n    }\n\n    @Override\n    public void onLowMemory() {\n        super.onLowMemory();\n        if (applicationLike != null) {\n            applicationLike.onLowMemory();\n        }\n    }\n\n    @TargetApi(14)\n    @Override\n    public void onTrimMemory(int level) {\n        super.onTrimMemory(level);\n        if (applicationLike != null) {\n            applicationLike.onTrimMemory(level);\n        }\n    }\n\n    @Override\n    public void onConfigurationChanged(Configuration newConfig) {\n        super.onConfigurationChanged(newConfig);\n        if (applicationLike != null) {\n            applicationLike.onConfigurationChanged(newConfig);\n        }\n    }\n\n  ...\n}\n```\n其中过程在onBaseContextAttached中做了比较全的概括，loadtinker之所以在applicationlike创立之前创建，就是为了能够修改application的内容\n\n## hotfix\n\n替换patch的方法在tinker类中\n\n```\npublic class Tinker {\n    ...\n    final PatchListener listener;\n    final LoadReporter  loadReporter;\n    final PatchReporter patchReporter;\n    ...\n}\n```\n\n其成员变量就三个\n\n```\nif (loadReporter == null) {\n                loadReporter = new DefaultLoadReporter(context);\n            }\n\n            if (patchReporter == null) {\n                patchReporter = new DefaultPatchReporter(context);\n            }\n\n            if (listener == null) {\n                listener = new DefaultPatchListener(context);\n            }\n```\n\n### 准备补丁\n\n\n","source":"_posts/tinker机制学习.md","raw":"---\ntitle: tinker机制学习\ndate: 2019-01-28 13:06:52\ntags: android\n---\n\n# tinker作用\n\ntinker一般可以用作热修复，其作为热修复java方案的代表，日常工作也经常用到。\n\n其原理是参考自instant run 的方案，通过生成patch包，不过是通过网络下发，然后在本地进行处理。\n\n# instant run\n\n基于提升平时打包的速度，instant run 需要\n\n- 只对代码改变部分做构建和部署\n- 不重新安装应用\n- 不重启应用\n- 不重启activity\n\n从其官方图中可以看出，针对上面四个需求，生成了三种插拔机制。\n\n![swap](/images/android/instantRunSwapImage.webp)\n\n- 热插拔：代码改变被应用、投射到app上面，不需要重启应用，不需要重建activity\n- 温插拔：activity需要被重启才能看到所需更改\n- 冷插拔：app需要被重启（不需要重新安装）\n\n## 原理\n\n![原理](/images/android/instantRunApkMarker.webp)\n\n从这个图可以看出来，APK的生成分为两个部分。\n第一个部分是通过aapt生成res，第二部分是通过javaC生成dex文件\n\n不涉及instantrun的话，编译也就上述几个步骤。打包的话会有签名和对齐动作。\n\n打开instant run 开关，会有所变化\n\n![打开instant run的编译效果](/images/android/instantRunOpenApkMarker.webp)\n\n打开开关后，会新增一个appserver.class类编译进dex，同时会有一个新的application类。\n\n新的application类注入了一个新的自定义类加载器，同时该application类会启动我们所需的新注入的\nappserver，该application是原生application类的一个代理类。这样instantrun就跑起来了。\n\n（该appserver主要是检测app是否在前台，以及是否是对应与android studio的appserver）\n\n### 热插拔\n\n热插拔主要体现在一个ui不变化，即时响应。\n\n其步骤：\n1. 首先通过gradle生成增量dex文件\n\n```\nGradle Incremental Build\n```\n\ngradle会通过增量编译脚本，将dex文件最小化的进行更改\n2. 更改完的dex文件会发送到appserver中，发送到appserver\n\n3. appserver接收到dex后，会重写类文件。\nappserver是保持活跃的，所以一旦有新的dex发来，就会立即执行处理任务。这里就体现了热插拔的效果。\n\ninstant run 热插拔的局限性：只能适用于简单改变，类似于方法上面的修改，或者变量值修改。\n\n### 温插拔\n\n温插拔体现在activity需要被重启才能看到修改\n\n从上面的app构建图可以看出来，资源文件这种在activity创建时加载的内容，需要重启activity才能重新加载。\n\n其步骤和热插拔几乎相同，唯一不同是修改了资源文件之后会走这步，发送的是资源文件的增量包，同时附带一个重启栈顶activity的指令\n\n温插拔的局限性：只能适用于资源文件的更改，不包括manifest，架构，结构的变化。\n\n### 冷插拔\n\n基于art虚拟机的模式，工程会被拆分成10个部分，每个部分拥有自己的dex文件，然后所有的类会根据包名被分配给对应的dex文件。\n\n结构更改产生的变化，此时带来dex的变化，这个变化不是增量变化，而是单纯的变化，这种变化需要重新替换dex文件\n\n替换dex需要自定义类加载器选择性的加载新的dex，因此必须要重启app才能走到这一步。\n\n冷插拔在art虚拟机上面是有效的，但是dalvik中则不行 api-21以上才有效。\n\n## 注意点\n\ninstant run 只能在主进程运行，多进程模式下，所有的温插拔都会变为冷插拔。\n不可以多台部署，只可以通过gradle生成增量包，jack编译器不行。\n\n# tinker\n\n## applicationlike\n\ntinker 目前的版本已经支持反射模式修改application，不需要像以前那样傻乎乎的继承一个applicationlike。\n\n而applicationlike是干嘛的？\n\n从上面分析instantrun知道了，在开启instantrun之后，build的过程在dex生成过程中增加了application和appserver。\n添加的自定义application主要是做了一个自定义类加载器的作用。\n\n我们来看一下tinker中是如何做的。\n\n```\npublic abstract class ApplicationLike implements ApplicationLifeCycle {\n    private final Application application;\n    private final Intent      tinkerResultIntent;\n    private final long        applicationStartElapsedTime;\n    private final long        applicationStartMillisTime;\n    private final int         tinkerFlags;\n    private final boolean     tinkerLoadVerifyFlag;\n\n    public ApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,\n                           long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) {\n        this.application = application;\n        this.tinkerFlags = tinkerFlags;\n        this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;\n        this.applicationStartElapsedTime = applicationStartElapsedTime;\n        this.applicationStartMillisTime = applicationStartMillisTime;\n        this.tinkerResultIntent = tinkerResultIntent;\n    }\n\n    ...\n}\n```\n\n```\npublic interface ApplicationLifeCycle {\n\n    /**\n     * Same as {@link Application#onCreate()}.\n     */\n    void onCreate();\n\n    /**\n     * Same as {@link Application#onLowMemory()}.\n     */\n    void onLowMemory();\n\n    /**\n     * Same as {@link Application#onTrimMemory(int level)}.\n     * @param level\n     */\n    void onTrimMemory(int level);\n\n    /**\n     * Same as {@link Application#onTerminate()}.\n     */\n    void onTerminate();\n\n    /**\n     * Same as {@link Application#onConfigurationChanged(Configuration newconfig)}.\n     */\n    void onConfigurationChanged(Configuration newConfig);\n\n    /**\n     * Same as {@link Application#attachBaseContext(Context context)}.\n     */\n    void onBaseContextAttached(Context base);\n}\n```\n\n从这里可以看出，这个applicationlike并不是一个application，而是一个代理类，application通过构造器构造的方式添加的。\n\n其生命周期略过不表，毕竟我也没怎么在这里面改过东西。。\n\n我从项目里面没找到tinkerapplication，从网上抄下来了。。\n\n```\npublic abstract class TinkerApplication extends Application {\n    ...\n\n    private ApplicationLike applicationLike = null;\n    /**\n     * current build.\n     */\n    protected TinkerApplication(int tinkerFlags) {\n        this(tinkerFlags, \"com.tencent.tinker.loader.app.DefaultApplicationLike\", TinkerLoader.class.getName(), false);\n    }\n\n    /**\n     * @param delegateClassName The fully-qualified name of the {@link ApplicationLifeCycle} class\n     *                          that will act as the delegate for application lifecycle callbacks.\n     */\n    protected TinkerApplication(int tinkerFlags, String delegateClassName,\n                                String loaderClassName, boolean tinkerLoadVerifyFlag) {\n        this.tinkerFlags = tinkerFlags;\n        this.delegateClassName = delegateClassName;\n        this.loaderClassName = loaderClassName;\n        this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;\n\n    }\n\n    protected TinkerApplication(int tinkerFlags, String delegateClassName) {\n        this(tinkerFlags, delegateClassName, TinkerLoader.class.getName(), false);\n    }\n\n    private ApplicationLike createDelegate() {\n        try {\n            // 通过反射创建ApplicationLike对象\n            Class<?> delegateClass = Class.forName(delegateClassName, false, getClassLoader());\n            Constructor<?> constructor = delegateClass.getConstructor(Application.class, int.class, boolean.class,\n                long.class, long.class, Intent.class);\n            return (ApplicationLike) constructor.newInstance(this, tinkerFlags, tinkerLoadVerifyFlag,\n                applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);\n        } catch (Throwable e) {\n            throw new TinkerRuntimeException(\"createDelegate failed\", e);\n        }\n    }\n\n    private synchronized void ensureDelegate() {\n        if (applicationLike == null) {\n            applicationLike = createDelegate();\n        }\n    }\n\n\n    private void onBaseContextAttached(Context base) {\n        applicationStartElapsedTime = SystemClock.elapsedRealtime();\n        applicationStartMillisTime = System.currentTimeMillis();\n        //先调用了tinker进行patch等操作\n        loadTinker();\n       //再创建ApplicationLike对象\n        ensureDelegate();\n       //最后再执行ApplicationLike的生命周期\n        applicationLike.onBaseContextAttached(base);\n        ...\n    }\n\n    @Override\n    protected void attachBaseContext(Context base) {\n        super.attachBaseContext(base);\n        Thread.setDefaultUncaughtExceptionHandler(new TinkerUncaughtHandler(this));\n        onBaseContextAttached(base);\n    }\n\n    private void loadTinker() {\n        //disable tinker, not need to install\n        if (tinkerFlags == TINKER_DISABLE) {\n            return;\n        }\n        tinkerResultIntent = new Intent();\n        try {\n            //反射调用TinkLoader的tryLoad方法\n            Class<?> tinkerLoadClass = Class.forName(loaderClassName, false, getClassLoader());\n\n            Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class, int.class, boolean.class);\n            Constructor<?> constructor = tinkerLoadClass.getConstructor();\n            tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this, tinkerFlags, tinkerLoadVerifyFlag);\n        } catch (Throwable e) {\n            //has exception, put exception error code\n            ShareIntentUtil.setIntentReturnCode(tinkerResultIntent, ShareConstants.ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION);\n            tinkerResultIntent.putExtra(INTENT_PATCH_EXCEPTION, e);\n        }\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        ensureDelegate();\n        applicationLike.onCreate();\n    }\n\n    @Override\n    public void onTerminate() {\n        super.onTerminate();\n        if (applicationLike != null) {\n            applicationLike.onTerminate();\n        }\n    }\n\n    @Override\n    public void onLowMemory() {\n        super.onLowMemory();\n        if (applicationLike != null) {\n            applicationLike.onLowMemory();\n        }\n    }\n\n    @TargetApi(14)\n    @Override\n    public void onTrimMemory(int level) {\n        super.onTrimMemory(level);\n        if (applicationLike != null) {\n            applicationLike.onTrimMemory(level);\n        }\n    }\n\n    @Override\n    public void onConfigurationChanged(Configuration newConfig) {\n        super.onConfigurationChanged(newConfig);\n        if (applicationLike != null) {\n            applicationLike.onConfigurationChanged(newConfig);\n        }\n    }\n\n  ...\n}\n```\n其中过程在onBaseContextAttached中做了比较全的概括，loadtinker之所以在applicationlike创立之前创建，就是为了能够修改application的内容\n\n## hotfix\n\n替换patch的方法在tinker类中\n\n```\npublic class Tinker {\n    ...\n    final PatchListener listener;\n    final LoadReporter  loadReporter;\n    final PatchReporter patchReporter;\n    ...\n}\n```\n\n其成员变量就三个\n\n```\nif (loadReporter == null) {\n                loadReporter = new DefaultLoadReporter(context);\n            }\n\n            if (patchReporter == null) {\n                patchReporter = new DefaultPatchReporter(context);\n            }\n\n            if (listener == null) {\n                listener = new DefaultPatchListener(context);\n            }\n```\n\n### 准备补丁\n\n\n","slug":"tinker机制学习","published":1,"updated":"2019-03-12T09:26:33.163Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltu04006p3a8kqfj6crxg","content":"<h1 id=\"tinker作用\"><a href=\"#tinker作用\" class=\"headerlink\" title=\"tinker作用\"></a>tinker作用</h1><p>tinker一般可以用作热修复，其作为热修复java方案的代表，日常工作也经常用到。</p>\n<p>其原理是参考自instant run 的方案，通过生成patch包，不过是通过网络下发，然后在本地进行处理。</p>\n<h1 id=\"instant-run\"><a href=\"#instant-run\" class=\"headerlink\" title=\"instant run\"></a>instant run</h1><p>基于提升平时打包的速度，instant run 需要</p>\n<ul>\n<li>只对代码改变部分做构建和部署</li>\n<li>不重新安装应用</li>\n<li>不重启应用</li>\n<li>不重启activity</li>\n</ul>\n<p>从其官方图中可以看出，针对上面四个需求，生成了三种插拔机制。</p>\n<p><img src=\"/images/android/instantRunSwapImage.webp\" alt=\"swap\"></p>\n<ul>\n<li>热插拔：代码改变被应用、投射到app上面，不需要重启应用，不需要重建activity</li>\n<li>温插拔：activity需要被重启才能看到所需更改</li>\n<li>冷插拔：app需要被重启（不需要重新安装）</li>\n</ul>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p><img src=\"/images/android/instantRunApkMarker.webp\" alt=\"原理\"></p>\n<p>从这个图可以看出来，APK的生成分为两个部分。<br>第一个部分是通过aapt生成res，第二部分是通过javaC生成dex文件</p>\n<p>不涉及instantrun的话，编译也就上述几个步骤。打包的话会有签名和对齐动作。</p>\n<p>打开instant run 开关，会有所变化</p>\n<p><img src=\"/images/android/instantRunOpenApkMarker.webp\" alt=\"打开instant run的编译效果\"></p>\n<p>打开开关后，会新增一个appserver.class类编译进dex，同时会有一个新的application类。</p>\n<p>新的application类注入了一个新的自定义类加载器，同时该application类会启动我们所需的新注入的<br>appserver，该application是原生application类的一个代理类。这样instantrun就跑起来了。</p>\n<p>（该appserver主要是检测app是否在前台，以及是否是对应与android studio的appserver）</p>\n<h3 id=\"热插拔\"><a href=\"#热插拔\" class=\"headerlink\" title=\"热插拔\"></a>热插拔</h3><p>热插拔主要体现在一个ui不变化，即时响应。</p>\n<p>其步骤：</p>\n<ol>\n<li>首先通过gradle生成增量dex文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Gradle Incremental Build</span><br></pre></td></tr></table></figure>\n<p>gradle会通过增量编译脚本，将dex文件最小化的进行更改</p>\n<ol start=\"2\">\n<li><p>更改完的dex文件会发送到appserver中，发送到appserver</p>\n</li>\n<li><p>appserver接收到dex后，会重写类文件。<br>appserver是保持活跃的，所以一旦有新的dex发来，就会立即执行处理任务。这里就体现了热插拔的效果。</p>\n</li>\n</ol>\n<p>instant run 热插拔的局限性：只能适用于简单改变，类似于方法上面的修改，或者变量值修改。</p>\n<h3 id=\"温插拔\"><a href=\"#温插拔\" class=\"headerlink\" title=\"温插拔\"></a>温插拔</h3><p>温插拔体现在activity需要被重启才能看到修改</p>\n<p>从上面的app构建图可以看出来，资源文件这种在activity创建时加载的内容，需要重启activity才能重新加载。</p>\n<p>其步骤和热插拔几乎相同，唯一不同是修改了资源文件之后会走这步，发送的是资源文件的增量包，同时附带一个重启栈顶activity的指令</p>\n<p>温插拔的局限性：只能适用于资源文件的更改，不包括manifest，架构，结构的变化。</p>\n<h3 id=\"冷插拔\"><a href=\"#冷插拔\" class=\"headerlink\" title=\"冷插拔\"></a>冷插拔</h3><p>基于art虚拟机的模式，工程会被拆分成10个部分，每个部分拥有自己的dex文件，然后所有的类会根据包名被分配给对应的dex文件。</p>\n<p>结构更改产生的变化，此时带来dex的变化，这个变化不是增量变化，而是单纯的变化，这种变化需要重新替换dex文件</p>\n<p>替换dex需要自定义类加载器选择性的加载新的dex，因此必须要重启app才能走到这一步。</p>\n<p>冷插拔在art虚拟机上面是有效的，但是dalvik中则不行 api-21以上才有效。</p>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><p>instant run 只能在主进程运行，多进程模式下，所有的温插拔都会变为冷插拔。<br>不可以多台部署，只可以通过gradle生成增量包，jack编译器不行。</p>\n<h1 id=\"tinker\"><a href=\"#tinker\" class=\"headerlink\" title=\"tinker\"></a>tinker</h1><h2 id=\"applicationlike\"><a href=\"#applicationlike\" class=\"headerlink\" title=\"applicationlike\"></a>applicationlike</h2><p>tinker 目前的版本已经支持反射模式修改application，不需要像以前那样傻乎乎的继承一个applicationlike。</p>\n<p>而applicationlike是干嘛的？</p>\n<p>从上面分析instantrun知道了，在开启instantrun之后，build的过程在dex生成过程中增加了application和appserver。<br>添加的自定义application主要是做了一个自定义类加载器的作用。</p>\n<p>我们来看一下tinker中是如何做的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class ApplicationLike implements ApplicationLifeCycle &#123;</span><br><span class=\"line\">    private final Application application;</span><br><span class=\"line\">    private final Intent      tinkerResultIntent;</span><br><span class=\"line\">    private final long        applicationStartElapsedTime;</span><br><span class=\"line\">    private final long        applicationStartMillisTime;</span><br><span class=\"line\">    private final int         tinkerFlags;</span><br><span class=\"line\">    private final boolean     tinkerLoadVerifyFlag;</span><br><span class=\"line\"></span><br><span class=\"line\">    public ApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,</span><br><span class=\"line\">                           long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) &#123;</span><br><span class=\"line\">        this.application = application;</span><br><span class=\"line\">        this.tinkerFlags = tinkerFlags;</span><br><span class=\"line\">        this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;</span><br><span class=\"line\">        this.applicationStartElapsedTime = applicationStartElapsedTime;</span><br><span class=\"line\">        this.applicationStartMillisTime = applicationStartMillisTime;</span><br><span class=\"line\">        this.tinkerResultIntent = tinkerResultIntent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface ApplicationLifeCycle &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Same as &#123;@link Application#onCreate()&#125;.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void onCreate();</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Same as &#123;@link Application#onLowMemory()&#125;.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void onLowMemory();</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Same as &#123;@link Application#onTrimMemory(int level)&#125;.</span><br><span class=\"line\">     * @param level</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void onTrimMemory(int level);</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Same as &#123;@link Application#onTerminate()&#125;.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void onTerminate();</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Same as &#123;@link Application#onConfigurationChanged(Configuration newconfig)&#125;.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void onConfigurationChanged(Configuration newConfig);</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Same as &#123;@link Application#attachBaseContext(Context context)&#125;.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void onBaseContextAttached(Context base);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从这里可以看出，这个applicationlike并不是一个application，而是一个代理类，application通过构造器构造的方式添加的。</p>\n<p>其生命周期略过不表，毕竟我也没怎么在这里面改过东西。。</p>\n<p>我从项目里面没找到tinkerapplication，从网上抄下来了。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class TinkerApplication extends Application &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    private ApplicationLike applicationLike = null;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * current build.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    protected TinkerApplication(int tinkerFlags) &#123;</span><br><span class=\"line\">        this(tinkerFlags, &quot;com.tencent.tinker.loader.app.DefaultApplicationLike&quot;, TinkerLoader.class.getName(), false);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * @param delegateClassName The fully-qualified name of the &#123;@link ApplicationLifeCycle&#125; class</span><br><span class=\"line\">     *                          that will act as the delegate for application lifecycle callbacks.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    protected TinkerApplication(int tinkerFlags, String delegateClassName,</span><br><span class=\"line\">                                String loaderClassName, boolean tinkerLoadVerifyFlag) &#123;</span><br><span class=\"line\">        this.tinkerFlags = tinkerFlags;</span><br><span class=\"line\">        this.delegateClassName = delegateClassName;</span><br><span class=\"line\">        this.loaderClassName = loaderClassName;</span><br><span class=\"line\">        this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected TinkerApplication(int tinkerFlags, String delegateClassName) &#123;</span><br><span class=\"line\">        this(tinkerFlags, delegateClassName, TinkerLoader.class.getName(), false);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private ApplicationLike createDelegate() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            // 通过反射创建ApplicationLike对象</span><br><span class=\"line\">            Class&lt;?&gt; delegateClass = Class.forName(delegateClassName, false, getClassLoader());</span><br><span class=\"line\">            Constructor&lt;?&gt; constructor = delegateClass.getConstructor(Application.class, int.class, boolean.class,</span><br><span class=\"line\">                long.class, long.class, Intent.class);</span><br><span class=\"line\">            return (ApplicationLike) constructor.newInstance(this, tinkerFlags, tinkerLoadVerifyFlag,</span><br><span class=\"line\">                applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);</span><br><span class=\"line\">        &#125; catch (Throwable e) &#123;</span><br><span class=\"line\">            throw new TinkerRuntimeException(&quot;createDelegate failed&quot;, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private synchronized void ensureDelegate() &#123;</span><br><span class=\"line\">        if (applicationLike == null) &#123;</span><br><span class=\"line\">            applicationLike = createDelegate();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private void onBaseContextAttached(Context base) &#123;</span><br><span class=\"line\">        applicationStartElapsedTime = SystemClock.elapsedRealtime();</span><br><span class=\"line\">        applicationStartMillisTime = System.currentTimeMillis();</span><br><span class=\"line\">        //先调用了tinker进行patch等操作</span><br><span class=\"line\">        loadTinker();</span><br><span class=\"line\">       //再创建ApplicationLike对象</span><br><span class=\"line\">        ensureDelegate();</span><br><span class=\"line\">       //最后再执行ApplicationLike的生命周期</span><br><span class=\"line\">        applicationLike.onBaseContextAttached(base);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void attachBaseContext(Context base) &#123;</span><br><span class=\"line\">        super.attachBaseContext(base);</span><br><span class=\"line\">        Thread.setDefaultUncaughtExceptionHandler(new TinkerUncaughtHandler(this));</span><br><span class=\"line\">        onBaseContextAttached(base);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void loadTinker() &#123;</span><br><span class=\"line\">        //disable tinker, not need to install</span><br><span class=\"line\">        if (tinkerFlags == TINKER_DISABLE) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tinkerResultIntent = new Intent();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            //反射调用TinkLoader的tryLoad方法</span><br><span class=\"line\">            Class&lt;?&gt; tinkerLoadClass = Class.forName(loaderClassName, false, getClassLoader());</span><br><span class=\"line\"></span><br><span class=\"line\">            Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class, int.class, boolean.class);</span><br><span class=\"line\">            Constructor&lt;?&gt; constructor = tinkerLoadClass.getConstructor();</span><br><span class=\"line\">            tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this, tinkerFlags, tinkerLoadVerifyFlag);</span><br><span class=\"line\">        &#125; catch (Throwable e) &#123;</span><br><span class=\"line\">            //has exception, put exception error code</span><br><span class=\"line\">            ShareIntentUtil.setIntentReturnCode(tinkerResultIntent, ShareConstants.ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION);</span><br><span class=\"line\">            tinkerResultIntent.putExtra(INTENT_PATCH_EXCEPTION, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onCreate() &#123;</span><br><span class=\"line\">        super.onCreate();</span><br><span class=\"line\">        ensureDelegate();</span><br><span class=\"line\">        applicationLike.onCreate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onTerminate() &#123;</span><br><span class=\"line\">        super.onTerminate();</span><br><span class=\"line\">        if (applicationLike != null) &#123;</span><br><span class=\"line\">            applicationLike.onTerminate();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onLowMemory() &#123;</span><br><span class=\"line\">        super.onLowMemory();</span><br><span class=\"line\">        if (applicationLike != null) &#123;</span><br><span class=\"line\">            applicationLike.onLowMemory();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @TargetApi(14)</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onTrimMemory(int level) &#123;</span><br><span class=\"line\">        super.onTrimMemory(level);</span><br><span class=\"line\">        if (applicationLike != null) &#123;</span><br><span class=\"line\">            applicationLike.onTrimMemory(level);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onConfigurationChanged(Configuration newConfig) &#123;</span><br><span class=\"line\">        super.onConfigurationChanged(newConfig);</span><br><span class=\"line\">        if (applicationLike != null) &#123;</span><br><span class=\"line\">            applicationLike.onConfigurationChanged(newConfig);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中过程在onBaseContextAttached中做了比较全的概括，loadtinker之所以在applicationlike创立之前创建，就是为了能够修改application的内容</p>\n<h2 id=\"hotfix\"><a href=\"#hotfix\" class=\"headerlink\" title=\"hotfix\"></a>hotfix</h2><p>替换patch的方法在tinker类中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Tinker &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    final PatchListener listener;</span><br><span class=\"line\">    final LoadReporter  loadReporter;</span><br><span class=\"line\">    final PatchReporter patchReporter;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其成员变量就三个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (loadReporter == null) &#123;</span><br><span class=\"line\">                loadReporter = new DefaultLoadReporter(context);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (patchReporter == null) &#123;</span><br><span class=\"line\">                patchReporter = new DefaultPatchReporter(context);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (listener == null) &#123;</span><br><span class=\"line\">                listener = new DefaultPatchListener(context);</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"准备补丁\"><a href=\"#准备补丁\" class=\"headerlink\" title=\"准备补丁\"></a>准备补丁</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"tinker作用\"><a href=\"#tinker作用\" class=\"headerlink\" title=\"tinker作用\"></a>tinker作用</h1><p>tinker一般可以用作热修复，其作为热修复java方案的代表，日常工作也经常用到。</p>\n<p>其原理是参考自instant run 的方案，通过生成patch包，不过是通过网络下发，然后在本地进行处理。</p>\n<h1 id=\"instant-run\"><a href=\"#instant-run\" class=\"headerlink\" title=\"instant run\"></a>instant run</h1><p>基于提升平时打包的速度，instant run 需要</p>\n<ul>\n<li>只对代码改变部分做构建和部署</li>\n<li>不重新安装应用</li>\n<li>不重启应用</li>\n<li>不重启activity</li>\n</ul>\n<p>从其官方图中可以看出，针对上面四个需求，生成了三种插拔机制。</p>\n<p><img src=\"/images/android/instantRunSwapImage.webp\" alt=\"swap\"></p>\n<ul>\n<li>热插拔：代码改变被应用、投射到app上面，不需要重启应用，不需要重建activity</li>\n<li>温插拔：activity需要被重启才能看到所需更改</li>\n<li>冷插拔：app需要被重启（不需要重新安装）</li>\n</ul>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p><img src=\"/images/android/instantRunApkMarker.webp\" alt=\"原理\"></p>\n<p>从这个图可以看出来，APK的生成分为两个部分。<br>第一个部分是通过aapt生成res，第二部分是通过javaC生成dex文件</p>\n<p>不涉及instantrun的话，编译也就上述几个步骤。打包的话会有签名和对齐动作。</p>\n<p>打开instant run 开关，会有所变化</p>\n<p><img src=\"/images/android/instantRunOpenApkMarker.webp\" alt=\"打开instant run的编译效果\"></p>\n<p>打开开关后，会新增一个appserver.class类编译进dex，同时会有一个新的application类。</p>\n<p>新的application类注入了一个新的自定义类加载器，同时该application类会启动我们所需的新注入的<br>appserver，该application是原生application类的一个代理类。这样instantrun就跑起来了。</p>\n<p>（该appserver主要是检测app是否在前台，以及是否是对应与android studio的appserver）</p>\n<h3 id=\"热插拔\"><a href=\"#热插拔\" class=\"headerlink\" title=\"热插拔\"></a>热插拔</h3><p>热插拔主要体现在一个ui不变化，即时响应。</p>\n<p>其步骤：</p>\n<ol>\n<li>首先通过gradle生成增量dex文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Gradle Incremental Build</span><br></pre></td></tr></table></figure>\n<p>gradle会通过增量编译脚本，将dex文件最小化的进行更改</p>\n<ol start=\"2\">\n<li><p>更改完的dex文件会发送到appserver中，发送到appserver</p>\n</li>\n<li><p>appserver接收到dex后，会重写类文件。<br>appserver是保持活跃的，所以一旦有新的dex发来，就会立即执行处理任务。这里就体现了热插拔的效果。</p>\n</li>\n</ol>\n<p>instant run 热插拔的局限性：只能适用于简单改变，类似于方法上面的修改，或者变量值修改。</p>\n<h3 id=\"温插拔\"><a href=\"#温插拔\" class=\"headerlink\" title=\"温插拔\"></a>温插拔</h3><p>温插拔体现在activity需要被重启才能看到修改</p>\n<p>从上面的app构建图可以看出来，资源文件这种在activity创建时加载的内容，需要重启activity才能重新加载。</p>\n<p>其步骤和热插拔几乎相同，唯一不同是修改了资源文件之后会走这步，发送的是资源文件的增量包，同时附带一个重启栈顶activity的指令</p>\n<p>温插拔的局限性：只能适用于资源文件的更改，不包括manifest，架构，结构的变化。</p>\n<h3 id=\"冷插拔\"><a href=\"#冷插拔\" class=\"headerlink\" title=\"冷插拔\"></a>冷插拔</h3><p>基于art虚拟机的模式，工程会被拆分成10个部分，每个部分拥有自己的dex文件，然后所有的类会根据包名被分配给对应的dex文件。</p>\n<p>结构更改产生的变化，此时带来dex的变化，这个变化不是增量变化，而是单纯的变化，这种变化需要重新替换dex文件</p>\n<p>替换dex需要自定义类加载器选择性的加载新的dex，因此必须要重启app才能走到这一步。</p>\n<p>冷插拔在art虚拟机上面是有效的，但是dalvik中则不行 api-21以上才有效。</p>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><p>instant run 只能在主进程运行，多进程模式下，所有的温插拔都会变为冷插拔。<br>不可以多台部署，只可以通过gradle生成增量包，jack编译器不行。</p>\n<h1 id=\"tinker\"><a href=\"#tinker\" class=\"headerlink\" title=\"tinker\"></a>tinker</h1><h2 id=\"applicationlike\"><a href=\"#applicationlike\" class=\"headerlink\" title=\"applicationlike\"></a>applicationlike</h2><p>tinker 目前的版本已经支持反射模式修改application，不需要像以前那样傻乎乎的继承一个applicationlike。</p>\n<p>而applicationlike是干嘛的？</p>\n<p>从上面分析instantrun知道了，在开启instantrun之后，build的过程在dex生成过程中增加了application和appserver。<br>添加的自定义application主要是做了一个自定义类加载器的作用。</p>\n<p>我们来看一下tinker中是如何做的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class ApplicationLike implements ApplicationLifeCycle &#123;</span><br><span class=\"line\">    private final Application application;</span><br><span class=\"line\">    private final Intent      tinkerResultIntent;</span><br><span class=\"line\">    private final long        applicationStartElapsedTime;</span><br><span class=\"line\">    private final long        applicationStartMillisTime;</span><br><span class=\"line\">    private final int         tinkerFlags;</span><br><span class=\"line\">    private final boolean     tinkerLoadVerifyFlag;</span><br><span class=\"line\"></span><br><span class=\"line\">    public ApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,</span><br><span class=\"line\">                           long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) &#123;</span><br><span class=\"line\">        this.application = application;</span><br><span class=\"line\">        this.tinkerFlags = tinkerFlags;</span><br><span class=\"line\">        this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;</span><br><span class=\"line\">        this.applicationStartElapsedTime = applicationStartElapsedTime;</span><br><span class=\"line\">        this.applicationStartMillisTime = applicationStartMillisTime;</span><br><span class=\"line\">        this.tinkerResultIntent = tinkerResultIntent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface ApplicationLifeCycle &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Same as &#123;@link Application#onCreate()&#125;.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void onCreate();</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Same as &#123;@link Application#onLowMemory()&#125;.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void onLowMemory();</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Same as &#123;@link Application#onTrimMemory(int level)&#125;.</span><br><span class=\"line\">     * @param level</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void onTrimMemory(int level);</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Same as &#123;@link Application#onTerminate()&#125;.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void onTerminate();</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Same as &#123;@link Application#onConfigurationChanged(Configuration newconfig)&#125;.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void onConfigurationChanged(Configuration newConfig);</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Same as &#123;@link Application#attachBaseContext(Context context)&#125;.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void onBaseContextAttached(Context base);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从这里可以看出，这个applicationlike并不是一个application，而是一个代理类，application通过构造器构造的方式添加的。</p>\n<p>其生命周期略过不表，毕竟我也没怎么在这里面改过东西。。</p>\n<p>我从项目里面没找到tinkerapplication，从网上抄下来了。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class TinkerApplication extends Application &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    private ApplicationLike applicationLike = null;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * current build.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    protected TinkerApplication(int tinkerFlags) &#123;</span><br><span class=\"line\">        this(tinkerFlags, &quot;com.tencent.tinker.loader.app.DefaultApplicationLike&quot;, TinkerLoader.class.getName(), false);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * @param delegateClassName The fully-qualified name of the &#123;@link ApplicationLifeCycle&#125; class</span><br><span class=\"line\">     *                          that will act as the delegate for application lifecycle callbacks.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    protected TinkerApplication(int tinkerFlags, String delegateClassName,</span><br><span class=\"line\">                                String loaderClassName, boolean tinkerLoadVerifyFlag) &#123;</span><br><span class=\"line\">        this.tinkerFlags = tinkerFlags;</span><br><span class=\"line\">        this.delegateClassName = delegateClassName;</span><br><span class=\"line\">        this.loaderClassName = loaderClassName;</span><br><span class=\"line\">        this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected TinkerApplication(int tinkerFlags, String delegateClassName) &#123;</span><br><span class=\"line\">        this(tinkerFlags, delegateClassName, TinkerLoader.class.getName(), false);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private ApplicationLike createDelegate() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            // 通过反射创建ApplicationLike对象</span><br><span class=\"line\">            Class&lt;?&gt; delegateClass = Class.forName(delegateClassName, false, getClassLoader());</span><br><span class=\"line\">            Constructor&lt;?&gt; constructor = delegateClass.getConstructor(Application.class, int.class, boolean.class,</span><br><span class=\"line\">                long.class, long.class, Intent.class);</span><br><span class=\"line\">            return (ApplicationLike) constructor.newInstance(this, tinkerFlags, tinkerLoadVerifyFlag,</span><br><span class=\"line\">                applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);</span><br><span class=\"line\">        &#125; catch (Throwable e) &#123;</span><br><span class=\"line\">            throw new TinkerRuntimeException(&quot;createDelegate failed&quot;, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private synchronized void ensureDelegate() &#123;</span><br><span class=\"line\">        if (applicationLike == null) &#123;</span><br><span class=\"line\">            applicationLike = createDelegate();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private void onBaseContextAttached(Context base) &#123;</span><br><span class=\"line\">        applicationStartElapsedTime = SystemClock.elapsedRealtime();</span><br><span class=\"line\">        applicationStartMillisTime = System.currentTimeMillis();</span><br><span class=\"line\">        //先调用了tinker进行patch等操作</span><br><span class=\"line\">        loadTinker();</span><br><span class=\"line\">       //再创建ApplicationLike对象</span><br><span class=\"line\">        ensureDelegate();</span><br><span class=\"line\">       //最后再执行ApplicationLike的生命周期</span><br><span class=\"line\">        applicationLike.onBaseContextAttached(base);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void attachBaseContext(Context base) &#123;</span><br><span class=\"line\">        super.attachBaseContext(base);</span><br><span class=\"line\">        Thread.setDefaultUncaughtExceptionHandler(new TinkerUncaughtHandler(this));</span><br><span class=\"line\">        onBaseContextAttached(base);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void loadTinker() &#123;</span><br><span class=\"line\">        //disable tinker, not need to install</span><br><span class=\"line\">        if (tinkerFlags == TINKER_DISABLE) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tinkerResultIntent = new Intent();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            //反射调用TinkLoader的tryLoad方法</span><br><span class=\"line\">            Class&lt;?&gt; tinkerLoadClass = Class.forName(loaderClassName, false, getClassLoader());</span><br><span class=\"line\"></span><br><span class=\"line\">            Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class, int.class, boolean.class);</span><br><span class=\"line\">            Constructor&lt;?&gt; constructor = tinkerLoadClass.getConstructor();</span><br><span class=\"line\">            tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this, tinkerFlags, tinkerLoadVerifyFlag);</span><br><span class=\"line\">        &#125; catch (Throwable e) &#123;</span><br><span class=\"line\">            //has exception, put exception error code</span><br><span class=\"line\">            ShareIntentUtil.setIntentReturnCode(tinkerResultIntent, ShareConstants.ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION);</span><br><span class=\"line\">            tinkerResultIntent.putExtra(INTENT_PATCH_EXCEPTION, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onCreate() &#123;</span><br><span class=\"line\">        super.onCreate();</span><br><span class=\"line\">        ensureDelegate();</span><br><span class=\"line\">        applicationLike.onCreate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onTerminate() &#123;</span><br><span class=\"line\">        super.onTerminate();</span><br><span class=\"line\">        if (applicationLike != null) &#123;</span><br><span class=\"line\">            applicationLike.onTerminate();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onLowMemory() &#123;</span><br><span class=\"line\">        super.onLowMemory();</span><br><span class=\"line\">        if (applicationLike != null) &#123;</span><br><span class=\"line\">            applicationLike.onLowMemory();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @TargetApi(14)</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onTrimMemory(int level) &#123;</span><br><span class=\"line\">        super.onTrimMemory(level);</span><br><span class=\"line\">        if (applicationLike != null) &#123;</span><br><span class=\"line\">            applicationLike.onTrimMemory(level);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onConfigurationChanged(Configuration newConfig) &#123;</span><br><span class=\"line\">        super.onConfigurationChanged(newConfig);</span><br><span class=\"line\">        if (applicationLike != null) &#123;</span><br><span class=\"line\">            applicationLike.onConfigurationChanged(newConfig);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中过程在onBaseContextAttached中做了比较全的概括，loadtinker之所以在applicationlike创立之前创建，就是为了能够修改application的内容</p>\n<h2 id=\"hotfix\"><a href=\"#hotfix\" class=\"headerlink\" title=\"hotfix\"></a>hotfix</h2><p>替换patch的方法在tinker类中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Tinker &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    final PatchListener listener;</span><br><span class=\"line\">    final LoadReporter  loadReporter;</span><br><span class=\"line\">    final PatchReporter patchReporter;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其成员变量就三个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (loadReporter == null) &#123;</span><br><span class=\"line\">                loadReporter = new DefaultLoadReporter(context);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (patchReporter == null) &#123;</span><br><span class=\"line\">                patchReporter = new DefaultPatchReporter(context);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (listener == null) &#123;</span><br><span class=\"line\">                listener = new DefaultPatchListener(context);</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"准备补丁\"><a href=\"#准备补丁\" class=\"headerlink\" title=\"准备补丁\"></a>准备补丁</h3>"},{"title":"tree学习","date":"2018-11-12T05:36:55.000Z","_content":"\n# tree\n\n## 构造\n\n树的构造很简单，节点的思想。\n\n```\nclass TreeNode{\n\tObject element;\n\tTreeNode firstChild;\n\tTreeNode nextSibling;\n}\n```\n\n## 示意图\n\n![树示意图](/images/数据结构/tree图1.png)\n\n## 先序遍历\n\n先序遍历的思想是对节点的处理工作在他的子节点处理之前执行，显示结果为D->L->R\n对示意图的先序遍历，结果为：ABDECFG\n\n\n## 中序遍历\n\n中序遍历的思想是先对左节点优先处理，之后在处理自己，最后处理右节点，显示结果为 L->D->R\n对示意图的中序遍历，结果为：DBEAFCG\n\n## 后序遍历\n\n后序遍历的思想是优先处理子节点，最后处理自己，子节点的处理优先是左节点，显示结果为L->R->D\n对示意图的后序遍历，结果为：DEBFGCA\n\n# 二叉树\n\n## 构造\n\n```\nclass BinaryNode{\n\tObject element;\n\tBinaryNode left;\n\tBinaryNode right;\n}\n```\n\n二叉树是一棵树，每个节点都不能有多于两个的儿子，平均深度为O(根号N)\n\n# 二叉查找树\n\n二叉查找树对于树中的每个节点X，它的左子树中所有的项的值小于X中的项，右子树种所有项的值大于X的值\n\n## 构造\n\n```\npublic class BinarySearchTree<T extends Comparable<? super T>>{\n\t/*\n\t* 构造函数\n\t*/\n\tprivate static class BinaryNode<T>{\n\t\tBinaryNode(T element){\n\t\t\tthis(element, null, null);\n\t\t}\n\t\tBinaryNode(T element, Binary<T> left, BinaryNode<T> right){\n\t\t\tthis.element = element;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\t\tT element;\n\t\tBinary<T> left;\n\t\tBinary<T> right;\n\t}\n\n\t/*\n\t* 初始节点\n\t*/\n\tprivate BinaryNode<T> root;\n\n\t/*\n\t* 初始化\n\t*/\n\tpublic BinarySearchTree(){\n\t\troot = null;\n\t}\n\n\t/*\n\t* 置空操作\n\t*/\n\tpublic void makeEmpty(){\n\t\troot = null;\n\t}\n\n\t/*\n\t* 判空操作\n\t*/\n\tpublic void isEmpty(){\n\t\treturn root == null;\n\t}\n\n\t/*\n\t* 判断是否包含\n\t*/\n\tpublic boolean contains(T x){\n\t\treturn contains(x, root);\n\t}\n\t/*\n\t* 判断思想：先和root对比，小就和左节点比较，大就和右节点比较，相同就true，核心思想是递归，递归到最后空的时候就会判false\n\t*/\n\tprivate boolean contains(T x, BinaryNode<T> t){\n\t\tif(t == null){\n\t\t\treturn false;\n\t\t}\n\n\t\tint compareResult = x.compareTo(t.element);\n\n\t\tif( compareResult < 0){\n\t\t\treturn contains(x, left);\n\t\t}else if( compareResult > 0){\n\t\t\treturn contains(x, right);\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/*\n\t* 寻找最小子节点\n\t*/\n\tpublic T findMin(){\n\t\tif (isEmpty()){\n\t\t\tthrow new UnderflowException();\n\t\t}\n\t\treturn findMin(root).element;\n\t}\n\n\t/*\n\t* 寻找思想：查找是否有左节点，如果有就继续遍历左节点，直到某个节点的左节点为null，此时该节点就是最小节点\n\t*/\n\tprivate BinaryNode<T> findMin(BinaryNode<T> t){\n\t\tif (t == null){\n\t\t\treturn null;\n\t\t}else if(t.left == null){\n\t\t\treturn t;\n\t\t}else{\n\t\t\treturn findMin(t.left);\n\t\t}\n\t}\n\n\t/*\n\t* 寻找最大子节点\n\t*/\n\tpublic T findMax(){\n\t\tif(isEmpty()){\n\t\t\tthrow new UnderflowException();\n\t\t}\n\t\treturn findMax(root).element;\n\t}\n\n\t/*\n\t* 思想和寻找最小子节点一样\n\t*/\n\tprivate BinaryNode<T> findMax(BinaryNode<T> t){\n\t\tif (t == null){\n\t\t\treturn null;\n\t\t}else if(t.right == null){\n\t\t\treturn t;\n\t\t}else {\n\t\t\treturn findMax(t.right);\n\t\t}\n\t}\n\n\t/*\n\t* 插入\n\t*/\n\tpublic void insert(T x){\n\t\troot = insert(x, root);\n\t}\n\n\t/*\n\t* 插入数值思想:仍然是和当前节点做比较，如果小就递归左节点，大就递归右节点，直到某个节点的左节点或者右节点不存在，此时就新建一个节点，插入。\n\t*/\n\tprivate BinaryNode<T> insert(T x, BinaryNode<T> t){\n\t\tif (t == null){\n\t\t\treturn new BinaryNode<>(x, null, null);\n\t\t}\n\t\tint compareResult = x.compareTo(t.element);\n\t\tif (compareResult < 0){\n\t\t\tt.left = insert(x, t.left);\n\t\t}else if (compareResult > 0){\n\t\t\tt.right = insert(x, t.right);\n\t\t}else{\n\t\t\t;\n\t\t}\n\t\treturn t;\n\t}\n\n\t/*\n\t* 删除\n\t*/\n\tpublic void remove(T x){\n\t\troot = remove(x, root);\n\t}\n\n\t/*\n\t* 删除的机制：当删除某个节点的时候，如果两个子节点都在，就需要将右侧的最小子节点放到该位置上面来，并且遍历删除右侧的最小子节点\n\t*/\n\tprivate BinaryNode<T> remove(T x, BinaryNode<T> t){\n\t\tif(t == null){\n\t\t\treturn t;\n\t\t}\n\t\tint compareResult = x.compareTo(t.element);\n\t\tif (compareResult < 0){\n\t\t\tt.left = remove(x, t.left);\n\t\t}else if(compareResult > 0){\n\t\t\tt.right = remove(x, t.right);\n\t\t}else if(t.left != null && t.right != null){\n\t\t\tt.element = findMin(t.right).element;\n\t\t\tt.right = remove(t.element, t.right);\n\t\t}else{\n\t\t\tt = (t.left != null)? t.left : t.right;\n\t\t}\n\t\treturn t;\n\t}\n\n\tpublic void printTree(){\n\t\tif (isEmpty()){\n\t\t\tSystem.out.println(\"Empty tree\");\n\t\t}else{\n\t\t\tprintTree(root);\n\t\t}\n\t}\n\t//中序遍历\n\tprivate void printTree(BinaryNode<T> t){\n\t\tif(t != null){\n\t\t\tprintTree(t.left);\n\t\t\tSystem.out.println(t.element);\n\t\t\tprintTree(t.right);\n\t\t}\n\t}\n\t\n\t//先序遍历\n\tprivate void printBeforeTree(BinaryNode<T> t){\n\t\tif(t != null){\n\t\t\tSystem.out.println(t.element);\n\t\t\tprintBeforeTree(t.left);\n\t\t\tprintBeforeTree(t.right);\n\t\t}\n\t}\n\n\t//后序遍历\n\tprivate void printAfterTree(BinaryNode<T> t){\n\t\tif(t != null){\n\t\t\tprintAfterTree(t.left);\n\t\t\tprintAfterTree(t.right);\n\t\t\tSystem.out.println(t.element);\n\t\t}\n\t}\n\t\n\t//层级遍历\n\tpublic void levelTravel(TreeNode<T> root){\n\t\tQueue<TreeNode<T>> q = new LinkedList<TreeNode<T>>();\n\t\tq.offer(root);\n\t\twhile(!q.isEmpty()){\n\t\t\tTreeNode<T> temp = q.poll();\n\t\t\tSystem.out.println(temp);\n\t\t\tif(temp.leftChild != null){\n\t\t\t\tq.offer(temp.leftChild);\n\t\t\t}\n\t\t\tif(temp.rightChild != null){\n\t\t\t\tq.offer(temp.rightChild);\n\t\t\t}\n\t\t}\n\t}\n\n\t//求K层节点总数\n\tpublic int getNumForKLevel(TreeNode<T> root, int k){\n\t\tif(root == null || k < 1){\n\t\t\treturn 0;\n\t\t}\n\t\tif(k == 1){\n\t\t\treturn 1;\n\t\t}\n\t\tint leftNum = getNumForKLevel(root.left, k-1);\n\t\tint rightNum = getNumForKLevel(root.right, k-1);\n\t\treturn leftNum + rightNum;\n\t}\n\n\t//求二叉树中叶子节点的个数\n\tpublic int getLeafNum(TreeNode<T> root){\n\t\tif(root == null){\n\t\t\treturn 0;\n\t\t}\n\t\tif(root.leftChild == null && root.rightChild == null){\n\t\t\treturn 1;\n\t\t}\n\t\tint leftNum = getLeafNum(root.leftChild);\n\t\tint rightNum = getLeafNum(root.rightChild);\n\t\treturn leftNum + rightNum;\n\t}\n\n\t//交换根节点的左右子树\n\tpublic TreeNode<T> exchange(TreeNode<T> root){\n\t\tif(root == null){\n\t\t\treturn null;\n\t\t}\n\t\tTreeNode<T> left = exchange(root.left);\n\t\tTreeNode<T> right = exchange(root.right);\n\t\troot.leftChild = right;\n\t\troot.rightChild = left;\n\t\treturn root;\n\t}\n\n\t//查看node是否是root的子节点\n\tpublic boolean nodeIsChild(TreeNode<T> root, TreeNode<T> node){\n\t\tif(root == null || node == null){\n\t\t\treturn false;\n\t\t}\n\t\tif(root == node){\n\t\t\treturn true;\n\t\t}\n\t\tboolean isFind = nodeIsChild(root.leftChild, node);\n\t\tif(!isFind){\n\t\t\tisFind = nodeIsChild(root.rightChild, node);\n\t\t}\n\t\treturn isFind;\n\t}\n\n\t//根据前序和中序构建二叉树\n\tpublic TreeNode<T> getTreeFromPreAndMid(List<T> pre, List<T> mid){\n\t\tif(pre == null || mid == null || pre.size() == 0 || mid.size == 0){\n\t\t\treturn null;\n\t\t}\n\t\tif(pre.size() == 1){\n\t\t\treturn new TreeNode<T>(pre.get(0));\n\t\t}\n\t\tTreeNode<T> root = new TreeNode<T>(pre.get(0));\n\t\tint index = 0;\n\t\twhile(!mid.get(index ++).equals(pre.get(0)));//挪动到root的位置\n\t\tList<T> preLeft = new ArrayList<T>(index);\n\t\tList<T> midLeft = new ArrayList<T>(index);\n\t\tfor(int i = 1; i < index; i ++){\n\t\t\tpreLeft.add(pre.get(i));\n\t\t}\n\t\tfor(int i = 0; i < index -1; i ++){\n\t\t\tmidLeft.add(mid.get())\n\t\t}\n\t\troot.leftChild = getTreeFromPreAndMid(preLeft, midLeft);\n\t\tList<T> preRight = new ArrayList<T>(pre.size() - index - 1);\n\t\tList<T> midRight = new ArrayList<T>(pre.size() - index - 1);\n\t\tfor(int i = 0; i <= pre.size() - index - 1; i ++){\n\t\t\tpreRight.add(pre.get(index + i));\n\t\t}\n\t\tfor(int i = 0; i <= pre.size() - index - 1; i ++){\n\t\t\tmidRight.add(mid.get(index + i));\n\t\t}\n\t\troot.rightChild = getTreeFromPreAndMid(preRight, midRight);\n\t\treturn root;\n\t}\n\n\tpublic boolean equals(TreeNode<T> node1, TreeNode<T> node2){\n\t\tif(node1 == null && node2 == null){\n\t\t\treturn true;\n\t\t} else if(node1 == null || node2 == null){\n\t\t\treturn false;\n\t\t}\n\t\tboolean isEqual = node1.value.equals(node2.value);\n\t\tboolean isLeftEqual = equals(node1.leftChild, node2.leftChild);\n\t\tboolean isRightEqual = equals(node1.rightChild, node2.rightChild);\n\t\treturn isEqual && isLeftEqual && isRightEqual;\n\t}\n}\n```\n\n# AVL树\n\n平衡二叉树，即左右节点高度差不超过1的二叉树\n\n## 构造函数\n\n```\nprivate static class AvlNode<AnyType>{\n\tAnyType element;\n\tAvlNode<AnyType> left;\n\tAvlNode<AnyType> right;\n\tint height;\n\tAvlNode(AnyType theElement){\n\t\tthis(theElement, null, null);\n\t}\n\tAvlNode(AnyType theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt){\n\t\telement = theElement;\n\t\tleft = lt;\n\t\tright = rt;\n\t\theight = 0;\n\t}\n}\n```\n\n## 单旋过程\n\n```\nprivate AvlNode<AnyType> rotateWithLeftChild(AvlNode<AnyType> k2){\n\tAvlNode<AnyType> k1 = k2.left;\n\tk2.left = k1.right;\n\tk1.right = k2;\n\tk2.height = Math.max(height(k2.left), height(k2.right)) + 1;\n\tk1.height = Math.max(height(k1.left), k2.height) +1;\n\treturn k1;\n}\n```\n\n## 双旋过程\n\n```\nprivate AvlNode<AnyType> doubleWithLeftChild(AvlNode<AnyType> k3){\n\tk3.left = rotateWithRightChild(k3.left);\n\treturn rotateWthLeftChild(k3);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/tree学习.md","raw":"---\ntitle: tree学习\ndate: 2018-11-12 13:36:55\ntags: 数据结构\n---\n\n# tree\n\n## 构造\n\n树的构造很简单，节点的思想。\n\n```\nclass TreeNode{\n\tObject element;\n\tTreeNode firstChild;\n\tTreeNode nextSibling;\n}\n```\n\n## 示意图\n\n![树示意图](/images/数据结构/tree图1.png)\n\n## 先序遍历\n\n先序遍历的思想是对节点的处理工作在他的子节点处理之前执行，显示结果为D->L->R\n对示意图的先序遍历，结果为：ABDECFG\n\n\n## 中序遍历\n\n中序遍历的思想是先对左节点优先处理，之后在处理自己，最后处理右节点，显示结果为 L->D->R\n对示意图的中序遍历，结果为：DBEAFCG\n\n## 后序遍历\n\n后序遍历的思想是优先处理子节点，最后处理自己，子节点的处理优先是左节点，显示结果为L->R->D\n对示意图的后序遍历，结果为：DEBFGCA\n\n# 二叉树\n\n## 构造\n\n```\nclass BinaryNode{\n\tObject element;\n\tBinaryNode left;\n\tBinaryNode right;\n}\n```\n\n二叉树是一棵树，每个节点都不能有多于两个的儿子，平均深度为O(根号N)\n\n# 二叉查找树\n\n二叉查找树对于树中的每个节点X，它的左子树中所有的项的值小于X中的项，右子树种所有项的值大于X的值\n\n## 构造\n\n```\npublic class BinarySearchTree<T extends Comparable<? super T>>{\n\t/*\n\t* 构造函数\n\t*/\n\tprivate static class BinaryNode<T>{\n\t\tBinaryNode(T element){\n\t\t\tthis(element, null, null);\n\t\t}\n\t\tBinaryNode(T element, Binary<T> left, BinaryNode<T> right){\n\t\t\tthis.element = element;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\t\tT element;\n\t\tBinary<T> left;\n\t\tBinary<T> right;\n\t}\n\n\t/*\n\t* 初始节点\n\t*/\n\tprivate BinaryNode<T> root;\n\n\t/*\n\t* 初始化\n\t*/\n\tpublic BinarySearchTree(){\n\t\troot = null;\n\t}\n\n\t/*\n\t* 置空操作\n\t*/\n\tpublic void makeEmpty(){\n\t\troot = null;\n\t}\n\n\t/*\n\t* 判空操作\n\t*/\n\tpublic void isEmpty(){\n\t\treturn root == null;\n\t}\n\n\t/*\n\t* 判断是否包含\n\t*/\n\tpublic boolean contains(T x){\n\t\treturn contains(x, root);\n\t}\n\t/*\n\t* 判断思想：先和root对比，小就和左节点比较，大就和右节点比较，相同就true，核心思想是递归，递归到最后空的时候就会判false\n\t*/\n\tprivate boolean contains(T x, BinaryNode<T> t){\n\t\tif(t == null){\n\t\t\treturn false;\n\t\t}\n\n\t\tint compareResult = x.compareTo(t.element);\n\n\t\tif( compareResult < 0){\n\t\t\treturn contains(x, left);\n\t\t}else if( compareResult > 0){\n\t\t\treturn contains(x, right);\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/*\n\t* 寻找最小子节点\n\t*/\n\tpublic T findMin(){\n\t\tif (isEmpty()){\n\t\t\tthrow new UnderflowException();\n\t\t}\n\t\treturn findMin(root).element;\n\t}\n\n\t/*\n\t* 寻找思想：查找是否有左节点，如果有就继续遍历左节点，直到某个节点的左节点为null，此时该节点就是最小节点\n\t*/\n\tprivate BinaryNode<T> findMin(BinaryNode<T> t){\n\t\tif (t == null){\n\t\t\treturn null;\n\t\t}else if(t.left == null){\n\t\t\treturn t;\n\t\t}else{\n\t\t\treturn findMin(t.left);\n\t\t}\n\t}\n\n\t/*\n\t* 寻找最大子节点\n\t*/\n\tpublic T findMax(){\n\t\tif(isEmpty()){\n\t\t\tthrow new UnderflowException();\n\t\t}\n\t\treturn findMax(root).element;\n\t}\n\n\t/*\n\t* 思想和寻找最小子节点一样\n\t*/\n\tprivate BinaryNode<T> findMax(BinaryNode<T> t){\n\t\tif (t == null){\n\t\t\treturn null;\n\t\t}else if(t.right == null){\n\t\t\treturn t;\n\t\t}else {\n\t\t\treturn findMax(t.right);\n\t\t}\n\t}\n\n\t/*\n\t* 插入\n\t*/\n\tpublic void insert(T x){\n\t\troot = insert(x, root);\n\t}\n\n\t/*\n\t* 插入数值思想:仍然是和当前节点做比较，如果小就递归左节点，大就递归右节点，直到某个节点的左节点或者右节点不存在，此时就新建一个节点，插入。\n\t*/\n\tprivate BinaryNode<T> insert(T x, BinaryNode<T> t){\n\t\tif (t == null){\n\t\t\treturn new BinaryNode<>(x, null, null);\n\t\t}\n\t\tint compareResult = x.compareTo(t.element);\n\t\tif (compareResult < 0){\n\t\t\tt.left = insert(x, t.left);\n\t\t}else if (compareResult > 0){\n\t\t\tt.right = insert(x, t.right);\n\t\t}else{\n\t\t\t;\n\t\t}\n\t\treturn t;\n\t}\n\n\t/*\n\t* 删除\n\t*/\n\tpublic void remove(T x){\n\t\troot = remove(x, root);\n\t}\n\n\t/*\n\t* 删除的机制：当删除某个节点的时候，如果两个子节点都在，就需要将右侧的最小子节点放到该位置上面来，并且遍历删除右侧的最小子节点\n\t*/\n\tprivate BinaryNode<T> remove(T x, BinaryNode<T> t){\n\t\tif(t == null){\n\t\t\treturn t;\n\t\t}\n\t\tint compareResult = x.compareTo(t.element);\n\t\tif (compareResult < 0){\n\t\t\tt.left = remove(x, t.left);\n\t\t}else if(compareResult > 0){\n\t\t\tt.right = remove(x, t.right);\n\t\t}else if(t.left != null && t.right != null){\n\t\t\tt.element = findMin(t.right).element;\n\t\t\tt.right = remove(t.element, t.right);\n\t\t}else{\n\t\t\tt = (t.left != null)? t.left : t.right;\n\t\t}\n\t\treturn t;\n\t}\n\n\tpublic void printTree(){\n\t\tif (isEmpty()){\n\t\t\tSystem.out.println(\"Empty tree\");\n\t\t}else{\n\t\t\tprintTree(root);\n\t\t}\n\t}\n\t//中序遍历\n\tprivate void printTree(BinaryNode<T> t){\n\t\tif(t != null){\n\t\t\tprintTree(t.left);\n\t\t\tSystem.out.println(t.element);\n\t\t\tprintTree(t.right);\n\t\t}\n\t}\n\t\n\t//先序遍历\n\tprivate void printBeforeTree(BinaryNode<T> t){\n\t\tif(t != null){\n\t\t\tSystem.out.println(t.element);\n\t\t\tprintBeforeTree(t.left);\n\t\t\tprintBeforeTree(t.right);\n\t\t}\n\t}\n\n\t//后序遍历\n\tprivate void printAfterTree(BinaryNode<T> t){\n\t\tif(t != null){\n\t\t\tprintAfterTree(t.left);\n\t\t\tprintAfterTree(t.right);\n\t\t\tSystem.out.println(t.element);\n\t\t}\n\t}\n\t\n\t//层级遍历\n\tpublic void levelTravel(TreeNode<T> root){\n\t\tQueue<TreeNode<T>> q = new LinkedList<TreeNode<T>>();\n\t\tq.offer(root);\n\t\twhile(!q.isEmpty()){\n\t\t\tTreeNode<T> temp = q.poll();\n\t\t\tSystem.out.println(temp);\n\t\t\tif(temp.leftChild != null){\n\t\t\t\tq.offer(temp.leftChild);\n\t\t\t}\n\t\t\tif(temp.rightChild != null){\n\t\t\t\tq.offer(temp.rightChild);\n\t\t\t}\n\t\t}\n\t}\n\n\t//求K层节点总数\n\tpublic int getNumForKLevel(TreeNode<T> root, int k){\n\t\tif(root == null || k < 1){\n\t\t\treturn 0;\n\t\t}\n\t\tif(k == 1){\n\t\t\treturn 1;\n\t\t}\n\t\tint leftNum = getNumForKLevel(root.left, k-1);\n\t\tint rightNum = getNumForKLevel(root.right, k-1);\n\t\treturn leftNum + rightNum;\n\t}\n\n\t//求二叉树中叶子节点的个数\n\tpublic int getLeafNum(TreeNode<T> root){\n\t\tif(root == null){\n\t\t\treturn 0;\n\t\t}\n\t\tif(root.leftChild == null && root.rightChild == null){\n\t\t\treturn 1;\n\t\t}\n\t\tint leftNum = getLeafNum(root.leftChild);\n\t\tint rightNum = getLeafNum(root.rightChild);\n\t\treturn leftNum + rightNum;\n\t}\n\n\t//交换根节点的左右子树\n\tpublic TreeNode<T> exchange(TreeNode<T> root){\n\t\tif(root == null){\n\t\t\treturn null;\n\t\t}\n\t\tTreeNode<T> left = exchange(root.left);\n\t\tTreeNode<T> right = exchange(root.right);\n\t\troot.leftChild = right;\n\t\troot.rightChild = left;\n\t\treturn root;\n\t}\n\n\t//查看node是否是root的子节点\n\tpublic boolean nodeIsChild(TreeNode<T> root, TreeNode<T> node){\n\t\tif(root == null || node == null){\n\t\t\treturn false;\n\t\t}\n\t\tif(root == node){\n\t\t\treturn true;\n\t\t}\n\t\tboolean isFind = nodeIsChild(root.leftChild, node);\n\t\tif(!isFind){\n\t\t\tisFind = nodeIsChild(root.rightChild, node);\n\t\t}\n\t\treturn isFind;\n\t}\n\n\t//根据前序和中序构建二叉树\n\tpublic TreeNode<T> getTreeFromPreAndMid(List<T> pre, List<T> mid){\n\t\tif(pre == null || mid == null || pre.size() == 0 || mid.size == 0){\n\t\t\treturn null;\n\t\t}\n\t\tif(pre.size() == 1){\n\t\t\treturn new TreeNode<T>(pre.get(0));\n\t\t}\n\t\tTreeNode<T> root = new TreeNode<T>(pre.get(0));\n\t\tint index = 0;\n\t\twhile(!mid.get(index ++).equals(pre.get(0)));//挪动到root的位置\n\t\tList<T> preLeft = new ArrayList<T>(index);\n\t\tList<T> midLeft = new ArrayList<T>(index);\n\t\tfor(int i = 1; i < index; i ++){\n\t\t\tpreLeft.add(pre.get(i));\n\t\t}\n\t\tfor(int i = 0; i < index -1; i ++){\n\t\t\tmidLeft.add(mid.get())\n\t\t}\n\t\troot.leftChild = getTreeFromPreAndMid(preLeft, midLeft);\n\t\tList<T> preRight = new ArrayList<T>(pre.size() - index - 1);\n\t\tList<T> midRight = new ArrayList<T>(pre.size() - index - 1);\n\t\tfor(int i = 0; i <= pre.size() - index - 1; i ++){\n\t\t\tpreRight.add(pre.get(index + i));\n\t\t}\n\t\tfor(int i = 0; i <= pre.size() - index - 1; i ++){\n\t\t\tmidRight.add(mid.get(index + i));\n\t\t}\n\t\troot.rightChild = getTreeFromPreAndMid(preRight, midRight);\n\t\treturn root;\n\t}\n\n\tpublic boolean equals(TreeNode<T> node1, TreeNode<T> node2){\n\t\tif(node1 == null && node2 == null){\n\t\t\treturn true;\n\t\t} else if(node1 == null || node2 == null){\n\t\t\treturn false;\n\t\t}\n\t\tboolean isEqual = node1.value.equals(node2.value);\n\t\tboolean isLeftEqual = equals(node1.leftChild, node2.leftChild);\n\t\tboolean isRightEqual = equals(node1.rightChild, node2.rightChild);\n\t\treturn isEqual && isLeftEqual && isRightEqual;\n\t}\n}\n```\n\n# AVL树\n\n平衡二叉树，即左右节点高度差不超过1的二叉树\n\n## 构造函数\n\n```\nprivate static class AvlNode<AnyType>{\n\tAnyType element;\n\tAvlNode<AnyType> left;\n\tAvlNode<AnyType> right;\n\tint height;\n\tAvlNode(AnyType theElement){\n\t\tthis(theElement, null, null);\n\t}\n\tAvlNode(AnyType theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt){\n\t\telement = theElement;\n\t\tleft = lt;\n\t\tright = rt;\n\t\theight = 0;\n\t}\n}\n```\n\n## 单旋过程\n\n```\nprivate AvlNode<AnyType> rotateWithLeftChild(AvlNode<AnyType> k2){\n\tAvlNode<AnyType> k1 = k2.left;\n\tk2.left = k1.right;\n\tk1.right = k2;\n\tk2.height = Math.max(height(k2.left), height(k2.right)) + 1;\n\tk1.height = Math.max(height(k1.left), k2.height) +1;\n\treturn k1;\n}\n```\n\n## 双旋过程\n\n```\nprivate AvlNode<AnyType> doubleWithLeftChild(AvlNode<AnyType> k3){\n\tk3.left = rotateWithRightChild(k3.left);\n\treturn rotateWthLeftChild(k3);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"tree学习","published":1,"updated":"2019-03-12T09:26:33.163Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltu05006r3a8kxv1bnx1v","content":"<h1 id=\"tree\"><a href=\"#tree\" class=\"headerlink\" title=\"tree\"></a>tree</h1><h2 id=\"构造\"><a href=\"#构造\" class=\"headerlink\" title=\"构造\"></a>构造</h2><p>树的构造很简单，节点的思想。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TreeNode&#123;</span><br><span class=\"line\">\tObject element;</span><br><span class=\"line\">\tTreeNode firstChild;</span><br><span class=\"line\">\tTreeNode nextSibling;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"示意图\"><a href=\"#示意图\" class=\"headerlink\" title=\"示意图\"></a>示意图</h2><p><img src=\"/images/数据结构/tree图1.png\" alt=\"树示意图\"></p>\n<h2 id=\"先序遍历\"><a href=\"#先序遍历\" class=\"headerlink\" title=\"先序遍历\"></a>先序遍历</h2><p>先序遍历的思想是对节点的处理工作在他的子节点处理之前执行，显示结果为D-&gt;L-&gt;R<br>对示意图的先序遍历，结果为：ABDECFG</p>\n<h2 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h2><p>中序遍历的思想是先对左节点优先处理，之后在处理自己，最后处理右节点，显示结果为 L-&gt;D-&gt;R<br>对示意图的中序遍历，结果为：DBEAFCG</p>\n<h2 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h2><p>后序遍历的思想是优先处理子节点，最后处理自己，子节点的处理优先是左节点，显示结果为L-&gt;R-&gt;D<br>对示意图的后序遍历，结果为：DEBFGCA</p>\n<h1 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h1><h2 id=\"构造-1\"><a href=\"#构造-1\" class=\"headerlink\" title=\"构造\"></a>构造</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class BinaryNode&#123;</span><br><span class=\"line\">\tObject element;</span><br><span class=\"line\">\tBinaryNode left;</span><br><span class=\"line\">\tBinaryNode right;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>二叉树是一棵树，每个节点都不能有多于两个的儿子，平均深度为O(根号N)</p>\n<h1 id=\"二叉查找树\"><a href=\"#二叉查找树\" class=\"headerlink\" title=\"二叉查找树\"></a>二叉查找树</h1><p>二叉查找树对于树中的每个节点X，它的左子树中所有的项的值小于X中的项，右子树种所有项的值大于X的值</p>\n<h2 id=\"构造-2\"><a href=\"#构造-2\" class=\"headerlink\" title=\"构造\"></a>构造</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BinarySearchTree&lt;T extends Comparable&lt;? super T&gt;&gt;&#123;</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 构造函数</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tprivate static class BinaryNode&lt;T&gt;&#123;</span><br><span class=\"line\">\t\tBinaryNode(T element)&#123;</span><br><span class=\"line\">\t\t\tthis(element, null, null);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tBinaryNode(T element, Binary&lt;T&gt; left, BinaryNode&lt;T&gt; right)&#123;</span><br><span class=\"line\">\t\t\tthis.element = element;</span><br><span class=\"line\">\t\t\tthis.left = left;</span><br><span class=\"line\">\t\t\tthis.right = right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tT element;</span><br><span class=\"line\">\t\tBinary&lt;T&gt; left;</span><br><span class=\"line\">\t\tBinary&lt;T&gt; right;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 初始节点</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tprivate BinaryNode&lt;T&gt; root;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 初始化</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tpublic BinarySearchTree()&#123;</span><br><span class=\"line\">\t\troot = null;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 置空操作</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tpublic void makeEmpty()&#123;</span><br><span class=\"line\">\t\troot = null;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 判空操作</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tpublic void isEmpty()&#123;</span><br><span class=\"line\">\t\treturn root == null;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 判断是否包含</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tpublic boolean contains(T x)&#123;</span><br><span class=\"line\">\t\treturn contains(x, root);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 判断思想：先和root对比，小就和左节点比较，大就和右节点比较，相同就true，核心思想是递归，递归到最后空的时候就会判false</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tprivate boolean contains(T x, BinaryNode&lt;T&gt; t)&#123;</span><br><span class=\"line\">\t\tif(t == null)&#123;</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tint compareResult = x.compareTo(t.element);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif( compareResult &lt; 0)&#123;</span><br><span class=\"line\">\t\t\treturn contains(x, left);</span><br><span class=\"line\">\t\t&#125;else if( compareResult &gt; 0)&#123;</span><br><span class=\"line\">\t\t\treturn contains(x, right);</span><br><span class=\"line\">\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\treturn true;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 寻找最小子节点</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tpublic T findMin()&#123;</span><br><span class=\"line\">\t\tif (isEmpty())&#123;</span><br><span class=\"line\">\t\t\tthrow new UnderflowException();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn findMin(root).element;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 寻找思想：查找是否有左节点，如果有就继续遍历左节点，直到某个节点的左节点为null，此时该节点就是最小节点</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tprivate BinaryNode&lt;T&gt; findMin(BinaryNode&lt;T&gt; t)&#123;</span><br><span class=\"line\">\t\tif (t == null)&#123;</span><br><span class=\"line\">\t\t\treturn null;</span><br><span class=\"line\">\t\t&#125;else if(t.left == null)&#123;</span><br><span class=\"line\">\t\t\treturn t;</span><br><span class=\"line\">\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\treturn findMin(t.left);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 寻找最大子节点</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tpublic T findMax()&#123;</span><br><span class=\"line\">\t\tif(isEmpty())&#123;</span><br><span class=\"line\">\t\t\tthrow new UnderflowException();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn findMax(root).element;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 思想和寻找最小子节点一样</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tprivate BinaryNode&lt;T&gt; findMax(BinaryNode&lt;T&gt; t)&#123;</span><br><span class=\"line\">\t\tif (t == null)&#123;</span><br><span class=\"line\">\t\t\treturn null;</span><br><span class=\"line\">\t\t&#125;else if(t.right == null)&#123;</span><br><span class=\"line\">\t\t\treturn t;</span><br><span class=\"line\">\t\t&#125;else &#123;</span><br><span class=\"line\">\t\t\treturn findMax(t.right);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 插入</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tpublic void insert(T x)&#123;</span><br><span class=\"line\">\t\troot = insert(x, root);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 插入数值思想:仍然是和当前节点做比较，如果小就递归左节点，大就递归右节点，直到某个节点的左节点或者右节点不存在，此时就新建一个节点，插入。</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tprivate BinaryNode&lt;T&gt; insert(T x, BinaryNode&lt;T&gt; t)&#123;</span><br><span class=\"line\">\t\tif (t == null)&#123;</span><br><span class=\"line\">\t\t\treturn new BinaryNode&lt;&gt;(x, null, null);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tint compareResult = x.compareTo(t.element);</span><br><span class=\"line\">\t\tif (compareResult &lt; 0)&#123;</span><br><span class=\"line\">\t\t\tt.left = insert(x, t.left);</span><br><span class=\"line\">\t\t&#125;else if (compareResult &gt; 0)&#123;</span><br><span class=\"line\">\t\t\tt.right = insert(x, t.right);</span><br><span class=\"line\">\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\t;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn t;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 删除</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tpublic void remove(T x)&#123;</span><br><span class=\"line\">\t\troot = remove(x, root);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 删除的机制：当删除某个节点的时候，如果两个子节点都在，就需要将右侧的最小子节点放到该位置上面来，并且遍历删除右侧的最小子节点</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tprivate BinaryNode&lt;T&gt; remove(T x, BinaryNode&lt;T&gt; t)&#123;</span><br><span class=\"line\">\t\tif(t == null)&#123;</span><br><span class=\"line\">\t\t\treturn t;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tint compareResult = x.compareTo(t.element);</span><br><span class=\"line\">\t\tif (compareResult &lt; 0)&#123;</span><br><span class=\"line\">\t\t\tt.left = remove(x, t.left);</span><br><span class=\"line\">\t\t&#125;else if(compareResult &gt; 0)&#123;</span><br><span class=\"line\">\t\t\tt.right = remove(x, t.right);</span><br><span class=\"line\">\t\t&#125;else if(t.left != null &amp;&amp; t.right != null)&#123;</span><br><span class=\"line\">\t\t\tt.element = findMin(t.right).element;</span><br><span class=\"line\">\t\t\tt.right = remove(t.element, t.right);</span><br><span class=\"line\">\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\tt = (t.left != null)? t.left : t.right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn t;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void printTree()&#123;</span><br><span class=\"line\">\t\tif (isEmpty())&#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(&quot;Empty tree&quot;);</span><br><span class=\"line\">\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\tprintTree(root);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t//中序遍历</span><br><span class=\"line\">\tprivate void printTree(BinaryNode&lt;T&gt; t)&#123;</span><br><span class=\"line\">\t\tif(t != null)&#123;</span><br><span class=\"line\">\t\t\tprintTree(t.left);</span><br><span class=\"line\">\t\t\tSystem.out.println(t.element);</span><br><span class=\"line\">\t\t\tprintTree(t.right);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//先序遍历</span><br><span class=\"line\">\tprivate void printBeforeTree(BinaryNode&lt;T&gt; t)&#123;</span><br><span class=\"line\">\t\tif(t != null)&#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(t.element);</span><br><span class=\"line\">\t\t\tprintBeforeTree(t.left);</span><br><span class=\"line\">\t\t\tprintBeforeTree(t.right);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//后序遍历</span><br><span class=\"line\">\tprivate void printAfterTree(BinaryNode&lt;T&gt; t)&#123;</span><br><span class=\"line\">\t\tif(t != null)&#123;</span><br><span class=\"line\">\t\t\tprintAfterTree(t.left);</span><br><span class=\"line\">\t\t\tprintAfterTree(t.right);</span><br><span class=\"line\">\t\t\tSystem.out.println(t.element);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//层级遍历</span><br><span class=\"line\">\tpublic void levelTravel(TreeNode&lt;T&gt; root)&#123;</span><br><span class=\"line\">\t\tQueue&lt;TreeNode&lt;T&gt;&gt; q = new LinkedList&lt;TreeNode&lt;T&gt;&gt;();</span><br><span class=\"line\">\t\tq.offer(root);</span><br><span class=\"line\">\t\twhile(!q.isEmpty())&#123;</span><br><span class=\"line\">\t\t\tTreeNode&lt;T&gt; temp = q.poll();</span><br><span class=\"line\">\t\t\tSystem.out.println(temp);</span><br><span class=\"line\">\t\t\tif(temp.leftChild != null)&#123;</span><br><span class=\"line\">\t\t\t\tq.offer(temp.leftChild);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tif(temp.rightChild != null)&#123;</span><br><span class=\"line\">\t\t\t\tq.offer(temp.rightChild);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//求K层节点总数</span><br><span class=\"line\">\tpublic int getNumForKLevel(TreeNode&lt;T&gt; root, int k)&#123;</span><br><span class=\"line\">\t\tif(root == null || k &lt; 1)&#123;</span><br><span class=\"line\">\t\t\treturn 0;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(k == 1)&#123;</span><br><span class=\"line\">\t\t\treturn 1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tint leftNum = getNumForKLevel(root.left, k-1);</span><br><span class=\"line\">\t\tint rightNum = getNumForKLevel(root.right, k-1);</span><br><span class=\"line\">\t\treturn leftNum + rightNum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//求二叉树中叶子节点的个数</span><br><span class=\"line\">\tpublic int getLeafNum(TreeNode&lt;T&gt; root)&#123;</span><br><span class=\"line\">\t\tif(root == null)&#123;</span><br><span class=\"line\">\t\t\treturn 0;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(root.leftChild == null &amp;&amp; root.rightChild == null)&#123;</span><br><span class=\"line\">\t\t\treturn 1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tint leftNum = getLeafNum(root.leftChild);</span><br><span class=\"line\">\t\tint rightNum = getLeafNum(root.rightChild);</span><br><span class=\"line\">\t\treturn leftNum + rightNum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//交换根节点的左右子树</span><br><span class=\"line\">\tpublic TreeNode&lt;T&gt; exchange(TreeNode&lt;T&gt; root)&#123;</span><br><span class=\"line\">\t\tif(root == null)&#123;</span><br><span class=\"line\">\t\t\treturn null;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tTreeNode&lt;T&gt; left = exchange(root.left);</span><br><span class=\"line\">\t\tTreeNode&lt;T&gt; right = exchange(root.right);</span><br><span class=\"line\">\t\troot.leftChild = right;</span><br><span class=\"line\">\t\troot.rightChild = left;</span><br><span class=\"line\">\t\treturn root;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//查看node是否是root的子节点</span><br><span class=\"line\">\tpublic boolean nodeIsChild(TreeNode&lt;T&gt; root, TreeNode&lt;T&gt; node)&#123;</span><br><span class=\"line\">\t\tif(root == null || node == null)&#123;</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(root == node)&#123;</span><br><span class=\"line\">\t\t\treturn true;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tboolean isFind = nodeIsChild(root.leftChild, node);</span><br><span class=\"line\">\t\tif(!isFind)&#123;</span><br><span class=\"line\">\t\t\tisFind = nodeIsChild(root.rightChild, node);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn isFind;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//根据前序和中序构建二叉树</span><br><span class=\"line\">\tpublic TreeNode&lt;T&gt; getTreeFromPreAndMid(List&lt;T&gt; pre, List&lt;T&gt; mid)&#123;</span><br><span class=\"line\">\t\tif(pre == null || mid == null || pre.size() == 0 || mid.size == 0)&#123;</span><br><span class=\"line\">\t\t\treturn null;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(pre.size() == 1)&#123;</span><br><span class=\"line\">\t\t\treturn new TreeNode&lt;T&gt;(pre.get(0));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tTreeNode&lt;T&gt; root = new TreeNode&lt;T&gt;(pre.get(0));</span><br><span class=\"line\">\t\tint index = 0;</span><br><span class=\"line\">\t\twhile(!mid.get(index ++).equals(pre.get(0)));//挪动到root的位置</span><br><span class=\"line\">\t\tList&lt;T&gt; preLeft = new ArrayList&lt;T&gt;(index);</span><br><span class=\"line\">\t\tList&lt;T&gt; midLeft = new ArrayList&lt;T&gt;(index);</span><br><span class=\"line\">\t\tfor(int i = 1; i &lt; index; i ++)&#123;</span><br><span class=\"line\">\t\t\tpreLeft.add(pre.get(i));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfor(int i = 0; i &lt; index -1; i ++)&#123;</span><br><span class=\"line\">\t\t\tmidLeft.add(mid.get())</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\troot.leftChild = getTreeFromPreAndMid(preLeft, midLeft);</span><br><span class=\"line\">\t\tList&lt;T&gt; preRight = new ArrayList&lt;T&gt;(pre.size() - index - 1);</span><br><span class=\"line\">\t\tList&lt;T&gt; midRight = new ArrayList&lt;T&gt;(pre.size() - index - 1);</span><br><span class=\"line\">\t\tfor(int i = 0; i &lt;= pre.size() - index - 1; i ++)&#123;</span><br><span class=\"line\">\t\t\tpreRight.add(pre.get(index + i));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfor(int i = 0; i &lt;= pre.size() - index - 1; i ++)&#123;</span><br><span class=\"line\">\t\t\tmidRight.add(mid.get(index + i));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\troot.rightChild = getTreeFromPreAndMid(preRight, midRight);</span><br><span class=\"line\">\t\treturn root;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic boolean equals(TreeNode&lt;T&gt; node1, TreeNode&lt;T&gt; node2)&#123;</span><br><span class=\"line\">\t\tif(node1 == null &amp;&amp; node2 == null)&#123;</span><br><span class=\"line\">\t\t\treturn true;</span><br><span class=\"line\">\t\t&#125; else if(node1 == null || node2 == null)&#123;</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tboolean isEqual = node1.value.equals(node2.value);</span><br><span class=\"line\">\t\tboolean isLeftEqual = equals(node1.leftChild, node2.leftChild);</span><br><span class=\"line\">\t\tboolean isRightEqual = equals(node1.rightChild, node2.rightChild);</span><br><span class=\"line\">\t\treturn isEqual &amp;&amp; isLeftEqual &amp;&amp; isRightEqual;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"AVL树\"><a href=\"#AVL树\" class=\"headerlink\" title=\"AVL树\"></a>AVL树</h1><p>平衡二叉树，即左右节点高度差不超过1的二叉树</p>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class AvlNode&lt;AnyType&gt;&#123;</span><br><span class=\"line\">\tAnyType element;</span><br><span class=\"line\">\tAvlNode&lt;AnyType&gt; left;</span><br><span class=\"line\">\tAvlNode&lt;AnyType&gt; right;</span><br><span class=\"line\">\tint height;</span><br><span class=\"line\">\tAvlNode(AnyType theElement)&#123;</span><br><span class=\"line\">\t\tthis(theElement, null, null);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tAvlNode(AnyType theElement, AvlNode&lt;AnyType&gt; lt, AvlNode&lt;AnyType&gt; rt)&#123;</span><br><span class=\"line\">\t\telement = theElement;</span><br><span class=\"line\">\t\tleft = lt;</span><br><span class=\"line\">\t\tright = rt;</span><br><span class=\"line\">\t\theight = 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"单旋过程\"><a href=\"#单旋过程\" class=\"headerlink\" title=\"单旋过程\"></a>单旋过程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private AvlNode&lt;AnyType&gt; rotateWithLeftChild(AvlNode&lt;AnyType&gt; k2)&#123;</span><br><span class=\"line\">\tAvlNode&lt;AnyType&gt; k1 = k2.left;</span><br><span class=\"line\">\tk2.left = k1.right;</span><br><span class=\"line\">\tk1.right = k2;</span><br><span class=\"line\">\tk2.height = Math.max(height(k2.left), height(k2.right)) + 1;</span><br><span class=\"line\">\tk1.height = Math.max(height(k1.left), k2.height) +1;</span><br><span class=\"line\">\treturn k1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"双旋过程\"><a href=\"#双旋过程\" class=\"headerlink\" title=\"双旋过程\"></a>双旋过程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private AvlNode&lt;AnyType&gt; doubleWithLeftChild(AvlNode&lt;AnyType&gt; k3)&#123;</span><br><span class=\"line\">\tk3.left = rotateWithRightChild(k3.left);</span><br><span class=\"line\">\treturn rotateWthLeftChild(k3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"tree\"><a href=\"#tree\" class=\"headerlink\" title=\"tree\"></a>tree</h1><h2 id=\"构造\"><a href=\"#构造\" class=\"headerlink\" title=\"构造\"></a>构造</h2><p>树的构造很简单，节点的思想。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TreeNode&#123;</span><br><span class=\"line\">\tObject element;</span><br><span class=\"line\">\tTreeNode firstChild;</span><br><span class=\"line\">\tTreeNode nextSibling;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"示意图\"><a href=\"#示意图\" class=\"headerlink\" title=\"示意图\"></a>示意图</h2><p><img src=\"/images/数据结构/tree图1.png\" alt=\"树示意图\"></p>\n<h2 id=\"先序遍历\"><a href=\"#先序遍历\" class=\"headerlink\" title=\"先序遍历\"></a>先序遍历</h2><p>先序遍历的思想是对节点的处理工作在他的子节点处理之前执行，显示结果为D-&gt;L-&gt;R<br>对示意图的先序遍历，结果为：ABDECFG</p>\n<h2 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h2><p>中序遍历的思想是先对左节点优先处理，之后在处理自己，最后处理右节点，显示结果为 L-&gt;D-&gt;R<br>对示意图的中序遍历，结果为：DBEAFCG</p>\n<h2 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h2><p>后序遍历的思想是优先处理子节点，最后处理自己，子节点的处理优先是左节点，显示结果为L-&gt;R-&gt;D<br>对示意图的后序遍历，结果为：DEBFGCA</p>\n<h1 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h1><h2 id=\"构造-1\"><a href=\"#构造-1\" class=\"headerlink\" title=\"构造\"></a>构造</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class BinaryNode&#123;</span><br><span class=\"line\">\tObject element;</span><br><span class=\"line\">\tBinaryNode left;</span><br><span class=\"line\">\tBinaryNode right;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>二叉树是一棵树，每个节点都不能有多于两个的儿子，平均深度为O(根号N)</p>\n<h1 id=\"二叉查找树\"><a href=\"#二叉查找树\" class=\"headerlink\" title=\"二叉查找树\"></a>二叉查找树</h1><p>二叉查找树对于树中的每个节点X，它的左子树中所有的项的值小于X中的项，右子树种所有项的值大于X的值</p>\n<h2 id=\"构造-2\"><a href=\"#构造-2\" class=\"headerlink\" title=\"构造\"></a>构造</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BinarySearchTree&lt;T extends Comparable&lt;? super T&gt;&gt;&#123;</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 构造函数</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tprivate static class BinaryNode&lt;T&gt;&#123;</span><br><span class=\"line\">\t\tBinaryNode(T element)&#123;</span><br><span class=\"line\">\t\t\tthis(element, null, null);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tBinaryNode(T element, Binary&lt;T&gt; left, BinaryNode&lt;T&gt; right)&#123;</span><br><span class=\"line\">\t\t\tthis.element = element;</span><br><span class=\"line\">\t\t\tthis.left = left;</span><br><span class=\"line\">\t\t\tthis.right = right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tT element;</span><br><span class=\"line\">\t\tBinary&lt;T&gt; left;</span><br><span class=\"line\">\t\tBinary&lt;T&gt; right;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 初始节点</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tprivate BinaryNode&lt;T&gt; root;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 初始化</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tpublic BinarySearchTree()&#123;</span><br><span class=\"line\">\t\troot = null;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 置空操作</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tpublic void makeEmpty()&#123;</span><br><span class=\"line\">\t\troot = null;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 判空操作</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tpublic void isEmpty()&#123;</span><br><span class=\"line\">\t\treturn root == null;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 判断是否包含</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tpublic boolean contains(T x)&#123;</span><br><span class=\"line\">\t\treturn contains(x, root);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 判断思想：先和root对比，小就和左节点比较，大就和右节点比较，相同就true，核心思想是递归，递归到最后空的时候就会判false</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tprivate boolean contains(T x, BinaryNode&lt;T&gt; t)&#123;</span><br><span class=\"line\">\t\tif(t == null)&#123;</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tint compareResult = x.compareTo(t.element);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif( compareResult &lt; 0)&#123;</span><br><span class=\"line\">\t\t\treturn contains(x, left);</span><br><span class=\"line\">\t\t&#125;else if( compareResult &gt; 0)&#123;</span><br><span class=\"line\">\t\t\treturn contains(x, right);</span><br><span class=\"line\">\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\treturn true;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 寻找最小子节点</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tpublic T findMin()&#123;</span><br><span class=\"line\">\t\tif (isEmpty())&#123;</span><br><span class=\"line\">\t\t\tthrow new UnderflowException();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn findMin(root).element;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 寻找思想：查找是否有左节点，如果有就继续遍历左节点，直到某个节点的左节点为null，此时该节点就是最小节点</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tprivate BinaryNode&lt;T&gt; findMin(BinaryNode&lt;T&gt; t)&#123;</span><br><span class=\"line\">\t\tif (t == null)&#123;</span><br><span class=\"line\">\t\t\treturn null;</span><br><span class=\"line\">\t\t&#125;else if(t.left == null)&#123;</span><br><span class=\"line\">\t\t\treturn t;</span><br><span class=\"line\">\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\treturn findMin(t.left);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 寻找最大子节点</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tpublic T findMax()&#123;</span><br><span class=\"line\">\t\tif(isEmpty())&#123;</span><br><span class=\"line\">\t\t\tthrow new UnderflowException();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn findMax(root).element;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 思想和寻找最小子节点一样</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tprivate BinaryNode&lt;T&gt; findMax(BinaryNode&lt;T&gt; t)&#123;</span><br><span class=\"line\">\t\tif (t == null)&#123;</span><br><span class=\"line\">\t\t\treturn null;</span><br><span class=\"line\">\t\t&#125;else if(t.right == null)&#123;</span><br><span class=\"line\">\t\t\treturn t;</span><br><span class=\"line\">\t\t&#125;else &#123;</span><br><span class=\"line\">\t\t\treturn findMax(t.right);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 插入</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tpublic void insert(T x)&#123;</span><br><span class=\"line\">\t\troot = insert(x, root);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 插入数值思想:仍然是和当前节点做比较，如果小就递归左节点，大就递归右节点，直到某个节点的左节点或者右节点不存在，此时就新建一个节点，插入。</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tprivate BinaryNode&lt;T&gt; insert(T x, BinaryNode&lt;T&gt; t)&#123;</span><br><span class=\"line\">\t\tif (t == null)&#123;</span><br><span class=\"line\">\t\t\treturn new BinaryNode&lt;&gt;(x, null, null);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tint compareResult = x.compareTo(t.element);</span><br><span class=\"line\">\t\tif (compareResult &lt; 0)&#123;</span><br><span class=\"line\">\t\t\tt.left = insert(x, t.left);</span><br><span class=\"line\">\t\t&#125;else if (compareResult &gt; 0)&#123;</span><br><span class=\"line\">\t\t\tt.right = insert(x, t.right);</span><br><span class=\"line\">\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\t;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn t;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 删除</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tpublic void remove(T x)&#123;</span><br><span class=\"line\">\t\troot = remove(x, root);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t* 删除的机制：当删除某个节点的时候，如果两个子节点都在，就需要将右侧的最小子节点放到该位置上面来，并且遍历删除右侧的最小子节点</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">\tprivate BinaryNode&lt;T&gt; remove(T x, BinaryNode&lt;T&gt; t)&#123;</span><br><span class=\"line\">\t\tif(t == null)&#123;</span><br><span class=\"line\">\t\t\treturn t;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tint compareResult = x.compareTo(t.element);</span><br><span class=\"line\">\t\tif (compareResult &lt; 0)&#123;</span><br><span class=\"line\">\t\t\tt.left = remove(x, t.left);</span><br><span class=\"line\">\t\t&#125;else if(compareResult &gt; 0)&#123;</span><br><span class=\"line\">\t\t\tt.right = remove(x, t.right);</span><br><span class=\"line\">\t\t&#125;else if(t.left != null &amp;&amp; t.right != null)&#123;</span><br><span class=\"line\">\t\t\tt.element = findMin(t.right).element;</span><br><span class=\"line\">\t\t\tt.right = remove(t.element, t.right);</span><br><span class=\"line\">\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\tt = (t.left != null)? t.left : t.right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn t;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void printTree()&#123;</span><br><span class=\"line\">\t\tif (isEmpty())&#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(&quot;Empty tree&quot;);</span><br><span class=\"line\">\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\tprintTree(root);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t//中序遍历</span><br><span class=\"line\">\tprivate void printTree(BinaryNode&lt;T&gt; t)&#123;</span><br><span class=\"line\">\t\tif(t != null)&#123;</span><br><span class=\"line\">\t\t\tprintTree(t.left);</span><br><span class=\"line\">\t\t\tSystem.out.println(t.element);</span><br><span class=\"line\">\t\t\tprintTree(t.right);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//先序遍历</span><br><span class=\"line\">\tprivate void printBeforeTree(BinaryNode&lt;T&gt; t)&#123;</span><br><span class=\"line\">\t\tif(t != null)&#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(t.element);</span><br><span class=\"line\">\t\t\tprintBeforeTree(t.left);</span><br><span class=\"line\">\t\t\tprintBeforeTree(t.right);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//后序遍历</span><br><span class=\"line\">\tprivate void printAfterTree(BinaryNode&lt;T&gt; t)&#123;</span><br><span class=\"line\">\t\tif(t != null)&#123;</span><br><span class=\"line\">\t\t\tprintAfterTree(t.left);</span><br><span class=\"line\">\t\t\tprintAfterTree(t.right);</span><br><span class=\"line\">\t\t\tSystem.out.println(t.element);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//层级遍历</span><br><span class=\"line\">\tpublic void levelTravel(TreeNode&lt;T&gt; root)&#123;</span><br><span class=\"line\">\t\tQueue&lt;TreeNode&lt;T&gt;&gt; q = new LinkedList&lt;TreeNode&lt;T&gt;&gt;();</span><br><span class=\"line\">\t\tq.offer(root);</span><br><span class=\"line\">\t\twhile(!q.isEmpty())&#123;</span><br><span class=\"line\">\t\t\tTreeNode&lt;T&gt; temp = q.poll();</span><br><span class=\"line\">\t\t\tSystem.out.println(temp);</span><br><span class=\"line\">\t\t\tif(temp.leftChild != null)&#123;</span><br><span class=\"line\">\t\t\t\tq.offer(temp.leftChild);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tif(temp.rightChild != null)&#123;</span><br><span class=\"line\">\t\t\t\tq.offer(temp.rightChild);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//求K层节点总数</span><br><span class=\"line\">\tpublic int getNumForKLevel(TreeNode&lt;T&gt; root, int k)&#123;</span><br><span class=\"line\">\t\tif(root == null || k &lt; 1)&#123;</span><br><span class=\"line\">\t\t\treturn 0;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(k == 1)&#123;</span><br><span class=\"line\">\t\t\treturn 1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tint leftNum = getNumForKLevel(root.left, k-1);</span><br><span class=\"line\">\t\tint rightNum = getNumForKLevel(root.right, k-1);</span><br><span class=\"line\">\t\treturn leftNum + rightNum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//求二叉树中叶子节点的个数</span><br><span class=\"line\">\tpublic int getLeafNum(TreeNode&lt;T&gt; root)&#123;</span><br><span class=\"line\">\t\tif(root == null)&#123;</span><br><span class=\"line\">\t\t\treturn 0;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(root.leftChild == null &amp;&amp; root.rightChild == null)&#123;</span><br><span class=\"line\">\t\t\treturn 1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tint leftNum = getLeafNum(root.leftChild);</span><br><span class=\"line\">\t\tint rightNum = getLeafNum(root.rightChild);</span><br><span class=\"line\">\t\treturn leftNum + rightNum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//交换根节点的左右子树</span><br><span class=\"line\">\tpublic TreeNode&lt;T&gt; exchange(TreeNode&lt;T&gt; root)&#123;</span><br><span class=\"line\">\t\tif(root == null)&#123;</span><br><span class=\"line\">\t\t\treturn null;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tTreeNode&lt;T&gt; left = exchange(root.left);</span><br><span class=\"line\">\t\tTreeNode&lt;T&gt; right = exchange(root.right);</span><br><span class=\"line\">\t\troot.leftChild = right;</span><br><span class=\"line\">\t\troot.rightChild = left;</span><br><span class=\"line\">\t\treturn root;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//查看node是否是root的子节点</span><br><span class=\"line\">\tpublic boolean nodeIsChild(TreeNode&lt;T&gt; root, TreeNode&lt;T&gt; node)&#123;</span><br><span class=\"line\">\t\tif(root == null || node == null)&#123;</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(root == node)&#123;</span><br><span class=\"line\">\t\t\treturn true;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tboolean isFind = nodeIsChild(root.leftChild, node);</span><br><span class=\"line\">\t\tif(!isFind)&#123;</span><br><span class=\"line\">\t\t\tisFind = nodeIsChild(root.rightChild, node);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn isFind;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//根据前序和中序构建二叉树</span><br><span class=\"line\">\tpublic TreeNode&lt;T&gt; getTreeFromPreAndMid(List&lt;T&gt; pre, List&lt;T&gt; mid)&#123;</span><br><span class=\"line\">\t\tif(pre == null || mid == null || pre.size() == 0 || mid.size == 0)&#123;</span><br><span class=\"line\">\t\t\treturn null;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(pre.size() == 1)&#123;</span><br><span class=\"line\">\t\t\treturn new TreeNode&lt;T&gt;(pre.get(0));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tTreeNode&lt;T&gt; root = new TreeNode&lt;T&gt;(pre.get(0));</span><br><span class=\"line\">\t\tint index = 0;</span><br><span class=\"line\">\t\twhile(!mid.get(index ++).equals(pre.get(0)));//挪动到root的位置</span><br><span class=\"line\">\t\tList&lt;T&gt; preLeft = new ArrayList&lt;T&gt;(index);</span><br><span class=\"line\">\t\tList&lt;T&gt; midLeft = new ArrayList&lt;T&gt;(index);</span><br><span class=\"line\">\t\tfor(int i = 1; i &lt; index; i ++)&#123;</span><br><span class=\"line\">\t\t\tpreLeft.add(pre.get(i));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfor(int i = 0; i &lt; index -1; i ++)&#123;</span><br><span class=\"line\">\t\t\tmidLeft.add(mid.get())</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\troot.leftChild = getTreeFromPreAndMid(preLeft, midLeft);</span><br><span class=\"line\">\t\tList&lt;T&gt; preRight = new ArrayList&lt;T&gt;(pre.size() - index - 1);</span><br><span class=\"line\">\t\tList&lt;T&gt; midRight = new ArrayList&lt;T&gt;(pre.size() - index - 1);</span><br><span class=\"line\">\t\tfor(int i = 0; i &lt;= pre.size() - index - 1; i ++)&#123;</span><br><span class=\"line\">\t\t\tpreRight.add(pre.get(index + i));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfor(int i = 0; i &lt;= pre.size() - index - 1; i ++)&#123;</span><br><span class=\"line\">\t\t\tmidRight.add(mid.get(index + i));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\troot.rightChild = getTreeFromPreAndMid(preRight, midRight);</span><br><span class=\"line\">\t\treturn root;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic boolean equals(TreeNode&lt;T&gt; node1, TreeNode&lt;T&gt; node2)&#123;</span><br><span class=\"line\">\t\tif(node1 == null &amp;&amp; node2 == null)&#123;</span><br><span class=\"line\">\t\t\treturn true;</span><br><span class=\"line\">\t\t&#125; else if(node1 == null || node2 == null)&#123;</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tboolean isEqual = node1.value.equals(node2.value);</span><br><span class=\"line\">\t\tboolean isLeftEqual = equals(node1.leftChild, node2.leftChild);</span><br><span class=\"line\">\t\tboolean isRightEqual = equals(node1.rightChild, node2.rightChild);</span><br><span class=\"line\">\t\treturn isEqual &amp;&amp; isLeftEqual &amp;&amp; isRightEqual;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"AVL树\"><a href=\"#AVL树\" class=\"headerlink\" title=\"AVL树\"></a>AVL树</h1><p>平衡二叉树，即左右节点高度差不超过1的二叉树</p>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class AvlNode&lt;AnyType&gt;&#123;</span><br><span class=\"line\">\tAnyType element;</span><br><span class=\"line\">\tAvlNode&lt;AnyType&gt; left;</span><br><span class=\"line\">\tAvlNode&lt;AnyType&gt; right;</span><br><span class=\"line\">\tint height;</span><br><span class=\"line\">\tAvlNode(AnyType theElement)&#123;</span><br><span class=\"line\">\t\tthis(theElement, null, null);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tAvlNode(AnyType theElement, AvlNode&lt;AnyType&gt; lt, AvlNode&lt;AnyType&gt; rt)&#123;</span><br><span class=\"line\">\t\telement = theElement;</span><br><span class=\"line\">\t\tleft = lt;</span><br><span class=\"line\">\t\tright = rt;</span><br><span class=\"line\">\t\theight = 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"单旋过程\"><a href=\"#单旋过程\" class=\"headerlink\" title=\"单旋过程\"></a>单旋过程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private AvlNode&lt;AnyType&gt; rotateWithLeftChild(AvlNode&lt;AnyType&gt; k2)&#123;</span><br><span class=\"line\">\tAvlNode&lt;AnyType&gt; k1 = k2.left;</span><br><span class=\"line\">\tk2.left = k1.right;</span><br><span class=\"line\">\tk1.right = k2;</span><br><span class=\"line\">\tk2.height = Math.max(height(k2.left), height(k2.right)) + 1;</span><br><span class=\"line\">\tk1.height = Math.max(height(k1.left), k2.height) +1;</span><br><span class=\"line\">\treturn k1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"双旋过程\"><a href=\"#双旋过程\" class=\"headerlink\" title=\"双旋过程\"></a>双旋过程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private AvlNode&lt;AnyType&gt; doubleWithLeftChild(AvlNode&lt;AnyType&gt; k3)&#123;</span><br><span class=\"line\">\tk3.left = rotateWithRightChild(k3.left);</span><br><span class=\"line\">\treturn rotateWthLeftChild(k3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"volatile的作用及其原理","date":"2019-01-09T11:03:23.000Z","_content":"\n# 作用\n\n## 缓存一致性\n\n背景：计算机执行程序时，每条指令都是在cpu中执行的，执行过程中会涉及到数据的读取和写入，由于程序运行过程中的临时数据时存放在主存中（物理内存），这就产生了一个问题，cpu执行速度很快，而从内存读取数据和向内写入数据的过程比cpu执行的速度慢，因此计算机在cpu里面增加了高速缓存\n\ncpu运行过程中，会讲运算需要的数据从主存中复制一份到cpu的高速缓存当中，那么当cpu进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，运算结束之后，再将高速缓存中的数据刷行到主存当中。\n\n譬如\n```\ni = i + 1;\n```\n\n当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后cpu执行指令对i进行+1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存中。\n\n这个代码在多线程中会出现问题，由于多核cpu环境下，每条线程可能运行于不同的cpu中，因此每个线程运行时有自己的高速缓存。当a和b同时执行这条语句的时候，a将i拷贝到了高速缓存中，执行+1操作，此时如果b线程也拷贝到高速缓存中，此时读取的值还是a未+1的值\n\n此时就出现了缓存不一致的问题，这也是著名的缓存一致性问题，通常这种被多个线程访问的变量称为共享变量。\n\n## 解决方法\n\n解决方法有两种，一种是在总线加lock锁的方式，二是通过缓存一致性协议\n\n### 总线加lock\n\n总线加lock的方式可以阻塞主所有其他cpu对其他部件的访问（如内存），从而使得只有一个cpu能使用这个变量的内存。\n\n上述的例子，a在执行i = i + 1的时候，在总线上面发出lock的信号，那么只有等这段代码执行完毕之后，其他cpu才能在i所在的内存读取变量\n\n也就是sychronize在代码块上面加个锁\n\n### 通过缓存一致性协议\n\n当cpu写数据时，如果发现操作的变量是共享变量，即在其他cpu中也存在该变量的副本，会发出信号通知其他cpu将该变量的缓存行为设置为无效状态，因此当其他cpu需要读取这个变量时，发现自己缓存中缓存该变量的缓存时无效的，那么它就会从内存中重新读取\n\n# 并发编程三大特性\n\n## 原子性\n\njava中对基本数据类型的读取和赋值操作是原子性操作，要么执行要么不执行。\n\n```\nx = 10;//原子性操作\n\ny = x;//非原子性，先读取x的值，再将x的值写入工作内存，这两个过程都是原子性，但是合起来不是\n\nx ++;//读取x的值，加1，写入新的值，也是合起来就不是原子性了\n\nx = x + 1;//同x++\n```\n\n## 可见性\n\n可见性就是使用volatile关键字来保证\n\n当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存中，当有其他线程需要读取时，他会去内存中读取新值。\n\n对于一个没有被volatile修饰的普通共享变量，因为普通共享变量被修改之后，什么时候被写入主存时不确定的，当其他线程去读取时，此时内存可能还是原来的旧值，因此无法保证可见性。\n\n另外，通过sychronized和lock也可以保证可见性，sychronized和lock能保证同一时刻只有一个线程获取锁，然后执行同步代码，并且释放锁之前会将对变量的修改刷行到主存当中，因此可以保证可见性\n\n## 有序性\n\n在java内存模型中，允许编译器和处理器对指令进行重排序，但是排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性\n\n在java里面可以通过volatile关键字来保证一定的“有序性”，另外可以通过sychronized和lock来保证有序性，sychronized和lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性\n\n另外，java内存模型具备一些先天的“有序性”，即不需要任何手段就能保证的有序性\n\n### happens - before原则\n\n#### 程序次序规则\n\n```\n一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作\n```\n\n#### 锁定规则\n\n```\n一个unlock操作先行发生于后面对同一个锁unlock操作\n```\n\n#### volatile变量规则\n\n```\n对一个变量的写操作先行发生于后面对这个变量的读操作\n```\n\n#### 传递规则\n\n```\n如果操作a先行发生于操作b，而操作b又先行发生于操作c，则可以得出操作a先行发生于操作c\n```\n\n#### 线程启动规则\n\n```\nthread对象的start()方法先行发生于此线程的每一个动作\n```\n\n#### 线程终结规则\n\n```\n线程中的所有操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行\n```\n\n#### 对象终结规则\n\n```\n一个对象的初始化完成先行发生于它的finalize()方法的开始\n```\n\n# volatile\n\n一个共享变量被volatile修饰之后，就具备了两层语义\n\n1. 保证了不同线程对这个变量进行操作时的**可见性**，即一个线程修改了某个变量的值，这新值对其他线程来说时立即可见的\n\n2. 禁止进行指令重排序\n\n一个例子\n\n```\n//A\nboolean stop = false;\nwhile(!stop){\n\tdoSomething();\n}\n//B\nstop = true;\n```\n\n假如stop没有被volatile修饰的话，当a线程在执行A段语句的时候，b线程执行了B语句，此时可能由于没有来得及写入主存，导致a线程不知道b线程做了修改，就会造成死循环\n\n## 原理和实现机制\n\n```\n观察加入volatile关键字和没有加入volatile关键字时所生成的会变代码发现，加入volatile关键字时，会多出一个lock前缀指令\n \t\t\t\t\t\t\t\t\t\t----《深入理解java虚拟机》\n```\n\nlock前缀指令实际上相当于一个内存屏障(也称内存栅栏)\n\n其提供了三个功能\n\n1. 确保指令重排序时不会吧后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在他前面的操作已经全部完成\n\n2. 他会强制对缓存的操作修改立即写入主存\n\n3. 如果是写操作，他会导致其他cpu中对应的缓存行无效\n\n## 使用场景\n\nsychronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于sychronized，但是要注意volatile关键字是**无法替代**sychronized关键字的，因为**volatile关键字无法保证操作的原子性**\n\n一般使用时需要具备2个条件：\n\n1. 对变量的写操作不依赖于当前值\n\n2. 该变量没有包含在具有其他变量的不变式中\n\n### 场景一：状态标记量\n\n```\nvolatile boolean flag = false;\n\nwhile(!flag){\n\tdoSomething();\n}\n\npublic void setFlag(){\n\tflag = true;\n}\n```\n\n```\nvolatile boolean inited = false;\n//线程1:\ncontext = loadContext();\ninited = true;\n\n//线程2:\nwhile(!inited){\n\tsleep();\n}\ndoSomethingWithConfig(context);\n```\n\n### 场景二：double check\n\n```\nclass Singleton{\n\tprivate volatile static Singleton instance = null;\n\tprivate Singleton(){\n\n\t}\n\n\tpublic static Singleton getInstance(){\n\t\tif(instance == null){\n\t\t\tsychronized(Singleton.class){\n\t\t\t\tif(instance == null){\n\t\t\t\t\tinstance = new Singleton();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n# Q&A\n\n## volatile如何保证有序性？\n\n首先，volatile禁止指令重排序，这代表两层意思\n\n1.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，而在其后面的操作还没有执行\n\n2.在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行，这也就是上面说的内存栅栏\n\n譬如\n\n```\n//x、y为非volatile变量\n//flag为volatile变量\n \nx = 2;        //语句1\ny = 0;        //语句2\nflag = true;  //语句3\nx = 4;         //语句4\ny = -1;       //语句5\n```\n\n由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会将语句3放到语句4、语句5后面，但是语句1和语句2的顺序、语句4和语句5的顺序是不做任何保证的。\n\n再譬如\n\n```\n//线程1:\ncontext = loadContext();   //语句1\ninited = true;             //语句2\n \n//线程2:\nwhile(!inited ){\n  sleep()\n}\ndoSomethingwithconfig(context);\n```\n加入inited没有被volatile修饰的话，那么就有可能语句2再语句1之前执行，就会导致线程2崩溃。\n\n\n\n\n\n\n\n\n","source":"_posts/volatile的作用及其原理.md","raw":"---\ntitle: volatile的作用及其原理\ndate: 2019-01-09 19:03:23\ntags: 多线程\n---\n\n# 作用\n\n## 缓存一致性\n\n背景：计算机执行程序时，每条指令都是在cpu中执行的，执行过程中会涉及到数据的读取和写入，由于程序运行过程中的临时数据时存放在主存中（物理内存），这就产生了一个问题，cpu执行速度很快，而从内存读取数据和向内写入数据的过程比cpu执行的速度慢，因此计算机在cpu里面增加了高速缓存\n\ncpu运行过程中，会讲运算需要的数据从主存中复制一份到cpu的高速缓存当中，那么当cpu进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，运算结束之后，再将高速缓存中的数据刷行到主存当中。\n\n譬如\n```\ni = i + 1;\n```\n\n当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后cpu执行指令对i进行+1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存中。\n\n这个代码在多线程中会出现问题，由于多核cpu环境下，每条线程可能运行于不同的cpu中，因此每个线程运行时有自己的高速缓存。当a和b同时执行这条语句的时候，a将i拷贝到了高速缓存中，执行+1操作，此时如果b线程也拷贝到高速缓存中，此时读取的值还是a未+1的值\n\n此时就出现了缓存不一致的问题，这也是著名的缓存一致性问题，通常这种被多个线程访问的变量称为共享变量。\n\n## 解决方法\n\n解决方法有两种，一种是在总线加lock锁的方式，二是通过缓存一致性协议\n\n### 总线加lock\n\n总线加lock的方式可以阻塞主所有其他cpu对其他部件的访问（如内存），从而使得只有一个cpu能使用这个变量的内存。\n\n上述的例子，a在执行i = i + 1的时候，在总线上面发出lock的信号，那么只有等这段代码执行完毕之后，其他cpu才能在i所在的内存读取变量\n\n也就是sychronize在代码块上面加个锁\n\n### 通过缓存一致性协议\n\n当cpu写数据时，如果发现操作的变量是共享变量，即在其他cpu中也存在该变量的副本，会发出信号通知其他cpu将该变量的缓存行为设置为无效状态，因此当其他cpu需要读取这个变量时，发现自己缓存中缓存该变量的缓存时无效的，那么它就会从内存中重新读取\n\n# 并发编程三大特性\n\n## 原子性\n\njava中对基本数据类型的读取和赋值操作是原子性操作，要么执行要么不执行。\n\n```\nx = 10;//原子性操作\n\ny = x;//非原子性，先读取x的值，再将x的值写入工作内存，这两个过程都是原子性，但是合起来不是\n\nx ++;//读取x的值，加1，写入新的值，也是合起来就不是原子性了\n\nx = x + 1;//同x++\n```\n\n## 可见性\n\n可见性就是使用volatile关键字来保证\n\n当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存中，当有其他线程需要读取时，他会去内存中读取新值。\n\n对于一个没有被volatile修饰的普通共享变量，因为普通共享变量被修改之后，什么时候被写入主存时不确定的，当其他线程去读取时，此时内存可能还是原来的旧值，因此无法保证可见性。\n\n另外，通过sychronized和lock也可以保证可见性，sychronized和lock能保证同一时刻只有一个线程获取锁，然后执行同步代码，并且释放锁之前会将对变量的修改刷行到主存当中，因此可以保证可见性\n\n## 有序性\n\n在java内存模型中，允许编译器和处理器对指令进行重排序，但是排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性\n\n在java里面可以通过volatile关键字来保证一定的“有序性”，另外可以通过sychronized和lock来保证有序性，sychronized和lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性\n\n另外，java内存模型具备一些先天的“有序性”，即不需要任何手段就能保证的有序性\n\n### happens - before原则\n\n#### 程序次序规则\n\n```\n一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作\n```\n\n#### 锁定规则\n\n```\n一个unlock操作先行发生于后面对同一个锁unlock操作\n```\n\n#### volatile变量规则\n\n```\n对一个变量的写操作先行发生于后面对这个变量的读操作\n```\n\n#### 传递规则\n\n```\n如果操作a先行发生于操作b，而操作b又先行发生于操作c，则可以得出操作a先行发生于操作c\n```\n\n#### 线程启动规则\n\n```\nthread对象的start()方法先行发生于此线程的每一个动作\n```\n\n#### 线程终结规则\n\n```\n线程中的所有操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行\n```\n\n#### 对象终结规则\n\n```\n一个对象的初始化完成先行发生于它的finalize()方法的开始\n```\n\n# volatile\n\n一个共享变量被volatile修饰之后，就具备了两层语义\n\n1. 保证了不同线程对这个变量进行操作时的**可见性**，即一个线程修改了某个变量的值，这新值对其他线程来说时立即可见的\n\n2. 禁止进行指令重排序\n\n一个例子\n\n```\n//A\nboolean stop = false;\nwhile(!stop){\n\tdoSomething();\n}\n//B\nstop = true;\n```\n\n假如stop没有被volatile修饰的话，当a线程在执行A段语句的时候，b线程执行了B语句，此时可能由于没有来得及写入主存，导致a线程不知道b线程做了修改，就会造成死循环\n\n## 原理和实现机制\n\n```\n观察加入volatile关键字和没有加入volatile关键字时所生成的会变代码发现，加入volatile关键字时，会多出一个lock前缀指令\n \t\t\t\t\t\t\t\t\t\t----《深入理解java虚拟机》\n```\n\nlock前缀指令实际上相当于一个内存屏障(也称内存栅栏)\n\n其提供了三个功能\n\n1. 确保指令重排序时不会吧后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在他前面的操作已经全部完成\n\n2. 他会强制对缓存的操作修改立即写入主存\n\n3. 如果是写操作，他会导致其他cpu中对应的缓存行无效\n\n## 使用场景\n\nsychronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于sychronized，但是要注意volatile关键字是**无法替代**sychronized关键字的，因为**volatile关键字无法保证操作的原子性**\n\n一般使用时需要具备2个条件：\n\n1. 对变量的写操作不依赖于当前值\n\n2. 该变量没有包含在具有其他变量的不变式中\n\n### 场景一：状态标记量\n\n```\nvolatile boolean flag = false;\n\nwhile(!flag){\n\tdoSomething();\n}\n\npublic void setFlag(){\n\tflag = true;\n}\n```\n\n```\nvolatile boolean inited = false;\n//线程1:\ncontext = loadContext();\ninited = true;\n\n//线程2:\nwhile(!inited){\n\tsleep();\n}\ndoSomethingWithConfig(context);\n```\n\n### 场景二：double check\n\n```\nclass Singleton{\n\tprivate volatile static Singleton instance = null;\n\tprivate Singleton(){\n\n\t}\n\n\tpublic static Singleton getInstance(){\n\t\tif(instance == null){\n\t\t\tsychronized(Singleton.class){\n\t\t\t\tif(instance == null){\n\t\t\t\t\tinstance = new Singleton();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n# Q&A\n\n## volatile如何保证有序性？\n\n首先，volatile禁止指令重排序，这代表两层意思\n\n1.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，而在其后面的操作还没有执行\n\n2.在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行，这也就是上面说的内存栅栏\n\n譬如\n\n```\n//x、y为非volatile变量\n//flag为volatile变量\n \nx = 2;        //语句1\ny = 0;        //语句2\nflag = true;  //语句3\nx = 4;         //语句4\ny = -1;       //语句5\n```\n\n由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会将语句3放到语句4、语句5后面，但是语句1和语句2的顺序、语句4和语句5的顺序是不做任何保证的。\n\n再譬如\n\n```\n//线程1:\ncontext = loadContext();   //语句1\ninited = true;             //语句2\n \n//线程2:\nwhile(!inited ){\n  sleep()\n}\ndoSomethingwithconfig(context);\n```\n加入inited没有被volatile修饰的话，那么就有可能语句2再语句1之前执行，就会导致线程2崩溃。\n\n\n\n\n\n\n\n\n","slug":"volatile的作用及其原理","published":1,"updated":"2019-03-12T09:26:33.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltu06006t3a8kdzch8hb9","content":"<h1 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h1><h2 id=\"缓存一致性\"><a href=\"#缓存一致性\" class=\"headerlink\" title=\"缓存一致性\"></a>缓存一致性</h2><p>背景：计算机执行程序时，每条指令都是在cpu中执行的，执行过程中会涉及到数据的读取和写入，由于程序运行过程中的临时数据时存放在主存中（物理内存），这就产生了一个问题，cpu执行速度很快，而从内存读取数据和向内写入数据的过程比cpu执行的速度慢，因此计算机在cpu里面增加了高速缓存</p>\n<p>cpu运行过程中，会讲运算需要的数据从主存中复制一份到cpu的高速缓存当中，那么当cpu进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，运算结束之后，再将高速缓存中的数据刷行到主存当中。</p>\n<p>譬如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = i + 1;</span><br></pre></td></tr></table></figure></p>\n<p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后cpu执行指令对i进行+1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存中。</p>\n<p>这个代码在多线程中会出现问题，由于多核cpu环境下，每条线程可能运行于不同的cpu中，因此每个线程运行时有自己的高速缓存。当a和b同时执行这条语句的时候，a将i拷贝到了高速缓存中，执行+1操作，此时如果b线程也拷贝到高速缓存中，此时读取的值还是a未+1的值</p>\n<p>此时就出现了缓存不一致的问题，这也是著名的缓存一致性问题，通常这种被多个线程访问的变量称为共享变量。</p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>解决方法有两种，一种是在总线加lock锁的方式，二是通过缓存一致性协议</p>\n<h3 id=\"总线加lock\"><a href=\"#总线加lock\" class=\"headerlink\" title=\"总线加lock\"></a>总线加lock</h3><p>总线加lock的方式可以阻塞主所有其他cpu对其他部件的访问（如内存），从而使得只有一个cpu能使用这个变量的内存。</p>\n<p>上述的例子，a在执行i = i + 1的时候，在总线上面发出lock的信号，那么只有等这段代码执行完毕之后，其他cpu才能在i所在的内存读取变量</p>\n<p>也就是sychronize在代码块上面加个锁</p>\n<h3 id=\"通过缓存一致性协议\"><a href=\"#通过缓存一致性协议\" class=\"headerlink\" title=\"通过缓存一致性协议\"></a>通过缓存一致性协议</h3><p>当cpu写数据时，如果发现操作的变量是共享变量，即在其他cpu中也存在该变量的副本，会发出信号通知其他cpu将该变量的缓存行为设置为无效状态，因此当其他cpu需要读取这个变量时，发现自己缓存中缓存该变量的缓存时无效的，那么它就会从内存中重新读取</p>\n<h1 id=\"并发编程三大特性\"><a href=\"#并发编程三大特性\" class=\"headerlink\" title=\"并发编程三大特性\"></a>并发编程三大特性</h1><h2 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h2><p>java中对基本数据类型的读取和赋值操作是原子性操作，要么执行要么不执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = 10;//原子性操作</span><br><span class=\"line\"></span><br><span class=\"line\">y = x;//非原子性，先读取x的值，再将x的值写入工作内存，这两个过程都是原子性，但是合起来不是</span><br><span class=\"line\"></span><br><span class=\"line\">x ++;//读取x的值，加1，写入新的值，也是合起来就不是原子性了</span><br><span class=\"line\"></span><br><span class=\"line\">x = x + 1;//同x++</span><br></pre></td></tr></table></figure>\n<h2 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h2><p>可见性就是使用volatile关键字来保证</p>\n<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存中，当有其他线程需要读取时，他会去内存中读取新值。</p>\n<p>对于一个没有被volatile修饰的普通共享变量，因为普通共享变量被修改之后，什么时候被写入主存时不确定的，当其他线程去读取时，此时内存可能还是原来的旧值，因此无法保证可见性。</p>\n<p>另外，通过sychronized和lock也可以保证可见性，sychronized和lock能保证同一时刻只有一个线程获取锁，然后执行同步代码，并且释放锁之前会将对变量的修改刷行到主存当中，因此可以保证可见性</p>\n<h2 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h2><p>在java内存模型中，允许编译器和处理器对指令进行重排序，但是排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性</p>\n<p>在java里面可以通过volatile关键字来保证一定的“有序性”，另外可以通过sychronized和lock来保证有序性，sychronized和lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性</p>\n<p>另外，java内存模型具备一些先天的“有序性”，即不需要任何手段就能保证的有序性</p>\n<h3 id=\"happens-before原则\"><a href=\"#happens-before原则\" class=\"headerlink\" title=\"happens - before原则\"></a>happens - before原则</h3><h4 id=\"程序次序规则\"><a href=\"#程序次序规则\" class=\"headerlink\" title=\"程序次序规则\"></a>程序次序规则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</span><br></pre></td></tr></table></figure>\n<h4 id=\"锁定规则\"><a href=\"#锁定规则\" class=\"headerlink\" title=\"锁定规则\"></a>锁定规则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个unlock操作先行发生于后面对同一个锁unlock操作</span><br></pre></td></tr></table></figure>\n<h4 id=\"volatile变量规则\"><a href=\"#volatile变量规则\" class=\"headerlink\" title=\"volatile变量规则\"></a>volatile变量规则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对一个变量的写操作先行发生于后面对这个变量的读操作</span><br></pre></td></tr></table></figure>\n<h4 id=\"传递规则\"><a href=\"#传递规则\" class=\"headerlink\" title=\"传递规则\"></a>传递规则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果操作a先行发生于操作b，而操作b又先行发生于操作c，则可以得出操作a先行发生于操作c</span><br></pre></td></tr></table></figure>\n<h4 id=\"线程启动规则\"><a href=\"#线程启动规则\" class=\"headerlink\" title=\"线程启动规则\"></a>线程启动规则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thread对象的start()方法先行发生于此线程的每一个动作</span><br></pre></td></tr></table></figure>\n<h4 id=\"线程终结规则\"><a href=\"#线程终结规则\" class=\"headerlink\" title=\"线程终结规则\"></a>线程终结规则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">线程中的所有操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</span><br></pre></td></tr></table></figure>\n<h4 id=\"对象终结规则\"><a href=\"#对象终结规则\" class=\"headerlink\" title=\"对象终结规则\"></a>对象终结规则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个对象的初始化完成先行发生于它的finalize()方法的开始</span><br></pre></td></tr></table></figure>\n<h1 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h1><p>一个共享变量被volatile修饰之后，就具备了两层语义</p>\n<ol>\n<li><p>保证了不同线程对这个变量进行操作时的<strong>可见性</strong>，即一个线程修改了某个变量的值，这新值对其他线程来说时立即可见的</p>\n</li>\n<li><p>禁止进行指令重排序</p>\n</li>\n</ol>\n<p>一个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//A</span><br><span class=\"line\">boolean stop = false;</span><br><span class=\"line\">while(!stop)&#123;</span><br><span class=\"line\">\tdoSomething();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//B</span><br><span class=\"line\">stop = true;</span><br></pre></td></tr></table></figure>\n<p>假如stop没有被volatile修饰的话，当a线程在执行A段语句的时候，b线程执行了B语句，此时可能由于没有来得及写入主存，导致a线程不知道b线程做了修改，就会造成死循环</p>\n<h2 id=\"原理和实现机制\"><a href=\"#原理和实现机制\" class=\"headerlink\" title=\"原理和实现机制\"></a>原理和实现机制</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">观察加入volatile关键字和没有加入volatile关键字时所生成的会变代码发现，加入volatile关键字时，会多出一个lock前缀指令</span><br><span class=\"line\"> \t\t\t\t\t\t\t\t\t\t----《深入理解java虚拟机》</span><br></pre></td></tr></table></figure>\n<p>lock前缀指令实际上相当于一个内存屏障(也称内存栅栏)</p>\n<p>其提供了三个功能</p>\n<ol>\n<li><p>确保指令重排序时不会吧后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在他前面的操作已经全部完成</p>\n</li>\n<li><p>他会强制对缓存的操作修改立即写入主存</p>\n</li>\n<li><p>如果是写操作，他会导致其他cpu中对应的缓存行无效</p>\n</li>\n</ol>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>sychronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于sychronized，但是要注意volatile关键字是<strong>无法替代</strong>sychronized关键字的，因为<strong>volatile关键字无法保证操作的原子性</strong></p>\n<p>一般使用时需要具备2个条件：</p>\n<ol>\n<li><p>对变量的写操作不依赖于当前值</p>\n</li>\n<li><p>该变量没有包含在具有其他变量的不变式中</p>\n</li>\n</ol>\n<h3 id=\"场景一：状态标记量\"><a href=\"#场景一：状态标记量\" class=\"headerlink\" title=\"场景一：状态标记量\"></a>场景一：状态标记量</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">volatile boolean flag = false;</span><br><span class=\"line\"></span><br><span class=\"line\">while(!flag)&#123;</span><br><span class=\"line\">\tdoSomething();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void setFlag()&#123;</span><br><span class=\"line\">\tflag = true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">volatile boolean inited = false;</span><br><span class=\"line\">//线程1:</span><br><span class=\"line\">context = loadContext();</span><br><span class=\"line\">inited = true;</span><br><span class=\"line\"></span><br><span class=\"line\">//线程2:</span><br><span class=\"line\">while(!inited)&#123;</span><br><span class=\"line\">\tsleep();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doSomethingWithConfig(context);</span><br></pre></td></tr></table></figure>\n<h3 id=\"场景二：double-check\"><a href=\"#场景二：double-check\" class=\"headerlink\" title=\"场景二：double check\"></a>场景二：double check</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Singleton&#123;</span><br><span class=\"line\">\tprivate volatile static Singleton instance = null;</span><br><span class=\"line\">\tprivate Singleton()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static Singleton getInstance()&#123;</span><br><span class=\"line\">\t\tif(instance == null)&#123;</span><br><span class=\"line\">\t\t\tsychronized(Singleton.class)&#123;</span><br><span class=\"line\">\t\t\t\tif(instance == null)&#123;</span><br><span class=\"line\">\t\t\t\t\tinstance = new Singleton();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h1><h2 id=\"volatile如何保证有序性？\"><a href=\"#volatile如何保证有序性？\" class=\"headerlink\" title=\"volatile如何保证有序性？\"></a>volatile如何保证有序性？</h2><p>首先，volatile禁止指令重排序，这代表两层意思</p>\n<p>1.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，而在其后面的操作还没有执行</p>\n<p>2.在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行，这也就是上面说的内存栅栏</p>\n<p>譬如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//x、y为非volatile变量</span><br><span class=\"line\">//flag为volatile变量</span><br><span class=\"line\"> </span><br><span class=\"line\">x = 2;        //语句1</span><br><span class=\"line\">y = 0;        //语句2</span><br><span class=\"line\">flag = true;  //语句3</span><br><span class=\"line\">x = 4;         //语句4</span><br><span class=\"line\">y = -1;       //语句5</span><br></pre></td></tr></table></figure>\n<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会将语句3放到语句4、语句5后面，但是语句1和语句2的顺序、语句4和语句5的顺序是不做任何保证的。</p>\n<p>再譬如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//线程1:</span><br><span class=\"line\">context = loadContext();   //语句1</span><br><span class=\"line\">inited = true;             //语句2</span><br><span class=\"line\"> </span><br><span class=\"line\">//线程2:</span><br><span class=\"line\">while(!inited )&#123;</span><br><span class=\"line\">  sleep()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>\n<p>加入inited没有被volatile修饰的话，那么就有可能语句2再语句1之前执行，就会导致线程2崩溃。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h1><h2 id=\"缓存一致性\"><a href=\"#缓存一致性\" class=\"headerlink\" title=\"缓存一致性\"></a>缓存一致性</h2><p>背景：计算机执行程序时，每条指令都是在cpu中执行的，执行过程中会涉及到数据的读取和写入，由于程序运行过程中的临时数据时存放在主存中（物理内存），这就产生了一个问题，cpu执行速度很快，而从内存读取数据和向内写入数据的过程比cpu执行的速度慢，因此计算机在cpu里面增加了高速缓存</p>\n<p>cpu运行过程中，会讲运算需要的数据从主存中复制一份到cpu的高速缓存当中，那么当cpu进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，运算结束之后，再将高速缓存中的数据刷行到主存当中。</p>\n<p>譬如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = i + 1;</span><br></pre></td></tr></table></figure></p>\n<p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后cpu执行指令对i进行+1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存中。</p>\n<p>这个代码在多线程中会出现问题，由于多核cpu环境下，每条线程可能运行于不同的cpu中，因此每个线程运行时有自己的高速缓存。当a和b同时执行这条语句的时候，a将i拷贝到了高速缓存中，执行+1操作，此时如果b线程也拷贝到高速缓存中，此时读取的值还是a未+1的值</p>\n<p>此时就出现了缓存不一致的问题，这也是著名的缓存一致性问题，通常这种被多个线程访问的变量称为共享变量。</p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>解决方法有两种，一种是在总线加lock锁的方式，二是通过缓存一致性协议</p>\n<h3 id=\"总线加lock\"><a href=\"#总线加lock\" class=\"headerlink\" title=\"总线加lock\"></a>总线加lock</h3><p>总线加lock的方式可以阻塞主所有其他cpu对其他部件的访问（如内存），从而使得只有一个cpu能使用这个变量的内存。</p>\n<p>上述的例子，a在执行i = i + 1的时候，在总线上面发出lock的信号，那么只有等这段代码执行完毕之后，其他cpu才能在i所在的内存读取变量</p>\n<p>也就是sychronize在代码块上面加个锁</p>\n<h3 id=\"通过缓存一致性协议\"><a href=\"#通过缓存一致性协议\" class=\"headerlink\" title=\"通过缓存一致性协议\"></a>通过缓存一致性协议</h3><p>当cpu写数据时，如果发现操作的变量是共享变量，即在其他cpu中也存在该变量的副本，会发出信号通知其他cpu将该变量的缓存行为设置为无效状态，因此当其他cpu需要读取这个变量时，发现自己缓存中缓存该变量的缓存时无效的，那么它就会从内存中重新读取</p>\n<h1 id=\"并发编程三大特性\"><a href=\"#并发编程三大特性\" class=\"headerlink\" title=\"并发编程三大特性\"></a>并发编程三大特性</h1><h2 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h2><p>java中对基本数据类型的读取和赋值操作是原子性操作，要么执行要么不执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = 10;//原子性操作</span><br><span class=\"line\"></span><br><span class=\"line\">y = x;//非原子性，先读取x的值，再将x的值写入工作内存，这两个过程都是原子性，但是合起来不是</span><br><span class=\"line\"></span><br><span class=\"line\">x ++;//读取x的值，加1，写入新的值，也是合起来就不是原子性了</span><br><span class=\"line\"></span><br><span class=\"line\">x = x + 1;//同x++</span><br></pre></td></tr></table></figure>\n<h2 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h2><p>可见性就是使用volatile关键字来保证</p>\n<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存中，当有其他线程需要读取时，他会去内存中读取新值。</p>\n<p>对于一个没有被volatile修饰的普通共享变量，因为普通共享变量被修改之后，什么时候被写入主存时不确定的，当其他线程去读取时，此时内存可能还是原来的旧值，因此无法保证可见性。</p>\n<p>另外，通过sychronized和lock也可以保证可见性，sychronized和lock能保证同一时刻只有一个线程获取锁，然后执行同步代码，并且释放锁之前会将对变量的修改刷行到主存当中，因此可以保证可见性</p>\n<h2 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h2><p>在java内存模型中，允许编译器和处理器对指令进行重排序，但是排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性</p>\n<p>在java里面可以通过volatile关键字来保证一定的“有序性”，另外可以通过sychronized和lock来保证有序性，sychronized和lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性</p>\n<p>另外，java内存模型具备一些先天的“有序性”，即不需要任何手段就能保证的有序性</p>\n<h3 id=\"happens-before原则\"><a href=\"#happens-before原则\" class=\"headerlink\" title=\"happens - before原则\"></a>happens - before原则</h3><h4 id=\"程序次序规则\"><a href=\"#程序次序规则\" class=\"headerlink\" title=\"程序次序规则\"></a>程序次序规则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</span><br></pre></td></tr></table></figure>\n<h4 id=\"锁定规则\"><a href=\"#锁定规则\" class=\"headerlink\" title=\"锁定规则\"></a>锁定规则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个unlock操作先行发生于后面对同一个锁unlock操作</span><br></pre></td></tr></table></figure>\n<h4 id=\"volatile变量规则\"><a href=\"#volatile变量规则\" class=\"headerlink\" title=\"volatile变量规则\"></a>volatile变量规则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对一个变量的写操作先行发生于后面对这个变量的读操作</span><br></pre></td></tr></table></figure>\n<h4 id=\"传递规则\"><a href=\"#传递规则\" class=\"headerlink\" title=\"传递规则\"></a>传递规则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果操作a先行发生于操作b，而操作b又先行发生于操作c，则可以得出操作a先行发生于操作c</span><br></pre></td></tr></table></figure>\n<h4 id=\"线程启动规则\"><a href=\"#线程启动规则\" class=\"headerlink\" title=\"线程启动规则\"></a>线程启动规则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thread对象的start()方法先行发生于此线程的每一个动作</span><br></pre></td></tr></table></figure>\n<h4 id=\"线程终结规则\"><a href=\"#线程终结规则\" class=\"headerlink\" title=\"线程终结规则\"></a>线程终结规则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">线程中的所有操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</span><br></pre></td></tr></table></figure>\n<h4 id=\"对象终结规则\"><a href=\"#对象终结规则\" class=\"headerlink\" title=\"对象终结规则\"></a>对象终结规则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个对象的初始化完成先行发生于它的finalize()方法的开始</span><br></pre></td></tr></table></figure>\n<h1 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h1><p>一个共享变量被volatile修饰之后，就具备了两层语义</p>\n<ol>\n<li><p>保证了不同线程对这个变量进行操作时的<strong>可见性</strong>，即一个线程修改了某个变量的值，这新值对其他线程来说时立即可见的</p>\n</li>\n<li><p>禁止进行指令重排序</p>\n</li>\n</ol>\n<p>一个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//A</span><br><span class=\"line\">boolean stop = false;</span><br><span class=\"line\">while(!stop)&#123;</span><br><span class=\"line\">\tdoSomething();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//B</span><br><span class=\"line\">stop = true;</span><br></pre></td></tr></table></figure>\n<p>假如stop没有被volatile修饰的话，当a线程在执行A段语句的时候，b线程执行了B语句，此时可能由于没有来得及写入主存，导致a线程不知道b线程做了修改，就会造成死循环</p>\n<h2 id=\"原理和实现机制\"><a href=\"#原理和实现机制\" class=\"headerlink\" title=\"原理和实现机制\"></a>原理和实现机制</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">观察加入volatile关键字和没有加入volatile关键字时所生成的会变代码发现，加入volatile关键字时，会多出一个lock前缀指令</span><br><span class=\"line\"> \t\t\t\t\t\t\t\t\t\t----《深入理解java虚拟机》</span><br></pre></td></tr></table></figure>\n<p>lock前缀指令实际上相当于一个内存屏障(也称内存栅栏)</p>\n<p>其提供了三个功能</p>\n<ol>\n<li><p>确保指令重排序时不会吧后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在他前面的操作已经全部完成</p>\n</li>\n<li><p>他会强制对缓存的操作修改立即写入主存</p>\n</li>\n<li><p>如果是写操作，他会导致其他cpu中对应的缓存行无效</p>\n</li>\n</ol>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>sychronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于sychronized，但是要注意volatile关键字是<strong>无法替代</strong>sychronized关键字的，因为<strong>volatile关键字无法保证操作的原子性</strong></p>\n<p>一般使用时需要具备2个条件：</p>\n<ol>\n<li><p>对变量的写操作不依赖于当前值</p>\n</li>\n<li><p>该变量没有包含在具有其他变量的不变式中</p>\n</li>\n</ol>\n<h3 id=\"场景一：状态标记量\"><a href=\"#场景一：状态标记量\" class=\"headerlink\" title=\"场景一：状态标记量\"></a>场景一：状态标记量</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">volatile boolean flag = false;</span><br><span class=\"line\"></span><br><span class=\"line\">while(!flag)&#123;</span><br><span class=\"line\">\tdoSomething();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void setFlag()&#123;</span><br><span class=\"line\">\tflag = true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">volatile boolean inited = false;</span><br><span class=\"line\">//线程1:</span><br><span class=\"line\">context = loadContext();</span><br><span class=\"line\">inited = true;</span><br><span class=\"line\"></span><br><span class=\"line\">//线程2:</span><br><span class=\"line\">while(!inited)&#123;</span><br><span class=\"line\">\tsleep();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doSomethingWithConfig(context);</span><br></pre></td></tr></table></figure>\n<h3 id=\"场景二：double-check\"><a href=\"#场景二：double-check\" class=\"headerlink\" title=\"场景二：double check\"></a>场景二：double check</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Singleton&#123;</span><br><span class=\"line\">\tprivate volatile static Singleton instance = null;</span><br><span class=\"line\">\tprivate Singleton()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static Singleton getInstance()&#123;</span><br><span class=\"line\">\t\tif(instance == null)&#123;</span><br><span class=\"line\">\t\t\tsychronized(Singleton.class)&#123;</span><br><span class=\"line\">\t\t\t\tif(instance == null)&#123;</span><br><span class=\"line\">\t\t\t\t\tinstance = new Singleton();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h1><h2 id=\"volatile如何保证有序性？\"><a href=\"#volatile如何保证有序性？\" class=\"headerlink\" title=\"volatile如何保证有序性？\"></a>volatile如何保证有序性？</h2><p>首先，volatile禁止指令重排序，这代表两层意思</p>\n<p>1.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，而在其后面的操作还没有执行</p>\n<p>2.在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行，这也就是上面说的内存栅栏</p>\n<p>譬如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//x、y为非volatile变量</span><br><span class=\"line\">//flag为volatile变量</span><br><span class=\"line\"> </span><br><span class=\"line\">x = 2;        //语句1</span><br><span class=\"line\">y = 0;        //语句2</span><br><span class=\"line\">flag = true;  //语句3</span><br><span class=\"line\">x = 4;         //语句4</span><br><span class=\"line\">y = -1;       //语句5</span><br></pre></td></tr></table></figure>\n<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会将语句3放到语句4、语句5后面，但是语句1和语句2的顺序、语句4和语句5的顺序是不做任何保证的。</p>\n<p>再譬如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//线程1:</span><br><span class=\"line\">context = loadContext();   //语句1</span><br><span class=\"line\">inited = true;             //语句2</span><br><span class=\"line\"> </span><br><span class=\"line\">//线程2:</span><br><span class=\"line\">while(!inited )&#123;</span><br><span class=\"line\">  sleep()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>\n<p>加入inited没有被volatile修饰的话，那么就有可能语句2再语句1之前执行，就会导致线程2崩溃。</p>\n"},{"title":"“rxjava2.0”","date":"2017-12-21T08:24:02.000Z","_content":"#[Rxjava2.0](http://blog.csdn.net/flybasker/article/details/78703295)\n\n## 基础概念\n\nObservable：在观察者模式中称为“被观察者”；\nObserver：观察者模式中的“观察者”，可接收Observable发送的数据；\nsubscribe：订阅，观察者与被观察者，通过Observable的subscribe()方法进行订阅；\nSubscriber：也是一种观察者，在2.0中 它与Observer没什么实质的区别，不同的是 Subscriber要与Flowable(也是一种被观察者)联合使用，该部分 内容是2.0新增的，后续文章再介绍。Obsesrver用于订阅Observable，而Subscriber用于订阅Flowable.\n\n## Rxjava中定义的事件方法\n\nonNext(),普通事件,按照队列依次进行处理.\nonComplete(),事件队列完结时调用该方法\nonError(),事件处理过程中出现异常时，onError()触发，同时队列终止,不再有事件发出.\nonSubscribe(),RxJava 2.0 中新增的，传递参数为Disposable,可用于切断接收事件让Observable (被观察者)开启子线程执行耗操作，完成耗时操作后，触发回调，通知Observer (观察者)进行主线程UI更新\n\n## observable的几种创建方式\n1. just()方式\n使用just( )，将创建一个Observable并自动调用onNext( )发射数据。\n也就是通过just( )方式 直接触发onNext()，just中传递的参数将直接在Observer的onNext()方法中接收到。\n\n2. fromIterable()方式\n使用fromIterable()，遍历集合，发送每个item.多次自动调用onNext()方法，每次传入一个item.\n注意：Collection接口是Iterable接口的子接口，所以所有Collection接口的实现类都可以作为Iterable对象直接传入fromIterable()    方法。\n\n3. defer()方式\n当观察者订阅时,才创建Observable，并且针对每个观察者创建都是一个新的Observable.\n通过Callable中的回调方法call(),决定使用以何种方式来创建这个Observable对象,当订阅后，发送事件.\n\n4. interval( )方式\n创建一个按固定时间间隔发射整数序列的Observable，可用作定时器。按照固定时间间隔来调用onNext()方法。\n\n5. timer( )方式\n通过此种创建一个Observable,它在一个给定的延迟后发射一个特殊的值，即表示延迟指定时间后，调用onNext()方法。\n\n6. range( )方式,range(x,y)\n创建一个发射特定整数序列的Observable，第一个参数x为起始值，第二个y为发送的个数，如果y为0则不发送，y为负数则抛异常。\nrange(1,5)\n上述表示发射1到5的数。即调用5次Next()方法，依次传入1-5数字。\n\n7. repeat( )方式\n创建一个Observable，该Observable的事件可以重复调用。\n\n## ObservableEmitter\nEmitter是发射器的意思,就是用来发出事件的，它可以发出三种类型的事件 \n通过调用onNext(T value),发出next事件 \n通过调用onComplete(),发出complete事件 \n通过调用onError(Throwable error),发出error事件 \n注意事项: \nonComplete和onError唯一并且互斥 \n发送多个onComplete, 第一个onComplete接收到,就不再接收了. \n发送多个onError, 则收到第二个onError事件会导致程序会崩溃. \n不可以随意乱七八糟发射事件，需要满足一定的规则： \n上游可以发送无限个onNext, 下游也可以接收无限个onNext. \n当上游发送了一个onComplete后, 上游onComplete之后的事件将会继续发送, 而下游收到onComplete事件之后将不再继续接收事件. \n上游发送了一个onError后, 上游onError之后的事件将继续发送, 而下游收到onError事件之后将不再继续接收事件. \n上游可以不发送onComplete或onError. \n最为关键的是onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError \n\n## Disposable\n一次性,它理解成两根管道之间的一个机关, 当调用它的dispose()方法时, 它就会将两根管道切断, 从而导致下游收不到事件. \n在RxJava中,用它来切断Observer(观察者)与Observable(被观察者)之间的连接，当调用它的dispose()方法时, 它就会将Observer(观察者)与Observable(被观察者)之间的连接切断, 从而导致Observer(观察者)收不到事件。 \n注意: 调用dispose()并不会导致上游不再继续发送事件, 上游会继续发送剩余的事件 \n\n## 线程调度\n1. Schedulers.immediate(): \n直接在当前线程运行，相当于不指定线程。这是默认的Scheduler。\n\n2. Schedulers.newThread(): \n总是启用新线程，并在新线程执行操作。\n\n3. Schedulers.io(): I/O \n操作（读写文件、读写数据库、网络信息交互等）所使用的Scheduler。行为模式和newThread()差不多，区别在于io()的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下io()比newThread()更有效率。不要把计算工作放在io()中，可以避免创建不必要的线程。\n\n4. Schedulers.computation(): \n计算所使用的Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个Scheduler使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在computation()中，否则 I/O 操作的等待时间会浪费 CPU。\n\n5. AndroidSchedulers.mainThread()，\nAndroid专用线程，指定操作在主线程运行。\n\n如何切换线程呢？RxJava中提供了两个方法：\n    subscribeOn() 和 observeOn() ，\n两者的不同点在于：\n\nsubscribeOn(): 指定subscribe()订阅所发生的线程，或者叫做事件产生的线程。\n\nobserveOn(): 指定Observer所运行在的线程，即onNext()执行的线程。或者叫做事件消费的线程。\n\n## 操作符\n操作符就是用于在Observable和最终的Observer之间，通过转换Observable为其他观察者对象的过程，修改发出的事件,最终将最简洁的数据传递给Observer对象. \n\n1. map()操作符，就是把原来的Observable对象转换成另一个Observable对象，同时将传输的数据进行一些灵活的操作，方便Observer获得想要的数据形式。\n举例:\n```\nObservable<Integer> observable = Observable\n        .just(\"hello\")\n        .map(new Function<String, Integer>() {\n            @Override\n            public Integer apply(String s) throws Exception {\n                return s.length();\n            }\n        });\n```\n\n2. flatMap()操作符 \nflatMap()对于数据的转换比map()更加彻底，如果发送的数据是集合，flatmap()重新生成一个Observable对象，并把数据转换成Observer想 要的数据形式。它可以返回任何它想返回的Observable对象。 \n举例:\n```\nObservable.just(list)\n       .flatMap(new Function<List<String>, ObservableSource<?>>() {\n            @Override\n            public ObservableSource<?> apply(List<String> strings) throws Exception {\n                return Observable.fromIterable(strings);\n            }\n        });\n```\n\n3. filter()操作符 \nfilter()操作符根据它的test()方法中，根据自己想过滤的数据加入相应的逻辑判断，返回true则表示数据满足条件，返回false则表示数据需要被过滤。最后过滤出的数据将加入到新的Observable对象中，方便传递给Observer想要的数据形式。 \n举例:\n```\nObservable\n        .just(list)\n        .flatMap(new Function<List<String>, ObservableSource<?>>() {\n            @Override\n            public ObservableSource<?> apply(List<String> strings) throws Exception {\n                return Observable.fromIterable(strings);\n            }\n        }).filter(new Predicate<Object>() {\n            @Override\n            public boolean test(Object s) throws Exception {\n                String newStr = (String) s;\n                if (newStr.charAt(5) - '0' > 5) {\n                    return true;\n                }\n                return false;\n            }\n        }).subscribe(new Consumer<Object>() {\n            @Override\n            public void accept(Object o) throws Exception {\n                System.out.println((String)o);\n            }\n        });\n```\n\n4. take()操作符\n输出最多指定数量的结果.(接收指定数量的结果) \n举例:\n```\nObservable.just(new ArrayList<String>(){\n            {\n                for (int i = 0; i < 8; i++) {\n                    add(\"data\"+i);\n                }\n            }\n        }).flatMap(new Function<List<String>, ObservableSource<?>>() {\n            @Override\n            public ObservableSource<?> apply(List<String> strings) throws Exception {\n                return Observable.fromIterable(strings);\n            }\n        }).take(5).subscribe(new Consumer<Object>() {\n            @Override\n            public void accept(Object s) throws Exception {\n                DemonstrateUtil.showLogResult(s.toString());\n            }\n        });\n```\n\n5. doOnNext()操作符\n允许我们在每次输出一个元素之前做一些额外的事情 \n举例:\n```\nObservable.just(new ArrayList<String>(){\n            {\n                for (int i = 0; i < 6; i++) {\n                    add(\"data\"+i);\n                }\n            }\n        }).flatMap(new Function<List<String>, ObservableSource<?>>() {\n            @Override\n            public ObservableSource<?> apply(List<String> strings) throws Exception {\n                return Observable.fromIterable(strings);\n            }\n        }).take(5).doOnNext(new Consumer<Object>() {\n            @Override\n            public void accept(Object o) throws Exception {\n                DemonstrateUtil.showLogResult(\"额外的准备工作!\");\n            }\n        }).subscribe(new Consumer<Object>() {\n            @Override\n            public void accept(Object s) throws Exception {\n                DemonstrateUtil.showLogResult(s.toString());\n            }\n        });\n```\n\n## Flowable的理解 \nFlowable是一个被观察者，与Subscriber(观察者)配合使用，解决Backpressure问题 \nBackpressure(背压)。所谓背压，即生产者的速度大于消费者的速度带来的问题。\n\n> 什么情况下才会产生Backpressure问题？\n1.如果生产者和消费者在一个线程的情况下，无论生产者的生产速度有多快，每生产一个事件都会通知消费者，等待消费者消费完毕，再生产下一个事件。\n所以在这种情况下，根本不存在Backpressure问题。即同步情况下，Backpressure问题不存在。\n2.如果生产者和消费者不在同一线程的情况下，如果生产者的速度大于消费者的速度，就会产生Backpressure问题。\n即异步情况下，Backpressure问题才会存在。\n\n现象演示说明:\n被观察者是事件的生产者,观察者是事件的消费者.假如生产者无限生成事件,而消费者以很缓慢的节奏来消费事件,会造成事件无限堆积,形成背压,最后造成OOM!\nFlowable悠然而生，专门用来处理这类问题。\nFlowable是为了应对Backpressure而产生的。Flowable是一个被观察者，\n与Subscriber(观察者)配合使用，解决Backpressure问题。\n注意：处理Backpressure的策略仅仅是处理Subscriber接收事件的方式，并不影响Flowable发送事件的方法。\n即使采用了处理Backpressure的策略，Flowable原来以什么样的速度产生事件，现在还是什么样的速度不会变化，主要处理的是Subscriber接收事件的方式。\n\n处理Backpressure问题的策略,或者来解决Backpressure问题\n\n    BackpressureStrategy.ERROR\n    如果缓存池溢出,就会立刻抛出MissingBackpressureException异常\n    request()用来向生产者申请可以消费的事件数量,这样我们便可以根据本身的消费能力进行消费事件.\n    虽然并不限制向request()方法中传入任意数字，但是如果消费者并没有这么多的消费能力，依旧会造成资源浪费，最后产生OOM\n    at java.lang.OutOfMemoryError.<init>(OutOfMemoryError.java:33)\n    在异步调用时，RxJava中有个缓存池，用来缓存消费者处理不了暂时缓存下来的数据，缓存池的默认大小为128，即只能缓存128个事件。\n    无论request()中传入的数字比128大或小，缓存池中在刚开始都会存入128个事件。\n    当然如果本身并没有这么多事件需要发送，则不会存128个事件。\n    应用举例:\n\n\n    BackpressureStrategy.BUFFER\n    是把RxJava中默认的只能存128个事件的缓存池换成一个大的缓存池,支持存更多的数据.\n    消费者通过request()即使传入一个很大的数字，生产者也会生产事件,并将处理不了的事件缓存.\n    注意:\n    这种方式任然比较消耗内存，除非是我们比较了解消费者的消费能力，能够把握具体情况，不会产生OOM。\n    BUFFER要慎用\n\n    BackpressureStrategy.DROP\n    顾名思义,当消费者处理不了事件，就丢弃!\n    例如,当数据源创建了200个事件,先不进行消费临时进行缓存实际缓存128个,我们第一次申请消费了100个,再次申请消费100个,\n    那么实际只消费了128个,而其余的72个被丢弃了!\n\n    BackpressureStrategy.LATEST\n    LATEST与DROP功能基本一致,当消费者处理不了事件，就丢弃!\n    唯一的区别就是LATEST总能使消费者能够接收到生产者产生的最后一个事件。\n    例如,当数据源创建了200个事件,先不进行消费临时进行缓存,我们第一次申请消费了100个,再次申请消费100个,\n    那么实际只消费了129个,而其余的71个被丢弃了,但是第200个(最后一个)会被消费.\n\n\n    BackpressureStrategy.MISSING\n    生产的事件没有进行缓存和丢弃,下游接收到的事件必须进行消费或者处理!\n\n\n\n在RxJava中会经常遇到一种情况就是被观察者发送消息十分迅速以至于观察者不能及时的响应这些消息\n举例:\nObservable.create(new ObservableOnSubscribe<Integer>() {\n        @Override\n        public void subscribe(ObservableEmitter<Integer> e) throws Exception {\n            while (true){\n                e.onNext(1);\n            }\n        }\n    })\n            .subscribeOn(Schedulers.io())\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(new Consumer<Integer>() {\n        @Override\n        public void accept(Integer integer) throws Exception {\n            Thread.sleep(2000);\n            System.out.println(integer);\n        }\n    });\n    被观察者是事件的生产者，观察者是事件的消费者。上述例子中可以看出生产者无限生成事件，而消费者每2秒才能消费一个事件，这会造成事件无限堆积，最后造成OOM。\nFlowable就是由此产生，专门用来处理这类问题","source":"_posts/“rxjava2-0”.md","raw":"---\ntitle: “rxjava2.0”\ndate: 2017-12-21 16:24:02\ntags: android\n---\n#[Rxjava2.0](http://blog.csdn.net/flybasker/article/details/78703295)\n\n## 基础概念\n\nObservable：在观察者模式中称为“被观察者”；\nObserver：观察者模式中的“观察者”，可接收Observable发送的数据；\nsubscribe：订阅，观察者与被观察者，通过Observable的subscribe()方法进行订阅；\nSubscriber：也是一种观察者，在2.0中 它与Observer没什么实质的区别，不同的是 Subscriber要与Flowable(也是一种被观察者)联合使用，该部分 内容是2.0新增的，后续文章再介绍。Obsesrver用于订阅Observable，而Subscriber用于订阅Flowable.\n\n## Rxjava中定义的事件方法\n\nonNext(),普通事件,按照队列依次进行处理.\nonComplete(),事件队列完结时调用该方法\nonError(),事件处理过程中出现异常时，onError()触发，同时队列终止,不再有事件发出.\nonSubscribe(),RxJava 2.0 中新增的，传递参数为Disposable,可用于切断接收事件让Observable (被观察者)开启子线程执行耗操作，完成耗时操作后，触发回调，通知Observer (观察者)进行主线程UI更新\n\n## observable的几种创建方式\n1. just()方式\n使用just( )，将创建一个Observable并自动调用onNext( )发射数据。\n也就是通过just( )方式 直接触发onNext()，just中传递的参数将直接在Observer的onNext()方法中接收到。\n\n2. fromIterable()方式\n使用fromIterable()，遍历集合，发送每个item.多次自动调用onNext()方法，每次传入一个item.\n注意：Collection接口是Iterable接口的子接口，所以所有Collection接口的实现类都可以作为Iterable对象直接传入fromIterable()    方法。\n\n3. defer()方式\n当观察者订阅时,才创建Observable，并且针对每个观察者创建都是一个新的Observable.\n通过Callable中的回调方法call(),决定使用以何种方式来创建这个Observable对象,当订阅后，发送事件.\n\n4. interval( )方式\n创建一个按固定时间间隔发射整数序列的Observable，可用作定时器。按照固定时间间隔来调用onNext()方法。\n\n5. timer( )方式\n通过此种创建一个Observable,它在一个给定的延迟后发射一个特殊的值，即表示延迟指定时间后，调用onNext()方法。\n\n6. range( )方式,range(x,y)\n创建一个发射特定整数序列的Observable，第一个参数x为起始值，第二个y为发送的个数，如果y为0则不发送，y为负数则抛异常。\nrange(1,5)\n上述表示发射1到5的数。即调用5次Next()方法，依次传入1-5数字。\n\n7. repeat( )方式\n创建一个Observable，该Observable的事件可以重复调用。\n\n## ObservableEmitter\nEmitter是发射器的意思,就是用来发出事件的，它可以发出三种类型的事件 \n通过调用onNext(T value),发出next事件 \n通过调用onComplete(),发出complete事件 \n通过调用onError(Throwable error),发出error事件 \n注意事项: \nonComplete和onError唯一并且互斥 \n发送多个onComplete, 第一个onComplete接收到,就不再接收了. \n发送多个onError, 则收到第二个onError事件会导致程序会崩溃. \n不可以随意乱七八糟发射事件，需要满足一定的规则： \n上游可以发送无限个onNext, 下游也可以接收无限个onNext. \n当上游发送了一个onComplete后, 上游onComplete之后的事件将会继续发送, 而下游收到onComplete事件之后将不再继续接收事件. \n上游发送了一个onError后, 上游onError之后的事件将继续发送, 而下游收到onError事件之后将不再继续接收事件. \n上游可以不发送onComplete或onError. \n最为关键的是onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError \n\n## Disposable\n一次性,它理解成两根管道之间的一个机关, 当调用它的dispose()方法时, 它就会将两根管道切断, 从而导致下游收不到事件. \n在RxJava中,用它来切断Observer(观察者)与Observable(被观察者)之间的连接，当调用它的dispose()方法时, 它就会将Observer(观察者)与Observable(被观察者)之间的连接切断, 从而导致Observer(观察者)收不到事件。 \n注意: 调用dispose()并不会导致上游不再继续发送事件, 上游会继续发送剩余的事件 \n\n## 线程调度\n1. Schedulers.immediate(): \n直接在当前线程运行，相当于不指定线程。这是默认的Scheduler。\n\n2. Schedulers.newThread(): \n总是启用新线程，并在新线程执行操作。\n\n3. Schedulers.io(): I/O \n操作（读写文件、读写数据库、网络信息交互等）所使用的Scheduler。行为模式和newThread()差不多，区别在于io()的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下io()比newThread()更有效率。不要把计算工作放在io()中，可以避免创建不必要的线程。\n\n4. Schedulers.computation(): \n计算所使用的Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个Scheduler使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在computation()中，否则 I/O 操作的等待时间会浪费 CPU。\n\n5. AndroidSchedulers.mainThread()，\nAndroid专用线程，指定操作在主线程运行。\n\n如何切换线程呢？RxJava中提供了两个方法：\n    subscribeOn() 和 observeOn() ，\n两者的不同点在于：\n\nsubscribeOn(): 指定subscribe()订阅所发生的线程，或者叫做事件产生的线程。\n\nobserveOn(): 指定Observer所运行在的线程，即onNext()执行的线程。或者叫做事件消费的线程。\n\n## 操作符\n操作符就是用于在Observable和最终的Observer之间，通过转换Observable为其他观察者对象的过程，修改发出的事件,最终将最简洁的数据传递给Observer对象. \n\n1. map()操作符，就是把原来的Observable对象转换成另一个Observable对象，同时将传输的数据进行一些灵活的操作，方便Observer获得想要的数据形式。\n举例:\n```\nObservable<Integer> observable = Observable\n        .just(\"hello\")\n        .map(new Function<String, Integer>() {\n            @Override\n            public Integer apply(String s) throws Exception {\n                return s.length();\n            }\n        });\n```\n\n2. flatMap()操作符 \nflatMap()对于数据的转换比map()更加彻底，如果发送的数据是集合，flatmap()重新生成一个Observable对象，并把数据转换成Observer想 要的数据形式。它可以返回任何它想返回的Observable对象。 \n举例:\n```\nObservable.just(list)\n       .flatMap(new Function<List<String>, ObservableSource<?>>() {\n            @Override\n            public ObservableSource<?> apply(List<String> strings) throws Exception {\n                return Observable.fromIterable(strings);\n            }\n        });\n```\n\n3. filter()操作符 \nfilter()操作符根据它的test()方法中，根据自己想过滤的数据加入相应的逻辑判断，返回true则表示数据满足条件，返回false则表示数据需要被过滤。最后过滤出的数据将加入到新的Observable对象中，方便传递给Observer想要的数据形式。 \n举例:\n```\nObservable\n        .just(list)\n        .flatMap(new Function<List<String>, ObservableSource<?>>() {\n            @Override\n            public ObservableSource<?> apply(List<String> strings) throws Exception {\n                return Observable.fromIterable(strings);\n            }\n        }).filter(new Predicate<Object>() {\n            @Override\n            public boolean test(Object s) throws Exception {\n                String newStr = (String) s;\n                if (newStr.charAt(5) - '0' > 5) {\n                    return true;\n                }\n                return false;\n            }\n        }).subscribe(new Consumer<Object>() {\n            @Override\n            public void accept(Object o) throws Exception {\n                System.out.println((String)o);\n            }\n        });\n```\n\n4. take()操作符\n输出最多指定数量的结果.(接收指定数量的结果) \n举例:\n```\nObservable.just(new ArrayList<String>(){\n            {\n                for (int i = 0; i < 8; i++) {\n                    add(\"data\"+i);\n                }\n            }\n        }).flatMap(new Function<List<String>, ObservableSource<?>>() {\n            @Override\n            public ObservableSource<?> apply(List<String> strings) throws Exception {\n                return Observable.fromIterable(strings);\n            }\n        }).take(5).subscribe(new Consumer<Object>() {\n            @Override\n            public void accept(Object s) throws Exception {\n                DemonstrateUtil.showLogResult(s.toString());\n            }\n        });\n```\n\n5. doOnNext()操作符\n允许我们在每次输出一个元素之前做一些额外的事情 \n举例:\n```\nObservable.just(new ArrayList<String>(){\n            {\n                for (int i = 0; i < 6; i++) {\n                    add(\"data\"+i);\n                }\n            }\n        }).flatMap(new Function<List<String>, ObservableSource<?>>() {\n            @Override\n            public ObservableSource<?> apply(List<String> strings) throws Exception {\n                return Observable.fromIterable(strings);\n            }\n        }).take(5).doOnNext(new Consumer<Object>() {\n            @Override\n            public void accept(Object o) throws Exception {\n                DemonstrateUtil.showLogResult(\"额外的准备工作!\");\n            }\n        }).subscribe(new Consumer<Object>() {\n            @Override\n            public void accept(Object s) throws Exception {\n                DemonstrateUtil.showLogResult(s.toString());\n            }\n        });\n```\n\n## Flowable的理解 \nFlowable是一个被观察者，与Subscriber(观察者)配合使用，解决Backpressure问题 \nBackpressure(背压)。所谓背压，即生产者的速度大于消费者的速度带来的问题。\n\n> 什么情况下才会产生Backpressure问题？\n1.如果生产者和消费者在一个线程的情况下，无论生产者的生产速度有多快，每生产一个事件都会通知消费者，等待消费者消费完毕，再生产下一个事件。\n所以在这种情况下，根本不存在Backpressure问题。即同步情况下，Backpressure问题不存在。\n2.如果生产者和消费者不在同一线程的情况下，如果生产者的速度大于消费者的速度，就会产生Backpressure问题。\n即异步情况下，Backpressure问题才会存在。\n\n现象演示说明:\n被观察者是事件的生产者,观察者是事件的消费者.假如生产者无限生成事件,而消费者以很缓慢的节奏来消费事件,会造成事件无限堆积,形成背压,最后造成OOM!\nFlowable悠然而生，专门用来处理这类问题。\nFlowable是为了应对Backpressure而产生的。Flowable是一个被观察者，\n与Subscriber(观察者)配合使用，解决Backpressure问题。\n注意：处理Backpressure的策略仅仅是处理Subscriber接收事件的方式，并不影响Flowable发送事件的方法。\n即使采用了处理Backpressure的策略，Flowable原来以什么样的速度产生事件，现在还是什么样的速度不会变化，主要处理的是Subscriber接收事件的方式。\n\n处理Backpressure问题的策略,或者来解决Backpressure问题\n\n    BackpressureStrategy.ERROR\n    如果缓存池溢出,就会立刻抛出MissingBackpressureException异常\n    request()用来向生产者申请可以消费的事件数量,这样我们便可以根据本身的消费能力进行消费事件.\n    虽然并不限制向request()方法中传入任意数字，但是如果消费者并没有这么多的消费能力，依旧会造成资源浪费，最后产生OOM\n    at java.lang.OutOfMemoryError.<init>(OutOfMemoryError.java:33)\n    在异步调用时，RxJava中有个缓存池，用来缓存消费者处理不了暂时缓存下来的数据，缓存池的默认大小为128，即只能缓存128个事件。\n    无论request()中传入的数字比128大或小，缓存池中在刚开始都会存入128个事件。\n    当然如果本身并没有这么多事件需要发送，则不会存128个事件。\n    应用举例:\n\n\n    BackpressureStrategy.BUFFER\n    是把RxJava中默认的只能存128个事件的缓存池换成一个大的缓存池,支持存更多的数据.\n    消费者通过request()即使传入一个很大的数字，生产者也会生产事件,并将处理不了的事件缓存.\n    注意:\n    这种方式任然比较消耗内存，除非是我们比较了解消费者的消费能力，能够把握具体情况，不会产生OOM。\n    BUFFER要慎用\n\n    BackpressureStrategy.DROP\n    顾名思义,当消费者处理不了事件，就丢弃!\n    例如,当数据源创建了200个事件,先不进行消费临时进行缓存实际缓存128个,我们第一次申请消费了100个,再次申请消费100个,\n    那么实际只消费了128个,而其余的72个被丢弃了!\n\n    BackpressureStrategy.LATEST\n    LATEST与DROP功能基本一致,当消费者处理不了事件，就丢弃!\n    唯一的区别就是LATEST总能使消费者能够接收到生产者产生的最后一个事件。\n    例如,当数据源创建了200个事件,先不进行消费临时进行缓存,我们第一次申请消费了100个,再次申请消费100个,\n    那么实际只消费了129个,而其余的71个被丢弃了,但是第200个(最后一个)会被消费.\n\n\n    BackpressureStrategy.MISSING\n    生产的事件没有进行缓存和丢弃,下游接收到的事件必须进行消费或者处理!\n\n\n\n在RxJava中会经常遇到一种情况就是被观察者发送消息十分迅速以至于观察者不能及时的响应这些消息\n举例:\nObservable.create(new ObservableOnSubscribe<Integer>() {\n        @Override\n        public void subscribe(ObservableEmitter<Integer> e) throws Exception {\n            while (true){\n                e.onNext(1);\n            }\n        }\n    })\n            .subscribeOn(Schedulers.io())\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(new Consumer<Integer>() {\n        @Override\n        public void accept(Integer integer) throws Exception {\n            Thread.sleep(2000);\n            System.out.println(integer);\n        }\n    });\n    被观察者是事件的生产者，观察者是事件的消费者。上述例子中可以看出生产者无限生成事件，而消费者每2秒才能消费一个事件，这会造成事件无限堆积，最后造成OOM。\nFlowable就是由此产生，专门用来处理这类问题","slug":"“rxjava2-0”","published":1,"updated":"2019-03-12T09:26:33.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltu06006v3a8kkgbsdb0w","content":"<p>#<a href=\"http://blog.csdn.net/flybasker/article/details/78703295\" target=\"_blank\" rel=\"noopener\">Rxjava2.0</a></p>\n<h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><p>Observable：在观察者模式中称为“被观察者”；<br>Observer：观察者模式中的“观察者”，可接收Observable发送的数据；<br>subscribe：订阅，观察者与被观察者，通过Observable的subscribe()方法进行订阅；<br>Subscriber：也是一种观察者，在2.0中 它与Observer没什么实质的区别，不同的是 Subscriber要与Flowable(也是一种被观察者)联合使用，该部分 内容是2.0新增的，后续文章再介绍。Obsesrver用于订阅Observable，而Subscriber用于订阅Flowable.</p>\n<h2 id=\"Rxjava中定义的事件方法\"><a href=\"#Rxjava中定义的事件方法\" class=\"headerlink\" title=\"Rxjava中定义的事件方法\"></a>Rxjava中定义的事件方法</h2><p>onNext(),普通事件,按照队列依次进行处理.<br>onComplete(),事件队列完结时调用该方法<br>onError(),事件处理过程中出现异常时，onError()触发，同时队列终止,不再有事件发出.<br>onSubscribe(),RxJava 2.0 中新增的，传递参数为Disposable,可用于切断接收事件让Observable (被观察者)开启子线程执行耗操作，完成耗时操作后，触发回调，通知Observer (观察者)进行主线程UI更新</p>\n<h2 id=\"observable的几种创建方式\"><a href=\"#observable的几种创建方式\" class=\"headerlink\" title=\"observable的几种创建方式\"></a>observable的几种创建方式</h2><ol>\n<li><p>just()方式<br>使用just( )，将创建一个Observable并自动调用onNext( )发射数据。<br>也就是通过just( )方式 直接触发onNext()，just中传递的参数将直接在Observer的onNext()方法中接收到。</p>\n</li>\n<li><p>fromIterable()方式<br>使用fromIterable()，遍历集合，发送每个item.多次自动调用onNext()方法，每次传入一个item.<br>注意：Collection接口是Iterable接口的子接口，所以所有Collection接口的实现类都可以作为Iterable对象直接传入fromIterable()    方法。</p>\n</li>\n<li><p>defer()方式<br>当观察者订阅时,才创建Observable，并且针对每个观察者创建都是一个新的Observable.<br>通过Callable中的回调方法call(),决定使用以何种方式来创建这个Observable对象,当订阅后，发送事件.</p>\n</li>\n<li><p>interval( )方式<br>创建一个按固定时间间隔发射整数序列的Observable，可用作定时器。按照固定时间间隔来调用onNext()方法。</p>\n</li>\n<li><p>timer( )方式<br>通过此种创建一个Observable,它在一个给定的延迟后发射一个特殊的值，即表示延迟指定时间后，调用onNext()方法。</p>\n</li>\n<li><p>range( )方式,range(x,y)<br>创建一个发射特定整数序列的Observable，第一个参数x为起始值，第二个y为发送的个数，如果y为0则不发送，y为负数则抛异常。<br>range(1,5)<br>上述表示发射1到5的数。即调用5次Next()方法，依次传入1-5数字。</p>\n</li>\n<li><p>repeat( )方式<br>创建一个Observable，该Observable的事件可以重复调用。</p>\n</li>\n</ol>\n<h2 id=\"ObservableEmitter\"><a href=\"#ObservableEmitter\" class=\"headerlink\" title=\"ObservableEmitter\"></a>ObservableEmitter</h2><p>Emitter是发射器的意思,就是用来发出事件的，它可以发出三种类型的事件<br>通过调用onNext(T value),发出next事件<br>通过调用onComplete(),发出complete事件<br>通过调用onError(Throwable error),发出error事件<br>注意事项:<br>onComplete和onError唯一并且互斥<br>发送多个onComplete, 第一个onComplete接收到,就不再接收了.<br>发送多个onError, 则收到第二个onError事件会导致程序会崩溃.<br>不可以随意乱七八糟发射事件，需要满足一定的规则：<br>上游可以发送无限个onNext, 下游也可以接收无限个onNext.<br>当上游发送了一个onComplete后, 上游onComplete之后的事件将会继续发送, 而下游收到onComplete事件之后将不再继续接收事件.<br>上游发送了一个onError后, 上游onError之后的事件将继续发送, 而下游收到onError事件之后将不再继续接收事件.<br>上游可以不发送onComplete或onError.<br>最为关键的是onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError </p>\n<h2 id=\"Disposable\"><a href=\"#Disposable\" class=\"headerlink\" title=\"Disposable\"></a>Disposable</h2><p>一次性,它理解成两根管道之间的一个机关, 当调用它的dispose()方法时, 它就会将两根管道切断, 从而导致下游收不到事件.<br>在RxJava中,用它来切断Observer(观察者)与Observable(被观察者)之间的连接，当调用它的dispose()方法时, 它就会将Observer(观察者)与Observable(被观察者)之间的连接切断, 从而导致Observer(观察者)收不到事件。<br>注意: 调用dispose()并不会导致上游不再继续发送事件, 上游会继续发送剩余的事件 </p>\n<h2 id=\"线程调度\"><a href=\"#线程调度\" class=\"headerlink\" title=\"线程调度\"></a>线程调度</h2><ol>\n<li><p>Schedulers.immediate():<br>直接在当前线程运行，相当于不指定线程。这是默认的Scheduler。</p>\n</li>\n<li><p>Schedulers.newThread():<br>总是启用新线程，并在新线程执行操作。</p>\n</li>\n<li><p>Schedulers.io(): I/O<br>操作（读写文件、读写数据库、网络信息交互等）所使用的Scheduler。行为模式和newThread()差不多，区别在于io()的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下io()比newThread()更有效率。不要把计算工作放在io()中，可以避免创建不必要的线程。</p>\n</li>\n<li><p>Schedulers.computation():<br>计算所使用的Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个Scheduler使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在computation()中，否则 I/O 操作的等待时间会浪费 CPU。</p>\n</li>\n<li><p>AndroidSchedulers.mainThread()，<br>Android专用线程，指定操作在主线程运行。</p>\n</li>\n</ol>\n<p>如何切换线程呢？RxJava中提供了两个方法：<br>    subscribeOn() 和 observeOn() ，<br>两者的不同点在于：</p>\n<p>subscribeOn(): 指定subscribe()订阅所发生的线程，或者叫做事件产生的线程。</p>\n<p>observeOn(): 指定Observer所运行在的线程，即onNext()执行的线程。或者叫做事件消费的线程。</p>\n<h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h2><p>操作符就是用于在Observable和最终的Observer之间，通过转换Observable为其他观察者对象的过程，修改发出的事件,最终将最简洁的数据传递给Observer对象. </p>\n<ol>\n<li><p>map()操作符，就是把原来的Observable对象转换成另一个Observable对象，同时将传输的数据进行一些灵活的操作，方便Observer获得想要的数据形式。<br>举例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable&lt;Integer&gt; observable = Observable</span><br><span class=\"line\">        .just(&quot;hello&quot;)</span><br><span class=\"line\">        .map(new Function&lt;String, Integer&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public Integer apply(String s) throws Exception &#123;</span><br><span class=\"line\">                return s.length();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>flatMap()操作符<br>flatMap()对于数据的转换比map()更加彻底，如果发送的数据是集合，flatmap()重新生成一个Observable对象，并把数据转换成Observer想 要的数据形式。它可以返回任何它想返回的Observable对象。<br>举例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.just(list)</span><br><span class=\"line\">       .flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class=\"line\">                return Observable.fromIterable(strings);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>filter()操作符<br>filter()操作符根据它的test()方法中，根据自己想过滤的数据加入相应的逻辑判断，返回true则表示数据满足条件，返回false则表示数据需要被过滤。最后过滤出的数据将加入到新的Observable对象中，方便传递给Observer想要的数据形式。<br>举例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable</span><br><span class=\"line\">        .just(list)</span><br><span class=\"line\">        .flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class=\"line\">                return Observable.fromIterable(strings);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).filter(new Predicate&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public boolean test(Object s) throws Exception &#123;</span><br><span class=\"line\">                String newStr = (String) s;</span><br><span class=\"line\">                if (newStr.charAt(5) - &apos;0&apos; &gt; 5) &#123;</span><br><span class=\"line\">                    return true;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).subscribe(new Consumer&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(Object o) throws Exception &#123;</span><br><span class=\"line\">                System.out.println((String)o);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>take()操作符<br>输出最多指定数量的结果.(接收指定数量的结果)<br>举例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.just(new ArrayList&lt;String&gt;()&#123;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class=\"line\">                    add(&quot;data&quot;+i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class=\"line\">                return Observable.fromIterable(strings);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).take(5).subscribe(new Consumer&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(Object s) throws Exception &#123;</span><br><span class=\"line\">                DemonstrateUtil.showLogResult(s.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>doOnNext()操作符<br>允许我们在每次输出一个元素之前做一些额外的事情<br>举例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.just(new ArrayList&lt;String&gt;()&#123;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class=\"line\">                    add(&quot;data&quot;+i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class=\"line\">                return Observable.fromIterable(strings);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).take(5).doOnNext(new Consumer&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(Object o) throws Exception &#123;</span><br><span class=\"line\">                DemonstrateUtil.showLogResult(&quot;额外的准备工作!&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).subscribe(new Consumer&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(Object s) throws Exception &#123;</span><br><span class=\"line\">                DemonstrateUtil.showLogResult(s.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"Flowable的理解\"><a href=\"#Flowable的理解\" class=\"headerlink\" title=\"Flowable的理解\"></a>Flowable的理解</h2><p>Flowable是一个被观察者，与Subscriber(观察者)配合使用，解决Backpressure问题<br>Backpressure(背压)。所谓背压，即生产者的速度大于消费者的速度带来的问题。</p>\n<blockquote>\n<p>什么情况下才会产生Backpressure问题？<br>1.如果生产者和消费者在一个线程的情况下，无论生产者的生产速度有多快，每生产一个事件都会通知消费者，等待消费者消费完毕，再生产下一个事件。<br>所以在这种情况下，根本不存在Backpressure问题。即同步情况下，Backpressure问题不存在。<br>2.如果生产者和消费者不在同一线程的情况下，如果生产者的速度大于消费者的速度，就会产生Backpressure问题。<br>即异步情况下，Backpressure问题才会存在。</p>\n</blockquote>\n<p>现象演示说明:<br>被观察者是事件的生产者,观察者是事件的消费者.假如生产者无限生成事件,而消费者以很缓慢的节奏来消费事件,会造成事件无限堆积,形成背压,最后造成OOM!<br>Flowable悠然而生，专门用来处理这类问题。<br>Flowable是为了应对Backpressure而产生的。Flowable是一个被观察者，<br>与Subscriber(观察者)配合使用，解决Backpressure问题。<br>注意：处理Backpressure的策略仅仅是处理Subscriber接收事件的方式，并不影响Flowable发送事件的方法。<br>即使采用了处理Backpressure的策略，Flowable原来以什么样的速度产生事件，现在还是什么样的速度不会变化，主要处理的是Subscriber接收事件的方式。</p>\n<p>处理Backpressure问题的策略,或者来解决Backpressure问题</p>\n<pre><code>BackpressureStrategy.ERROR\n如果缓存池溢出,就会立刻抛出MissingBackpressureException异常\nrequest()用来向生产者申请可以消费的事件数量,这样我们便可以根据本身的消费能力进行消费事件.\n虽然并不限制向request()方法中传入任意数字，但是如果消费者并没有这么多的消费能力，依旧会造成资源浪费，最后产生OOM\nat java.lang.OutOfMemoryError.&lt;init&gt;(OutOfMemoryError.java:33)\n在异步调用时，RxJava中有个缓存池，用来缓存消费者处理不了暂时缓存下来的数据，缓存池的默认大小为128，即只能缓存128个事件。\n无论request()中传入的数字比128大或小，缓存池中在刚开始都会存入128个事件。\n当然如果本身并没有这么多事件需要发送，则不会存128个事件。\n应用举例:\n\n\nBackpressureStrategy.BUFFER\n是把RxJava中默认的只能存128个事件的缓存池换成一个大的缓存池,支持存更多的数据.\n消费者通过request()即使传入一个很大的数字，生产者也会生产事件,并将处理不了的事件缓存.\n注意:\n这种方式任然比较消耗内存，除非是我们比较了解消费者的消费能力，能够把握具体情况，不会产生OOM。\nBUFFER要慎用\n\nBackpressureStrategy.DROP\n顾名思义,当消费者处理不了事件，就丢弃!\n例如,当数据源创建了200个事件,先不进行消费临时进行缓存实际缓存128个,我们第一次申请消费了100个,再次申请消费100个,\n那么实际只消费了128个,而其余的72个被丢弃了!\n\nBackpressureStrategy.LATEST\nLATEST与DROP功能基本一致,当消费者处理不了事件，就丢弃!\n唯一的区别就是LATEST总能使消费者能够接收到生产者产生的最后一个事件。\n例如,当数据源创建了200个事件,先不进行消费临时进行缓存,我们第一次申请消费了100个,再次申请消费100个,\n那么实际只消费了129个,而其余的71个被丢弃了,但是第200个(最后一个)会被消费.\n\n\nBackpressureStrategy.MISSING\n生产的事件没有进行缓存和丢弃,下游接收到的事件必须进行消费或者处理!\n</code></pre><p>在RxJava中会经常遇到一种情况就是被观察者发送消息十分迅速以至于观察者不能及时的响应这些消息<br>举例:<br>Observable.create(new ObservableOnSubscribe<integer>() {<br>        @Override<br>        public void subscribe(ObservableEmitter<integer> e) throws Exception {<br>            while (true){<br>                e.onNext(1);<br>            }<br>        }<br>    })<br>            .subscribeOn(Schedulers.io())<br>            .observeOn(AndroidSchedulers.mainThread())<br>            .subscribe(new Consumer<integer>() {<br>        @Override<br>        public void accept(Integer integer) throws Exception {<br>            Thread.sleep(2000);<br>            System.out.println(integer);<br>        }<br>    });<br>    被观察者是事件的生产者，观察者是事件的消费者。上述例子中可以看出生产者无限生成事件，而消费者每2秒才能消费一个事件，这会造成事件无限堆积，最后造成OOM。<br>Flowable就是由此产生，专门用来处理这类问题</integer></integer></integer></p>\n","site":{"data":{}},"excerpt":"","more":"<p>#<a href=\"http://blog.csdn.net/flybasker/article/details/78703295\" target=\"_blank\" rel=\"noopener\">Rxjava2.0</a></p>\n<h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><p>Observable：在观察者模式中称为“被观察者”；<br>Observer：观察者模式中的“观察者”，可接收Observable发送的数据；<br>subscribe：订阅，观察者与被观察者，通过Observable的subscribe()方法进行订阅；<br>Subscriber：也是一种观察者，在2.0中 它与Observer没什么实质的区别，不同的是 Subscriber要与Flowable(也是一种被观察者)联合使用，该部分 内容是2.0新增的，后续文章再介绍。Obsesrver用于订阅Observable，而Subscriber用于订阅Flowable.</p>\n<h2 id=\"Rxjava中定义的事件方法\"><a href=\"#Rxjava中定义的事件方法\" class=\"headerlink\" title=\"Rxjava中定义的事件方法\"></a>Rxjava中定义的事件方法</h2><p>onNext(),普通事件,按照队列依次进行处理.<br>onComplete(),事件队列完结时调用该方法<br>onError(),事件处理过程中出现异常时，onError()触发，同时队列终止,不再有事件发出.<br>onSubscribe(),RxJava 2.0 中新增的，传递参数为Disposable,可用于切断接收事件让Observable (被观察者)开启子线程执行耗操作，完成耗时操作后，触发回调，通知Observer (观察者)进行主线程UI更新</p>\n<h2 id=\"observable的几种创建方式\"><a href=\"#observable的几种创建方式\" class=\"headerlink\" title=\"observable的几种创建方式\"></a>observable的几种创建方式</h2><ol>\n<li><p>just()方式<br>使用just( )，将创建一个Observable并自动调用onNext( )发射数据。<br>也就是通过just( )方式 直接触发onNext()，just中传递的参数将直接在Observer的onNext()方法中接收到。</p>\n</li>\n<li><p>fromIterable()方式<br>使用fromIterable()，遍历集合，发送每个item.多次自动调用onNext()方法，每次传入一个item.<br>注意：Collection接口是Iterable接口的子接口，所以所有Collection接口的实现类都可以作为Iterable对象直接传入fromIterable()    方法。</p>\n</li>\n<li><p>defer()方式<br>当观察者订阅时,才创建Observable，并且针对每个观察者创建都是一个新的Observable.<br>通过Callable中的回调方法call(),决定使用以何种方式来创建这个Observable对象,当订阅后，发送事件.</p>\n</li>\n<li><p>interval( )方式<br>创建一个按固定时间间隔发射整数序列的Observable，可用作定时器。按照固定时间间隔来调用onNext()方法。</p>\n</li>\n<li><p>timer( )方式<br>通过此种创建一个Observable,它在一个给定的延迟后发射一个特殊的值，即表示延迟指定时间后，调用onNext()方法。</p>\n</li>\n<li><p>range( )方式,range(x,y)<br>创建一个发射特定整数序列的Observable，第一个参数x为起始值，第二个y为发送的个数，如果y为0则不发送，y为负数则抛异常。<br>range(1,5)<br>上述表示发射1到5的数。即调用5次Next()方法，依次传入1-5数字。</p>\n</li>\n<li><p>repeat( )方式<br>创建一个Observable，该Observable的事件可以重复调用。</p>\n</li>\n</ol>\n<h2 id=\"ObservableEmitter\"><a href=\"#ObservableEmitter\" class=\"headerlink\" title=\"ObservableEmitter\"></a>ObservableEmitter</h2><p>Emitter是发射器的意思,就是用来发出事件的，它可以发出三种类型的事件<br>通过调用onNext(T value),发出next事件<br>通过调用onComplete(),发出complete事件<br>通过调用onError(Throwable error),发出error事件<br>注意事项:<br>onComplete和onError唯一并且互斥<br>发送多个onComplete, 第一个onComplete接收到,就不再接收了.<br>发送多个onError, 则收到第二个onError事件会导致程序会崩溃.<br>不可以随意乱七八糟发射事件，需要满足一定的规则：<br>上游可以发送无限个onNext, 下游也可以接收无限个onNext.<br>当上游发送了一个onComplete后, 上游onComplete之后的事件将会继续发送, 而下游收到onComplete事件之后将不再继续接收事件.<br>上游发送了一个onError后, 上游onError之后的事件将继续发送, 而下游收到onError事件之后将不再继续接收事件.<br>上游可以不发送onComplete或onError.<br>最为关键的是onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError </p>\n<h2 id=\"Disposable\"><a href=\"#Disposable\" class=\"headerlink\" title=\"Disposable\"></a>Disposable</h2><p>一次性,它理解成两根管道之间的一个机关, 当调用它的dispose()方法时, 它就会将两根管道切断, 从而导致下游收不到事件.<br>在RxJava中,用它来切断Observer(观察者)与Observable(被观察者)之间的连接，当调用它的dispose()方法时, 它就会将Observer(观察者)与Observable(被观察者)之间的连接切断, 从而导致Observer(观察者)收不到事件。<br>注意: 调用dispose()并不会导致上游不再继续发送事件, 上游会继续发送剩余的事件 </p>\n<h2 id=\"线程调度\"><a href=\"#线程调度\" class=\"headerlink\" title=\"线程调度\"></a>线程调度</h2><ol>\n<li><p>Schedulers.immediate():<br>直接在当前线程运行，相当于不指定线程。这是默认的Scheduler。</p>\n</li>\n<li><p>Schedulers.newThread():<br>总是启用新线程，并在新线程执行操作。</p>\n</li>\n<li><p>Schedulers.io(): I/O<br>操作（读写文件、读写数据库、网络信息交互等）所使用的Scheduler。行为模式和newThread()差不多，区别在于io()的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下io()比newThread()更有效率。不要把计算工作放在io()中，可以避免创建不必要的线程。</p>\n</li>\n<li><p>Schedulers.computation():<br>计算所使用的Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个Scheduler使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在computation()中，否则 I/O 操作的等待时间会浪费 CPU。</p>\n</li>\n<li><p>AndroidSchedulers.mainThread()，<br>Android专用线程，指定操作在主线程运行。</p>\n</li>\n</ol>\n<p>如何切换线程呢？RxJava中提供了两个方法：<br>    subscribeOn() 和 observeOn() ，<br>两者的不同点在于：</p>\n<p>subscribeOn(): 指定subscribe()订阅所发生的线程，或者叫做事件产生的线程。</p>\n<p>observeOn(): 指定Observer所运行在的线程，即onNext()执行的线程。或者叫做事件消费的线程。</p>\n<h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h2><p>操作符就是用于在Observable和最终的Observer之间，通过转换Observable为其他观察者对象的过程，修改发出的事件,最终将最简洁的数据传递给Observer对象. </p>\n<ol>\n<li><p>map()操作符，就是把原来的Observable对象转换成另一个Observable对象，同时将传输的数据进行一些灵活的操作，方便Observer获得想要的数据形式。<br>举例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable&lt;Integer&gt; observable = Observable</span><br><span class=\"line\">        .just(&quot;hello&quot;)</span><br><span class=\"line\">        .map(new Function&lt;String, Integer&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public Integer apply(String s) throws Exception &#123;</span><br><span class=\"line\">                return s.length();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>flatMap()操作符<br>flatMap()对于数据的转换比map()更加彻底，如果发送的数据是集合，flatmap()重新生成一个Observable对象，并把数据转换成Observer想 要的数据形式。它可以返回任何它想返回的Observable对象。<br>举例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.just(list)</span><br><span class=\"line\">       .flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class=\"line\">                return Observable.fromIterable(strings);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>filter()操作符<br>filter()操作符根据它的test()方法中，根据自己想过滤的数据加入相应的逻辑判断，返回true则表示数据满足条件，返回false则表示数据需要被过滤。最后过滤出的数据将加入到新的Observable对象中，方便传递给Observer想要的数据形式。<br>举例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable</span><br><span class=\"line\">        .just(list)</span><br><span class=\"line\">        .flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class=\"line\">                return Observable.fromIterable(strings);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).filter(new Predicate&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public boolean test(Object s) throws Exception &#123;</span><br><span class=\"line\">                String newStr = (String) s;</span><br><span class=\"line\">                if (newStr.charAt(5) - &apos;0&apos; &gt; 5) &#123;</span><br><span class=\"line\">                    return true;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).subscribe(new Consumer&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(Object o) throws Exception &#123;</span><br><span class=\"line\">                System.out.println((String)o);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>take()操作符<br>输出最多指定数量的结果.(接收指定数量的结果)<br>举例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.just(new ArrayList&lt;String&gt;()&#123;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class=\"line\">                    add(&quot;data&quot;+i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class=\"line\">                return Observable.fromIterable(strings);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).take(5).subscribe(new Consumer&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(Object s) throws Exception &#123;</span><br><span class=\"line\">                DemonstrateUtil.showLogResult(s.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>doOnNext()操作符<br>允许我们在每次输出一个元素之前做一些额外的事情<br>举例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.just(new ArrayList&lt;String&gt;()&#123;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class=\"line\">                    add(&quot;data&quot;+i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception &#123;</span><br><span class=\"line\">                return Observable.fromIterable(strings);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).take(5).doOnNext(new Consumer&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(Object o) throws Exception &#123;</span><br><span class=\"line\">                DemonstrateUtil.showLogResult(&quot;额外的准备工作!&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).subscribe(new Consumer&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(Object s) throws Exception &#123;</span><br><span class=\"line\">                DemonstrateUtil.showLogResult(s.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"Flowable的理解\"><a href=\"#Flowable的理解\" class=\"headerlink\" title=\"Flowable的理解\"></a>Flowable的理解</h2><p>Flowable是一个被观察者，与Subscriber(观察者)配合使用，解决Backpressure问题<br>Backpressure(背压)。所谓背压，即生产者的速度大于消费者的速度带来的问题。</p>\n<blockquote>\n<p>什么情况下才会产生Backpressure问题？<br>1.如果生产者和消费者在一个线程的情况下，无论生产者的生产速度有多快，每生产一个事件都会通知消费者，等待消费者消费完毕，再生产下一个事件。<br>所以在这种情况下，根本不存在Backpressure问题。即同步情况下，Backpressure问题不存在。<br>2.如果生产者和消费者不在同一线程的情况下，如果生产者的速度大于消费者的速度，就会产生Backpressure问题。<br>即异步情况下，Backpressure问题才会存在。</p>\n</blockquote>\n<p>现象演示说明:<br>被观察者是事件的生产者,观察者是事件的消费者.假如生产者无限生成事件,而消费者以很缓慢的节奏来消费事件,会造成事件无限堆积,形成背压,最后造成OOM!<br>Flowable悠然而生，专门用来处理这类问题。<br>Flowable是为了应对Backpressure而产生的。Flowable是一个被观察者，<br>与Subscriber(观察者)配合使用，解决Backpressure问题。<br>注意：处理Backpressure的策略仅仅是处理Subscriber接收事件的方式，并不影响Flowable发送事件的方法。<br>即使采用了处理Backpressure的策略，Flowable原来以什么样的速度产生事件，现在还是什么样的速度不会变化，主要处理的是Subscriber接收事件的方式。</p>\n<p>处理Backpressure问题的策略,或者来解决Backpressure问题</p>\n<pre><code>BackpressureStrategy.ERROR\n如果缓存池溢出,就会立刻抛出MissingBackpressureException异常\nrequest()用来向生产者申请可以消费的事件数量,这样我们便可以根据本身的消费能力进行消费事件.\n虽然并不限制向request()方法中传入任意数字，但是如果消费者并没有这么多的消费能力，依旧会造成资源浪费，最后产生OOM\nat java.lang.OutOfMemoryError.&lt;init&gt;(OutOfMemoryError.java:33)\n在异步调用时，RxJava中有个缓存池，用来缓存消费者处理不了暂时缓存下来的数据，缓存池的默认大小为128，即只能缓存128个事件。\n无论request()中传入的数字比128大或小，缓存池中在刚开始都会存入128个事件。\n当然如果本身并没有这么多事件需要发送，则不会存128个事件。\n应用举例:\n\n\nBackpressureStrategy.BUFFER\n是把RxJava中默认的只能存128个事件的缓存池换成一个大的缓存池,支持存更多的数据.\n消费者通过request()即使传入一个很大的数字，生产者也会生产事件,并将处理不了的事件缓存.\n注意:\n这种方式任然比较消耗内存，除非是我们比较了解消费者的消费能力，能够把握具体情况，不会产生OOM。\nBUFFER要慎用\n\nBackpressureStrategy.DROP\n顾名思义,当消费者处理不了事件，就丢弃!\n例如,当数据源创建了200个事件,先不进行消费临时进行缓存实际缓存128个,我们第一次申请消费了100个,再次申请消费100个,\n那么实际只消费了128个,而其余的72个被丢弃了!\n\nBackpressureStrategy.LATEST\nLATEST与DROP功能基本一致,当消费者处理不了事件，就丢弃!\n唯一的区别就是LATEST总能使消费者能够接收到生产者产生的最后一个事件。\n例如,当数据源创建了200个事件,先不进行消费临时进行缓存,我们第一次申请消费了100个,再次申请消费100个,\n那么实际只消费了129个,而其余的71个被丢弃了,但是第200个(最后一个)会被消费.\n\n\nBackpressureStrategy.MISSING\n生产的事件没有进行缓存和丢弃,下游接收到的事件必须进行消费或者处理!\n</code></pre><p>在RxJava中会经常遇到一种情况就是被观察者发送消息十分迅速以至于观察者不能及时的响应这些消息<br>举例:<br>Observable.create(new ObservableOnSubscribe<integer>() {<br>        @Override<br>        public void subscribe(ObservableEmitter<integer> e) throws Exception {<br>            while (true){<br>                e.onNext(1);<br>            }<br>        }<br>    })<br>            .subscribeOn(Schedulers.io())<br>            .observeOn(AndroidSchedulers.mainThread())<br>            .subscribe(new Consumer<integer>() {<br>        @Override<br>        public void accept(Integer integer) throws Exception {<br>            Thread.sleep(2000);<br>            System.out.println(integer);<br>        }<br>    });<br>    被观察者是事件的生产者，观察者是事件的消费者。上述例子中可以看出生产者无限生成事件，而消费者每2秒才能消费一个事件，这会造成事件无限堆积，最后造成OOM。<br>Flowable就是由此产生，专门用来处理这类问题</integer></integer></integer></p>\n"},{"title":"关于WebviewJavaScriptBrige的一些学习","date":"2018-03-20T02:36:19.000Z","_content":"\n项目中用到了js连调的技术，之前有使用过，但是没有全面的了解过，这次做个复习和深入学习。\n\n# js与native交互\n\njs与native交互总共有四种方式\n\n## JavascriptInterface\n\n首先Java代码要实现这么一个类，它的作用是提供给Javascript调用。\n\n```\npublic class JavascriptInterface {\n\n    @JavascriptInterface\n    public void showToast(String toast) {\n        Toast.makeText(MainActivity.this, toast, Toast.LENGTH_SHORT).show();\n    }\n}\n```\n\n然后把这个类添加到WebView的JavascriptInterface中。\n\n```\nwebView.addJavascriptInterface(new JavascriptInterface(), \"javascriptInterface\");\n```\n\n在Javascript代码中就能直接通过“javascriptInterface”直接调用了该Native的类的方法。\n\n```\nfunction showToast(toast) {\n    javascript:javascriptInterface.showToast(toast);\n}\n```\n\n\n但是这个官方提供的解决方案在Android4.2之前存在安全漏洞。在Android4.2之后，加入了@JavascriptInterface才得到解决。所以考虑到兼容低版本的系统，JavascriptInterface并不适合。\n\n## WebViewClient.shouldOverrideUrlLoading()\n\n这个方法的作用是拦截所有WebView的Url跳转。页面可以构造一个特殊格式的Url跳转，shouldOverrideUrlLoading拦截Url后判断其格式，然后Native就能执行自身的逻辑了。\n\n```\npublic class CustomWebViewClient extends WebViewClient {\n\n    @Override\n    public boolean shouldOverrideUrlLoading(WebView view, String url) {\n        if (isJsBridgeUrl(url)) {\n            // JSbridge的处理逻辑\n            return true;\n        }\n        return super.shouldOverrideUrlLoading(view, url);\n    }\n}\n```\n\n## WebChromeClient.onConsoleMessage()\n\n这是Android提供给Javascript调试在Native代码里面打印日志信息的API，同时这也成了其中一种Javascript与Native代码通信的方法。\n\n在Javascript代码中调用console.log('xxx')方法。\n\n```\nconsole.log('log message that is going to native code')\n```\n\n就会在Native代码的WebChromeClient.consoleMessage()中得到回调。\n\nconsoleMessage.message()获得的正是Javascript代码console.log('xxx')的内容.\n\n```\npublic class CustomWebChromeClient extends WebChromeClient {\n\n    @Override\n    public boolean onConsoleMessage(ConsoleMessage consoleMessage) {\n        super.onConsoleMessage(consoleMessage);\n        String msg = consoleMessage.message();//Javascript输入的Log内容\n    }\n}\n```\n\n## WebChromeClient.onJsPrompt()\n\n其实除了WebChromeClient.onJsPrompt()，还有WebChromeClient.onJsAlert()和WebChromeClient.onJsConfirm()。顾名思义，这三个Javascript给Native代码的回调接口的作用分别是提示展示提示信息，展示警告信息和展示确认信息。鉴于，alert和confirm在Javascript的使用率很高，所以JSBridge的解决方案中都倾向于选用onJsPrompt()。\n\nJavascript中调用\n\n```\nwindow.prompt(message, value)\n```\n\nWebChromeClient.onJsPrompt()就会受到回调。\n\nonJsPrompt()方法的message参数的值正是Javascript的方法window.prompt()的message的值。\n\n```\npublic class CustomWebChromeClient extends WebChromeClient {\n\n    @Override\n    public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) {\n        // 处理JS 的调用逻辑\n        result.confirm();\n        return true;\n    }\n}\n```\n\n\n# JsBridge\n\njava 通信js只有这一种方式\n\n- WebView加载html页面\n\nwebView.registerHandler(\"submitFromWeb\",...);这是Java层注册了一个叫\"submitFromWeb\"的接口方法，目的是提供给Javascript来调用。这个\"submitFromWeb\"的接口方法的回调就是BridgeHandler.handler()。\n\nwebView.callHandler(\"functionInJs\", ..., new CallBackFunction());\n这是Java层主动调用Javascript的\"functionInJs\"方法。\n\n\n```\npublic class MainActivity extends Activity implements OnClickListener {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        webView = (BridgeWebView) findViewById(R.id.webView);\n        webView.loadUrl(\"file:///android_asset/demo.html\");\n        webView.registerHandler(\"submitFromWeb\", new BridgeHandler() {\n\n            @Override\n            public void handler(String data, CallBackFunction function) {\n                Log.i(TAG, \"handler = submitFromWeb, data from web = \" + data);\n                function.onCallBack(\"submitFromWeb exe, response data 中文 from Java\");\n            }\n\n        });\n\n        webView.callHandler(\"functionInJs\", new Gson().toJson(user), new CallBackFunction() {\n            @Override\n            public void onCallBack(String data) {\n                \n            }\n        });\n    }\n}\n```\n\n我们一层层深入callHandler()方法的实现。这其中会调用到doSend()方法，这里想解释下callbackId。\n\ncallbackId生成后不仅仅会被传到Javascript，而且会以key-value对的形式和responseCallback配对保存到responseCallbacks这个Map里面。\n\n它的目的，就是为了等Javascript把处理结果回调给Java层后，Java层能根据callbackId找到对应的responseCallback，做后续的回调处理。\n\n```\nprivate void doSend(String handlerName, String data, CallBackFunction responseCallback) {\n        Message m = new Message();\n        if (!TextUtils.isEmpty(data)) {\n            m.setData(data);\n        }\n        if (responseCallback != null) {\n            String callbackStr = String.format(BridgeUtil.CALLBACK_ID_FORMAT, ++uniqueId + (BridgeUtil.UNDERLINE_STR + SystemClock.currentThreadTimeMillis()));\n            responseCallbacks.put(callbackStr, responseCallback);\n            m.setCallbackId(callbackStr);\n        }\n        if (!TextUtils.isEmpty(handlerName)) {\n            m.setHandlerName(handlerName);\n        }\n        queueMessage(m);\n    }\n```\n\n最终可以看到是BridgeWebView.dispatchMessage(Message m)方法调用的是this.loadUrl()，调用了_handleMessageFromNative这个Javascript方法。那这个Javascript的方法是哪里来的呢？\n\n```\nfinal static String JS_HANDLE_MESSAGE_FROM_JAVA = \"javascript:WebViewJavascriptBridge._handleMessageFromNative('%s');\";\n\nvoid dispatchMessage(Message m) {\n        String messageJson = m.toJson();\n        //escape special characters for json string\n        messageJson = messageJson.replaceAll(\"(\\\\\\\\)([^utrn])\", \"\\\\\\\\\\\\\\\\$1$2\");\n        messageJson = messageJson.replaceAll(\"(?<=[^\\\\\\\\])(\\\")\", \"\\\\\\\\\\\"\");\n        String javascriptCommand = String.format(BridgeUtil.JS_HANDLE_MESSAGE_FROM_JAVA, messageJson);\n        if (Thread.currentThread() == Looper.getMainLooper().getThread()) {\n            this.loadUrl(javascriptCommand);\n        }\n    }\n\n```\n\n- 页面加载完成后会加在一段Javascript。\n\n在WebViewClient.onPageFinished()里面的BridgeUtil.webViewLoadLocalJs(view, BridgeWebView.toLoadJs)。正是把保存在assert/WebViewJavascriptBridge.js加载到WebView中。\n\n```\npublic class BridgeWebViewClient extends WebViewClient {\n　　\n    @Override\n    public void onPageFinished(WebView view, String url) {\n        super.onPageFinished(view, url);\n\n        if (BridgeWebView.toLoadJs != null) {\n            BridgeUtil.webViewLoadLocalJs(view, BridgeWebView.toLoadJs);\n        }\n\n        //\n        if (webView.getStartupMessage() != null) {\n            for (Message m : webView.getStartupMessage()) {\n                webView.dispatchMessage(m);\n            }\n            webView.setStartupMessage(null);\n        }\n    }\n}\n```\n\n我们看看WebViewJavascriptBridge.js的代码，就能找到function _handleMessageFromNative()这个Javascript方法了。\n\n- WebViewJavascriptBridge.js\n\n_handleMessageFromNative()方法里面会调用_dispatchMessageFromNative()方法。\n\n当处理来自Java层的主动调用时候会走“直接发送”的else分支。\n\nmessage.callbackId会被取出来，实例化一个responseCallback，而它是用来Javascript处理完成后把结果数据回调给Java层代码的。\n\n接着会根据message.handleName（在这个分析例子中，handleName的值就是\"functionInJs\"）在messageHandlers这个Map去获取handler，最后交给handler去处理。\n\n```\nfunction _dispatchMessageFromNative(messageJSON) {\n    setTimeout(function() {\n        var message = JSON.parse(messageJSON);\n        var responseCallback;\n        //java call finished, now need to call js callback function\n        if (message.responseId) {\n            ...\n        } else {\n            //直接发送\n            if (message.callbackId) {\n                var callbackResponseId = message.callbackId;\n                responseCallback = function(responseData) {\n                    _doSend({\n                        responseId: callbackResponseId,\n                        responseData: responseData\n                    });\n                };\n            }\n\n            var handler = WebViewJavascriptBridge._messageHandler;\n            if (message.handlerName) {\n                handler = messageHandlers[message.handlerName];\n            }\n            //查找指定handler\n            try {\n                handler(message.data, responseCallback);\n            } catch (exception) {\n                if (typeof console != 'undefined') {\n                    console.log(\"WebViewJavascriptBridge: WARNING: javascript handler threw.\", message, exception);\n                }\n            }\n        }\n    });\n}\n```\n\n- 页面注册的\"functionInJs\"方法，提供给Java调用Javascript的。\n\n延续上面的分析，messageHandler是哪里设置的呢。答案就在当初webView.loadUrl(\"file:///android_asset/demo.html\");加载的这个demo.html中。\n\nbridge.registerHandler(\"functionInJs\", ...)这里注册了\"functionInJs\"。\n\n```\n<html>\n    <head>\n    ...\n    </head>\n    <body>\n    ...\n    </body>\n    <script>\n        ...\n\n        connectWebViewJavascriptBridge(function(bridge) {\n            bridge.init(function(message, responseCallback) {\n                console.log('JS got a message', message);\n                var data = {\n                    'Javascript Responds': '测试中文!'\n                };\n                console.log('JS responding with', data);\n                responseCallback(data);\n            });\n\n            bridge.registerHandler(\"functionInJs\", function(data, responseCallback) {\n                document.getElementById(\"show\").innerHTML = (\"data from Java: = \" + data);\n                var responseData = \"Javascript Says Right back aka!\";\n                responseCallback(responseData);\n            });\n        })\n    </script>\n</html>\n\n```\n\n\n- \"functionInJs\"执行完毕把结果回传给Java\n\n\"funciontInJs\"执行完毕后调用的responseCallback正是_dispatchMessageFromNative()实例化的，而它实际会调用_doSend()方法。\n\n_doSend()方法会先把Message推送到sendMessageQueue中。\n\n然后修改messagingIframe.src，这里会出发Java层的WebViewClient.shouldOverrideUrlLoading()的回调。\n\n```\nfunction _doSend(message, responseCallback) {\n    if (responseCallback) {\n        var callbackId = 'cb_' + (uniqueId++) + '_' + new Date().getTime();\n        responseCallbacks[callbackId] = responseCallback;\n        message.callbackId = callbackId;\n    }\n\n    sendMessageQueue.push(message);\n    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE;\n}\n```\n\n 在BridgeWebViewClient.shouldOverrideUrlLoading()里面，会先执行webView.flushMessageQueue()的分支。\n\n```\n@Override\npublic boolean shouldOverrideUrlLoading(WebView view, String url) {\n    try {\n        url = URLDecoder.decode(url, \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    }\n\n    if (url.startsWith(BridgeUtil.YY_RETURN_DATA)) { // 如果是返回数据\n        webView.handlerReturnData(url);\n        return true;\n    } else if (url.startsWith(BridgeUtil.YY_OVERRIDE_SCHEMA)) { //\n        webView.flushMessageQueue();\n        return true;\n    } else {\n        return super.shouldOverrideUrlLoading(view, url);\n    }\n}\n```\n\nwebView.flushMessageQueue()首先去执行Javascript的_flushQueue()方法，并附带着CallBackFunction。\n\nJavascript的_flushQueue()方法会把sendMessageQueue中的所有message都回传给Java层。\n\nCallBackFunction就是把messageQueue解析出来后一个一个Message在for循环中处理，也正是在for循环中，\"functionInJs\"的Java层回调方法被执行了。\n\n```\nvoid flushMessageQueue() {\n    if (Thread.currentThread() == Looper.getMainLooper().getThread()) {\n        loadUrl(BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA, new CallBackFunction() {\n\n            @Override\n            public void onCallBack(String data) {\n                // deserializeMessage\n                List<Message> list = null;\n                try {\n                    list = Message.toArrayList(data);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    return;\n                }\n                if (list == null || list.size() == 0) {\n                    return;\n                }\n                for (int i = 0; i < list.size(); i++) {\n                    ...\n                }\n            }\n        });\n    }\n}\n```\n\n到此，JsBridge的调用流程就分析完毕了。虽然JsBridge使用了MessageQueue后，分析起来有点绕，但原理是不变的。\n\nJavascript调用Java是通过WebViewClient.shouldOverrideUrlLoading()。当然，还有在文章开头介绍另外3种方式。\n\nJava调用Javascript是通过WebView.loadUrl(\"javascript:xxxx\")。\n\n\n\n\n","source":"_posts/关于WebviewJavaScriptBrige的一些学习.md","raw":"---\ntitle: 关于WebviewJavaScriptBrige的一些学习\ndate: 2018-03-20 10:36:19\ntags: android\n---\n\n项目中用到了js连调的技术，之前有使用过，但是没有全面的了解过，这次做个复习和深入学习。\n\n# js与native交互\n\njs与native交互总共有四种方式\n\n## JavascriptInterface\n\n首先Java代码要实现这么一个类，它的作用是提供给Javascript调用。\n\n```\npublic class JavascriptInterface {\n\n    @JavascriptInterface\n    public void showToast(String toast) {\n        Toast.makeText(MainActivity.this, toast, Toast.LENGTH_SHORT).show();\n    }\n}\n```\n\n然后把这个类添加到WebView的JavascriptInterface中。\n\n```\nwebView.addJavascriptInterface(new JavascriptInterface(), \"javascriptInterface\");\n```\n\n在Javascript代码中就能直接通过“javascriptInterface”直接调用了该Native的类的方法。\n\n```\nfunction showToast(toast) {\n    javascript:javascriptInterface.showToast(toast);\n}\n```\n\n\n但是这个官方提供的解决方案在Android4.2之前存在安全漏洞。在Android4.2之后，加入了@JavascriptInterface才得到解决。所以考虑到兼容低版本的系统，JavascriptInterface并不适合。\n\n## WebViewClient.shouldOverrideUrlLoading()\n\n这个方法的作用是拦截所有WebView的Url跳转。页面可以构造一个特殊格式的Url跳转，shouldOverrideUrlLoading拦截Url后判断其格式，然后Native就能执行自身的逻辑了。\n\n```\npublic class CustomWebViewClient extends WebViewClient {\n\n    @Override\n    public boolean shouldOverrideUrlLoading(WebView view, String url) {\n        if (isJsBridgeUrl(url)) {\n            // JSbridge的处理逻辑\n            return true;\n        }\n        return super.shouldOverrideUrlLoading(view, url);\n    }\n}\n```\n\n## WebChromeClient.onConsoleMessage()\n\n这是Android提供给Javascript调试在Native代码里面打印日志信息的API，同时这也成了其中一种Javascript与Native代码通信的方法。\n\n在Javascript代码中调用console.log('xxx')方法。\n\n```\nconsole.log('log message that is going to native code')\n```\n\n就会在Native代码的WebChromeClient.consoleMessage()中得到回调。\n\nconsoleMessage.message()获得的正是Javascript代码console.log('xxx')的内容.\n\n```\npublic class CustomWebChromeClient extends WebChromeClient {\n\n    @Override\n    public boolean onConsoleMessage(ConsoleMessage consoleMessage) {\n        super.onConsoleMessage(consoleMessage);\n        String msg = consoleMessage.message();//Javascript输入的Log内容\n    }\n}\n```\n\n## WebChromeClient.onJsPrompt()\n\n其实除了WebChromeClient.onJsPrompt()，还有WebChromeClient.onJsAlert()和WebChromeClient.onJsConfirm()。顾名思义，这三个Javascript给Native代码的回调接口的作用分别是提示展示提示信息，展示警告信息和展示确认信息。鉴于，alert和confirm在Javascript的使用率很高，所以JSBridge的解决方案中都倾向于选用onJsPrompt()。\n\nJavascript中调用\n\n```\nwindow.prompt(message, value)\n```\n\nWebChromeClient.onJsPrompt()就会受到回调。\n\nonJsPrompt()方法的message参数的值正是Javascript的方法window.prompt()的message的值。\n\n```\npublic class CustomWebChromeClient extends WebChromeClient {\n\n    @Override\n    public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) {\n        // 处理JS 的调用逻辑\n        result.confirm();\n        return true;\n    }\n}\n```\n\n\n# JsBridge\n\njava 通信js只有这一种方式\n\n- WebView加载html页面\n\nwebView.registerHandler(\"submitFromWeb\",...);这是Java层注册了一个叫\"submitFromWeb\"的接口方法，目的是提供给Javascript来调用。这个\"submitFromWeb\"的接口方法的回调就是BridgeHandler.handler()。\n\nwebView.callHandler(\"functionInJs\", ..., new CallBackFunction());\n这是Java层主动调用Javascript的\"functionInJs\"方法。\n\n\n```\npublic class MainActivity extends Activity implements OnClickListener {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        webView = (BridgeWebView) findViewById(R.id.webView);\n        webView.loadUrl(\"file:///android_asset/demo.html\");\n        webView.registerHandler(\"submitFromWeb\", new BridgeHandler() {\n\n            @Override\n            public void handler(String data, CallBackFunction function) {\n                Log.i(TAG, \"handler = submitFromWeb, data from web = \" + data);\n                function.onCallBack(\"submitFromWeb exe, response data 中文 from Java\");\n            }\n\n        });\n\n        webView.callHandler(\"functionInJs\", new Gson().toJson(user), new CallBackFunction() {\n            @Override\n            public void onCallBack(String data) {\n                \n            }\n        });\n    }\n}\n```\n\n我们一层层深入callHandler()方法的实现。这其中会调用到doSend()方法，这里想解释下callbackId。\n\ncallbackId生成后不仅仅会被传到Javascript，而且会以key-value对的形式和responseCallback配对保存到responseCallbacks这个Map里面。\n\n它的目的，就是为了等Javascript把处理结果回调给Java层后，Java层能根据callbackId找到对应的responseCallback，做后续的回调处理。\n\n```\nprivate void doSend(String handlerName, String data, CallBackFunction responseCallback) {\n        Message m = new Message();\n        if (!TextUtils.isEmpty(data)) {\n            m.setData(data);\n        }\n        if (responseCallback != null) {\n            String callbackStr = String.format(BridgeUtil.CALLBACK_ID_FORMAT, ++uniqueId + (BridgeUtil.UNDERLINE_STR + SystemClock.currentThreadTimeMillis()));\n            responseCallbacks.put(callbackStr, responseCallback);\n            m.setCallbackId(callbackStr);\n        }\n        if (!TextUtils.isEmpty(handlerName)) {\n            m.setHandlerName(handlerName);\n        }\n        queueMessage(m);\n    }\n```\n\n最终可以看到是BridgeWebView.dispatchMessage(Message m)方法调用的是this.loadUrl()，调用了_handleMessageFromNative这个Javascript方法。那这个Javascript的方法是哪里来的呢？\n\n```\nfinal static String JS_HANDLE_MESSAGE_FROM_JAVA = \"javascript:WebViewJavascriptBridge._handleMessageFromNative('%s');\";\n\nvoid dispatchMessage(Message m) {\n        String messageJson = m.toJson();\n        //escape special characters for json string\n        messageJson = messageJson.replaceAll(\"(\\\\\\\\)([^utrn])\", \"\\\\\\\\\\\\\\\\$1$2\");\n        messageJson = messageJson.replaceAll(\"(?<=[^\\\\\\\\])(\\\")\", \"\\\\\\\\\\\"\");\n        String javascriptCommand = String.format(BridgeUtil.JS_HANDLE_MESSAGE_FROM_JAVA, messageJson);\n        if (Thread.currentThread() == Looper.getMainLooper().getThread()) {\n            this.loadUrl(javascriptCommand);\n        }\n    }\n\n```\n\n- 页面加载完成后会加在一段Javascript。\n\n在WebViewClient.onPageFinished()里面的BridgeUtil.webViewLoadLocalJs(view, BridgeWebView.toLoadJs)。正是把保存在assert/WebViewJavascriptBridge.js加载到WebView中。\n\n```\npublic class BridgeWebViewClient extends WebViewClient {\n　　\n    @Override\n    public void onPageFinished(WebView view, String url) {\n        super.onPageFinished(view, url);\n\n        if (BridgeWebView.toLoadJs != null) {\n            BridgeUtil.webViewLoadLocalJs(view, BridgeWebView.toLoadJs);\n        }\n\n        //\n        if (webView.getStartupMessage() != null) {\n            for (Message m : webView.getStartupMessage()) {\n                webView.dispatchMessage(m);\n            }\n            webView.setStartupMessage(null);\n        }\n    }\n}\n```\n\n我们看看WebViewJavascriptBridge.js的代码，就能找到function _handleMessageFromNative()这个Javascript方法了。\n\n- WebViewJavascriptBridge.js\n\n_handleMessageFromNative()方法里面会调用_dispatchMessageFromNative()方法。\n\n当处理来自Java层的主动调用时候会走“直接发送”的else分支。\n\nmessage.callbackId会被取出来，实例化一个responseCallback，而它是用来Javascript处理完成后把结果数据回调给Java层代码的。\n\n接着会根据message.handleName（在这个分析例子中，handleName的值就是\"functionInJs\"）在messageHandlers这个Map去获取handler，最后交给handler去处理。\n\n```\nfunction _dispatchMessageFromNative(messageJSON) {\n    setTimeout(function() {\n        var message = JSON.parse(messageJSON);\n        var responseCallback;\n        //java call finished, now need to call js callback function\n        if (message.responseId) {\n            ...\n        } else {\n            //直接发送\n            if (message.callbackId) {\n                var callbackResponseId = message.callbackId;\n                responseCallback = function(responseData) {\n                    _doSend({\n                        responseId: callbackResponseId,\n                        responseData: responseData\n                    });\n                };\n            }\n\n            var handler = WebViewJavascriptBridge._messageHandler;\n            if (message.handlerName) {\n                handler = messageHandlers[message.handlerName];\n            }\n            //查找指定handler\n            try {\n                handler(message.data, responseCallback);\n            } catch (exception) {\n                if (typeof console != 'undefined') {\n                    console.log(\"WebViewJavascriptBridge: WARNING: javascript handler threw.\", message, exception);\n                }\n            }\n        }\n    });\n}\n```\n\n- 页面注册的\"functionInJs\"方法，提供给Java调用Javascript的。\n\n延续上面的分析，messageHandler是哪里设置的呢。答案就在当初webView.loadUrl(\"file:///android_asset/demo.html\");加载的这个demo.html中。\n\nbridge.registerHandler(\"functionInJs\", ...)这里注册了\"functionInJs\"。\n\n```\n<html>\n    <head>\n    ...\n    </head>\n    <body>\n    ...\n    </body>\n    <script>\n        ...\n\n        connectWebViewJavascriptBridge(function(bridge) {\n            bridge.init(function(message, responseCallback) {\n                console.log('JS got a message', message);\n                var data = {\n                    'Javascript Responds': '测试中文!'\n                };\n                console.log('JS responding with', data);\n                responseCallback(data);\n            });\n\n            bridge.registerHandler(\"functionInJs\", function(data, responseCallback) {\n                document.getElementById(\"show\").innerHTML = (\"data from Java: = \" + data);\n                var responseData = \"Javascript Says Right back aka!\";\n                responseCallback(responseData);\n            });\n        })\n    </script>\n</html>\n\n```\n\n\n- \"functionInJs\"执行完毕把结果回传给Java\n\n\"funciontInJs\"执行完毕后调用的responseCallback正是_dispatchMessageFromNative()实例化的，而它实际会调用_doSend()方法。\n\n_doSend()方法会先把Message推送到sendMessageQueue中。\n\n然后修改messagingIframe.src，这里会出发Java层的WebViewClient.shouldOverrideUrlLoading()的回调。\n\n```\nfunction _doSend(message, responseCallback) {\n    if (responseCallback) {\n        var callbackId = 'cb_' + (uniqueId++) + '_' + new Date().getTime();\n        responseCallbacks[callbackId] = responseCallback;\n        message.callbackId = callbackId;\n    }\n\n    sendMessageQueue.push(message);\n    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE;\n}\n```\n\n 在BridgeWebViewClient.shouldOverrideUrlLoading()里面，会先执行webView.flushMessageQueue()的分支。\n\n```\n@Override\npublic boolean shouldOverrideUrlLoading(WebView view, String url) {\n    try {\n        url = URLDecoder.decode(url, \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    }\n\n    if (url.startsWith(BridgeUtil.YY_RETURN_DATA)) { // 如果是返回数据\n        webView.handlerReturnData(url);\n        return true;\n    } else if (url.startsWith(BridgeUtil.YY_OVERRIDE_SCHEMA)) { //\n        webView.flushMessageQueue();\n        return true;\n    } else {\n        return super.shouldOverrideUrlLoading(view, url);\n    }\n}\n```\n\nwebView.flushMessageQueue()首先去执行Javascript的_flushQueue()方法，并附带着CallBackFunction。\n\nJavascript的_flushQueue()方法会把sendMessageQueue中的所有message都回传给Java层。\n\nCallBackFunction就是把messageQueue解析出来后一个一个Message在for循环中处理，也正是在for循环中，\"functionInJs\"的Java层回调方法被执行了。\n\n```\nvoid flushMessageQueue() {\n    if (Thread.currentThread() == Looper.getMainLooper().getThread()) {\n        loadUrl(BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA, new CallBackFunction() {\n\n            @Override\n            public void onCallBack(String data) {\n                // deserializeMessage\n                List<Message> list = null;\n                try {\n                    list = Message.toArrayList(data);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    return;\n                }\n                if (list == null || list.size() == 0) {\n                    return;\n                }\n                for (int i = 0; i < list.size(); i++) {\n                    ...\n                }\n            }\n        });\n    }\n}\n```\n\n到此，JsBridge的调用流程就分析完毕了。虽然JsBridge使用了MessageQueue后，分析起来有点绕，但原理是不变的。\n\nJavascript调用Java是通过WebViewClient.shouldOverrideUrlLoading()。当然，还有在文章开头介绍另外3种方式。\n\nJava调用Javascript是通过WebView.loadUrl(\"javascript:xxxx\")。\n\n\n\n\n","slug":"关于WebviewJavaScriptBrige的一些学习","published":1,"updated":"2019-03-12T09:26:33.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltu07006y3a8kbkzedqh9","content":"<p>项目中用到了js连调的技术，之前有使用过，但是没有全面的了解过，这次做个复习和深入学习。</p>\n<h1 id=\"js与native交互\"><a href=\"#js与native交互\" class=\"headerlink\" title=\"js与native交互\"></a>js与native交互</h1><p>js与native交互总共有四种方式</p>\n<h2 id=\"JavascriptInterface\"><a href=\"#JavascriptInterface\" class=\"headerlink\" title=\"JavascriptInterface\"></a>JavascriptInterface</h2><p>首先Java代码要实现这么一个类，它的作用是提供给Javascript调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class JavascriptInterface &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @JavascriptInterface</span><br><span class=\"line\">    public void showToast(String toast) &#123;</span><br><span class=\"line\">        Toast.makeText(MainActivity.this, toast, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后把这个类添加到WebView的JavascriptInterface中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webView.addJavascriptInterface(new JavascriptInterface(), &quot;javascriptInterface&quot;);</span><br></pre></td></tr></table></figure>\n<p>在Javascript代码中就能直接通过“javascriptInterface”直接调用了该Native的类的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function showToast(toast) &#123;</span><br><span class=\"line\">    javascript:javascriptInterface.showToast(toast);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是这个官方提供的解决方案在Android4.2之前存在安全漏洞。在Android4.2之后，加入了@JavascriptInterface才得到解决。所以考虑到兼容低版本的系统，JavascriptInterface并不适合。</p>\n<h2 id=\"WebViewClient-shouldOverrideUrlLoading\"><a href=\"#WebViewClient-shouldOverrideUrlLoading\" class=\"headerlink\" title=\"WebViewClient.shouldOverrideUrlLoading()\"></a>WebViewClient.shouldOverrideUrlLoading()</h2><p>这个方法的作用是拦截所有WebView的Url跳转。页面可以构造一个特殊格式的Url跳转，shouldOverrideUrlLoading拦截Url后判断其格式，然后Native就能执行自身的逻辑了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CustomWebViewClient extends WebViewClient &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</span><br><span class=\"line\">        if (isJsBridgeUrl(url)) &#123;</span><br><span class=\"line\">            // JSbridge的处理逻辑</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return super.shouldOverrideUrlLoading(view, url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"WebChromeClient-onConsoleMessage\"><a href=\"#WebChromeClient-onConsoleMessage\" class=\"headerlink\" title=\"WebChromeClient.onConsoleMessage()\"></a>WebChromeClient.onConsoleMessage()</h2><p>这是Android提供给Javascript调试在Native代码里面打印日志信息的API，同时这也成了其中一种Javascript与Native代码通信的方法。</p>\n<p>在Javascript代码中调用console.log(‘xxx’)方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;log message that is going to native code&apos;)</span><br></pre></td></tr></table></figure>\n<p>就会在Native代码的WebChromeClient.consoleMessage()中得到回调。</p>\n<p>consoleMessage.message()获得的正是Javascript代码console.log(‘xxx’)的内容.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CustomWebChromeClient extends WebChromeClient &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onConsoleMessage(ConsoleMessage consoleMessage) &#123;</span><br><span class=\"line\">        super.onConsoleMessage(consoleMessage);</span><br><span class=\"line\">        String msg = consoleMessage.message();//Javascript输入的Log内容</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"WebChromeClient-onJsPrompt\"><a href=\"#WebChromeClient-onJsPrompt\" class=\"headerlink\" title=\"WebChromeClient.onJsPrompt()\"></a>WebChromeClient.onJsPrompt()</h2><p>其实除了WebChromeClient.onJsPrompt()，还有WebChromeClient.onJsAlert()和WebChromeClient.onJsConfirm()。顾名思义，这三个Javascript给Native代码的回调接口的作用分别是提示展示提示信息，展示警告信息和展示确认信息。鉴于，alert和confirm在Javascript的使用率很高，所以JSBridge的解决方案中都倾向于选用onJsPrompt()。</p>\n<p>Javascript中调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.prompt(message, value)</span><br></pre></td></tr></table></figure>\n<p>WebChromeClient.onJsPrompt()就会受到回调。</p>\n<p>onJsPrompt()方法的message参数的值正是Javascript的方法window.prompt()的message的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CustomWebChromeClient extends WebChromeClient &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123;</span><br><span class=\"line\">        // 处理JS 的调用逻辑</span><br><span class=\"line\">        result.confirm();</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"JsBridge\"><a href=\"#JsBridge\" class=\"headerlink\" title=\"JsBridge\"></a>JsBridge</h1><p>java 通信js只有这一种方式</p>\n<ul>\n<li>WebView加载html页面</li>\n</ul>\n<p>webView.registerHandler(“submitFromWeb”,…);这是Java层注册了一个叫”submitFromWeb”的接口方法，目的是提供给Javascript来调用。这个”submitFromWeb”的接口方法的回调就是BridgeHandler.handler()。</p>\n<p>webView.callHandler(“functionInJs”, …, new CallBackFunction());<br>这是Java层主动调用Javascript的”functionInJs”方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MainActivity extends Activity implements OnClickListener &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        webView = (BridgeWebView) findViewById(R.id.webView);</span><br><span class=\"line\">        webView.loadUrl(&quot;file:///android_asset/demo.html&quot;);</span><br><span class=\"line\">        webView.registerHandler(&quot;submitFromWeb&quot;, new BridgeHandler() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void handler(String data, CallBackFunction function) &#123;</span><br><span class=\"line\">                Log.i(TAG, &quot;handler = submitFromWeb, data from web = &quot; + data);</span><br><span class=\"line\">                function.onCallBack(&quot;submitFromWeb exe, response data 中文 from Java&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        webView.callHandler(&quot;functionInJs&quot;, new Gson().toJson(user), new CallBackFunction() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onCallBack(String data) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们一层层深入callHandler()方法的实现。这其中会调用到doSend()方法，这里想解释下callbackId。</p>\n<p>callbackId生成后不仅仅会被传到Javascript，而且会以key-value对的形式和responseCallback配对保存到responseCallbacks这个Map里面。</p>\n<p>它的目的，就是为了等Javascript把处理结果回调给Java层后，Java层能根据callbackId找到对应的responseCallback，做后续的回调处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void doSend(String handlerName, String data, CallBackFunction responseCallback) &#123;</span><br><span class=\"line\">        Message m = new Message();</span><br><span class=\"line\">        if (!TextUtils.isEmpty(data)) &#123;</span><br><span class=\"line\">            m.setData(data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (responseCallback != null) &#123;</span><br><span class=\"line\">            String callbackStr = String.format(BridgeUtil.CALLBACK_ID_FORMAT, ++uniqueId + (BridgeUtil.UNDERLINE_STR + SystemClock.currentThreadTimeMillis()));</span><br><span class=\"line\">            responseCallbacks.put(callbackStr, responseCallback);</span><br><span class=\"line\">            m.setCallbackId(callbackStr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (!TextUtils.isEmpty(handlerName)) &#123;</span><br><span class=\"line\">            m.setHandlerName(handlerName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        queueMessage(m);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>最终可以看到是BridgeWebView.dispatchMessage(Message m)方法调用的是this.loadUrl()，调用了_handleMessageFromNative这个Javascript方法。那这个Javascript的方法是哪里来的呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final static String JS_HANDLE_MESSAGE_FROM_JAVA = &quot;javascript:WebViewJavascriptBridge._handleMessageFromNative(&apos;%s&apos;);&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">void dispatchMessage(Message m) &#123;</span><br><span class=\"line\">        String messageJson = m.toJson();</span><br><span class=\"line\">        //escape special characters for json string</span><br><span class=\"line\">        messageJson = messageJson.replaceAll(&quot;(\\\\\\\\)([^utrn])&quot;, &quot;\\\\\\\\\\\\\\\\$1$2&quot;);</span><br><span class=\"line\">        messageJson = messageJson.replaceAll(&quot;(?&lt;=[^\\\\\\\\])(\\&quot;)&quot;, &quot;\\\\\\\\\\&quot;&quot;);</span><br><span class=\"line\">        String javascriptCommand = String.format(BridgeUtil.JS_HANDLE_MESSAGE_FROM_JAVA, messageJson);</span><br><span class=\"line\">        if (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123;</span><br><span class=\"line\">            this.loadUrl(javascriptCommand);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>页面加载完成后会加在一段Javascript。</li>\n</ul>\n<p>在WebViewClient.onPageFinished()里面的BridgeUtil.webViewLoadLocalJs(view, BridgeWebView.toLoadJs)。正是把保存在assert/WebViewJavascriptBridge.js加载到WebView中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BridgeWebViewClient extends WebViewClient &#123;</span><br><span class=\"line\">　　</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onPageFinished(WebView view, String url) &#123;</span><br><span class=\"line\">        super.onPageFinished(view, url);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (BridgeWebView.toLoadJs != null) &#123;</span><br><span class=\"line\">            BridgeUtil.webViewLoadLocalJs(view, BridgeWebView.toLoadJs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //</span><br><span class=\"line\">        if (webView.getStartupMessage() != null) &#123;</span><br><span class=\"line\">            for (Message m : webView.getStartupMessage()) &#123;</span><br><span class=\"line\">                webView.dispatchMessage(m);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            webView.setStartupMessage(null);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看看WebViewJavascriptBridge.js的代码，就能找到function _handleMessageFromNative()这个Javascript方法了。</p>\n<ul>\n<li>WebViewJavascriptBridge.js</li>\n</ul>\n<p>_handleMessageFromNative()方法里面会调用_dispatchMessageFromNative()方法。</p>\n<p>当处理来自Java层的主动调用时候会走“直接发送”的else分支。</p>\n<p>message.callbackId会被取出来，实例化一个responseCallback，而它是用来Javascript处理完成后把结果数据回调给Java层代码的。</p>\n<p>接着会根据message.handleName（在这个分析例子中，handleName的值就是”functionInJs”）在messageHandlers这个Map去获取handler，最后交给handler去处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function _dispatchMessageFromNative(messageJSON) &#123;</span><br><span class=\"line\">    setTimeout(function() &#123;</span><br><span class=\"line\">        var message = JSON.parse(messageJSON);</span><br><span class=\"line\">        var responseCallback;</span><br><span class=\"line\">        //java call finished, now need to call js callback function</span><br><span class=\"line\">        if (message.responseId) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            //直接发送</span><br><span class=\"line\">            if (message.callbackId) &#123;</span><br><span class=\"line\">                var callbackResponseId = message.callbackId;</span><br><span class=\"line\">                responseCallback = function(responseData) &#123;</span><br><span class=\"line\">                    _doSend(&#123;</span><br><span class=\"line\">                        responseId: callbackResponseId,</span><br><span class=\"line\">                        responseData: responseData</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            var handler = WebViewJavascriptBridge._messageHandler;</span><br><span class=\"line\">            if (message.handlerName) &#123;</span><br><span class=\"line\">                handler = messageHandlers[message.handlerName];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //查找指定handler</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                handler(message.data, responseCallback);</span><br><span class=\"line\">            &#125; catch (exception) &#123;</span><br><span class=\"line\">                if (typeof console != &apos;undefined&apos;) &#123;</span><br><span class=\"line\">                    console.log(&quot;WebViewJavascriptBridge: WARNING: javascript handler threw.&quot;, message, exception);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>页面注册的”functionInJs”方法，提供给Java调用Javascript的。</li>\n</ul>\n<p>延续上面的分析，messageHandler是哪里设置的呢。答案就在当初webView.loadUrl(“file:///android_asset/demo.html”);加载的这个demo.html中。</p>\n<p>bridge.registerHandler(“functionInJs”, …)这里注册了”functionInJs”。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">    &lt;head&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &lt;/head&gt;</span><br><span class=\"line\">    &lt;body&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &lt;/body&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        connectWebViewJavascriptBridge(function(bridge) &#123;</span><br><span class=\"line\">            bridge.init(function(message, responseCallback) &#123;</span><br><span class=\"line\">                console.log(&apos;JS got a message&apos;, message);</span><br><span class=\"line\">                var data = &#123;</span><br><span class=\"line\">                    &apos;Javascript Responds&apos;: &apos;测试中文!&apos;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">                console.log(&apos;JS responding with&apos;, data);</span><br><span class=\"line\">                responseCallback(data);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            bridge.registerHandler(&quot;functionInJs&quot;, function(data, responseCallback) &#123;</span><br><span class=\"line\">                document.getElementById(&quot;show&quot;).innerHTML = (&quot;data from Java: = &quot; + data);</span><br><span class=\"line\">                var responseData = &quot;Javascript Says Right back aka!&quot;;</span><br><span class=\"line\">                responseCallback(responseData);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>“functionInJs”执行完毕把结果回传给Java</li>\n</ul>\n<p>“funciontInJs”执行完毕后调用的responseCallback正是_dispatchMessageFromNative()实例化的，而它实际会调用_doSend()方法。</p>\n<p>_doSend()方法会先把Message推送到sendMessageQueue中。</p>\n<p>然后修改messagingIframe.src，这里会出发Java层的WebViewClient.shouldOverrideUrlLoading()的回调。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function _doSend(message, responseCallback) &#123;</span><br><span class=\"line\">    if (responseCallback) &#123;</span><br><span class=\"line\">        var callbackId = &apos;cb_&apos; + (uniqueId++) + &apos;_&apos; + new Date().getTime();</span><br><span class=\"line\">        responseCallbacks[callbackId] = responseCallback;</span><br><span class=\"line\">        message.callbackId = callbackId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    sendMessageQueue.push(message);</span><br><span class=\"line\">    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + &apos;://&apos; + QUEUE_HAS_MESSAGE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 在BridgeWebViewClient.shouldOverrideUrlLoading()里面，会先执行webView.flushMessageQueue()的分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        url = URLDecoder.decode(url, &quot;UTF-8&quot;);</span><br><span class=\"line\">    &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (url.startsWith(BridgeUtil.YY_RETURN_DATA)) &#123; // 如果是返回数据</span><br><span class=\"line\">        webView.handlerReturnData(url);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125; else if (url.startsWith(BridgeUtil.YY_OVERRIDE_SCHEMA)) &#123; //</span><br><span class=\"line\">        webView.flushMessageQueue();</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return super.shouldOverrideUrlLoading(view, url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>webView.flushMessageQueue()首先去执行Javascript的_flushQueue()方法，并附带着CallBackFunction。</p>\n<p>Javascript的_flushQueue()方法会把sendMessageQueue中的所有message都回传给Java层。</p>\n<p>CallBackFunction就是把messageQueue解析出来后一个一个Message在for循环中处理，也正是在for循环中，”functionInJs”的Java层回调方法被执行了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void flushMessageQueue() &#123;</span><br><span class=\"line\">    if (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123;</span><br><span class=\"line\">        loadUrl(BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA, new CallBackFunction() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onCallBack(String data) &#123;</span><br><span class=\"line\">                // deserializeMessage</span><br><span class=\"line\">                List&lt;Message&gt; list = null;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    list = Message.toArrayList(data);</span><br><span class=\"line\">                &#125; catch (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (list == null || list.size() == 0) &#123;</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">                    ...</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到此，JsBridge的调用流程就分析完毕了。虽然JsBridge使用了MessageQueue后，分析起来有点绕，但原理是不变的。</p>\n<p>Javascript调用Java是通过WebViewClient.shouldOverrideUrlLoading()。当然，还有在文章开头介绍另外3种方式。</p>\n<p>Java调用Javascript是通过WebView.loadUrl(“javascript:xxxx”)。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>项目中用到了js连调的技术，之前有使用过，但是没有全面的了解过，这次做个复习和深入学习。</p>\n<h1 id=\"js与native交互\"><a href=\"#js与native交互\" class=\"headerlink\" title=\"js与native交互\"></a>js与native交互</h1><p>js与native交互总共有四种方式</p>\n<h2 id=\"JavascriptInterface\"><a href=\"#JavascriptInterface\" class=\"headerlink\" title=\"JavascriptInterface\"></a>JavascriptInterface</h2><p>首先Java代码要实现这么一个类，它的作用是提供给Javascript调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class JavascriptInterface &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @JavascriptInterface</span><br><span class=\"line\">    public void showToast(String toast) &#123;</span><br><span class=\"line\">        Toast.makeText(MainActivity.this, toast, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后把这个类添加到WebView的JavascriptInterface中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webView.addJavascriptInterface(new JavascriptInterface(), &quot;javascriptInterface&quot;);</span><br></pre></td></tr></table></figure>\n<p>在Javascript代码中就能直接通过“javascriptInterface”直接调用了该Native的类的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function showToast(toast) &#123;</span><br><span class=\"line\">    javascript:javascriptInterface.showToast(toast);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是这个官方提供的解决方案在Android4.2之前存在安全漏洞。在Android4.2之后，加入了@JavascriptInterface才得到解决。所以考虑到兼容低版本的系统，JavascriptInterface并不适合。</p>\n<h2 id=\"WebViewClient-shouldOverrideUrlLoading\"><a href=\"#WebViewClient-shouldOverrideUrlLoading\" class=\"headerlink\" title=\"WebViewClient.shouldOverrideUrlLoading()\"></a>WebViewClient.shouldOverrideUrlLoading()</h2><p>这个方法的作用是拦截所有WebView的Url跳转。页面可以构造一个特殊格式的Url跳转，shouldOverrideUrlLoading拦截Url后判断其格式，然后Native就能执行自身的逻辑了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CustomWebViewClient extends WebViewClient &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</span><br><span class=\"line\">        if (isJsBridgeUrl(url)) &#123;</span><br><span class=\"line\">            // JSbridge的处理逻辑</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return super.shouldOverrideUrlLoading(view, url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"WebChromeClient-onConsoleMessage\"><a href=\"#WebChromeClient-onConsoleMessage\" class=\"headerlink\" title=\"WebChromeClient.onConsoleMessage()\"></a>WebChromeClient.onConsoleMessage()</h2><p>这是Android提供给Javascript调试在Native代码里面打印日志信息的API，同时这也成了其中一种Javascript与Native代码通信的方法。</p>\n<p>在Javascript代码中调用console.log(‘xxx’)方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;log message that is going to native code&apos;)</span><br></pre></td></tr></table></figure>\n<p>就会在Native代码的WebChromeClient.consoleMessage()中得到回调。</p>\n<p>consoleMessage.message()获得的正是Javascript代码console.log(‘xxx’)的内容.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CustomWebChromeClient extends WebChromeClient &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onConsoleMessage(ConsoleMessage consoleMessage) &#123;</span><br><span class=\"line\">        super.onConsoleMessage(consoleMessage);</span><br><span class=\"line\">        String msg = consoleMessage.message();//Javascript输入的Log内容</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"WebChromeClient-onJsPrompt\"><a href=\"#WebChromeClient-onJsPrompt\" class=\"headerlink\" title=\"WebChromeClient.onJsPrompt()\"></a>WebChromeClient.onJsPrompt()</h2><p>其实除了WebChromeClient.onJsPrompt()，还有WebChromeClient.onJsAlert()和WebChromeClient.onJsConfirm()。顾名思义，这三个Javascript给Native代码的回调接口的作用分别是提示展示提示信息，展示警告信息和展示确认信息。鉴于，alert和confirm在Javascript的使用率很高，所以JSBridge的解决方案中都倾向于选用onJsPrompt()。</p>\n<p>Javascript中调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.prompt(message, value)</span><br></pre></td></tr></table></figure>\n<p>WebChromeClient.onJsPrompt()就会受到回调。</p>\n<p>onJsPrompt()方法的message参数的值正是Javascript的方法window.prompt()的message的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CustomWebChromeClient extends WebChromeClient &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123;</span><br><span class=\"line\">        // 处理JS 的调用逻辑</span><br><span class=\"line\">        result.confirm();</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"JsBridge\"><a href=\"#JsBridge\" class=\"headerlink\" title=\"JsBridge\"></a>JsBridge</h1><p>java 通信js只有这一种方式</p>\n<ul>\n<li>WebView加载html页面</li>\n</ul>\n<p>webView.registerHandler(“submitFromWeb”,…);这是Java层注册了一个叫”submitFromWeb”的接口方法，目的是提供给Javascript来调用。这个”submitFromWeb”的接口方法的回调就是BridgeHandler.handler()。</p>\n<p>webView.callHandler(“functionInJs”, …, new CallBackFunction());<br>这是Java层主动调用Javascript的”functionInJs”方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MainActivity extends Activity implements OnClickListener &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        webView = (BridgeWebView) findViewById(R.id.webView);</span><br><span class=\"line\">        webView.loadUrl(&quot;file:///android_asset/demo.html&quot;);</span><br><span class=\"line\">        webView.registerHandler(&quot;submitFromWeb&quot;, new BridgeHandler() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void handler(String data, CallBackFunction function) &#123;</span><br><span class=\"line\">                Log.i(TAG, &quot;handler = submitFromWeb, data from web = &quot; + data);</span><br><span class=\"line\">                function.onCallBack(&quot;submitFromWeb exe, response data 中文 from Java&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        webView.callHandler(&quot;functionInJs&quot;, new Gson().toJson(user), new CallBackFunction() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onCallBack(String data) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们一层层深入callHandler()方法的实现。这其中会调用到doSend()方法，这里想解释下callbackId。</p>\n<p>callbackId生成后不仅仅会被传到Javascript，而且会以key-value对的形式和responseCallback配对保存到responseCallbacks这个Map里面。</p>\n<p>它的目的，就是为了等Javascript把处理结果回调给Java层后，Java层能根据callbackId找到对应的responseCallback，做后续的回调处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void doSend(String handlerName, String data, CallBackFunction responseCallback) &#123;</span><br><span class=\"line\">        Message m = new Message();</span><br><span class=\"line\">        if (!TextUtils.isEmpty(data)) &#123;</span><br><span class=\"line\">            m.setData(data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (responseCallback != null) &#123;</span><br><span class=\"line\">            String callbackStr = String.format(BridgeUtil.CALLBACK_ID_FORMAT, ++uniqueId + (BridgeUtil.UNDERLINE_STR + SystemClock.currentThreadTimeMillis()));</span><br><span class=\"line\">            responseCallbacks.put(callbackStr, responseCallback);</span><br><span class=\"line\">            m.setCallbackId(callbackStr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (!TextUtils.isEmpty(handlerName)) &#123;</span><br><span class=\"line\">            m.setHandlerName(handlerName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        queueMessage(m);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>最终可以看到是BridgeWebView.dispatchMessage(Message m)方法调用的是this.loadUrl()，调用了_handleMessageFromNative这个Javascript方法。那这个Javascript的方法是哪里来的呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final static String JS_HANDLE_MESSAGE_FROM_JAVA = &quot;javascript:WebViewJavascriptBridge._handleMessageFromNative(&apos;%s&apos;);&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">void dispatchMessage(Message m) &#123;</span><br><span class=\"line\">        String messageJson = m.toJson();</span><br><span class=\"line\">        //escape special characters for json string</span><br><span class=\"line\">        messageJson = messageJson.replaceAll(&quot;(\\\\\\\\)([^utrn])&quot;, &quot;\\\\\\\\\\\\\\\\$1$2&quot;);</span><br><span class=\"line\">        messageJson = messageJson.replaceAll(&quot;(?&lt;=[^\\\\\\\\])(\\&quot;)&quot;, &quot;\\\\\\\\\\&quot;&quot;);</span><br><span class=\"line\">        String javascriptCommand = String.format(BridgeUtil.JS_HANDLE_MESSAGE_FROM_JAVA, messageJson);</span><br><span class=\"line\">        if (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123;</span><br><span class=\"line\">            this.loadUrl(javascriptCommand);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>页面加载完成后会加在一段Javascript。</li>\n</ul>\n<p>在WebViewClient.onPageFinished()里面的BridgeUtil.webViewLoadLocalJs(view, BridgeWebView.toLoadJs)。正是把保存在assert/WebViewJavascriptBridge.js加载到WebView中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BridgeWebViewClient extends WebViewClient &#123;</span><br><span class=\"line\">　　</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onPageFinished(WebView view, String url) &#123;</span><br><span class=\"line\">        super.onPageFinished(view, url);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (BridgeWebView.toLoadJs != null) &#123;</span><br><span class=\"line\">            BridgeUtil.webViewLoadLocalJs(view, BridgeWebView.toLoadJs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //</span><br><span class=\"line\">        if (webView.getStartupMessage() != null) &#123;</span><br><span class=\"line\">            for (Message m : webView.getStartupMessage()) &#123;</span><br><span class=\"line\">                webView.dispatchMessage(m);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            webView.setStartupMessage(null);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看看WebViewJavascriptBridge.js的代码，就能找到function _handleMessageFromNative()这个Javascript方法了。</p>\n<ul>\n<li>WebViewJavascriptBridge.js</li>\n</ul>\n<p>_handleMessageFromNative()方法里面会调用_dispatchMessageFromNative()方法。</p>\n<p>当处理来自Java层的主动调用时候会走“直接发送”的else分支。</p>\n<p>message.callbackId会被取出来，实例化一个responseCallback，而它是用来Javascript处理完成后把结果数据回调给Java层代码的。</p>\n<p>接着会根据message.handleName（在这个分析例子中，handleName的值就是”functionInJs”）在messageHandlers这个Map去获取handler，最后交给handler去处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function _dispatchMessageFromNative(messageJSON) &#123;</span><br><span class=\"line\">    setTimeout(function() &#123;</span><br><span class=\"line\">        var message = JSON.parse(messageJSON);</span><br><span class=\"line\">        var responseCallback;</span><br><span class=\"line\">        //java call finished, now need to call js callback function</span><br><span class=\"line\">        if (message.responseId) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            //直接发送</span><br><span class=\"line\">            if (message.callbackId) &#123;</span><br><span class=\"line\">                var callbackResponseId = message.callbackId;</span><br><span class=\"line\">                responseCallback = function(responseData) &#123;</span><br><span class=\"line\">                    _doSend(&#123;</span><br><span class=\"line\">                        responseId: callbackResponseId,</span><br><span class=\"line\">                        responseData: responseData</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            var handler = WebViewJavascriptBridge._messageHandler;</span><br><span class=\"line\">            if (message.handlerName) &#123;</span><br><span class=\"line\">                handler = messageHandlers[message.handlerName];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //查找指定handler</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                handler(message.data, responseCallback);</span><br><span class=\"line\">            &#125; catch (exception) &#123;</span><br><span class=\"line\">                if (typeof console != &apos;undefined&apos;) &#123;</span><br><span class=\"line\">                    console.log(&quot;WebViewJavascriptBridge: WARNING: javascript handler threw.&quot;, message, exception);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>页面注册的”functionInJs”方法，提供给Java调用Javascript的。</li>\n</ul>\n<p>延续上面的分析，messageHandler是哪里设置的呢。答案就在当初webView.loadUrl(“file:///android_asset/demo.html”);加载的这个demo.html中。</p>\n<p>bridge.registerHandler(“functionInJs”, …)这里注册了”functionInJs”。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">    &lt;head&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &lt;/head&gt;</span><br><span class=\"line\">    &lt;body&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &lt;/body&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        connectWebViewJavascriptBridge(function(bridge) &#123;</span><br><span class=\"line\">            bridge.init(function(message, responseCallback) &#123;</span><br><span class=\"line\">                console.log(&apos;JS got a message&apos;, message);</span><br><span class=\"line\">                var data = &#123;</span><br><span class=\"line\">                    &apos;Javascript Responds&apos;: &apos;测试中文!&apos;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">                console.log(&apos;JS responding with&apos;, data);</span><br><span class=\"line\">                responseCallback(data);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            bridge.registerHandler(&quot;functionInJs&quot;, function(data, responseCallback) &#123;</span><br><span class=\"line\">                document.getElementById(&quot;show&quot;).innerHTML = (&quot;data from Java: = &quot; + data);</span><br><span class=\"line\">                var responseData = &quot;Javascript Says Right back aka!&quot;;</span><br><span class=\"line\">                responseCallback(responseData);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>“functionInJs”执行完毕把结果回传给Java</li>\n</ul>\n<p>“funciontInJs”执行完毕后调用的responseCallback正是_dispatchMessageFromNative()实例化的，而它实际会调用_doSend()方法。</p>\n<p>_doSend()方法会先把Message推送到sendMessageQueue中。</p>\n<p>然后修改messagingIframe.src，这里会出发Java层的WebViewClient.shouldOverrideUrlLoading()的回调。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function _doSend(message, responseCallback) &#123;</span><br><span class=\"line\">    if (responseCallback) &#123;</span><br><span class=\"line\">        var callbackId = &apos;cb_&apos; + (uniqueId++) + &apos;_&apos; + new Date().getTime();</span><br><span class=\"line\">        responseCallbacks[callbackId] = responseCallback;</span><br><span class=\"line\">        message.callbackId = callbackId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    sendMessageQueue.push(message);</span><br><span class=\"line\">    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + &apos;://&apos; + QUEUE_HAS_MESSAGE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 在BridgeWebViewClient.shouldOverrideUrlLoading()里面，会先执行webView.flushMessageQueue()的分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        url = URLDecoder.decode(url, &quot;UTF-8&quot;);</span><br><span class=\"line\">    &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (url.startsWith(BridgeUtil.YY_RETURN_DATA)) &#123; // 如果是返回数据</span><br><span class=\"line\">        webView.handlerReturnData(url);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125; else if (url.startsWith(BridgeUtil.YY_OVERRIDE_SCHEMA)) &#123; //</span><br><span class=\"line\">        webView.flushMessageQueue();</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return super.shouldOverrideUrlLoading(view, url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>webView.flushMessageQueue()首先去执行Javascript的_flushQueue()方法，并附带着CallBackFunction。</p>\n<p>Javascript的_flushQueue()方法会把sendMessageQueue中的所有message都回传给Java层。</p>\n<p>CallBackFunction就是把messageQueue解析出来后一个一个Message在for循环中处理，也正是在for循环中，”functionInJs”的Java层回调方法被执行了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void flushMessageQueue() &#123;</span><br><span class=\"line\">    if (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123;</span><br><span class=\"line\">        loadUrl(BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA, new CallBackFunction() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onCallBack(String data) &#123;</span><br><span class=\"line\">                // deserializeMessage</span><br><span class=\"line\">                List&lt;Message&gt; list = null;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    list = Message.toArrayList(data);</span><br><span class=\"line\">                &#125; catch (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (list == null || list.size() == 0) &#123;</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">                    ...</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到此，JsBridge的调用流程就分析完毕了。虽然JsBridge使用了MessageQueue后，分析起来有点绕，但原理是不变的。</p>\n<p>Javascript调用Java是通过WebViewClient.shouldOverrideUrlLoading()。当然，还有在文章开头介绍另外3种方式。</p>\n<p>Java调用Javascript是通过WebView.loadUrl(“javascript:xxxx”)。</p>\n"},{"title":"大话多线程阅读笔记","date":"2018-02-23T15:05:12.000Z","_content":"\n本篇文章主要是针对技术掘金上面《大话android多线程》进行笔记总结，好记性不如烂笔头。\n\n# Thread和Runnable的联系和区别\n\n线程的创建有两种方式，一种是重写runnable的run方法然后放到thread中，一种是重写thread的run方法\n\n## 两者的联系\n\n1. thread实现了runnable接口\n2. 都需要重写run方法\n\n## 两者的区别\n\n1. 实现runnable的类更具有健壮性，避免了单继承的局限\n2. runnable更容易实现资源共享，能多个线程同时处理一个资源\n\n## 两者的比较\n\n使用runnable创建的多线程，若是同一个runnable，那么运行的时候实际上执行的是同一个任务，共享的是相同的资源。\n相反，使用thread创建的多线程，则是不同的任务，也不会共享相同的资源。\n\n# Synchronized使用解析\n\n多线程的环境下面，很容易出现不同步的情况下，条件a为当b大于0的时候，b自减，结果1号线程2号线程同时进行操作，1号线程快2号线程几毫秒，对1号线程来讲，a成立，在1号线程准备对b进行操作的时候，2号线程进来，2号线程在判断的时候发现a也成立，而此时1号线程在2号线程判断之后顺利的进行的b的自减操作，此时2号线程虽然条件不成立，但是仍然需要进行b操作，此时就会产生一系列的问题。\n\n锁的作用，便是对方法块进行同步操作。在一个对象操作该方法的时候，另一个对象无法操作，等第一个对象操作完毕，该方法块才可以让别的对象操作。\n\nsynchronized (obj){}同步代码块和用synchronized声明方法的作用基本一致，都是对synchronized作用范围内的代码进行加锁保护，其区别在于synchronized同步代码块使用更加灵活、轻巧，synchronized (obj){}括号内的对象参数即为该代码块持有锁的对象\n\n## 同步方法和静态同步方法\n\n+ synchronized声明非静态方法、同步代码块的synchronized (this){}和synchronized (非this对象){}这三者持有锁的对象为实例对象（类的实例对象可以有很多个），线程想要执行该synchronized作用范围内的同步代码，需获得对象锁。\n\n```\npublic class SynchronizedTest {\n    public synchronized void test1(){\n        //持有锁的对象为SynchronizedTest的实例对象\n    }\n\n    public void test2(){\n        synchronized (this){\n            //持有锁的对象为SynchronizedTest的实例对象\n        }\n    }\n\n    private String obj = \"obj\";\n    public void test3(){\n        synchronized (obj){\n            //持有锁的对象为obj\n        }\n    }\n}\n```\n\n+ synchronized声明静态方法以及同步代码块的synchronized (类.class){}这两者持有锁的对象为Class对象（每个类只有一个Class对象，而Class对象是Java类编译后生成的.class文件，它包含了与类有关的信息），线程想要执行该synchronized作用范围内的同步代码，需获得类锁\n\n```\npublic class SynchronizedTest {\n    public static synchronized void test4(){\n        //持有锁的对象为SynchronizedTest的Class对象（SynchronizedTest.class）\n    }\n\n    public void test5(){\n        synchronized (SynchronizedTest.class){\n            //持有锁的对象为SynchronizedTest的Class对象（SynchronizedTest.class）\n        }\n    }\n}\n```\n\n\n若synchronized同步方法（代码块）持有锁的对象不同，则多线程执行相应的同步代码时互不干扰；若相同，则获得该对象锁的线程先执行同步代码，其他访问同步代码的线程会被阻塞并等待锁的释放\n\n# 线程间的通信机制之Handler\n\nhandler了解的还是比较多的，扫盲一下。\n\n1. 主线程的looper在应用开始前系统就已经创建好了，需要在主线程往子线程发射消息，需要在子线程重写looper并开启循环\n\n重写方式如下\n\n```\npublic class HandlerTestActivity extends AppCompatActivity {\n    private Handler handler2;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_handler_test);\n        TestThread testThread = new TestThread();\n        testThread.start();\n\n        while (true){//保证testThread.looper已经初始化\n            if(testThread.looper!=null){\n                handler2 = new Handler(testThread.looper){\n                    @Override\n                    public void handleMessage(Message msg) {//子线程收到消息后执行\n                        switch (msg.what){\n                            case CODE_TEST_FOUR:\n                                Log.e(TAG,\"收到主线程发送的消息\");\n                                break;\n                        }\n                    }\n                };\n\n                handler2.sendEmptyMessage(CODE_TEST_FOUR);//在主线程中发送消息\n                break;\n            }\n        }\n\n    private class TestThread extends Thread{\n        private Looper looper;\n\n        @Override\n        public void run() {\n            super.run();\n            Looper.prepare();//创建该子线程的Looper实例\n            looper = Looper.myLooper();//取出该子线程的Looper实例\n            Looper.loop();//开始循环\n        }\n    }\n}\n```\n\n虽然可以使用继承一个线程然后开looper的方式进行子线程设置looper，不过仍然是比较麻烦，直接使用handlerthread便可直接解决该问题。\n\n```\nhandler2 = new Handler(handlerThread.getLooper()){\n            @Override\n            public void handleMessage(Message msg) {//子线程收到消息后执行\n                switch (msg.what){\n                    case CODE_TEST_FOUR:\n                        Log.e(TAG,\"收到主线程发送的消息\");\n                        break;\n                }\n            }\n        };\n```\n\n这样子在主线程中使用handler便可直接获取子线程的looper，然后进行通信。\n\n2. 子线程和子线程之间进行通信，其实也就是子线程a能否获得子线程b的looper这个问题，如上使用handlerthread或者直接使用继承然后写一个get方法获取looper也可以。\n\n3. messagequeue其实是looper中包含的，并不能将他们区分开来看。\n\n# callable、future、futuretask\n\n## 使用callable方式创建线程\n```\npublic static class TestCallable implements Callable{\n\tprivate int ticket = 10;\n\n\t@Override\n\tpublic String call() throws Exception {\n\t\tSystem.out.println(Thread.currentThread().getName() + \"：我买几个橘子去。你就在此地，不要走动\" + \" 时间：\" + getTime());\n\t\tThread.sleep(2000);//模拟买橘子的时间\n\t\tSystem.out.println(Thread.currentThread().getName() + \"：橘子卖完了\" + \" 时间：\" + getTime());\n\t\t\n\t\tthrow new NullPointerException(\"橘子卖完了\");\n\t}\n}\n\npublic static void main(String args[]){\n\tTestCallable callable = new TestCallable();\n\tFutureTask<String> futureTask = new FutureTask<String>(callable);\n\n\tThread thread1 = new Thread(futureTask, \"爸爸\");\n\tthread1.start();\n\n\t//也可以用threadpool\n\t//ExecutorService executor = Executors.newCachedThreadPool();\n\t//Future<String> future = executor.submit(callable);\n\n\tSystem.out.println(\"儿子站在原地\" + \" 时间：\" + getTime());//验证主线程的执行情况\n\ttry{\n\t\tSystem.out.println(futureTask.get());\n\t\tSystem.out.println(\"儿子收到橘子\" + \" 时间：\" + getTime());//验证主线程的执行情况\n\t}catch (InterruptedException | ExecutionException e){\n\t\tSystem.out.println(\"儿子没收到橘子\" + \" 时间：\" + getTime());//验证主线程的执行情况\n\t}\n}\n```\n\n1. Callable在被线程执行后，可以提供一个返回值，我们可以通过Future的get()方法拿到这个值\n\n2. Future是一个接口，而FutureTask实现了RunnableFuture接口，RunnableFuture继承了Runnable接口和Future接口\n\n3. 与runnable不同的两点：\n\n1。FutureTask用于异步获取执行结果或取消执行任务的场景，它的主要功能有：\n可以判断任务是否完成\n可以获取任务执行结果\n可以中断任务\n\n2。Callable的call()方法可以抛出异常，我们可以在尝试执行get()方法时捕获这个异常\n\n3. FutureTask可以确保任务只执行一次\n\n4. 我们在某条线程执行get()方法时，该线程会被阻塞，直到Future拿到Callable.call()方法的返回值。\n\n在UI线程中使用时（尤其是后续还有更新UI的操作）要特别注意这点，以免造成界面卡顿。那么要如何处理这种多线程执行耗时任务，等待结果，然后再更新UI的情况呢？handler\n\n# ThreadPoolExecutor\n\n## new Thread()的缺点\n\n• 每次new Thread()耗费性能 \n• 调用new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制创建，之间相互竞争，会导致过多占用系统资源导致系统瘫痪 \n• 不利于扩展，比如如定时执行、定期执行、线程中断 \n\n## 线程池的优点\n\n• 重用存在的线程，减少对象创建、消亡的开销，性能佳 \n• 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞 \n• 提供定时执行、定期执行、单线程、并发数控制等功能\n\n## 参数解析\n\n```\n\tpublic ThreadPoolExecutor(int corePoolSize,\n\t\t\t  int maximumPoolSize,\n\t\t\t  long keepAliveTime,\n\t\t\t  TimeUnit unit,\n\t\t\t  BlockingQueue<Runnable> workQueue,\n\t\t\t  ThreadFactory threadFactory,\n\t\t\t  RejectedExecutionHandler handler)\n```\n\n\n\n\n","source":"_posts/大话多线程阅读笔记.md","raw":"---\ntitle: 大话多线程阅读笔记\ndate: 2018-02-23 23:05:12\ntags: android\n---\n\n本篇文章主要是针对技术掘金上面《大话android多线程》进行笔记总结，好记性不如烂笔头。\n\n# Thread和Runnable的联系和区别\n\n线程的创建有两种方式，一种是重写runnable的run方法然后放到thread中，一种是重写thread的run方法\n\n## 两者的联系\n\n1. thread实现了runnable接口\n2. 都需要重写run方法\n\n## 两者的区别\n\n1. 实现runnable的类更具有健壮性，避免了单继承的局限\n2. runnable更容易实现资源共享，能多个线程同时处理一个资源\n\n## 两者的比较\n\n使用runnable创建的多线程，若是同一个runnable，那么运行的时候实际上执行的是同一个任务，共享的是相同的资源。\n相反，使用thread创建的多线程，则是不同的任务，也不会共享相同的资源。\n\n# Synchronized使用解析\n\n多线程的环境下面，很容易出现不同步的情况下，条件a为当b大于0的时候，b自减，结果1号线程2号线程同时进行操作，1号线程快2号线程几毫秒，对1号线程来讲，a成立，在1号线程准备对b进行操作的时候，2号线程进来，2号线程在判断的时候发现a也成立，而此时1号线程在2号线程判断之后顺利的进行的b的自减操作，此时2号线程虽然条件不成立，但是仍然需要进行b操作，此时就会产生一系列的问题。\n\n锁的作用，便是对方法块进行同步操作。在一个对象操作该方法的时候，另一个对象无法操作，等第一个对象操作完毕，该方法块才可以让别的对象操作。\n\nsynchronized (obj){}同步代码块和用synchronized声明方法的作用基本一致，都是对synchronized作用范围内的代码进行加锁保护，其区别在于synchronized同步代码块使用更加灵活、轻巧，synchronized (obj){}括号内的对象参数即为该代码块持有锁的对象\n\n## 同步方法和静态同步方法\n\n+ synchronized声明非静态方法、同步代码块的synchronized (this){}和synchronized (非this对象){}这三者持有锁的对象为实例对象（类的实例对象可以有很多个），线程想要执行该synchronized作用范围内的同步代码，需获得对象锁。\n\n```\npublic class SynchronizedTest {\n    public synchronized void test1(){\n        //持有锁的对象为SynchronizedTest的实例对象\n    }\n\n    public void test2(){\n        synchronized (this){\n            //持有锁的对象为SynchronizedTest的实例对象\n        }\n    }\n\n    private String obj = \"obj\";\n    public void test3(){\n        synchronized (obj){\n            //持有锁的对象为obj\n        }\n    }\n}\n```\n\n+ synchronized声明静态方法以及同步代码块的synchronized (类.class){}这两者持有锁的对象为Class对象（每个类只有一个Class对象，而Class对象是Java类编译后生成的.class文件，它包含了与类有关的信息），线程想要执行该synchronized作用范围内的同步代码，需获得类锁\n\n```\npublic class SynchronizedTest {\n    public static synchronized void test4(){\n        //持有锁的对象为SynchronizedTest的Class对象（SynchronizedTest.class）\n    }\n\n    public void test5(){\n        synchronized (SynchronizedTest.class){\n            //持有锁的对象为SynchronizedTest的Class对象（SynchronizedTest.class）\n        }\n    }\n}\n```\n\n\n若synchronized同步方法（代码块）持有锁的对象不同，则多线程执行相应的同步代码时互不干扰；若相同，则获得该对象锁的线程先执行同步代码，其他访问同步代码的线程会被阻塞并等待锁的释放\n\n# 线程间的通信机制之Handler\n\nhandler了解的还是比较多的，扫盲一下。\n\n1. 主线程的looper在应用开始前系统就已经创建好了，需要在主线程往子线程发射消息，需要在子线程重写looper并开启循环\n\n重写方式如下\n\n```\npublic class HandlerTestActivity extends AppCompatActivity {\n    private Handler handler2;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_handler_test);\n        TestThread testThread = new TestThread();\n        testThread.start();\n\n        while (true){//保证testThread.looper已经初始化\n            if(testThread.looper!=null){\n                handler2 = new Handler(testThread.looper){\n                    @Override\n                    public void handleMessage(Message msg) {//子线程收到消息后执行\n                        switch (msg.what){\n                            case CODE_TEST_FOUR:\n                                Log.e(TAG,\"收到主线程发送的消息\");\n                                break;\n                        }\n                    }\n                };\n\n                handler2.sendEmptyMessage(CODE_TEST_FOUR);//在主线程中发送消息\n                break;\n            }\n        }\n\n    private class TestThread extends Thread{\n        private Looper looper;\n\n        @Override\n        public void run() {\n            super.run();\n            Looper.prepare();//创建该子线程的Looper实例\n            looper = Looper.myLooper();//取出该子线程的Looper实例\n            Looper.loop();//开始循环\n        }\n    }\n}\n```\n\n虽然可以使用继承一个线程然后开looper的方式进行子线程设置looper，不过仍然是比较麻烦，直接使用handlerthread便可直接解决该问题。\n\n```\nhandler2 = new Handler(handlerThread.getLooper()){\n            @Override\n            public void handleMessage(Message msg) {//子线程收到消息后执行\n                switch (msg.what){\n                    case CODE_TEST_FOUR:\n                        Log.e(TAG,\"收到主线程发送的消息\");\n                        break;\n                }\n            }\n        };\n```\n\n这样子在主线程中使用handler便可直接获取子线程的looper，然后进行通信。\n\n2. 子线程和子线程之间进行通信，其实也就是子线程a能否获得子线程b的looper这个问题，如上使用handlerthread或者直接使用继承然后写一个get方法获取looper也可以。\n\n3. messagequeue其实是looper中包含的，并不能将他们区分开来看。\n\n# callable、future、futuretask\n\n## 使用callable方式创建线程\n```\npublic static class TestCallable implements Callable{\n\tprivate int ticket = 10;\n\n\t@Override\n\tpublic String call() throws Exception {\n\t\tSystem.out.println(Thread.currentThread().getName() + \"：我买几个橘子去。你就在此地，不要走动\" + \" 时间：\" + getTime());\n\t\tThread.sleep(2000);//模拟买橘子的时间\n\t\tSystem.out.println(Thread.currentThread().getName() + \"：橘子卖完了\" + \" 时间：\" + getTime());\n\t\t\n\t\tthrow new NullPointerException(\"橘子卖完了\");\n\t}\n}\n\npublic static void main(String args[]){\n\tTestCallable callable = new TestCallable();\n\tFutureTask<String> futureTask = new FutureTask<String>(callable);\n\n\tThread thread1 = new Thread(futureTask, \"爸爸\");\n\tthread1.start();\n\n\t//也可以用threadpool\n\t//ExecutorService executor = Executors.newCachedThreadPool();\n\t//Future<String> future = executor.submit(callable);\n\n\tSystem.out.println(\"儿子站在原地\" + \" 时间：\" + getTime());//验证主线程的执行情况\n\ttry{\n\t\tSystem.out.println(futureTask.get());\n\t\tSystem.out.println(\"儿子收到橘子\" + \" 时间：\" + getTime());//验证主线程的执行情况\n\t}catch (InterruptedException | ExecutionException e){\n\t\tSystem.out.println(\"儿子没收到橘子\" + \" 时间：\" + getTime());//验证主线程的执行情况\n\t}\n}\n```\n\n1. Callable在被线程执行后，可以提供一个返回值，我们可以通过Future的get()方法拿到这个值\n\n2. Future是一个接口，而FutureTask实现了RunnableFuture接口，RunnableFuture继承了Runnable接口和Future接口\n\n3. 与runnable不同的两点：\n\n1。FutureTask用于异步获取执行结果或取消执行任务的场景，它的主要功能有：\n可以判断任务是否完成\n可以获取任务执行结果\n可以中断任务\n\n2。Callable的call()方法可以抛出异常，我们可以在尝试执行get()方法时捕获这个异常\n\n3. FutureTask可以确保任务只执行一次\n\n4. 我们在某条线程执行get()方法时，该线程会被阻塞，直到Future拿到Callable.call()方法的返回值。\n\n在UI线程中使用时（尤其是后续还有更新UI的操作）要特别注意这点，以免造成界面卡顿。那么要如何处理这种多线程执行耗时任务，等待结果，然后再更新UI的情况呢？handler\n\n# ThreadPoolExecutor\n\n## new Thread()的缺点\n\n• 每次new Thread()耗费性能 \n• 调用new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制创建，之间相互竞争，会导致过多占用系统资源导致系统瘫痪 \n• 不利于扩展，比如如定时执行、定期执行、线程中断 \n\n## 线程池的优点\n\n• 重用存在的线程，减少对象创建、消亡的开销，性能佳 \n• 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞 \n• 提供定时执行、定期执行、单线程、并发数控制等功能\n\n## 参数解析\n\n```\n\tpublic ThreadPoolExecutor(int corePoolSize,\n\t\t\t  int maximumPoolSize,\n\t\t\t  long keepAliveTime,\n\t\t\t  TimeUnit unit,\n\t\t\t  BlockingQueue<Runnable> workQueue,\n\t\t\t  ThreadFactory threadFactory,\n\t\t\t  RejectedExecutionHandler handler)\n```\n\n\n\n\n","slug":"大话多线程阅读笔记","published":1,"updated":"2019-03-12T09:26:33.167Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltu0800703a8k7hf171lv","content":"<p>本篇文章主要是针对技术掘金上面《大话android多线程》进行笔记总结，好记性不如烂笔头。</p>\n<h1 id=\"Thread和Runnable的联系和区别\"><a href=\"#Thread和Runnable的联系和区别\" class=\"headerlink\" title=\"Thread和Runnable的联系和区别\"></a>Thread和Runnable的联系和区别</h1><p>线程的创建有两种方式，一种是重写runnable的run方法然后放到thread中，一种是重写thread的run方法</p>\n<h2 id=\"两者的联系\"><a href=\"#两者的联系\" class=\"headerlink\" title=\"两者的联系\"></a>两者的联系</h2><ol>\n<li>thread实现了runnable接口</li>\n<li>都需要重写run方法</li>\n</ol>\n<h2 id=\"两者的区别\"><a href=\"#两者的区别\" class=\"headerlink\" title=\"两者的区别\"></a>两者的区别</h2><ol>\n<li>实现runnable的类更具有健壮性，避免了单继承的局限</li>\n<li>runnable更容易实现资源共享，能多个线程同时处理一个资源</li>\n</ol>\n<h2 id=\"两者的比较\"><a href=\"#两者的比较\" class=\"headerlink\" title=\"两者的比较\"></a>两者的比较</h2><p>使用runnable创建的多线程，若是同一个runnable，那么运行的时候实际上执行的是同一个任务，共享的是相同的资源。<br>相反，使用thread创建的多线程，则是不同的任务，也不会共享相同的资源。</p>\n<h1 id=\"Synchronized使用解析\"><a href=\"#Synchronized使用解析\" class=\"headerlink\" title=\"Synchronized使用解析\"></a>Synchronized使用解析</h1><p>多线程的环境下面，很容易出现不同步的情况下，条件a为当b大于0的时候，b自减，结果1号线程2号线程同时进行操作，1号线程快2号线程几毫秒，对1号线程来讲，a成立，在1号线程准备对b进行操作的时候，2号线程进来，2号线程在判断的时候发现a也成立，而此时1号线程在2号线程判断之后顺利的进行的b的自减操作，此时2号线程虽然条件不成立，但是仍然需要进行b操作，此时就会产生一系列的问题。</p>\n<p>锁的作用，便是对方法块进行同步操作。在一个对象操作该方法的时候，另一个对象无法操作，等第一个对象操作完毕，该方法块才可以让别的对象操作。</p>\n<p>synchronized (obj){}同步代码块和用synchronized声明方法的作用基本一致，都是对synchronized作用范围内的代码进行加锁保护，其区别在于synchronized同步代码块使用更加灵活、轻巧，synchronized (obj){}括号内的对象参数即为该代码块持有锁的对象</p>\n<h2 id=\"同步方法和静态同步方法\"><a href=\"#同步方法和静态同步方法\" class=\"headerlink\" title=\"同步方法和静态同步方法\"></a>同步方法和静态同步方法</h2><ul>\n<li>synchronized声明非静态方法、同步代码块的synchronized (this){}和synchronized (非this对象){}这三者持有锁的对象为实例对象（类的实例对象可以有很多个），线程想要执行该synchronized作用范围内的同步代码，需获得对象锁。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SynchronizedTest &#123;</span><br><span class=\"line\">    public synchronized void test1()&#123;</span><br><span class=\"line\">        //持有锁的对象为SynchronizedTest的实例对象</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void test2()&#123;</span><br><span class=\"line\">        synchronized (this)&#123;</span><br><span class=\"line\">            //持有锁的对象为SynchronizedTest的实例对象</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String obj = &quot;obj&quot;;</span><br><span class=\"line\">    public void test3()&#123;</span><br><span class=\"line\">        synchronized (obj)&#123;</span><br><span class=\"line\">            //持有锁的对象为obj</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>synchronized声明静态方法以及同步代码块的synchronized (类.class){}这两者持有锁的对象为Class对象（每个类只有一个Class对象，而Class对象是Java类编译后生成的.class文件，它包含了与类有关的信息），线程想要执行该synchronized作用范围内的同步代码，需获得类锁</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SynchronizedTest &#123;</span><br><span class=\"line\">    public static synchronized void test4()&#123;</span><br><span class=\"line\">        //持有锁的对象为SynchronizedTest的Class对象（SynchronizedTest.class）</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void test5()&#123;</span><br><span class=\"line\">        synchronized (SynchronizedTest.class)&#123;</span><br><span class=\"line\">            //持有锁的对象为SynchronizedTest的Class对象（SynchronizedTest.class）</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>若synchronized同步方法（代码块）持有锁的对象不同，则多线程执行相应的同步代码时互不干扰；若相同，则获得该对象锁的线程先执行同步代码，其他访问同步代码的线程会被阻塞并等待锁的释放</p>\n<h1 id=\"线程间的通信机制之Handler\"><a href=\"#线程间的通信机制之Handler\" class=\"headerlink\" title=\"线程间的通信机制之Handler\"></a>线程间的通信机制之Handler</h1><p>handler了解的还是比较多的，扫盲一下。</p>\n<ol>\n<li>主线程的looper在应用开始前系统就已经创建好了，需要在主线程往子线程发射消息，需要在子线程重写looper并开启循环</li>\n</ol>\n<p>重写方式如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HandlerTestActivity extends AppCompatActivity &#123;</span><br><span class=\"line\">    private Handler handler2;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_handler_test);</span><br><span class=\"line\">        TestThread testThread = new TestThread();</span><br><span class=\"line\">        testThread.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        while (true)&#123;//保证testThread.looper已经初始化</span><br><span class=\"line\">            if(testThread.looper!=null)&#123;</span><br><span class=\"line\">                handler2 = new Handler(testThread.looper)&#123;</span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    public void handleMessage(Message msg) &#123;//子线程收到消息后执行</span><br><span class=\"line\">                        switch (msg.what)&#123;</span><br><span class=\"line\">                            case CODE_TEST_FOUR:</span><br><span class=\"line\">                                Log.e(TAG,&quot;收到主线程发送的消息&quot;);</span><br><span class=\"line\">                                break;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">                handler2.sendEmptyMessage(CODE_TEST_FOUR);//在主线程中发送消息</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private class TestThread extends Thread&#123;</span><br><span class=\"line\">        private Looper looper;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            super.run();</span><br><span class=\"line\">            Looper.prepare();//创建该子线程的Looper实例</span><br><span class=\"line\">            looper = Looper.myLooper();//取出该子线程的Looper实例</span><br><span class=\"line\">            Looper.loop();//开始循环</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽然可以使用继承一个线程然后开looper的方式进行子线程设置looper，不过仍然是比较麻烦，直接使用handlerthread便可直接解决该问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handler2 = new Handler(handlerThread.getLooper())&#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void handleMessage(Message msg) &#123;//子线程收到消息后执行</span><br><span class=\"line\">                switch (msg.what)&#123;</span><br><span class=\"line\">                    case CODE_TEST_FOUR:</span><br><span class=\"line\">                        Log.e(TAG,&quot;收到主线程发送的消息&quot;);</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n<p>这样子在主线程中使用handler便可直接获取子线程的looper，然后进行通信。</p>\n<ol start=\"2\">\n<li><p>子线程和子线程之间进行通信，其实也就是子线程a能否获得子线程b的looper这个问题，如上使用handlerthread或者直接使用继承然后写一个get方法获取looper也可以。</p>\n</li>\n<li><p>messagequeue其实是looper中包含的，并不能将他们区分开来看。</p>\n</li>\n</ol>\n<h1 id=\"callable、future、futuretask\"><a href=\"#callable、future、futuretask\" class=\"headerlink\" title=\"callable、future、futuretask\"></a>callable、future、futuretask</h1><h2 id=\"使用callable方式创建线程\"><a href=\"#使用callable方式创建线程\" class=\"headerlink\" title=\"使用callable方式创建线程\"></a>使用callable方式创建线程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static class TestCallable implements Callable&#123;</span><br><span class=\"line\">\tprivate int ticket = 10;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic String call() throws Exception &#123;</span><br><span class=\"line\">\t\tSystem.out.println(Thread.currentThread().getName() + &quot;：我买几个橘子去。你就在此地，不要走动&quot; + &quot; 时间：&quot; + getTime());</span><br><span class=\"line\">\t\tThread.sleep(2000);//模拟买橘子的时间</span><br><span class=\"line\">\t\tSystem.out.println(Thread.currentThread().getName() + &quot;：橘子卖完了&quot; + &quot; 时间：&quot; + getTime());</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tthrow new NullPointerException(&quot;橘子卖完了&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void main(String args[])&#123;</span><br><span class=\"line\">\tTestCallable callable = new TestCallable();</span><br><span class=\"line\">\tFutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(callable);</span><br><span class=\"line\"></span><br><span class=\"line\">\tThread thread1 = new Thread(futureTask, &quot;爸爸&quot;);</span><br><span class=\"line\">\tthread1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">\t//也可以用threadpool</span><br><span class=\"line\">\t//ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class=\"line\">\t//Future&lt;String&gt; future = executor.submit(callable);</span><br><span class=\"line\"></span><br><span class=\"line\">\tSystem.out.println(&quot;儿子站在原地&quot; + &quot; 时间：&quot; + getTime());//验证主线程的执行情况</span><br><span class=\"line\">\ttry&#123;</span><br><span class=\"line\">\t\tSystem.out.println(futureTask.get());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;儿子收到橘子&quot; + &quot; 时间：&quot; + getTime());//验证主线程的执行情况</span><br><span class=\"line\">\t&#125;catch (InterruptedException | ExecutionException e)&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;儿子没收到橘子&quot; + &quot; 时间：&quot; + getTime());//验证主线程的执行情况</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>Callable在被线程执行后，可以提供一个返回值，我们可以通过Future的get()方法拿到这个值</p>\n</li>\n<li><p>Future是一个接口，而FutureTask实现了RunnableFuture接口，RunnableFuture继承了Runnable接口和Future接口</p>\n</li>\n<li><p>与runnable不同的两点：</p>\n</li>\n</ol>\n<p>1。FutureTask用于异步获取执行结果或取消执行任务的场景，它的主要功能有：<br>可以判断任务是否完成<br>可以获取任务执行结果<br>可以中断任务</p>\n<p>2。Callable的call()方法可以抛出异常，我们可以在尝试执行get()方法时捕获这个异常</p>\n<ol start=\"3\">\n<li><p>FutureTask可以确保任务只执行一次</p>\n</li>\n<li><p>我们在某条线程执行get()方法时，该线程会被阻塞，直到Future拿到Callable.call()方法的返回值。</p>\n</li>\n</ol>\n<p>在UI线程中使用时（尤其是后续还有更新UI的操作）要特别注意这点，以免造成界面卡顿。那么要如何处理这种多线程执行耗时任务，等待结果，然后再更新UI的情况呢？handler</p>\n<h1 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h1><h2 id=\"new-Thread-的缺点\"><a href=\"#new-Thread-的缺点\" class=\"headerlink\" title=\"new Thread()的缺点\"></a>new Thread()的缺点</h2><p>• 每次new Thread()耗费性能<br>• 调用new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制创建，之间相互竞争，会导致过多占用系统资源导致系统瘫痪<br>• 不利于扩展，比如如定时执行、定期执行、线程中断 </p>\n<h2 id=\"线程池的优点\"><a href=\"#线程池的优点\" class=\"headerlink\" title=\"线程池的优点\"></a>线程池的优点</h2><p>• 重用存在的线程，减少对象创建、消亡的开销，性能佳<br>• 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞<br>• 提供定时执行、定期执行、单线程、并发数控制等功能</p>\n<h2 id=\"参数解析\"><a href=\"#参数解析\" class=\"headerlink\" title=\"参数解析\"></a>参数解析</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ThreadPoolExecutor(int corePoolSize,</span><br><span class=\"line\">\t\t  int maximumPoolSize,</span><br><span class=\"line\">\t\t  long keepAliveTime,</span><br><span class=\"line\">\t\t  TimeUnit unit,</span><br><span class=\"line\">\t\t  BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class=\"line\">\t\t  ThreadFactory threadFactory,</span><br><span class=\"line\">\t\t  RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>本篇文章主要是针对技术掘金上面《大话android多线程》进行笔记总结，好记性不如烂笔头。</p>\n<h1 id=\"Thread和Runnable的联系和区别\"><a href=\"#Thread和Runnable的联系和区别\" class=\"headerlink\" title=\"Thread和Runnable的联系和区别\"></a>Thread和Runnable的联系和区别</h1><p>线程的创建有两种方式，一种是重写runnable的run方法然后放到thread中，一种是重写thread的run方法</p>\n<h2 id=\"两者的联系\"><a href=\"#两者的联系\" class=\"headerlink\" title=\"两者的联系\"></a>两者的联系</h2><ol>\n<li>thread实现了runnable接口</li>\n<li>都需要重写run方法</li>\n</ol>\n<h2 id=\"两者的区别\"><a href=\"#两者的区别\" class=\"headerlink\" title=\"两者的区别\"></a>两者的区别</h2><ol>\n<li>实现runnable的类更具有健壮性，避免了单继承的局限</li>\n<li>runnable更容易实现资源共享，能多个线程同时处理一个资源</li>\n</ol>\n<h2 id=\"两者的比较\"><a href=\"#两者的比较\" class=\"headerlink\" title=\"两者的比较\"></a>两者的比较</h2><p>使用runnable创建的多线程，若是同一个runnable，那么运行的时候实际上执行的是同一个任务，共享的是相同的资源。<br>相反，使用thread创建的多线程，则是不同的任务，也不会共享相同的资源。</p>\n<h1 id=\"Synchronized使用解析\"><a href=\"#Synchronized使用解析\" class=\"headerlink\" title=\"Synchronized使用解析\"></a>Synchronized使用解析</h1><p>多线程的环境下面，很容易出现不同步的情况下，条件a为当b大于0的时候，b自减，结果1号线程2号线程同时进行操作，1号线程快2号线程几毫秒，对1号线程来讲，a成立，在1号线程准备对b进行操作的时候，2号线程进来，2号线程在判断的时候发现a也成立，而此时1号线程在2号线程判断之后顺利的进行的b的自减操作，此时2号线程虽然条件不成立，但是仍然需要进行b操作，此时就会产生一系列的问题。</p>\n<p>锁的作用，便是对方法块进行同步操作。在一个对象操作该方法的时候，另一个对象无法操作，等第一个对象操作完毕，该方法块才可以让别的对象操作。</p>\n<p>synchronized (obj){}同步代码块和用synchronized声明方法的作用基本一致，都是对synchronized作用范围内的代码进行加锁保护，其区别在于synchronized同步代码块使用更加灵活、轻巧，synchronized (obj){}括号内的对象参数即为该代码块持有锁的对象</p>\n<h2 id=\"同步方法和静态同步方法\"><a href=\"#同步方法和静态同步方法\" class=\"headerlink\" title=\"同步方法和静态同步方法\"></a>同步方法和静态同步方法</h2><ul>\n<li>synchronized声明非静态方法、同步代码块的synchronized (this){}和synchronized (非this对象){}这三者持有锁的对象为实例对象（类的实例对象可以有很多个），线程想要执行该synchronized作用范围内的同步代码，需获得对象锁。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SynchronizedTest &#123;</span><br><span class=\"line\">    public synchronized void test1()&#123;</span><br><span class=\"line\">        //持有锁的对象为SynchronizedTest的实例对象</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void test2()&#123;</span><br><span class=\"line\">        synchronized (this)&#123;</span><br><span class=\"line\">            //持有锁的对象为SynchronizedTest的实例对象</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String obj = &quot;obj&quot;;</span><br><span class=\"line\">    public void test3()&#123;</span><br><span class=\"line\">        synchronized (obj)&#123;</span><br><span class=\"line\">            //持有锁的对象为obj</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>synchronized声明静态方法以及同步代码块的synchronized (类.class){}这两者持有锁的对象为Class对象（每个类只有一个Class对象，而Class对象是Java类编译后生成的.class文件，它包含了与类有关的信息），线程想要执行该synchronized作用范围内的同步代码，需获得类锁</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SynchronizedTest &#123;</span><br><span class=\"line\">    public static synchronized void test4()&#123;</span><br><span class=\"line\">        //持有锁的对象为SynchronizedTest的Class对象（SynchronizedTest.class）</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void test5()&#123;</span><br><span class=\"line\">        synchronized (SynchronizedTest.class)&#123;</span><br><span class=\"line\">            //持有锁的对象为SynchronizedTest的Class对象（SynchronizedTest.class）</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>若synchronized同步方法（代码块）持有锁的对象不同，则多线程执行相应的同步代码时互不干扰；若相同，则获得该对象锁的线程先执行同步代码，其他访问同步代码的线程会被阻塞并等待锁的释放</p>\n<h1 id=\"线程间的通信机制之Handler\"><a href=\"#线程间的通信机制之Handler\" class=\"headerlink\" title=\"线程间的通信机制之Handler\"></a>线程间的通信机制之Handler</h1><p>handler了解的还是比较多的，扫盲一下。</p>\n<ol>\n<li>主线程的looper在应用开始前系统就已经创建好了，需要在主线程往子线程发射消息，需要在子线程重写looper并开启循环</li>\n</ol>\n<p>重写方式如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HandlerTestActivity extends AppCompatActivity &#123;</span><br><span class=\"line\">    private Handler handler2;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_handler_test);</span><br><span class=\"line\">        TestThread testThread = new TestThread();</span><br><span class=\"line\">        testThread.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        while (true)&#123;//保证testThread.looper已经初始化</span><br><span class=\"line\">            if(testThread.looper!=null)&#123;</span><br><span class=\"line\">                handler2 = new Handler(testThread.looper)&#123;</span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    public void handleMessage(Message msg) &#123;//子线程收到消息后执行</span><br><span class=\"line\">                        switch (msg.what)&#123;</span><br><span class=\"line\">                            case CODE_TEST_FOUR:</span><br><span class=\"line\">                                Log.e(TAG,&quot;收到主线程发送的消息&quot;);</span><br><span class=\"line\">                                break;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">                handler2.sendEmptyMessage(CODE_TEST_FOUR);//在主线程中发送消息</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private class TestThread extends Thread&#123;</span><br><span class=\"line\">        private Looper looper;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            super.run();</span><br><span class=\"line\">            Looper.prepare();//创建该子线程的Looper实例</span><br><span class=\"line\">            looper = Looper.myLooper();//取出该子线程的Looper实例</span><br><span class=\"line\">            Looper.loop();//开始循环</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽然可以使用继承一个线程然后开looper的方式进行子线程设置looper，不过仍然是比较麻烦，直接使用handlerthread便可直接解决该问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handler2 = new Handler(handlerThread.getLooper())&#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void handleMessage(Message msg) &#123;//子线程收到消息后执行</span><br><span class=\"line\">                switch (msg.what)&#123;</span><br><span class=\"line\">                    case CODE_TEST_FOUR:</span><br><span class=\"line\">                        Log.e(TAG,&quot;收到主线程发送的消息&quot;);</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n<p>这样子在主线程中使用handler便可直接获取子线程的looper，然后进行通信。</p>\n<ol start=\"2\">\n<li><p>子线程和子线程之间进行通信，其实也就是子线程a能否获得子线程b的looper这个问题，如上使用handlerthread或者直接使用继承然后写一个get方法获取looper也可以。</p>\n</li>\n<li><p>messagequeue其实是looper中包含的，并不能将他们区分开来看。</p>\n</li>\n</ol>\n<h1 id=\"callable、future、futuretask\"><a href=\"#callable、future、futuretask\" class=\"headerlink\" title=\"callable、future、futuretask\"></a>callable、future、futuretask</h1><h2 id=\"使用callable方式创建线程\"><a href=\"#使用callable方式创建线程\" class=\"headerlink\" title=\"使用callable方式创建线程\"></a>使用callable方式创建线程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static class TestCallable implements Callable&#123;</span><br><span class=\"line\">\tprivate int ticket = 10;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic String call() throws Exception &#123;</span><br><span class=\"line\">\t\tSystem.out.println(Thread.currentThread().getName() + &quot;：我买几个橘子去。你就在此地，不要走动&quot; + &quot; 时间：&quot; + getTime());</span><br><span class=\"line\">\t\tThread.sleep(2000);//模拟买橘子的时间</span><br><span class=\"line\">\t\tSystem.out.println(Thread.currentThread().getName() + &quot;：橘子卖完了&quot; + &quot; 时间：&quot; + getTime());</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tthrow new NullPointerException(&quot;橘子卖完了&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void main(String args[])&#123;</span><br><span class=\"line\">\tTestCallable callable = new TestCallable();</span><br><span class=\"line\">\tFutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(callable);</span><br><span class=\"line\"></span><br><span class=\"line\">\tThread thread1 = new Thread(futureTask, &quot;爸爸&quot;);</span><br><span class=\"line\">\tthread1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">\t//也可以用threadpool</span><br><span class=\"line\">\t//ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class=\"line\">\t//Future&lt;String&gt; future = executor.submit(callable);</span><br><span class=\"line\"></span><br><span class=\"line\">\tSystem.out.println(&quot;儿子站在原地&quot; + &quot; 时间：&quot; + getTime());//验证主线程的执行情况</span><br><span class=\"line\">\ttry&#123;</span><br><span class=\"line\">\t\tSystem.out.println(futureTask.get());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;儿子收到橘子&quot; + &quot; 时间：&quot; + getTime());//验证主线程的执行情况</span><br><span class=\"line\">\t&#125;catch (InterruptedException | ExecutionException e)&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;儿子没收到橘子&quot; + &quot; 时间：&quot; + getTime());//验证主线程的执行情况</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>Callable在被线程执行后，可以提供一个返回值，我们可以通过Future的get()方法拿到这个值</p>\n</li>\n<li><p>Future是一个接口，而FutureTask实现了RunnableFuture接口，RunnableFuture继承了Runnable接口和Future接口</p>\n</li>\n<li><p>与runnable不同的两点：</p>\n</li>\n</ol>\n<p>1。FutureTask用于异步获取执行结果或取消执行任务的场景，它的主要功能有：<br>可以判断任务是否完成<br>可以获取任务执行结果<br>可以中断任务</p>\n<p>2。Callable的call()方法可以抛出异常，我们可以在尝试执行get()方法时捕获这个异常</p>\n<ol start=\"3\">\n<li><p>FutureTask可以确保任务只执行一次</p>\n</li>\n<li><p>我们在某条线程执行get()方法时，该线程会被阻塞，直到Future拿到Callable.call()方法的返回值。</p>\n</li>\n</ol>\n<p>在UI线程中使用时（尤其是后续还有更新UI的操作）要特别注意这点，以免造成界面卡顿。那么要如何处理这种多线程执行耗时任务，等待结果，然后再更新UI的情况呢？handler</p>\n<h1 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h1><h2 id=\"new-Thread-的缺点\"><a href=\"#new-Thread-的缺点\" class=\"headerlink\" title=\"new Thread()的缺点\"></a>new Thread()的缺点</h2><p>• 每次new Thread()耗费性能<br>• 调用new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制创建，之间相互竞争，会导致过多占用系统资源导致系统瘫痪<br>• 不利于扩展，比如如定时执行、定期执行、线程中断 </p>\n<h2 id=\"线程池的优点\"><a href=\"#线程池的优点\" class=\"headerlink\" title=\"线程池的优点\"></a>线程池的优点</h2><p>• 重用存在的线程，减少对象创建、消亡的开销，性能佳<br>• 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞<br>• 提供定时执行、定期执行、单线程、并发数控制等功能</p>\n<h2 id=\"参数解析\"><a href=\"#参数解析\" class=\"headerlink\" title=\"参数解析\"></a>参数解析</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ThreadPoolExecutor(int corePoolSize,</span><br><span class=\"line\">\t\t  int maximumPoolSize,</span><br><span class=\"line\">\t\t  long keepAliveTime,</span><br><span class=\"line\">\t\t  TimeUnit unit,</span><br><span class=\"line\">\t\t  BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class=\"line\">\t\t  ThreadFactory threadFactory,</span><br><span class=\"line\">\t\t  RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>\n"},{"title":"项目架构总结","date":"2018-11-14T03:29:32.000Z","_content":"\n该篇文章主要是分析一下目前项目的架构。\n\n# 背景\n\n好搭作为一个较为成熟的软件，从2016年我刚毕业的那年开始进行设计架构，到现在过了整整2年了。经手该项目的有大约20人了，我算是第四代接手这个项目的人。\n\n# 架构\n\n## clean结构\n\n![clean结构示意图](/images/架构/clean架构图.png)\n\n一开始看到这个架构是挺懵逼的，以前听说的时候知道这个架构是谷歌的，主要是用于项目架构，目的是为了解耦。\n\n项目中依托clean架构搭建了一套完整的解耦系统。\n\n### domain层\n\ndomian层是最内层，提供了项目的基础架构，包括了接口，util方法类（可以被视为实体类），model（完整的实体对象），event（消息通知的实体对象），exception（所有的自定义异常实体对象）\n\n另外提供了精华处，针对网络的封装实体对象，interactor\n\n```\npublic interface InteractorExecutor extends Executor {\n\n}\n```\n\n这是一个内部写的interactorexcutor，其实就是继承了executor，作为处理runnable的方式。\n\n另外还写了一个PostInteractionThread，作为获取线程的方式。\n\n```\npublic interface PostInteractionThread {\n    Scheduler getScheduler();\n}\n```\n仅提供了很简单的方法\n\ninteractor类：\n\n```\npublic abstract class Interactor<T> {\n\n    private static final boolean isDelay3Second = false;\n    protected PostInteractionThread postInteractionThread;\n    protected InteractorExecutor interactorExecutor;\n    private EventBus mEventBus;\n    private Disposable subscription = Disposables.empty();\n\n    public Interactor(InteractorExecutor interactorExecutor, PostInteractionThread postInteractionThread) {\n        this.postInteractionThread = postInteractionThread;\n        this.interactorExecutor = interactorExecutor;\n\n        mEventBus = EventBus.getDefault();\n    }\n\n    protected abstract Observable<T> buildObservable();\n\n    protected void checkConditions() {\n    }\n\n    public T executeSync() {\n        return buildObservable().blockingFirst();\n    }\n\n    public void execute(Consumer<? super T> onNext) {\n        execute(onNext, null, null);\n    }\n\n    public void execute(Consumer<? super T> onNext, Consumer<Throwable> onError) {\n        execute(onNext, onError, null);\n    }\n\n    public void execute(Consumer<? super T> onNext, Consumer<Throwable> onError, Action onComplete) {\n\n        execute(\n                new Observer<T>() {\n                    @Override\n                    public void onError(Throwable e) {\n                        Throwable t = new Exception();\n                        if (e instanceof HttpException) {\n                            if (((HttpException) e).code() == 401) {\n                                HttpException s = (HttpException) e;\n                                if (s != null && s.response() != null && s.response().errorBody() != null) {\n                                    try {\n                                        HttpErrorBody body = new Gson().fromJson(s.response().errorBody().string(), HttpErrorBody.class);\n                                        if (body != null && body.getError_reason() != null && body.getError_reason().startsWith(\"AuthenticationFailed\")) {\n                                            //todo\n                                        } else {\n                                            mEventBus.post(new OnAuthExpiredEvent());\n                                        }\n                                    } catch (IOException e1) {\n                                        e1.printStackTrace();\n                                        mEventBus.post(new OnAuthExpiredEvent());\n                                    }\n                                } else {\n                                    mEventBus.post(new OnAuthExpiredEvent());\n                                }\n                            } else if (((HttpException) e).code() == 400 || ((HttpException) e).code() == 403 || ((HttpException) e).code() == 500) {\n                                try {\n                                    if (((HttpException) e).response() != null && ((HttpException) e).response().errorBody() != null) {\n                                        String json = ((HttpException) e).response().errorBody().string();\n                                        HttpErrorBody body = new Gson().fromJson(json, HttpErrorBody.class);\n                                        HttpErrorMessageBody messageBody = new Gson().fromJson(json, HttpErrorMessageBody.class);\n                                        if (body != null && body.getError_reason() != null) {\n//                                            mEventBus.post(new OnHttpErrorEvent(body.getError_reason()));\n                                        } else if (messageBody != null && messageBody.getMessage() != null) {\n                                            mEventBus.post(new OnHttpErrorEvent(messageBody.getCode(), messageBody.getMessage()));\n                                        } else {\n                                            mEventBus.post(new OnHttpErrorEvent(\"网络异常，请稍后再试\"));\n                                        }\n                                        t = new Exception(messageBody.getMessage());\n                                    }\n\n                                } catch (Exception e1) {\n                                    e1.printStackTrace();\n                                }\n                            }\n                        }\n                        if (onError == null || subscription.isDisposed()) {\n                            e.printStackTrace();\n                        } else {\n                            try {\n                                onError.accept(t);\n                            } catch (Exception e1) {\n                                e1.printStackTrace();\n                            }\n                        }\n                        handleHttpError(e);\n                    }\n\n                    @Override\n                    public void onComplete() {\n                        if (onComplete != null && !subscription.isDisposed()) {\n                            try {\n                                onComplete.run();\n                            } catch (Exception e) {\n                                onError(e);\n                            }\n                        }\n                    }\n\n                    @Override\n                    public void onSubscribe(Disposable d) {\n                        subscription = d;\n                    }\n\n                    @Override\n                    public void onNext(T t) {\n                        if (onNext != null && !subscription.isDisposed()) {\n                            try {\n                                onNext.accept(t);\n                            } catch (Exception e) {\n                                onError(e);\n                            }\n                        }\n                    }\n                });\n    }\n\n    private void execute(Observer<T> observer) {\n        Observable<T> observable;\n        try {\n            checkConditions();\n            observable = buildObservable();\n        } catch (Exception e) {\n            observable = Observable.create(observableEmitter -> observableEmitter.onError(e));\n        }\n        // cancel latest execution\n        cancel();\n        if (isDelay3Second) {\n            observable.subscribeOn(Schedulers.io())\n                    .delay(3, TimeUnit.SECONDS)\n                    .observeOn(postInteractionThread.getScheduler())\n                    .subscribe(observer);\n        } else {\n            observable.subscribeOn(Schedulers.io())\n                    .observeOn(AndroidSchedulers.mainThread())\n                    .subscribe(observer);\n        }\n    }\n\n    public void cancel() {\n        if (!subscription.isDisposed()) {\n            subscription.dispose();\n        }\n    }\n\n    public boolean isCancel() {\n        return subscription == null || subscription.isDisposed();\n    }\n\n    public Observable<T> getObservable() {\n        return buildObservable();\n    }\n    private void handleHttpError(Throwable e) {\n        if (e instanceof RuntimeException) {\n            if (e.getCause() instanceof ConnectException) {\n                mEventBus.post(new OnHttpErrorEvent(\"连接失败，请检查网络后再试\"));\n            }\n            if (e.getCause() instanceof SocketTimeoutException) {\n                mEventBus.post(new OnHttpErrorEvent(\"请求超时，请检查网络后再试\"));\n            }\n            if (e.getCause() instanceof UnknownHostException) {\n                mEventBus.post(new OnHttpErrorEvent(\"域名连接失败，请检查网络后再试\"));\n            }\n            if (e.getCause() instanceof NetworkErrorException) {\n                mEventBus.post(new OnHttpErrorEvent(\"网络异常，请检查网络后再试\"));\n            }\n        }\n        if (e instanceof ConnectException) {\n            mEventBus.post(new OnHttpErrorEvent(\"连接失败，请检查网络后再试\"));\n        }\n        if (e instanceof SocketTimeoutException) {\n            mEventBus.post(new OnHttpErrorEvent(\"请求超时，请检查网络后再试\"));\n        }\n        if (e instanceof UnknownHostException) {\n            mEventBus.post(new OnHttpErrorEvent(\"域名连接失败，请检查网络后再试\"));\n        }\n        if (e instanceof NetworkErrorException) {\n            mEventBus.post(new OnHttpErrorEvent(\"网络异常，请检查网络后再试\"));\n        }\n    }\n}\n\n```\ninteractor可以说是整个domain的精华，首先包装了observable，然后在执行部分统一处理了异常等。并且切换线程也提供了统一的处理方式，这样完善的避免了OKhttp无法统一的问题。从上层提供了处理的机制。而且此处需要的是observable，刚好可以通过retrofit2进行提供。这样就形成了一个闭环，只需要对接interactor，然后接上retrofit提供的接口即可完整的处理网络请求。\n\ndomain中除了基类interactor，另外还提供了一系列基于基类interactor衍生的网络请求实体类，虽然此处这些实体类的存在仅仅使用到了接口来实现。接口的具体实现还需要更上一层来完成。但是巧妙的是此处通过dagger的注入，将上层提供的实现方法注入到了下层，这样实现的底层可以直接拿来用。\n\n### data层\n\ndomain层是独立的，无任何模块依赖，而data层就是domain层更上一层的，仅仅只依赖于domain模块。\n\ndata层是数据层，此处主要是处理或者说提供数据。domain层需要的接口实现就是在data层实现好了通过dagger注入到底层。\n\ndata层除了数据提供者这一个身份外，还有一个数据缓存者这个身份。整个data在关键的地方，比如说userbody，usercache等地方设置了三级缓存。这样完整的实现了一个数据层的功能。\n\ndata层对于数据的处理方面集中在获取，提供，以及保存。将数据隔离的效果很明显能够大幅度解耦。\n\n如果data层不隔离，那么获取的数据，存储的数据，提供者，三者会混乱，在A区域获取的数据可能和B区域获取的数据不同。当处于不同模块的代码进行相同的缓存，又会导致缓存不同步，而相同的代码进行不同的缓存，更是乱七八糟。因此这一层做隔离，哪怕是仅仅只有数据区域做隔离，总好过数据区域掺杂在不同的区域而导致相同的数据采用了过多缓存步骤。\n\n另外项目中提供的缓存方法，主要是ACache和Lrucache这两个老牌的库,\n\n```\npublic interface CacheStore {\n    int NONE_TIME = 0;\n    int DURATION_ONE_MINUTE = 60;\n    int DURATION_ONE_HOUR = DURATION_ONE_MINUTE * 60;\n    int DURATION_THREE_HOUR = DURATION_ONE_HOUR * 3;\n    int DURATION_ONE_DAY = DURATION_ONE_HOUR * 24;\n    int DURATION_FIVE_MINUTE = DURATION_ONE_MINUTE * 5;\n\n    void put(String key, byte[] data);\n    void put(String key, byte[] data, int duration);\n    byte[] get(String key);\n    void put(String key, Serializable obj);\n    void put(String key, Serializable obj, int duration);\n    Object getAsObject(String key);\n    void put(String key, boolean value);\n    boolean getAsBoolean(String key);\n    void clear();\n    void remove(String key);\n}\n```\n\n实现缓存使用的就是这个模板，这个模板演化为两个，一个memstore，一个DiskcatchStore。memstore就是内存缓存，仿照的是Lrucache，主要是规避gc的清除，实现的原理看一下就懂了。diskcatchstore就是文件缓存，使用的是Acache来实现的，甚至可以说是一个封装而已。\n\n实现缓存有个方法\n```\nvoid put(String key, Serializable obj, int duration);\n```\n其中有保存时长，这个保留的时长会转化为当前时间+时长的时间戳，将和data一起包装起来存储，在取出保存的data时会进行判断，如果携带了时间信息，就对时间进行判断，如果时间过期，那么在memcache里面就是移除这个key，在Acache里面也是相同的原理\n\n### baselibrary层\n\nbaselibrary是data层之上的一层。如果说domain是心脏，data是血液的话，那么baselibrary就是骨架。\n\nbaselibrary将所有用到的库进行综合，自我封装，以及改写，然后通过暴露api的方式让上层可以直接使用暴露出来的api\n\n到baselibrary这一层截止，整个项目的脚手架就已经都搭建ok，也就是到这一层为止，整个项目的核心基本上就已经完成。如果需要热插拔，使用我们的项目另外新建一个新的项目的话，那么只需要将baselibrary这一层以下的进行迁移，然后复写逻辑即可。\n\nbaselibrary在后期逐渐演化为和app混合了。\n\n### app层\n\napp是整个项目的逻辑层，当然也做了很多初始化的工作，最重要的比如说dagger的初始化工作，app层就像是肌肉，在肌肉填充满了之后，才会成为一个正常的人。\n\n\n\n\n\n\n","source":"_posts/项目架构总结.md","raw":"---\ntitle: 项目架构总结\ndate: 2018-11-14 11:29:32\ntags: andrid\n---\n\n该篇文章主要是分析一下目前项目的架构。\n\n# 背景\n\n好搭作为一个较为成熟的软件，从2016年我刚毕业的那年开始进行设计架构，到现在过了整整2年了。经手该项目的有大约20人了，我算是第四代接手这个项目的人。\n\n# 架构\n\n## clean结构\n\n![clean结构示意图](/images/架构/clean架构图.png)\n\n一开始看到这个架构是挺懵逼的，以前听说的时候知道这个架构是谷歌的，主要是用于项目架构，目的是为了解耦。\n\n项目中依托clean架构搭建了一套完整的解耦系统。\n\n### domain层\n\ndomian层是最内层，提供了项目的基础架构，包括了接口，util方法类（可以被视为实体类），model（完整的实体对象），event（消息通知的实体对象），exception（所有的自定义异常实体对象）\n\n另外提供了精华处，针对网络的封装实体对象，interactor\n\n```\npublic interface InteractorExecutor extends Executor {\n\n}\n```\n\n这是一个内部写的interactorexcutor，其实就是继承了executor，作为处理runnable的方式。\n\n另外还写了一个PostInteractionThread，作为获取线程的方式。\n\n```\npublic interface PostInteractionThread {\n    Scheduler getScheduler();\n}\n```\n仅提供了很简单的方法\n\ninteractor类：\n\n```\npublic abstract class Interactor<T> {\n\n    private static final boolean isDelay3Second = false;\n    protected PostInteractionThread postInteractionThread;\n    protected InteractorExecutor interactorExecutor;\n    private EventBus mEventBus;\n    private Disposable subscription = Disposables.empty();\n\n    public Interactor(InteractorExecutor interactorExecutor, PostInteractionThread postInteractionThread) {\n        this.postInteractionThread = postInteractionThread;\n        this.interactorExecutor = interactorExecutor;\n\n        mEventBus = EventBus.getDefault();\n    }\n\n    protected abstract Observable<T> buildObservable();\n\n    protected void checkConditions() {\n    }\n\n    public T executeSync() {\n        return buildObservable().blockingFirst();\n    }\n\n    public void execute(Consumer<? super T> onNext) {\n        execute(onNext, null, null);\n    }\n\n    public void execute(Consumer<? super T> onNext, Consumer<Throwable> onError) {\n        execute(onNext, onError, null);\n    }\n\n    public void execute(Consumer<? super T> onNext, Consumer<Throwable> onError, Action onComplete) {\n\n        execute(\n                new Observer<T>() {\n                    @Override\n                    public void onError(Throwable e) {\n                        Throwable t = new Exception();\n                        if (e instanceof HttpException) {\n                            if (((HttpException) e).code() == 401) {\n                                HttpException s = (HttpException) e;\n                                if (s != null && s.response() != null && s.response().errorBody() != null) {\n                                    try {\n                                        HttpErrorBody body = new Gson().fromJson(s.response().errorBody().string(), HttpErrorBody.class);\n                                        if (body != null && body.getError_reason() != null && body.getError_reason().startsWith(\"AuthenticationFailed\")) {\n                                            //todo\n                                        } else {\n                                            mEventBus.post(new OnAuthExpiredEvent());\n                                        }\n                                    } catch (IOException e1) {\n                                        e1.printStackTrace();\n                                        mEventBus.post(new OnAuthExpiredEvent());\n                                    }\n                                } else {\n                                    mEventBus.post(new OnAuthExpiredEvent());\n                                }\n                            } else if (((HttpException) e).code() == 400 || ((HttpException) e).code() == 403 || ((HttpException) e).code() == 500) {\n                                try {\n                                    if (((HttpException) e).response() != null && ((HttpException) e).response().errorBody() != null) {\n                                        String json = ((HttpException) e).response().errorBody().string();\n                                        HttpErrorBody body = new Gson().fromJson(json, HttpErrorBody.class);\n                                        HttpErrorMessageBody messageBody = new Gson().fromJson(json, HttpErrorMessageBody.class);\n                                        if (body != null && body.getError_reason() != null) {\n//                                            mEventBus.post(new OnHttpErrorEvent(body.getError_reason()));\n                                        } else if (messageBody != null && messageBody.getMessage() != null) {\n                                            mEventBus.post(new OnHttpErrorEvent(messageBody.getCode(), messageBody.getMessage()));\n                                        } else {\n                                            mEventBus.post(new OnHttpErrorEvent(\"网络异常，请稍后再试\"));\n                                        }\n                                        t = new Exception(messageBody.getMessage());\n                                    }\n\n                                } catch (Exception e1) {\n                                    e1.printStackTrace();\n                                }\n                            }\n                        }\n                        if (onError == null || subscription.isDisposed()) {\n                            e.printStackTrace();\n                        } else {\n                            try {\n                                onError.accept(t);\n                            } catch (Exception e1) {\n                                e1.printStackTrace();\n                            }\n                        }\n                        handleHttpError(e);\n                    }\n\n                    @Override\n                    public void onComplete() {\n                        if (onComplete != null && !subscription.isDisposed()) {\n                            try {\n                                onComplete.run();\n                            } catch (Exception e) {\n                                onError(e);\n                            }\n                        }\n                    }\n\n                    @Override\n                    public void onSubscribe(Disposable d) {\n                        subscription = d;\n                    }\n\n                    @Override\n                    public void onNext(T t) {\n                        if (onNext != null && !subscription.isDisposed()) {\n                            try {\n                                onNext.accept(t);\n                            } catch (Exception e) {\n                                onError(e);\n                            }\n                        }\n                    }\n                });\n    }\n\n    private void execute(Observer<T> observer) {\n        Observable<T> observable;\n        try {\n            checkConditions();\n            observable = buildObservable();\n        } catch (Exception e) {\n            observable = Observable.create(observableEmitter -> observableEmitter.onError(e));\n        }\n        // cancel latest execution\n        cancel();\n        if (isDelay3Second) {\n            observable.subscribeOn(Schedulers.io())\n                    .delay(3, TimeUnit.SECONDS)\n                    .observeOn(postInteractionThread.getScheduler())\n                    .subscribe(observer);\n        } else {\n            observable.subscribeOn(Schedulers.io())\n                    .observeOn(AndroidSchedulers.mainThread())\n                    .subscribe(observer);\n        }\n    }\n\n    public void cancel() {\n        if (!subscription.isDisposed()) {\n            subscription.dispose();\n        }\n    }\n\n    public boolean isCancel() {\n        return subscription == null || subscription.isDisposed();\n    }\n\n    public Observable<T> getObservable() {\n        return buildObservable();\n    }\n    private void handleHttpError(Throwable e) {\n        if (e instanceof RuntimeException) {\n            if (e.getCause() instanceof ConnectException) {\n                mEventBus.post(new OnHttpErrorEvent(\"连接失败，请检查网络后再试\"));\n            }\n            if (e.getCause() instanceof SocketTimeoutException) {\n                mEventBus.post(new OnHttpErrorEvent(\"请求超时，请检查网络后再试\"));\n            }\n            if (e.getCause() instanceof UnknownHostException) {\n                mEventBus.post(new OnHttpErrorEvent(\"域名连接失败，请检查网络后再试\"));\n            }\n            if (e.getCause() instanceof NetworkErrorException) {\n                mEventBus.post(new OnHttpErrorEvent(\"网络异常，请检查网络后再试\"));\n            }\n        }\n        if (e instanceof ConnectException) {\n            mEventBus.post(new OnHttpErrorEvent(\"连接失败，请检查网络后再试\"));\n        }\n        if (e instanceof SocketTimeoutException) {\n            mEventBus.post(new OnHttpErrorEvent(\"请求超时，请检查网络后再试\"));\n        }\n        if (e instanceof UnknownHostException) {\n            mEventBus.post(new OnHttpErrorEvent(\"域名连接失败，请检查网络后再试\"));\n        }\n        if (e instanceof NetworkErrorException) {\n            mEventBus.post(new OnHttpErrorEvent(\"网络异常，请检查网络后再试\"));\n        }\n    }\n}\n\n```\ninteractor可以说是整个domain的精华，首先包装了observable，然后在执行部分统一处理了异常等。并且切换线程也提供了统一的处理方式，这样完善的避免了OKhttp无法统一的问题。从上层提供了处理的机制。而且此处需要的是observable，刚好可以通过retrofit2进行提供。这样就形成了一个闭环，只需要对接interactor，然后接上retrofit提供的接口即可完整的处理网络请求。\n\ndomain中除了基类interactor，另外还提供了一系列基于基类interactor衍生的网络请求实体类，虽然此处这些实体类的存在仅仅使用到了接口来实现。接口的具体实现还需要更上一层来完成。但是巧妙的是此处通过dagger的注入，将上层提供的实现方法注入到了下层，这样实现的底层可以直接拿来用。\n\n### data层\n\ndomain层是独立的，无任何模块依赖，而data层就是domain层更上一层的，仅仅只依赖于domain模块。\n\ndata层是数据层，此处主要是处理或者说提供数据。domain层需要的接口实现就是在data层实现好了通过dagger注入到底层。\n\ndata层除了数据提供者这一个身份外，还有一个数据缓存者这个身份。整个data在关键的地方，比如说userbody，usercache等地方设置了三级缓存。这样完整的实现了一个数据层的功能。\n\ndata层对于数据的处理方面集中在获取，提供，以及保存。将数据隔离的效果很明显能够大幅度解耦。\n\n如果data层不隔离，那么获取的数据，存储的数据，提供者，三者会混乱，在A区域获取的数据可能和B区域获取的数据不同。当处于不同模块的代码进行相同的缓存，又会导致缓存不同步，而相同的代码进行不同的缓存，更是乱七八糟。因此这一层做隔离，哪怕是仅仅只有数据区域做隔离，总好过数据区域掺杂在不同的区域而导致相同的数据采用了过多缓存步骤。\n\n另外项目中提供的缓存方法，主要是ACache和Lrucache这两个老牌的库,\n\n```\npublic interface CacheStore {\n    int NONE_TIME = 0;\n    int DURATION_ONE_MINUTE = 60;\n    int DURATION_ONE_HOUR = DURATION_ONE_MINUTE * 60;\n    int DURATION_THREE_HOUR = DURATION_ONE_HOUR * 3;\n    int DURATION_ONE_DAY = DURATION_ONE_HOUR * 24;\n    int DURATION_FIVE_MINUTE = DURATION_ONE_MINUTE * 5;\n\n    void put(String key, byte[] data);\n    void put(String key, byte[] data, int duration);\n    byte[] get(String key);\n    void put(String key, Serializable obj);\n    void put(String key, Serializable obj, int duration);\n    Object getAsObject(String key);\n    void put(String key, boolean value);\n    boolean getAsBoolean(String key);\n    void clear();\n    void remove(String key);\n}\n```\n\n实现缓存使用的就是这个模板，这个模板演化为两个，一个memstore，一个DiskcatchStore。memstore就是内存缓存，仿照的是Lrucache，主要是规避gc的清除，实现的原理看一下就懂了。diskcatchstore就是文件缓存，使用的是Acache来实现的，甚至可以说是一个封装而已。\n\n实现缓存有个方法\n```\nvoid put(String key, Serializable obj, int duration);\n```\n其中有保存时长，这个保留的时长会转化为当前时间+时长的时间戳，将和data一起包装起来存储，在取出保存的data时会进行判断，如果携带了时间信息，就对时间进行判断，如果时间过期，那么在memcache里面就是移除这个key，在Acache里面也是相同的原理\n\n### baselibrary层\n\nbaselibrary是data层之上的一层。如果说domain是心脏，data是血液的话，那么baselibrary就是骨架。\n\nbaselibrary将所有用到的库进行综合，自我封装，以及改写，然后通过暴露api的方式让上层可以直接使用暴露出来的api\n\n到baselibrary这一层截止，整个项目的脚手架就已经都搭建ok，也就是到这一层为止，整个项目的核心基本上就已经完成。如果需要热插拔，使用我们的项目另外新建一个新的项目的话，那么只需要将baselibrary这一层以下的进行迁移，然后复写逻辑即可。\n\nbaselibrary在后期逐渐演化为和app混合了。\n\n### app层\n\napp是整个项目的逻辑层，当然也做了很多初始化的工作，最重要的比如说dagger的初始化工作，app层就像是肌肉，在肌肉填充满了之后，才会成为一个正常的人。\n\n\n\n\n\n\n","slug":"项目架构总结","published":1,"updated":"2019-03-12T09:26:33.171Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltu0900723a8kybkgi8yg","content":"<p>该篇文章主要是分析一下目前项目的架构。</p>\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>好搭作为一个较为成熟的软件，从2016年我刚毕业的那年开始进行设计架构，到现在过了整整2年了。经手该项目的有大约20人了，我算是第四代接手这个项目的人。</p>\n<h1 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h1><h2 id=\"clean结构\"><a href=\"#clean结构\" class=\"headerlink\" title=\"clean结构\"></a>clean结构</h2><p><img src=\"/images/架构/clean架构图.png\" alt=\"clean结构示意图\"></p>\n<p>一开始看到这个架构是挺懵逼的，以前听说的时候知道这个架构是谷歌的，主要是用于项目架构，目的是为了解耦。</p>\n<p>项目中依托clean架构搭建了一套完整的解耦系统。</p>\n<h3 id=\"domain层\"><a href=\"#domain层\" class=\"headerlink\" title=\"domain层\"></a>domain层</h3><p>domian层是最内层，提供了项目的基础架构，包括了接口，util方法类（可以被视为实体类），model（完整的实体对象），event（消息通知的实体对象），exception（所有的自定义异常实体对象）</p>\n<p>另外提供了精华处，针对网络的封装实体对象，interactor</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface InteractorExecutor extends Executor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个内部写的interactorexcutor，其实就是继承了executor，作为处理runnable的方式。</p>\n<p>另外还写了一个PostInteractionThread，作为获取线程的方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface PostInteractionThread &#123;</span><br><span class=\"line\">    Scheduler getScheduler();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>仅提供了很简单的方法</p>\n<p>interactor类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class Interactor&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final boolean isDelay3Second = false;</span><br><span class=\"line\">    protected PostInteractionThread postInteractionThread;</span><br><span class=\"line\">    protected InteractorExecutor interactorExecutor;</span><br><span class=\"line\">    private EventBus mEventBus;</span><br><span class=\"line\">    private Disposable subscription = Disposables.empty();</span><br><span class=\"line\"></span><br><span class=\"line\">    public Interactor(InteractorExecutor interactorExecutor, PostInteractionThread postInteractionThread) &#123;</span><br><span class=\"line\">        this.postInteractionThread = postInteractionThread;</span><br><span class=\"line\">        this.interactorExecutor = interactorExecutor;</span><br><span class=\"line\"></span><br><span class=\"line\">        mEventBus = EventBus.getDefault();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected abstract Observable&lt;T&gt; buildObservable();</span><br><span class=\"line\"></span><br><span class=\"line\">    protected void checkConditions() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public T executeSync() &#123;</span><br><span class=\"line\">        return buildObservable().blockingFirst();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void execute(Consumer&lt;? super T&gt; onNext) &#123;</span><br><span class=\"line\">        execute(onNext, null, null);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void execute(Consumer&lt;? super T&gt; onNext, Consumer&lt;Throwable&gt; onError) &#123;</span><br><span class=\"line\">        execute(onNext, onError, null);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void execute(Consumer&lt;? super T&gt; onNext, Consumer&lt;Throwable&gt; onError, Action onComplete) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        execute(</span><br><span class=\"line\">                new Observer&lt;T&gt;() &#123;</span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    public void onError(Throwable e) &#123;</span><br><span class=\"line\">                        Throwable t = new Exception();</span><br><span class=\"line\">                        if (e instanceof HttpException) &#123;</span><br><span class=\"line\">                            if (((HttpException) e).code() == 401) &#123;</span><br><span class=\"line\">                                HttpException s = (HttpException) e;</span><br><span class=\"line\">                                if (s != null &amp;&amp; s.response() != null &amp;&amp; s.response().errorBody() != null) &#123;</span><br><span class=\"line\">                                    try &#123;</span><br><span class=\"line\">                                        HttpErrorBody body = new Gson().fromJson(s.response().errorBody().string(), HttpErrorBody.class);</span><br><span class=\"line\">                                        if (body != null &amp;&amp; body.getError_reason() != null &amp;&amp; body.getError_reason().startsWith(&quot;AuthenticationFailed&quot;)) &#123;</span><br><span class=\"line\">                                            //todo</span><br><span class=\"line\">                                        &#125; else &#123;</span><br><span class=\"line\">                                            mEventBus.post(new OnAuthExpiredEvent());</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                    &#125; catch (IOException e1) &#123;</span><br><span class=\"line\">                                        e1.printStackTrace();</span><br><span class=\"line\">                                        mEventBus.post(new OnAuthExpiredEvent());</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                &#125; else &#123;</span><br><span class=\"line\">                                    mEventBus.post(new OnAuthExpiredEvent());</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125; else if (((HttpException) e).code() == 400 || ((HttpException) e).code() == 403 || ((HttpException) e).code() == 500) &#123;</span><br><span class=\"line\">                                try &#123;</span><br><span class=\"line\">                                    if (((HttpException) e).response() != null &amp;&amp; ((HttpException) e).response().errorBody() != null) &#123;</span><br><span class=\"line\">                                        String json = ((HttpException) e).response().errorBody().string();</span><br><span class=\"line\">                                        HttpErrorBody body = new Gson().fromJson(json, HttpErrorBody.class);</span><br><span class=\"line\">                                        HttpErrorMessageBody messageBody = new Gson().fromJson(json, HttpErrorMessageBody.class);</span><br><span class=\"line\">                                        if (body != null &amp;&amp; body.getError_reason() != null) &#123;</span><br><span class=\"line\">//                                            mEventBus.post(new OnHttpErrorEvent(body.getError_reason()));</span><br><span class=\"line\">                                        &#125; else if (messageBody != null &amp;&amp; messageBody.getMessage() != null) &#123;</span><br><span class=\"line\">                                            mEventBus.post(new OnHttpErrorEvent(messageBody.getCode(), messageBody.getMessage()));</span><br><span class=\"line\">                                        &#125; else &#123;</span><br><span class=\"line\">                                            mEventBus.post(new OnHttpErrorEvent(&quot;网络异常，请稍后再试&quot;));</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                        t = new Exception(messageBody.getMessage());</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                                &#125; catch (Exception e1) &#123;</span><br><span class=\"line\">                                    e1.printStackTrace();</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        if (onError == null || subscription.isDisposed()) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125; else &#123;</span><br><span class=\"line\">                            try &#123;</span><br><span class=\"line\">                                onError.accept(t);</span><br><span class=\"line\">                            &#125; catch (Exception e1) &#123;</span><br><span class=\"line\">                                e1.printStackTrace();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        handleHttpError(e);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    public void onComplete() &#123;</span><br><span class=\"line\">                        if (onComplete != null &amp;&amp; !subscription.isDisposed()) &#123;</span><br><span class=\"line\">                            try &#123;</span><br><span class=\"line\">                                onComplete.run();</span><br><span class=\"line\">                            &#125; catch (Exception e) &#123;</span><br><span class=\"line\">                                onError(e);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    public void onSubscribe(Disposable d) &#123;</span><br><span class=\"line\">                        subscription = d;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    public void onNext(T t) &#123;</span><br><span class=\"line\">                        if (onNext != null &amp;&amp; !subscription.isDisposed()) &#123;</span><br><span class=\"line\">                            try &#123;</span><br><span class=\"line\">                                onNext.accept(t);</span><br><span class=\"line\">                            &#125; catch (Exception e) &#123;</span><br><span class=\"line\">                                onError(e);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void execute(Observer&lt;T&gt; observer) &#123;</span><br><span class=\"line\">        Observable&lt;T&gt; observable;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            checkConditions();</span><br><span class=\"line\">            observable = buildObservable();</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            observable = Observable.create(observableEmitter -&gt; observableEmitter.onError(e));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // cancel latest execution</span><br><span class=\"line\">        cancel();</span><br><span class=\"line\">        if (isDelay3Second) &#123;</span><br><span class=\"line\">            observable.subscribeOn(Schedulers.io())</span><br><span class=\"line\">                    .delay(3, TimeUnit.SECONDS)</span><br><span class=\"line\">                    .observeOn(postInteractionThread.getScheduler())</span><br><span class=\"line\">                    .subscribe(observer);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            observable.subscribeOn(Schedulers.io())</span><br><span class=\"line\">                    .observeOn(AndroidSchedulers.mainThread())</span><br><span class=\"line\">                    .subscribe(observer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void cancel() &#123;</span><br><span class=\"line\">        if (!subscription.isDisposed()) &#123;</span><br><span class=\"line\">            subscription.dispose();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean isCancel() &#123;</span><br><span class=\"line\">        return subscription == null || subscription.isDisposed();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Observable&lt;T&gt; getObservable() &#123;</span><br><span class=\"line\">        return buildObservable();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private void handleHttpError(Throwable e) &#123;</span><br><span class=\"line\">        if (e instanceof RuntimeException) &#123;</span><br><span class=\"line\">            if (e.getCause() instanceof ConnectException) &#123;</span><br><span class=\"line\">                mEventBus.post(new OnHttpErrorEvent(&quot;连接失败，请检查网络后再试&quot;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (e.getCause() instanceof SocketTimeoutException) &#123;</span><br><span class=\"line\">                mEventBus.post(new OnHttpErrorEvent(&quot;请求超时，请检查网络后再试&quot;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (e.getCause() instanceof UnknownHostException) &#123;</span><br><span class=\"line\">                mEventBus.post(new OnHttpErrorEvent(&quot;域名连接失败，请检查网络后再试&quot;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (e.getCause() instanceof NetworkErrorException) &#123;</span><br><span class=\"line\">                mEventBus.post(new OnHttpErrorEvent(&quot;网络异常，请检查网络后再试&quot;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (e instanceof ConnectException) &#123;</span><br><span class=\"line\">            mEventBus.post(new OnHttpErrorEvent(&quot;连接失败，请检查网络后再试&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (e instanceof SocketTimeoutException) &#123;</span><br><span class=\"line\">            mEventBus.post(new OnHttpErrorEvent(&quot;请求超时，请检查网络后再试&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (e instanceof UnknownHostException) &#123;</span><br><span class=\"line\">            mEventBus.post(new OnHttpErrorEvent(&quot;域名连接失败，请检查网络后再试&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (e instanceof NetworkErrorException) &#123;</span><br><span class=\"line\">            mEventBus.post(new OnHttpErrorEvent(&quot;网络异常，请检查网络后再试&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>interactor可以说是整个domain的精华，首先包装了observable，然后在执行部分统一处理了异常等。并且切换线程也提供了统一的处理方式，这样完善的避免了OKhttp无法统一的问题。从上层提供了处理的机制。而且此处需要的是observable，刚好可以通过retrofit2进行提供。这样就形成了一个闭环，只需要对接interactor，然后接上retrofit提供的接口即可完整的处理网络请求。</p>\n<p>domain中除了基类interactor，另外还提供了一系列基于基类interactor衍生的网络请求实体类，虽然此处这些实体类的存在仅仅使用到了接口来实现。接口的具体实现还需要更上一层来完成。但是巧妙的是此处通过dagger的注入，将上层提供的实现方法注入到了下层，这样实现的底层可以直接拿来用。</p>\n<h3 id=\"data层\"><a href=\"#data层\" class=\"headerlink\" title=\"data层\"></a>data层</h3><p>domain层是独立的，无任何模块依赖，而data层就是domain层更上一层的，仅仅只依赖于domain模块。</p>\n<p>data层是数据层，此处主要是处理或者说提供数据。domain层需要的接口实现就是在data层实现好了通过dagger注入到底层。</p>\n<p>data层除了数据提供者这一个身份外，还有一个数据缓存者这个身份。整个data在关键的地方，比如说userbody，usercache等地方设置了三级缓存。这样完整的实现了一个数据层的功能。</p>\n<p>data层对于数据的处理方面集中在获取，提供，以及保存。将数据隔离的效果很明显能够大幅度解耦。</p>\n<p>如果data层不隔离，那么获取的数据，存储的数据，提供者，三者会混乱，在A区域获取的数据可能和B区域获取的数据不同。当处于不同模块的代码进行相同的缓存，又会导致缓存不同步，而相同的代码进行不同的缓存，更是乱七八糟。因此这一层做隔离，哪怕是仅仅只有数据区域做隔离，总好过数据区域掺杂在不同的区域而导致相同的数据采用了过多缓存步骤。</p>\n<p>另外项目中提供的缓存方法，主要是ACache和Lrucache这两个老牌的库,</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface CacheStore &#123;</span><br><span class=\"line\">    int NONE_TIME = 0;</span><br><span class=\"line\">    int DURATION_ONE_MINUTE = 60;</span><br><span class=\"line\">    int DURATION_ONE_HOUR = DURATION_ONE_MINUTE * 60;</span><br><span class=\"line\">    int DURATION_THREE_HOUR = DURATION_ONE_HOUR * 3;</span><br><span class=\"line\">    int DURATION_ONE_DAY = DURATION_ONE_HOUR * 24;</span><br><span class=\"line\">    int DURATION_FIVE_MINUTE = DURATION_ONE_MINUTE * 5;</span><br><span class=\"line\"></span><br><span class=\"line\">    void put(String key, byte[] data);</span><br><span class=\"line\">    void put(String key, byte[] data, int duration);</span><br><span class=\"line\">    byte[] get(String key);</span><br><span class=\"line\">    void put(String key, Serializable obj);</span><br><span class=\"line\">    void put(String key, Serializable obj, int duration);</span><br><span class=\"line\">    Object getAsObject(String key);</span><br><span class=\"line\">    void put(String key, boolean value);</span><br><span class=\"line\">    boolean getAsBoolean(String key);</span><br><span class=\"line\">    void clear();</span><br><span class=\"line\">    void remove(String key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现缓存使用的就是这个模板，这个模板演化为两个，一个memstore，一个DiskcatchStore。memstore就是内存缓存，仿照的是Lrucache，主要是规避gc的清除，实现的原理看一下就懂了。diskcatchstore就是文件缓存，使用的是Acache来实现的，甚至可以说是一个封装而已。</p>\n<p>实现缓存有个方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void put(String key, Serializable obj, int duration);</span><br></pre></td></tr></table></figure></p>\n<p>其中有保存时长，这个保留的时长会转化为当前时间+时长的时间戳，将和data一起包装起来存储，在取出保存的data时会进行判断，如果携带了时间信息，就对时间进行判断，如果时间过期，那么在memcache里面就是移除这个key，在Acache里面也是相同的原理</p>\n<h3 id=\"baselibrary层\"><a href=\"#baselibrary层\" class=\"headerlink\" title=\"baselibrary层\"></a>baselibrary层</h3><p>baselibrary是data层之上的一层。如果说domain是心脏，data是血液的话，那么baselibrary就是骨架。</p>\n<p>baselibrary将所有用到的库进行综合，自我封装，以及改写，然后通过暴露api的方式让上层可以直接使用暴露出来的api</p>\n<p>到baselibrary这一层截止，整个项目的脚手架就已经都搭建ok，也就是到这一层为止，整个项目的核心基本上就已经完成。如果需要热插拔，使用我们的项目另外新建一个新的项目的话，那么只需要将baselibrary这一层以下的进行迁移，然后复写逻辑即可。</p>\n<p>baselibrary在后期逐渐演化为和app混合了。</p>\n<h3 id=\"app层\"><a href=\"#app层\" class=\"headerlink\" title=\"app层\"></a>app层</h3><p>app是整个项目的逻辑层，当然也做了很多初始化的工作，最重要的比如说dagger的初始化工作，app层就像是肌肉，在肌肉填充满了之后，才会成为一个正常的人。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>该篇文章主要是分析一下目前项目的架构。</p>\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>好搭作为一个较为成熟的软件，从2016年我刚毕业的那年开始进行设计架构，到现在过了整整2年了。经手该项目的有大约20人了，我算是第四代接手这个项目的人。</p>\n<h1 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h1><h2 id=\"clean结构\"><a href=\"#clean结构\" class=\"headerlink\" title=\"clean结构\"></a>clean结构</h2><p><img src=\"/images/架构/clean架构图.png\" alt=\"clean结构示意图\"></p>\n<p>一开始看到这个架构是挺懵逼的，以前听说的时候知道这个架构是谷歌的，主要是用于项目架构，目的是为了解耦。</p>\n<p>项目中依托clean架构搭建了一套完整的解耦系统。</p>\n<h3 id=\"domain层\"><a href=\"#domain层\" class=\"headerlink\" title=\"domain层\"></a>domain层</h3><p>domian层是最内层，提供了项目的基础架构，包括了接口，util方法类（可以被视为实体类），model（完整的实体对象），event（消息通知的实体对象），exception（所有的自定义异常实体对象）</p>\n<p>另外提供了精华处，针对网络的封装实体对象，interactor</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface InteractorExecutor extends Executor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个内部写的interactorexcutor，其实就是继承了executor，作为处理runnable的方式。</p>\n<p>另外还写了一个PostInteractionThread，作为获取线程的方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface PostInteractionThread &#123;</span><br><span class=\"line\">    Scheduler getScheduler();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>仅提供了很简单的方法</p>\n<p>interactor类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class Interactor&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final boolean isDelay3Second = false;</span><br><span class=\"line\">    protected PostInteractionThread postInteractionThread;</span><br><span class=\"line\">    protected InteractorExecutor interactorExecutor;</span><br><span class=\"line\">    private EventBus mEventBus;</span><br><span class=\"line\">    private Disposable subscription = Disposables.empty();</span><br><span class=\"line\"></span><br><span class=\"line\">    public Interactor(InteractorExecutor interactorExecutor, PostInteractionThread postInteractionThread) &#123;</span><br><span class=\"line\">        this.postInteractionThread = postInteractionThread;</span><br><span class=\"line\">        this.interactorExecutor = interactorExecutor;</span><br><span class=\"line\"></span><br><span class=\"line\">        mEventBus = EventBus.getDefault();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected abstract Observable&lt;T&gt; buildObservable();</span><br><span class=\"line\"></span><br><span class=\"line\">    protected void checkConditions() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public T executeSync() &#123;</span><br><span class=\"line\">        return buildObservable().blockingFirst();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void execute(Consumer&lt;? super T&gt; onNext) &#123;</span><br><span class=\"line\">        execute(onNext, null, null);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void execute(Consumer&lt;? super T&gt; onNext, Consumer&lt;Throwable&gt; onError) &#123;</span><br><span class=\"line\">        execute(onNext, onError, null);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void execute(Consumer&lt;? super T&gt; onNext, Consumer&lt;Throwable&gt; onError, Action onComplete) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        execute(</span><br><span class=\"line\">                new Observer&lt;T&gt;() &#123;</span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    public void onError(Throwable e) &#123;</span><br><span class=\"line\">                        Throwable t = new Exception();</span><br><span class=\"line\">                        if (e instanceof HttpException) &#123;</span><br><span class=\"line\">                            if (((HttpException) e).code() == 401) &#123;</span><br><span class=\"line\">                                HttpException s = (HttpException) e;</span><br><span class=\"line\">                                if (s != null &amp;&amp; s.response() != null &amp;&amp; s.response().errorBody() != null) &#123;</span><br><span class=\"line\">                                    try &#123;</span><br><span class=\"line\">                                        HttpErrorBody body = new Gson().fromJson(s.response().errorBody().string(), HttpErrorBody.class);</span><br><span class=\"line\">                                        if (body != null &amp;&amp; body.getError_reason() != null &amp;&amp; body.getError_reason().startsWith(&quot;AuthenticationFailed&quot;)) &#123;</span><br><span class=\"line\">                                            //todo</span><br><span class=\"line\">                                        &#125; else &#123;</span><br><span class=\"line\">                                            mEventBus.post(new OnAuthExpiredEvent());</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                    &#125; catch (IOException e1) &#123;</span><br><span class=\"line\">                                        e1.printStackTrace();</span><br><span class=\"line\">                                        mEventBus.post(new OnAuthExpiredEvent());</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                &#125; else &#123;</span><br><span class=\"line\">                                    mEventBus.post(new OnAuthExpiredEvent());</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125; else if (((HttpException) e).code() == 400 || ((HttpException) e).code() == 403 || ((HttpException) e).code() == 500) &#123;</span><br><span class=\"line\">                                try &#123;</span><br><span class=\"line\">                                    if (((HttpException) e).response() != null &amp;&amp; ((HttpException) e).response().errorBody() != null) &#123;</span><br><span class=\"line\">                                        String json = ((HttpException) e).response().errorBody().string();</span><br><span class=\"line\">                                        HttpErrorBody body = new Gson().fromJson(json, HttpErrorBody.class);</span><br><span class=\"line\">                                        HttpErrorMessageBody messageBody = new Gson().fromJson(json, HttpErrorMessageBody.class);</span><br><span class=\"line\">                                        if (body != null &amp;&amp; body.getError_reason() != null) &#123;</span><br><span class=\"line\">//                                            mEventBus.post(new OnHttpErrorEvent(body.getError_reason()));</span><br><span class=\"line\">                                        &#125; else if (messageBody != null &amp;&amp; messageBody.getMessage() != null) &#123;</span><br><span class=\"line\">                                            mEventBus.post(new OnHttpErrorEvent(messageBody.getCode(), messageBody.getMessage()));</span><br><span class=\"line\">                                        &#125; else &#123;</span><br><span class=\"line\">                                            mEventBus.post(new OnHttpErrorEvent(&quot;网络异常，请稍后再试&quot;));</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                        t = new Exception(messageBody.getMessage());</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                                &#125; catch (Exception e1) &#123;</span><br><span class=\"line\">                                    e1.printStackTrace();</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        if (onError == null || subscription.isDisposed()) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125; else &#123;</span><br><span class=\"line\">                            try &#123;</span><br><span class=\"line\">                                onError.accept(t);</span><br><span class=\"line\">                            &#125; catch (Exception e1) &#123;</span><br><span class=\"line\">                                e1.printStackTrace();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        handleHttpError(e);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    public void onComplete() &#123;</span><br><span class=\"line\">                        if (onComplete != null &amp;&amp; !subscription.isDisposed()) &#123;</span><br><span class=\"line\">                            try &#123;</span><br><span class=\"line\">                                onComplete.run();</span><br><span class=\"line\">                            &#125; catch (Exception e) &#123;</span><br><span class=\"line\">                                onError(e);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    public void onSubscribe(Disposable d) &#123;</span><br><span class=\"line\">                        subscription = d;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    public void onNext(T t) &#123;</span><br><span class=\"line\">                        if (onNext != null &amp;&amp; !subscription.isDisposed()) &#123;</span><br><span class=\"line\">                            try &#123;</span><br><span class=\"line\">                                onNext.accept(t);</span><br><span class=\"line\">                            &#125; catch (Exception e) &#123;</span><br><span class=\"line\">                                onError(e);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void execute(Observer&lt;T&gt; observer) &#123;</span><br><span class=\"line\">        Observable&lt;T&gt; observable;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            checkConditions();</span><br><span class=\"line\">            observable = buildObservable();</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            observable = Observable.create(observableEmitter -&gt; observableEmitter.onError(e));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // cancel latest execution</span><br><span class=\"line\">        cancel();</span><br><span class=\"line\">        if (isDelay3Second) &#123;</span><br><span class=\"line\">            observable.subscribeOn(Schedulers.io())</span><br><span class=\"line\">                    .delay(3, TimeUnit.SECONDS)</span><br><span class=\"line\">                    .observeOn(postInteractionThread.getScheduler())</span><br><span class=\"line\">                    .subscribe(observer);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            observable.subscribeOn(Schedulers.io())</span><br><span class=\"line\">                    .observeOn(AndroidSchedulers.mainThread())</span><br><span class=\"line\">                    .subscribe(observer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void cancel() &#123;</span><br><span class=\"line\">        if (!subscription.isDisposed()) &#123;</span><br><span class=\"line\">            subscription.dispose();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean isCancel() &#123;</span><br><span class=\"line\">        return subscription == null || subscription.isDisposed();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Observable&lt;T&gt; getObservable() &#123;</span><br><span class=\"line\">        return buildObservable();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private void handleHttpError(Throwable e) &#123;</span><br><span class=\"line\">        if (e instanceof RuntimeException) &#123;</span><br><span class=\"line\">            if (e.getCause() instanceof ConnectException) &#123;</span><br><span class=\"line\">                mEventBus.post(new OnHttpErrorEvent(&quot;连接失败，请检查网络后再试&quot;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (e.getCause() instanceof SocketTimeoutException) &#123;</span><br><span class=\"line\">                mEventBus.post(new OnHttpErrorEvent(&quot;请求超时，请检查网络后再试&quot;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (e.getCause() instanceof UnknownHostException) &#123;</span><br><span class=\"line\">                mEventBus.post(new OnHttpErrorEvent(&quot;域名连接失败，请检查网络后再试&quot;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (e.getCause() instanceof NetworkErrorException) &#123;</span><br><span class=\"line\">                mEventBus.post(new OnHttpErrorEvent(&quot;网络异常，请检查网络后再试&quot;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (e instanceof ConnectException) &#123;</span><br><span class=\"line\">            mEventBus.post(new OnHttpErrorEvent(&quot;连接失败，请检查网络后再试&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (e instanceof SocketTimeoutException) &#123;</span><br><span class=\"line\">            mEventBus.post(new OnHttpErrorEvent(&quot;请求超时，请检查网络后再试&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (e instanceof UnknownHostException) &#123;</span><br><span class=\"line\">            mEventBus.post(new OnHttpErrorEvent(&quot;域名连接失败，请检查网络后再试&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (e instanceof NetworkErrorException) &#123;</span><br><span class=\"line\">            mEventBus.post(new OnHttpErrorEvent(&quot;网络异常，请检查网络后再试&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>interactor可以说是整个domain的精华，首先包装了observable，然后在执行部分统一处理了异常等。并且切换线程也提供了统一的处理方式，这样完善的避免了OKhttp无法统一的问题。从上层提供了处理的机制。而且此处需要的是observable，刚好可以通过retrofit2进行提供。这样就形成了一个闭环，只需要对接interactor，然后接上retrofit提供的接口即可完整的处理网络请求。</p>\n<p>domain中除了基类interactor，另外还提供了一系列基于基类interactor衍生的网络请求实体类，虽然此处这些实体类的存在仅仅使用到了接口来实现。接口的具体实现还需要更上一层来完成。但是巧妙的是此处通过dagger的注入，将上层提供的实现方法注入到了下层，这样实现的底层可以直接拿来用。</p>\n<h3 id=\"data层\"><a href=\"#data层\" class=\"headerlink\" title=\"data层\"></a>data层</h3><p>domain层是独立的，无任何模块依赖，而data层就是domain层更上一层的，仅仅只依赖于domain模块。</p>\n<p>data层是数据层，此处主要是处理或者说提供数据。domain层需要的接口实现就是在data层实现好了通过dagger注入到底层。</p>\n<p>data层除了数据提供者这一个身份外，还有一个数据缓存者这个身份。整个data在关键的地方，比如说userbody，usercache等地方设置了三级缓存。这样完整的实现了一个数据层的功能。</p>\n<p>data层对于数据的处理方面集中在获取，提供，以及保存。将数据隔离的效果很明显能够大幅度解耦。</p>\n<p>如果data层不隔离，那么获取的数据，存储的数据，提供者，三者会混乱，在A区域获取的数据可能和B区域获取的数据不同。当处于不同模块的代码进行相同的缓存，又会导致缓存不同步，而相同的代码进行不同的缓存，更是乱七八糟。因此这一层做隔离，哪怕是仅仅只有数据区域做隔离，总好过数据区域掺杂在不同的区域而导致相同的数据采用了过多缓存步骤。</p>\n<p>另外项目中提供的缓存方法，主要是ACache和Lrucache这两个老牌的库,</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface CacheStore &#123;</span><br><span class=\"line\">    int NONE_TIME = 0;</span><br><span class=\"line\">    int DURATION_ONE_MINUTE = 60;</span><br><span class=\"line\">    int DURATION_ONE_HOUR = DURATION_ONE_MINUTE * 60;</span><br><span class=\"line\">    int DURATION_THREE_HOUR = DURATION_ONE_HOUR * 3;</span><br><span class=\"line\">    int DURATION_ONE_DAY = DURATION_ONE_HOUR * 24;</span><br><span class=\"line\">    int DURATION_FIVE_MINUTE = DURATION_ONE_MINUTE * 5;</span><br><span class=\"line\"></span><br><span class=\"line\">    void put(String key, byte[] data);</span><br><span class=\"line\">    void put(String key, byte[] data, int duration);</span><br><span class=\"line\">    byte[] get(String key);</span><br><span class=\"line\">    void put(String key, Serializable obj);</span><br><span class=\"line\">    void put(String key, Serializable obj, int duration);</span><br><span class=\"line\">    Object getAsObject(String key);</span><br><span class=\"line\">    void put(String key, boolean value);</span><br><span class=\"line\">    boolean getAsBoolean(String key);</span><br><span class=\"line\">    void clear();</span><br><span class=\"line\">    void remove(String key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现缓存使用的就是这个模板，这个模板演化为两个，一个memstore，一个DiskcatchStore。memstore就是内存缓存，仿照的是Lrucache，主要是规避gc的清除，实现的原理看一下就懂了。diskcatchstore就是文件缓存，使用的是Acache来实现的，甚至可以说是一个封装而已。</p>\n<p>实现缓存有个方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void put(String key, Serializable obj, int duration);</span><br></pre></td></tr></table></figure></p>\n<p>其中有保存时长，这个保留的时长会转化为当前时间+时长的时间戳，将和data一起包装起来存储，在取出保存的data时会进行判断，如果携带了时间信息，就对时间进行判断，如果时间过期，那么在memcache里面就是移除这个key，在Acache里面也是相同的原理</p>\n<h3 id=\"baselibrary层\"><a href=\"#baselibrary层\" class=\"headerlink\" title=\"baselibrary层\"></a>baselibrary层</h3><p>baselibrary是data层之上的一层。如果说domain是心脏，data是血液的话，那么baselibrary就是骨架。</p>\n<p>baselibrary将所有用到的库进行综合，自我封装，以及改写，然后通过暴露api的方式让上层可以直接使用暴露出来的api</p>\n<p>到baselibrary这一层截止，整个项目的脚手架就已经都搭建ok，也就是到这一层为止，整个项目的核心基本上就已经完成。如果需要热插拔，使用我们的项目另外新建一个新的项目的话，那么只需要将baselibrary这一层以下的进行迁移，然后复写逻辑即可。</p>\n<p>baselibrary在后期逐渐演化为和app混合了。</p>\n<h3 id=\"app层\"><a href=\"#app层\" class=\"headerlink\" title=\"app层\"></a>app层</h3><p>app是整个项目的逻辑层，当然也做了很多初始化的工作，最重要的比如说dagger的初始化工作，app层就像是肌肉，在肌肉填充满了之后，才会成为一个正常的人。</p>\n"},{"title":"java基础知识点","date":"2018-01-31T15:15:56.000Z","_content":"\n感冒了好几天，昨天没有写blog，心慌慌。\n\n这篇从java核心来讲，估计要整理一阵\n\n# java 核心\n\n+ oop的概念\n\n1. 抽象\n\n在面向对象的概念中，所有对象都是由类来描述，但是反过来，并不是所有类都是用来描述对象的。如果一个类中没有包含足够信息来描绘一个具体的对象，这样的类就是抽象类。\n\n2. 继承\n\n继承（英语：inheritance）是面向对象软件技术当中的一个概念。如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。 一般静态的面向对象编程语言，继承属于静态的，意即在子类别的行为在编译期就已经决定，无法在执行期扩充。 有些编程语言支持多重继承，即一个子类别可以同时有多个父类别，比如C++编程语言；而在有些编程语言中，一个子类别只能继承自一个父类别，比如Java编程语言，这时可以利用接口来实现与多重继承相似的效果。 现今面向对象程式设计技巧中，继承并非以继承类别的“行为”为主，而是继承类别的“型态”，使得元件的型态一致。另外在设计模式中提到一个守则，“多用合成，少用继承”，此守则也是用来处理继承无法在执行期动态扩充行为的遗憾。\n\n3. 封装\n\n从字面上理解就是包装的意思，是指利用抽象数据类型，将数据和关于数据的操作封装起来，使其成为一个不可分割的独立实体。数据将会被保护在抽象数据类型的内部，仅能够通过暴露在表面的操作（public方法，比如setter和getter）来与这个对象进行交流和交互。用户不知道对象的内部细节，但是通过该对象提供的接口来访问对象。其好处是：减少耦合，方便地在未来修改调整自己，更加有把握地（精确地）控制成员，隐藏信息，实现细节。\n\n4. 多态\n\n使用相同的消息，使得类作出不同的反应（继承为我们使用多态打下了基础）。Java实现多态有三个必要条件：继承、重写、向上转型。\n\n+ 面向对象的三个基本元素和五个原则\n\n+ 三个元素：\n\n1. 封装： 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。\n\n2. 继承： 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。\n\n3. 多态： 多态性是指允许不同类的对象对同一消息作出 响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。\n\n+ 五个基本原则：\n\n1. 单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。\n\n2. 开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。\n\n3. Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。\n\n4. 依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。\n\n5. 接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口。\n\n+ 抽象类和接口的区别\n\n1. 抽象类是一个可同时包含具体方法和抽象方法(方法未被实现)的类。抽象方法必须被该抽象类的子类实现。抽象类是可以继承的。\n\n2. 接口像是描述类的一张蓝图或者说是类的一种契约，它包含了许多空方法，这代表着它的所有的子类都应该拥有共同点。它的子类应该提供这些空方法的具体实现。一 个类需要用 implements 来实现接口，接口可以用 extends 来继承其他接口。\n\n3. 设计模式上面来看：\n\n抽象的层次不同：抽象类对类的整体（包括属性，行为）都可以进行抽象，接口对类的局部进行抽象，具体来说接口仅仅是对类的行为进行抽象。\n\n跨域不同：抽象类是 从各种子类中提取相似的部分，然后泛化成抽象类，子类可以继承这样的抽象类。 实现接口是 不存在is-a的关系的类们，你不可以称同样可以飞行的飞机和鸟为同一个抽象类，但是他们可以有同样的接口fly-able。抽象类的父类和派生类在概念上一致，接口的原生类和派生类在仅仅在局部行为上一致。\n\n设计层次不同：抽象类是从一堆在底层的子类们来进行抽象提取，从下往上，从而产生抽象类；接口是在直接定义的高度来声明的，然后从这个高度上往下实现此接口。抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n\n+ 序列化是什么？如何实现？\n\n序列化是一种将对象转换为字节流的过程，目的是为了将对象存储到内存中，等后面再次构建该对象时可以获取到该对象先前的状态和数据信息。java中，使用Serializable和parcelable接口都可以实现，不过android中使用parcel效率高，性能高出10倍。\n\n+ 什么是单例？\n\n单例模式指的是一个类只能被初始化一次，限定一个类只能拥有一个实例。使用一个实例来和其他模块协调工作是很实用的。\n\n+ 什么是匿名内部类？\n\n普通的类可以自然的实例化自己吗，相反的，内部类却需要绑定上一个外部类才能实例。匿名内部类由于没有名字，只可以使用一次。\n\n+ 对字符串进行 == 和 equals()操作时有什么区别？\n\n == 主要比较的是两个字符串的地址，equals()假如不重写，也仅仅用于比较地址，重写就不是。\n\n+ hashcode()和equals()何时使用？\n\nhashCode()的存在主要是用于查找的快捷性，如hashtable、 hashmap等，hashcode是用来在散列存储结构中确定对象的存储地址的。\n\n如果两个对象相同，就是适用于equals()方法，那么这两个对象的hashcode一定要相同。\n\n如果对象的equals方法被重写，那么对象的hashcode也尽量重写，并且产生hashcode使用的对象，一定要和equals方法中使用的一致。\n\n两个对象的hashcode相同，并不一定就表示两个对象就相同，也就是不一定适用于equals方法，只能够说明这两个对象在散列存储结构中，如hashtable，他们“存放在同一个篮子里”\n\n+ java中 final、 finally 和finalize？\n\nfinal: 修饰变量、方法、类；修饰变量时表示这对象的值不可变，不能为这个变量赋一个新的值。修饰方法时便是我们希望把这个方法锁定，以防止任何继承类修改它的含义，这样会确保在继承中，final方法的行为不会改变，并且不会覆盖。修饰类的时候表示不打算继承该类，并且也不允许别人这样做。\n\nfinally: 是异常处理中进行收场处理的代码块，不管有没有异常，finally子句中的代码都会被执行。\n\nfinalize: 垃圾回收器准备释放对象占用的存储空间的时候，将首先调用其finalize()方法\n\n+ 什么是内存泄漏？java如何处理它？\n\n内存泄漏就是保留下来却永远不再使用的对象引用。java通过gc进行处理\n\n+ 垃圾回收器是什么？它是如何工作的？\n\n所有的对象实例都在jvm管理的堆区域分配内存，只要对象被引用，jvm就会认为它还活在进程中，一旦对象不再被引用，就不能被应用程序所访问，垃圾收集器将删除它并重新声明未使用的内存。\n\n+ 比较arrays 和arraylists\n\nArrays:一个包含许多和操作数组有关方法的类，比如说排序和查找。\nArrayList:一个容器，可以实现数组的大小可变，方便地增加和删除元素。\n\n+ 比较hashset和treeset\n\ntreeset是基于二叉树实现的，其中的数据是自动排序好的，不允许放入null值\nhashset是基于hash实现的，其中的数据是无序的，允许放入null值。\n\n+ java中的类型转换\n\n基本数据的类型转换：将一个数据范围较小的类型赋给一个数值范围较大的数值型变量，jvm在编译过程中会将此数值的类型进行自动提升。自动提升意味着数值精度至少不应该降低。而需要将数值范围较大的数值赋给数值范围较小的数值类型变量时，需要手动转换，成为强制类型转换。\n\n引用数据类型的类型转换：由于继承和向上转型，子类向父类的转换是很自然的，但是当把父类转换为子类时，强制类型转换会在运行时检查父类的真实类型，如果引用的父类对象的真实身份是子类类型，那就可以；否则如果真的是父类的类型，就会抛出ClassCastException的异常。\n\n+ 方法重载和重写的区别。\n\n重载发生在编译时，重写发生在运行时，重载方法调用与其定义的绑定发生在编译时，重写方法调用与其定义的绑定在运行时发生。\n\n静态方法可以重载，但不能重写。\n\n最基本的区别是重载是在同一个类中完成的，重写父类的话需要子类。重写是给父类的继承方法一个具体的实现。\n\n静态绑定用于方法重载，动态绑定用于方法重写。重载比重写更有效率，因为重写是在运行时完成的。\n\n私有方法和用final修饰的方法可以重载但不能重写。这意味着一个类可以有多个同名的final/private方法，子类不能重写父类的private/final方法。\n\n方法重载的情况下不关心返回值类型，他可以相同，也可以不同，重写的情况下可以有多个具体的返回值类型。\n\n重载参数列表必须不同，方法重写时参数列表必须相同。\n\n+ 什么是防卫修饰符？她们能做什么？\n\npublic、protected、private、这几个关键字叫做访问修饰符。\n作用是控制它所定义的域或者方法的访问权。\n\n+ 接口可以继承另一个接口吗？\n\n可以\n\n+ java中static关键字什么意思？\n\nstatic是java里面的非访问修饰符，可以用来创建类方法和类变量。\n当修饰一个变量的时候，此变量就成了独立于对象的静态变量，无论一个类实例化多少个对象，这个类只有一份这个静态变量的拷贝，所以static修饰的变量，即静态变量，也被叫做类变量。\n\n当修饰一个方法的时候，此方法就成了独立于对象的静态方法，静态方法不能使用类的非静态方法，因为静态变量先于非静态的其他成员初始化，静态方法先出来，然后才是非静态的，\n\n+ 什么是多态？什么是继承？\n\n多态是：允许不同类的对象对同一消息作出响应\n\n继承是：子类继承父类的特征和行为，使得子类具有父类的各种属性和方法\n\n+ integer和int之间的区别\n\ninteger是int提供的封装类，而int是java的基本数据类型；integer默认值是null，而int默认值是0，声明为integer的变量需要实例化，而声明为int的变量不需要实例化，integer是对象，用一个引用指向这个对象，而int是基本类型，直接存储数据。\n\n两个new出来的integer总是不一样的，当使用 == 时，因为其内存地址不同，所以进行 == 时返回false。\n\n两个不是new出来的integer，而是诸如integer i = x， 如果x的范围在 -128 ～ 127，其缓存指向同一个对象，所以此时使用 == 比较返回true，x范围在 -128 ～ 127之外的话，没有缓存存在，即使他们包裹的数值相同，他们也不能使用 == 得到true。\n\nint 和integer的比较，无论integer是否使用new， 其值和将平常与亮的一样：integer自动拆箱，然后和int比较，这里就不会被内存地址的不同所影响，该相等就相等。\n\n+ java中的对象是否会以引用传递或者值传递？\n\njava中的对象总是以值传递的。\n\n+ 什么是ThreadPoolExecutor?\n\n线程池是用于管理一个池子的工作线程，一个任务队列保持着一些等待执行的任务，这些任务由任何一个空闲的线程为止服务。任务是被生产者假如到队列的，同时，工作线程就像一个消费者，每当线程池里有空闲的线程，他就会开启一个后台的服务来执行一个任务。\n\nThreadPoolExecutor会使用线程池里的一个线程来执行一个任务。\n\n```\n\tThreadPoolExecutor threadPoolExecutor = \n\t\tnew ThreadPoolExecutor(int corePoolSize,\n\t\t\tint maximumPoolSize, long keepAliveTime, TimeUnit unit,\n\t\t\tBlockingQueue<Runnable> workQueue);\n```\n\ncorePoolSize: 保持在池中的最小线程数量。一开始，0个线程在池中，但是随着任务加入队列中，新的线程就会被创建。有空闲的线程，但是线程的数量小于corePoolSize，新的线程就会被继续创建。\n\nmaximumPoolSize:最大能允许的待在池中的线程数量。如果这个超过了corePoolSize而且现在线程的数量大于等于corePoolSize，那么新的工作线程会被创建，直到队列满了。\n\nkeepAliveTime: 当线程数量大于核心线程数，非核心的线程（超出空闲线程）会等着新任务来，然后如果任务到了keepAliveTime还没来，这些线程就会被冻结。\n\nunit: keepAliveTime的时间单位\n\nworkQueue:任务队列，仅仅会维持一些runnable任务，一定要是一个blockingQueue\n\nThreadPoolExecutor是一个强力的任务执行框架，它支持任务添加、任务取消、任务优先级。并且减少了之前的有关线程创建之类的开销，因为管理着一个给定数量的线程池。\n\n+ 本地变量、实例变量以及类变量之间的区别？\n\n本地变量就是局部变量，他在方法或者代码块里面被声明并使用，其内存中的位置是栈，没有默认初始化值，生命周期很短。\n实例变量是没有被static修饰的成员变量，它属于一个类的一个实例。每次new一个实例，这样的变量也new一遍，其位置在堆区，有默认初始化的值，生命周期和它所在的实例一样长。\n类变量，又称静态变量，它是被static修饰的成员变量，它属于一个类，被所有实例共享。每次new一个实例，这样的变量并不会被new一遍，其内存存在于方法区内，可以通过类名直接访问。有默认的初始化值，生命周期很长。\n\n+ 什么是反射？\n\n也就是说,在编译时,你获取了一个指向某个并不存在你的程序空间中的对象的引用;事实上在编译时你的程序无法获知这个对象所属的类\n\n+ 在java中什么是强引用、软引用、弱引用以及虚引用？\n\n强引用：不会被gc轻易清理，只要引用存在，垃圾回收器永远不会回收。\n\n软引用：非必须引用，内存溢出之前进行回收\n\n弱引用：第二次垃圾回收时回收\n\n虚引用：垃圾回收时回收，无法通过引用取到对象值。\n\n+ 关键字synchronized的作用是什么？\n\nsynchronized通过修饰一个方法或者代码块，从而产生一个同步对象锁，以及对应的同步代码块。每当有线程要对该同步代码块进行访问时，线程就会首先尝试获取这个对象的锁，并在成功获取到对象锁之后，对这个同步代码块进行正常的访问。在同步代码块的访问过程中，线程会一直持有这个对象锁，直到同步代码块访问完毕，然后才会释放。\n在上述线程中持有同步锁并且进行同步代码块访问过程中，其他线程无法获得该对象锁，也无法访问该同步代码，这些线程都会被阻塞直到上述线程访问完毕。\n\n+ 为什么说string不可变？\n\nstring类型在实现时，其内部变量全部使用final来修饰，保证成员变量的引用值只能通过构造函数来修改\nstring类型在实现时，在外部某个地方，可能修改一个string实例的内部存储值的函数实现中，在这个地方的调用返回时，一律构造新的string对象或者新的byte数组或者char数组，给赋值符号的左边变量\n\n+ 修饰符transient和volatile的作用？\n\nvolatile：易式修饰符，带有volatile修饰的变量，就是当其在某个线程自己的工作内存中发生改变时，会被强制地，写回公共成员变量所在的公共内存处。\n\ntransient是一个类型修饰符，仅仅能用来修饰字段（变量）。在此字段所在的对象进行序列化的时候，这个字段不会被序列化。\n\n其他没有transient修饰的变量将会被序列化，然后进行传输，或者存储到本地磁盘，transient变量就在这个过程里丢失了\n\n+ StringBuffer和StringBuilder的区别在哪里？\n\nStringBuffer,StringBuilder和String一样，都用来代表字符串。\nString类是不可变类，任何针对String的改变都会引起string对象的生成。而StringBuilder和StringBuffer则是可变类。StringBuilder不支持并发操作，线程不安全，不适合多线程。而StringBuffer支持并发操作，线程安全，单线程的性能低于StringBuilder\n\n+ StringBuilder怎么避免不可变字符串分配的问题？\n\nString类型在改变的时候都会生成一个新的string，然后指向这个string，因此经常改变内容的字符串最好不要用string，会导致gc。\nstringbuffer则是每次结果都会对stringbuffer对象本身操作，而不是生成新的对象。\n\n+ 什么是自动装箱和拆箱？\n\n装箱就是自动将数据类型转换为包装器类型，拆箱就是自动将包装齐类型转换为基本数据类型。\n\n```\n\tInteger i = 100;\n```\n\n这句话会被编译器执行为：\n\n```\n\tInteger i = Integer.valueOf(100);\n```\n\n这就是自动装箱\n\n```\n\tInteger i = 10; // autoboxing\n\tint c = i; // unboxing\n```\n\n+ 枚举和迭代器有什么区别？\n\n函数接口不同：枚举只有2个函数接口，只能读取集合的数据，而不能更改，迭代器有三个接口，出了读取集合的数据之外，还能进行删除操作\n\n迭代器支持failfast，而枚举不支持。\n\n+ java中fail-fast和fail-safe的区别？\n\nfail-fast： 当遍历一个集合时，集合结构若被修改，就会抛出ConcurrentModificationException。\n\nfail-safe:任何对集合的修改都会在一个复制的集合上进行修改，因此不会抛出ConcurrentModificationException。failsafe需要复制集合，产生大量的无效对象，开销大，而且无法保证读取的数据是目前原始数据结构中的数据。\n\n+ 优先级队列\n\npriorityQueue类用来表示优先队列，优先队列是一个以集合为基础的抽象数据类型，队列中的每个元素都有一个优先级值，优先级值用来表示该元素的出列的优先级\n\njava中的优先队列基于堆，堆是一个完全二叉树，所以PriorityQueue不是线性结构，而是树形结构。","source":"_posts/java基础知识点.md","raw":"---\ntitle: java基础知识点\ndate: 2018-01-31 23:15:56\ntags: java\n---\n\n感冒了好几天，昨天没有写blog，心慌慌。\n\n这篇从java核心来讲，估计要整理一阵\n\n# java 核心\n\n+ oop的概念\n\n1. 抽象\n\n在面向对象的概念中，所有对象都是由类来描述，但是反过来，并不是所有类都是用来描述对象的。如果一个类中没有包含足够信息来描绘一个具体的对象，这样的类就是抽象类。\n\n2. 继承\n\n继承（英语：inheritance）是面向对象软件技术当中的一个概念。如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。 一般静态的面向对象编程语言，继承属于静态的，意即在子类别的行为在编译期就已经决定，无法在执行期扩充。 有些编程语言支持多重继承，即一个子类别可以同时有多个父类别，比如C++编程语言；而在有些编程语言中，一个子类别只能继承自一个父类别，比如Java编程语言，这时可以利用接口来实现与多重继承相似的效果。 现今面向对象程式设计技巧中，继承并非以继承类别的“行为”为主，而是继承类别的“型态”，使得元件的型态一致。另外在设计模式中提到一个守则，“多用合成，少用继承”，此守则也是用来处理继承无法在执行期动态扩充行为的遗憾。\n\n3. 封装\n\n从字面上理解就是包装的意思，是指利用抽象数据类型，将数据和关于数据的操作封装起来，使其成为一个不可分割的独立实体。数据将会被保护在抽象数据类型的内部，仅能够通过暴露在表面的操作（public方法，比如setter和getter）来与这个对象进行交流和交互。用户不知道对象的内部细节，但是通过该对象提供的接口来访问对象。其好处是：减少耦合，方便地在未来修改调整自己，更加有把握地（精确地）控制成员，隐藏信息，实现细节。\n\n4. 多态\n\n使用相同的消息，使得类作出不同的反应（继承为我们使用多态打下了基础）。Java实现多态有三个必要条件：继承、重写、向上转型。\n\n+ 面向对象的三个基本元素和五个原则\n\n+ 三个元素：\n\n1. 封装： 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。\n\n2. 继承： 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。\n\n3. 多态： 多态性是指允许不同类的对象对同一消息作出 响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。\n\n+ 五个基本原则：\n\n1. 单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。\n\n2. 开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。\n\n3. Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。\n\n4. 依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。\n\n5. 接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口。\n\n+ 抽象类和接口的区别\n\n1. 抽象类是一个可同时包含具体方法和抽象方法(方法未被实现)的类。抽象方法必须被该抽象类的子类实现。抽象类是可以继承的。\n\n2. 接口像是描述类的一张蓝图或者说是类的一种契约，它包含了许多空方法，这代表着它的所有的子类都应该拥有共同点。它的子类应该提供这些空方法的具体实现。一 个类需要用 implements 来实现接口，接口可以用 extends 来继承其他接口。\n\n3. 设计模式上面来看：\n\n抽象的层次不同：抽象类对类的整体（包括属性，行为）都可以进行抽象，接口对类的局部进行抽象，具体来说接口仅仅是对类的行为进行抽象。\n\n跨域不同：抽象类是 从各种子类中提取相似的部分，然后泛化成抽象类，子类可以继承这样的抽象类。 实现接口是 不存在is-a的关系的类们，你不可以称同样可以飞行的飞机和鸟为同一个抽象类，但是他们可以有同样的接口fly-able。抽象类的父类和派生类在概念上一致，接口的原生类和派生类在仅仅在局部行为上一致。\n\n设计层次不同：抽象类是从一堆在底层的子类们来进行抽象提取，从下往上，从而产生抽象类；接口是在直接定义的高度来声明的，然后从这个高度上往下实现此接口。抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n\n+ 序列化是什么？如何实现？\n\n序列化是一种将对象转换为字节流的过程，目的是为了将对象存储到内存中，等后面再次构建该对象时可以获取到该对象先前的状态和数据信息。java中，使用Serializable和parcelable接口都可以实现，不过android中使用parcel效率高，性能高出10倍。\n\n+ 什么是单例？\n\n单例模式指的是一个类只能被初始化一次，限定一个类只能拥有一个实例。使用一个实例来和其他模块协调工作是很实用的。\n\n+ 什么是匿名内部类？\n\n普通的类可以自然的实例化自己吗，相反的，内部类却需要绑定上一个外部类才能实例。匿名内部类由于没有名字，只可以使用一次。\n\n+ 对字符串进行 == 和 equals()操作时有什么区别？\n\n == 主要比较的是两个字符串的地址，equals()假如不重写，也仅仅用于比较地址，重写就不是。\n\n+ hashcode()和equals()何时使用？\n\nhashCode()的存在主要是用于查找的快捷性，如hashtable、 hashmap等，hashcode是用来在散列存储结构中确定对象的存储地址的。\n\n如果两个对象相同，就是适用于equals()方法，那么这两个对象的hashcode一定要相同。\n\n如果对象的equals方法被重写，那么对象的hashcode也尽量重写，并且产生hashcode使用的对象，一定要和equals方法中使用的一致。\n\n两个对象的hashcode相同，并不一定就表示两个对象就相同，也就是不一定适用于equals方法，只能够说明这两个对象在散列存储结构中，如hashtable，他们“存放在同一个篮子里”\n\n+ java中 final、 finally 和finalize？\n\nfinal: 修饰变量、方法、类；修饰变量时表示这对象的值不可变，不能为这个变量赋一个新的值。修饰方法时便是我们希望把这个方法锁定，以防止任何继承类修改它的含义，这样会确保在继承中，final方法的行为不会改变，并且不会覆盖。修饰类的时候表示不打算继承该类，并且也不允许别人这样做。\n\nfinally: 是异常处理中进行收场处理的代码块，不管有没有异常，finally子句中的代码都会被执行。\n\nfinalize: 垃圾回收器准备释放对象占用的存储空间的时候，将首先调用其finalize()方法\n\n+ 什么是内存泄漏？java如何处理它？\n\n内存泄漏就是保留下来却永远不再使用的对象引用。java通过gc进行处理\n\n+ 垃圾回收器是什么？它是如何工作的？\n\n所有的对象实例都在jvm管理的堆区域分配内存，只要对象被引用，jvm就会认为它还活在进程中，一旦对象不再被引用，就不能被应用程序所访问，垃圾收集器将删除它并重新声明未使用的内存。\n\n+ 比较arrays 和arraylists\n\nArrays:一个包含许多和操作数组有关方法的类，比如说排序和查找。\nArrayList:一个容器，可以实现数组的大小可变，方便地增加和删除元素。\n\n+ 比较hashset和treeset\n\ntreeset是基于二叉树实现的，其中的数据是自动排序好的，不允许放入null值\nhashset是基于hash实现的，其中的数据是无序的，允许放入null值。\n\n+ java中的类型转换\n\n基本数据的类型转换：将一个数据范围较小的类型赋给一个数值范围较大的数值型变量，jvm在编译过程中会将此数值的类型进行自动提升。自动提升意味着数值精度至少不应该降低。而需要将数值范围较大的数值赋给数值范围较小的数值类型变量时，需要手动转换，成为强制类型转换。\n\n引用数据类型的类型转换：由于继承和向上转型，子类向父类的转换是很自然的，但是当把父类转换为子类时，强制类型转换会在运行时检查父类的真实类型，如果引用的父类对象的真实身份是子类类型，那就可以；否则如果真的是父类的类型，就会抛出ClassCastException的异常。\n\n+ 方法重载和重写的区别。\n\n重载发生在编译时，重写发生在运行时，重载方法调用与其定义的绑定发生在编译时，重写方法调用与其定义的绑定在运行时发生。\n\n静态方法可以重载，但不能重写。\n\n最基本的区别是重载是在同一个类中完成的，重写父类的话需要子类。重写是给父类的继承方法一个具体的实现。\n\n静态绑定用于方法重载，动态绑定用于方法重写。重载比重写更有效率，因为重写是在运行时完成的。\n\n私有方法和用final修饰的方法可以重载但不能重写。这意味着一个类可以有多个同名的final/private方法，子类不能重写父类的private/final方法。\n\n方法重载的情况下不关心返回值类型，他可以相同，也可以不同，重写的情况下可以有多个具体的返回值类型。\n\n重载参数列表必须不同，方法重写时参数列表必须相同。\n\n+ 什么是防卫修饰符？她们能做什么？\n\npublic、protected、private、这几个关键字叫做访问修饰符。\n作用是控制它所定义的域或者方法的访问权。\n\n+ 接口可以继承另一个接口吗？\n\n可以\n\n+ java中static关键字什么意思？\n\nstatic是java里面的非访问修饰符，可以用来创建类方法和类变量。\n当修饰一个变量的时候，此变量就成了独立于对象的静态变量，无论一个类实例化多少个对象，这个类只有一份这个静态变量的拷贝，所以static修饰的变量，即静态变量，也被叫做类变量。\n\n当修饰一个方法的时候，此方法就成了独立于对象的静态方法，静态方法不能使用类的非静态方法，因为静态变量先于非静态的其他成员初始化，静态方法先出来，然后才是非静态的，\n\n+ 什么是多态？什么是继承？\n\n多态是：允许不同类的对象对同一消息作出响应\n\n继承是：子类继承父类的特征和行为，使得子类具有父类的各种属性和方法\n\n+ integer和int之间的区别\n\ninteger是int提供的封装类，而int是java的基本数据类型；integer默认值是null，而int默认值是0，声明为integer的变量需要实例化，而声明为int的变量不需要实例化，integer是对象，用一个引用指向这个对象，而int是基本类型，直接存储数据。\n\n两个new出来的integer总是不一样的，当使用 == 时，因为其内存地址不同，所以进行 == 时返回false。\n\n两个不是new出来的integer，而是诸如integer i = x， 如果x的范围在 -128 ～ 127，其缓存指向同一个对象，所以此时使用 == 比较返回true，x范围在 -128 ～ 127之外的话，没有缓存存在，即使他们包裹的数值相同，他们也不能使用 == 得到true。\n\nint 和integer的比较，无论integer是否使用new， 其值和将平常与亮的一样：integer自动拆箱，然后和int比较，这里就不会被内存地址的不同所影响，该相等就相等。\n\n+ java中的对象是否会以引用传递或者值传递？\n\njava中的对象总是以值传递的。\n\n+ 什么是ThreadPoolExecutor?\n\n线程池是用于管理一个池子的工作线程，一个任务队列保持着一些等待执行的任务，这些任务由任何一个空闲的线程为止服务。任务是被生产者假如到队列的，同时，工作线程就像一个消费者，每当线程池里有空闲的线程，他就会开启一个后台的服务来执行一个任务。\n\nThreadPoolExecutor会使用线程池里的一个线程来执行一个任务。\n\n```\n\tThreadPoolExecutor threadPoolExecutor = \n\t\tnew ThreadPoolExecutor(int corePoolSize,\n\t\t\tint maximumPoolSize, long keepAliveTime, TimeUnit unit,\n\t\t\tBlockingQueue<Runnable> workQueue);\n```\n\ncorePoolSize: 保持在池中的最小线程数量。一开始，0个线程在池中，但是随着任务加入队列中，新的线程就会被创建。有空闲的线程，但是线程的数量小于corePoolSize，新的线程就会被继续创建。\n\nmaximumPoolSize:最大能允许的待在池中的线程数量。如果这个超过了corePoolSize而且现在线程的数量大于等于corePoolSize，那么新的工作线程会被创建，直到队列满了。\n\nkeepAliveTime: 当线程数量大于核心线程数，非核心的线程（超出空闲线程）会等着新任务来，然后如果任务到了keepAliveTime还没来，这些线程就会被冻结。\n\nunit: keepAliveTime的时间单位\n\nworkQueue:任务队列，仅仅会维持一些runnable任务，一定要是一个blockingQueue\n\nThreadPoolExecutor是一个强力的任务执行框架，它支持任务添加、任务取消、任务优先级。并且减少了之前的有关线程创建之类的开销，因为管理着一个给定数量的线程池。\n\n+ 本地变量、实例变量以及类变量之间的区别？\n\n本地变量就是局部变量，他在方法或者代码块里面被声明并使用，其内存中的位置是栈，没有默认初始化值，生命周期很短。\n实例变量是没有被static修饰的成员变量，它属于一个类的一个实例。每次new一个实例，这样的变量也new一遍，其位置在堆区，有默认初始化的值，生命周期和它所在的实例一样长。\n类变量，又称静态变量，它是被static修饰的成员变量，它属于一个类，被所有实例共享。每次new一个实例，这样的变量并不会被new一遍，其内存存在于方法区内，可以通过类名直接访问。有默认的初始化值，生命周期很长。\n\n+ 什么是反射？\n\n也就是说,在编译时,你获取了一个指向某个并不存在你的程序空间中的对象的引用;事实上在编译时你的程序无法获知这个对象所属的类\n\n+ 在java中什么是强引用、软引用、弱引用以及虚引用？\n\n强引用：不会被gc轻易清理，只要引用存在，垃圾回收器永远不会回收。\n\n软引用：非必须引用，内存溢出之前进行回收\n\n弱引用：第二次垃圾回收时回收\n\n虚引用：垃圾回收时回收，无法通过引用取到对象值。\n\n+ 关键字synchronized的作用是什么？\n\nsynchronized通过修饰一个方法或者代码块，从而产生一个同步对象锁，以及对应的同步代码块。每当有线程要对该同步代码块进行访问时，线程就会首先尝试获取这个对象的锁，并在成功获取到对象锁之后，对这个同步代码块进行正常的访问。在同步代码块的访问过程中，线程会一直持有这个对象锁，直到同步代码块访问完毕，然后才会释放。\n在上述线程中持有同步锁并且进行同步代码块访问过程中，其他线程无法获得该对象锁，也无法访问该同步代码，这些线程都会被阻塞直到上述线程访问完毕。\n\n+ 为什么说string不可变？\n\nstring类型在实现时，其内部变量全部使用final来修饰，保证成员变量的引用值只能通过构造函数来修改\nstring类型在实现时，在外部某个地方，可能修改一个string实例的内部存储值的函数实现中，在这个地方的调用返回时，一律构造新的string对象或者新的byte数组或者char数组，给赋值符号的左边变量\n\n+ 修饰符transient和volatile的作用？\n\nvolatile：易式修饰符，带有volatile修饰的变量，就是当其在某个线程自己的工作内存中发生改变时，会被强制地，写回公共成员变量所在的公共内存处。\n\ntransient是一个类型修饰符，仅仅能用来修饰字段（变量）。在此字段所在的对象进行序列化的时候，这个字段不会被序列化。\n\n其他没有transient修饰的变量将会被序列化，然后进行传输，或者存储到本地磁盘，transient变量就在这个过程里丢失了\n\n+ StringBuffer和StringBuilder的区别在哪里？\n\nStringBuffer,StringBuilder和String一样，都用来代表字符串。\nString类是不可变类，任何针对String的改变都会引起string对象的生成。而StringBuilder和StringBuffer则是可变类。StringBuilder不支持并发操作，线程不安全，不适合多线程。而StringBuffer支持并发操作，线程安全，单线程的性能低于StringBuilder\n\n+ StringBuilder怎么避免不可变字符串分配的问题？\n\nString类型在改变的时候都会生成一个新的string，然后指向这个string，因此经常改变内容的字符串最好不要用string，会导致gc。\nstringbuffer则是每次结果都会对stringbuffer对象本身操作，而不是生成新的对象。\n\n+ 什么是自动装箱和拆箱？\n\n装箱就是自动将数据类型转换为包装器类型，拆箱就是自动将包装齐类型转换为基本数据类型。\n\n```\n\tInteger i = 100;\n```\n\n这句话会被编译器执行为：\n\n```\n\tInteger i = Integer.valueOf(100);\n```\n\n这就是自动装箱\n\n```\n\tInteger i = 10; // autoboxing\n\tint c = i; // unboxing\n```\n\n+ 枚举和迭代器有什么区别？\n\n函数接口不同：枚举只有2个函数接口，只能读取集合的数据，而不能更改，迭代器有三个接口，出了读取集合的数据之外，还能进行删除操作\n\n迭代器支持failfast，而枚举不支持。\n\n+ java中fail-fast和fail-safe的区别？\n\nfail-fast： 当遍历一个集合时，集合结构若被修改，就会抛出ConcurrentModificationException。\n\nfail-safe:任何对集合的修改都会在一个复制的集合上进行修改，因此不会抛出ConcurrentModificationException。failsafe需要复制集合，产生大量的无效对象，开销大，而且无法保证读取的数据是目前原始数据结构中的数据。\n\n+ 优先级队列\n\npriorityQueue类用来表示优先队列，优先队列是一个以集合为基础的抽象数据类型，队列中的每个元素都有一个优先级值，优先级值用来表示该元素的出列的优先级\n\njava中的优先队列基于堆，堆是一个完全二叉树，所以PriorityQueue不是线性结构，而是树形结构。","slug":"java基础知识点","published":1,"updated":"2019-03-12T09:26:33.158Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltu0c00773a8kiwb87al4","content":"<p>感冒了好几天，昨天没有写blog，心慌慌。</p>\n<p>这篇从java核心来讲，估计要整理一阵</p>\n<h1 id=\"java-核心\"><a href=\"#java-核心\" class=\"headerlink\" title=\"java 核心\"></a>java 核心</h1><ul>\n<li>oop的概念</li>\n</ul>\n<ol>\n<li>抽象</li>\n</ol>\n<p>在面向对象的概念中，所有对象都是由类来描述，但是反过来，并不是所有类都是用来描述对象的。如果一个类中没有包含足够信息来描绘一个具体的对象，这样的类就是抽象类。</p>\n<ol start=\"2\">\n<li>继承</li>\n</ol>\n<p>继承（英语：inheritance）是面向对象软件技术当中的一个概念。如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。 一般静态的面向对象编程语言，继承属于静态的，意即在子类别的行为在编译期就已经决定，无法在执行期扩充。 有些编程语言支持多重继承，即一个子类别可以同时有多个父类别，比如C++编程语言；而在有些编程语言中，一个子类别只能继承自一个父类别，比如Java编程语言，这时可以利用接口来实现与多重继承相似的效果。 现今面向对象程式设计技巧中，继承并非以继承类别的“行为”为主，而是继承类别的“型态”，使得元件的型态一致。另外在设计模式中提到一个守则，“多用合成，少用继承”，此守则也是用来处理继承无法在执行期动态扩充行为的遗憾。</p>\n<ol start=\"3\">\n<li>封装</li>\n</ol>\n<p>从字面上理解就是包装的意思，是指利用抽象数据类型，将数据和关于数据的操作封装起来，使其成为一个不可分割的独立实体。数据将会被保护在抽象数据类型的内部，仅能够通过暴露在表面的操作（public方法，比如setter和getter）来与这个对象进行交流和交互。用户不知道对象的内部细节，但是通过该对象提供的接口来访问对象。其好处是：减少耦合，方便地在未来修改调整自己，更加有把握地（精确地）控制成员，隐藏信息，实现细节。</p>\n<ol start=\"4\">\n<li>多态</li>\n</ol>\n<p>使用相同的消息，使得类作出不同的反应（继承为我们使用多态打下了基础）。Java实现多态有三个必要条件：继承、重写、向上转型。</p>\n<ul>\n<li><p>面向对象的三个基本元素和五个原则</p>\n</li>\n<li><p>三个元素：</p>\n</li>\n</ul>\n<ol>\n<li><p>封装： 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</p>\n</li>\n<li><p>继承： 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。</p>\n</li>\n<li><p>多态： 多态性是指允许不同类的对象对同一消息作出 响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。</p>\n</li>\n</ol>\n<ul>\n<li>五个基本原则：</li>\n</ul>\n<ol>\n<li><p>单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。</p>\n</li>\n<li><p>开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。</p>\n</li>\n<li><p>Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。</p>\n</li>\n<li><p>依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。</p>\n</li>\n<li><p>接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口。</p>\n</li>\n</ol>\n<ul>\n<li>抽象类和接口的区别</li>\n</ul>\n<ol>\n<li><p>抽象类是一个可同时包含具体方法和抽象方法(方法未被实现)的类。抽象方法必须被该抽象类的子类实现。抽象类是可以继承的。</p>\n</li>\n<li><p>接口像是描述类的一张蓝图或者说是类的一种契约，它包含了许多空方法，这代表着它的所有的子类都应该拥有共同点。它的子类应该提供这些空方法的具体实现。一 个类需要用 implements 来实现接口，接口可以用 extends 来继承其他接口。</p>\n</li>\n<li><p>设计模式上面来看：</p>\n</li>\n</ol>\n<p>抽象的层次不同：抽象类对类的整体（包括属性，行为）都可以进行抽象，接口对类的局部进行抽象，具体来说接口仅仅是对类的行为进行抽象。</p>\n<p>跨域不同：抽象类是 从各种子类中提取相似的部分，然后泛化成抽象类，子类可以继承这样的抽象类。 实现接口是 不存在is-a的关系的类们，你不可以称同样可以飞行的飞机和鸟为同一个抽象类，但是他们可以有同样的接口fly-able。抽象类的父类和派生类在概念上一致，接口的原生类和派生类在仅仅在局部行为上一致。</p>\n<p>设计层次不同：抽象类是从一堆在底层的子类们来进行抽象提取，从下往上，从而产生抽象类；接口是在直接定义的高度来声明的，然后从这个高度上往下实现此接口。抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</p>\n<ul>\n<li>序列化是什么？如何实现？</li>\n</ul>\n<p>序列化是一种将对象转换为字节流的过程，目的是为了将对象存储到内存中，等后面再次构建该对象时可以获取到该对象先前的状态和数据信息。java中，使用Serializable和parcelable接口都可以实现，不过android中使用parcel效率高，性能高出10倍。</p>\n<ul>\n<li>什么是单例？</li>\n</ul>\n<p>单例模式指的是一个类只能被初始化一次，限定一个类只能拥有一个实例。使用一个实例来和其他模块协调工作是很实用的。</p>\n<ul>\n<li>什么是匿名内部类？</li>\n</ul>\n<p>普通的类可以自然的实例化自己吗，相反的，内部类却需要绑定上一个外部类才能实例。匿名内部类由于没有名字，只可以使用一次。</p>\n<ul>\n<li><p>对字符串进行 == 和 equals()操作时有什么区别？</p>\n<p>== 主要比较的是两个字符串的地址，equals()假如不重写，也仅仅用于比较地址，重写就不是。</p>\n</li>\n<li><p>hashcode()和equals()何时使用？</p>\n</li>\n</ul>\n<p>hashCode()的存在主要是用于查找的快捷性，如hashtable、 hashmap等，hashcode是用来在散列存储结构中确定对象的存储地址的。</p>\n<p>如果两个对象相同，就是适用于equals()方法，那么这两个对象的hashcode一定要相同。</p>\n<p>如果对象的equals方法被重写，那么对象的hashcode也尽量重写，并且产生hashcode使用的对象，一定要和equals方法中使用的一致。</p>\n<p>两个对象的hashcode相同，并不一定就表示两个对象就相同，也就是不一定适用于equals方法，只能够说明这两个对象在散列存储结构中，如hashtable，他们“存放在同一个篮子里”</p>\n<ul>\n<li>java中 final、 finally 和finalize？</li>\n</ul>\n<p>final: 修饰变量、方法、类；修饰变量时表示这对象的值不可变，不能为这个变量赋一个新的值。修饰方法时便是我们希望把这个方法锁定，以防止任何继承类修改它的含义，这样会确保在继承中，final方法的行为不会改变，并且不会覆盖。修饰类的时候表示不打算继承该类，并且也不允许别人这样做。</p>\n<p>finally: 是异常处理中进行收场处理的代码块，不管有没有异常，finally子句中的代码都会被执行。</p>\n<p>finalize: 垃圾回收器准备释放对象占用的存储空间的时候，将首先调用其finalize()方法</p>\n<ul>\n<li>什么是内存泄漏？java如何处理它？</li>\n</ul>\n<p>内存泄漏就是保留下来却永远不再使用的对象引用。java通过gc进行处理</p>\n<ul>\n<li>垃圾回收器是什么？它是如何工作的？</li>\n</ul>\n<p>所有的对象实例都在jvm管理的堆区域分配内存，只要对象被引用，jvm就会认为它还活在进程中，一旦对象不再被引用，就不能被应用程序所访问，垃圾收集器将删除它并重新声明未使用的内存。</p>\n<ul>\n<li>比较arrays 和arraylists</li>\n</ul>\n<p>Arrays:一个包含许多和操作数组有关方法的类，比如说排序和查找。<br>ArrayList:一个容器，可以实现数组的大小可变，方便地增加和删除元素。</p>\n<ul>\n<li>比较hashset和treeset</li>\n</ul>\n<p>treeset是基于二叉树实现的，其中的数据是自动排序好的，不允许放入null值<br>hashset是基于hash实现的，其中的数据是无序的，允许放入null值。</p>\n<ul>\n<li>java中的类型转换</li>\n</ul>\n<p>基本数据的类型转换：将一个数据范围较小的类型赋给一个数值范围较大的数值型变量，jvm在编译过程中会将此数值的类型进行自动提升。自动提升意味着数值精度至少不应该降低。而需要将数值范围较大的数值赋给数值范围较小的数值类型变量时，需要手动转换，成为强制类型转换。</p>\n<p>引用数据类型的类型转换：由于继承和向上转型，子类向父类的转换是很自然的，但是当把父类转换为子类时，强制类型转换会在运行时检查父类的真实类型，如果引用的父类对象的真实身份是子类类型，那就可以；否则如果真的是父类的类型，就会抛出ClassCastException的异常。</p>\n<ul>\n<li>方法重载和重写的区别。</li>\n</ul>\n<p>重载发生在编译时，重写发生在运行时，重载方法调用与其定义的绑定发生在编译时，重写方法调用与其定义的绑定在运行时发生。</p>\n<p>静态方法可以重载，但不能重写。</p>\n<p>最基本的区别是重载是在同一个类中完成的，重写父类的话需要子类。重写是给父类的继承方法一个具体的实现。</p>\n<p>静态绑定用于方法重载，动态绑定用于方法重写。重载比重写更有效率，因为重写是在运行时完成的。</p>\n<p>私有方法和用final修饰的方法可以重载但不能重写。这意味着一个类可以有多个同名的final/private方法，子类不能重写父类的private/final方法。</p>\n<p>方法重载的情况下不关心返回值类型，他可以相同，也可以不同，重写的情况下可以有多个具体的返回值类型。</p>\n<p>重载参数列表必须不同，方法重写时参数列表必须相同。</p>\n<ul>\n<li>什么是防卫修饰符？她们能做什么？</li>\n</ul>\n<p>public、protected、private、这几个关键字叫做访问修饰符。<br>作用是控制它所定义的域或者方法的访问权。</p>\n<ul>\n<li>接口可以继承另一个接口吗？</li>\n</ul>\n<p>可以</p>\n<ul>\n<li>java中static关键字什么意思？</li>\n</ul>\n<p>static是java里面的非访问修饰符，可以用来创建类方法和类变量。<br>当修饰一个变量的时候，此变量就成了独立于对象的静态变量，无论一个类实例化多少个对象，这个类只有一份这个静态变量的拷贝，所以static修饰的变量，即静态变量，也被叫做类变量。</p>\n<p>当修饰一个方法的时候，此方法就成了独立于对象的静态方法，静态方法不能使用类的非静态方法，因为静态变量先于非静态的其他成员初始化，静态方法先出来，然后才是非静态的，</p>\n<ul>\n<li>什么是多态？什么是继承？</li>\n</ul>\n<p>多态是：允许不同类的对象对同一消息作出响应</p>\n<p>继承是：子类继承父类的特征和行为，使得子类具有父类的各种属性和方法</p>\n<ul>\n<li>integer和int之间的区别</li>\n</ul>\n<p>integer是int提供的封装类，而int是java的基本数据类型；integer默认值是null，而int默认值是0，声明为integer的变量需要实例化，而声明为int的变量不需要实例化，integer是对象，用一个引用指向这个对象，而int是基本类型，直接存储数据。</p>\n<p>两个new出来的integer总是不一样的，当使用 == 时，因为其内存地址不同，所以进行 == 时返回false。</p>\n<p>两个不是new出来的integer，而是诸如integer i = x， 如果x的范围在 -128 ～ 127，其缓存指向同一个对象，所以此时使用 == 比较返回true，x范围在 -128 ～ 127之外的话，没有缓存存在，即使他们包裹的数值相同，他们也不能使用 == 得到true。</p>\n<p>int 和integer的比较，无论integer是否使用new， 其值和将平常与亮的一样：integer自动拆箱，然后和int比较，这里就不会被内存地址的不同所影响，该相等就相等。</p>\n<ul>\n<li>java中的对象是否会以引用传递或者值传递？</li>\n</ul>\n<p>java中的对象总是以值传递的。</p>\n<ul>\n<li>什么是ThreadPoolExecutor?</li>\n</ul>\n<p>线程池是用于管理一个池子的工作线程，一个任务队列保持着一些等待执行的任务，这些任务由任何一个空闲的线程为止服务。任务是被生产者假如到队列的，同时，工作线程就像一个消费者，每当线程池里有空闲的线程，他就会开启一个后台的服务来执行一个任务。</p>\n<p>ThreadPoolExecutor会使用线程池里的一个线程来执行一个任务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPoolExecutor threadPoolExecutor = </span><br><span class=\"line\">\tnew ThreadPoolExecutor(int corePoolSize,</span><br><span class=\"line\">\t\tint maximumPoolSize, long keepAliveTime, TimeUnit unit,</span><br><span class=\"line\">\t\tBlockingQueue&lt;Runnable&gt; workQueue);</span><br></pre></td></tr></table></figure>\n<p>corePoolSize: 保持在池中的最小线程数量。一开始，0个线程在池中，但是随着任务加入队列中，新的线程就会被创建。有空闲的线程，但是线程的数量小于corePoolSize，新的线程就会被继续创建。</p>\n<p>maximumPoolSize:最大能允许的待在池中的线程数量。如果这个超过了corePoolSize而且现在线程的数量大于等于corePoolSize，那么新的工作线程会被创建，直到队列满了。</p>\n<p>keepAliveTime: 当线程数量大于核心线程数，非核心的线程（超出空闲线程）会等着新任务来，然后如果任务到了keepAliveTime还没来，这些线程就会被冻结。</p>\n<p>unit: keepAliveTime的时间单位</p>\n<p>workQueue:任务队列，仅仅会维持一些runnable任务，一定要是一个blockingQueue</p>\n<p>ThreadPoolExecutor是一个强力的任务执行框架，它支持任务添加、任务取消、任务优先级。并且减少了之前的有关线程创建之类的开销，因为管理着一个给定数量的线程池。</p>\n<ul>\n<li>本地变量、实例变量以及类变量之间的区别？</li>\n</ul>\n<p>本地变量就是局部变量，他在方法或者代码块里面被声明并使用，其内存中的位置是栈，没有默认初始化值，生命周期很短。<br>实例变量是没有被static修饰的成员变量，它属于一个类的一个实例。每次new一个实例，这样的变量也new一遍，其位置在堆区，有默认初始化的值，生命周期和它所在的实例一样长。<br>类变量，又称静态变量，它是被static修饰的成员变量，它属于一个类，被所有实例共享。每次new一个实例，这样的变量并不会被new一遍，其内存存在于方法区内，可以通过类名直接访问。有默认的初始化值，生命周期很长。</p>\n<ul>\n<li>什么是反射？</li>\n</ul>\n<p>也就是说,在编译时,你获取了一个指向某个并不存在你的程序空间中的对象的引用;事实上在编译时你的程序无法获知这个对象所属的类</p>\n<ul>\n<li>在java中什么是强引用、软引用、弱引用以及虚引用？</li>\n</ul>\n<p>强引用：不会被gc轻易清理，只要引用存在，垃圾回收器永远不会回收。</p>\n<p>软引用：非必须引用，内存溢出之前进行回收</p>\n<p>弱引用：第二次垃圾回收时回收</p>\n<p>虚引用：垃圾回收时回收，无法通过引用取到对象值。</p>\n<ul>\n<li>关键字synchronized的作用是什么？</li>\n</ul>\n<p>synchronized通过修饰一个方法或者代码块，从而产生一个同步对象锁，以及对应的同步代码块。每当有线程要对该同步代码块进行访问时，线程就会首先尝试获取这个对象的锁，并在成功获取到对象锁之后，对这个同步代码块进行正常的访问。在同步代码块的访问过程中，线程会一直持有这个对象锁，直到同步代码块访问完毕，然后才会释放。<br>在上述线程中持有同步锁并且进行同步代码块访问过程中，其他线程无法获得该对象锁，也无法访问该同步代码，这些线程都会被阻塞直到上述线程访问完毕。</p>\n<ul>\n<li>为什么说string不可变？</li>\n</ul>\n<p>string类型在实现时，其内部变量全部使用final来修饰，保证成员变量的引用值只能通过构造函数来修改<br>string类型在实现时，在外部某个地方，可能修改一个string实例的内部存储值的函数实现中，在这个地方的调用返回时，一律构造新的string对象或者新的byte数组或者char数组，给赋值符号的左边变量</p>\n<ul>\n<li>修饰符transient和volatile的作用？</li>\n</ul>\n<p>volatile：易式修饰符，带有volatile修饰的变量，就是当其在某个线程自己的工作内存中发生改变时，会被强制地，写回公共成员变量所在的公共内存处。</p>\n<p>transient是一个类型修饰符，仅仅能用来修饰字段（变量）。在此字段所在的对象进行序列化的时候，这个字段不会被序列化。</p>\n<p>其他没有transient修饰的变量将会被序列化，然后进行传输，或者存储到本地磁盘，transient变量就在这个过程里丢失了</p>\n<ul>\n<li>StringBuffer和StringBuilder的区别在哪里？</li>\n</ul>\n<p>StringBuffer,StringBuilder和String一样，都用来代表字符串。<br>String类是不可变类，任何针对String的改变都会引起string对象的生成。而StringBuilder和StringBuffer则是可变类。StringBuilder不支持并发操作，线程不安全，不适合多线程。而StringBuffer支持并发操作，线程安全，单线程的性能低于StringBuilder</p>\n<ul>\n<li>StringBuilder怎么避免不可变字符串分配的问题？</li>\n</ul>\n<p>String类型在改变的时候都会生成一个新的string，然后指向这个string，因此经常改变内容的字符串最好不要用string，会导致gc。<br>stringbuffer则是每次结果都会对stringbuffer对象本身操作，而不是生成新的对象。</p>\n<ul>\n<li>什么是自动装箱和拆箱？</li>\n</ul>\n<p>装箱就是自动将数据类型转换为包装器类型，拆箱就是自动将包装齐类型转换为基本数据类型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i = 100;</span><br></pre></td></tr></table></figure>\n<p>这句话会被编译器执行为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i = Integer.valueOf(100);</span><br></pre></td></tr></table></figure>\n<p>这就是自动装箱</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i = 10; // autoboxing</span><br><span class=\"line\">int c = i; // unboxing</span><br></pre></td></tr></table></figure>\n<ul>\n<li>枚举和迭代器有什么区别？</li>\n</ul>\n<p>函数接口不同：枚举只有2个函数接口，只能读取集合的数据，而不能更改，迭代器有三个接口，出了读取集合的数据之外，还能进行删除操作</p>\n<p>迭代器支持failfast，而枚举不支持。</p>\n<ul>\n<li>java中fail-fast和fail-safe的区别？</li>\n</ul>\n<p>fail-fast： 当遍历一个集合时，集合结构若被修改，就会抛出ConcurrentModificationException。</p>\n<p>fail-safe:任何对集合的修改都会在一个复制的集合上进行修改，因此不会抛出ConcurrentModificationException。failsafe需要复制集合，产生大量的无效对象，开销大，而且无法保证读取的数据是目前原始数据结构中的数据。</p>\n<ul>\n<li>优先级队列</li>\n</ul>\n<p>priorityQueue类用来表示优先队列，优先队列是一个以集合为基础的抽象数据类型，队列中的每个元素都有一个优先级值，优先级值用来表示该元素的出列的优先级</p>\n<p>java中的优先队列基于堆，堆是一个完全二叉树，所以PriorityQueue不是线性结构，而是树形结构。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>感冒了好几天，昨天没有写blog，心慌慌。</p>\n<p>这篇从java核心来讲，估计要整理一阵</p>\n<h1 id=\"java-核心\"><a href=\"#java-核心\" class=\"headerlink\" title=\"java 核心\"></a>java 核心</h1><ul>\n<li>oop的概念</li>\n</ul>\n<ol>\n<li>抽象</li>\n</ol>\n<p>在面向对象的概念中，所有对象都是由类来描述，但是反过来，并不是所有类都是用来描述对象的。如果一个类中没有包含足够信息来描绘一个具体的对象，这样的类就是抽象类。</p>\n<ol start=\"2\">\n<li>继承</li>\n</ol>\n<p>继承（英语：inheritance）是面向对象软件技术当中的一个概念。如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。 一般静态的面向对象编程语言，继承属于静态的，意即在子类别的行为在编译期就已经决定，无法在执行期扩充。 有些编程语言支持多重继承，即一个子类别可以同时有多个父类别，比如C++编程语言；而在有些编程语言中，一个子类别只能继承自一个父类别，比如Java编程语言，这时可以利用接口来实现与多重继承相似的效果。 现今面向对象程式设计技巧中，继承并非以继承类别的“行为”为主，而是继承类别的“型态”，使得元件的型态一致。另外在设计模式中提到一个守则，“多用合成，少用继承”，此守则也是用来处理继承无法在执行期动态扩充行为的遗憾。</p>\n<ol start=\"3\">\n<li>封装</li>\n</ol>\n<p>从字面上理解就是包装的意思，是指利用抽象数据类型，将数据和关于数据的操作封装起来，使其成为一个不可分割的独立实体。数据将会被保护在抽象数据类型的内部，仅能够通过暴露在表面的操作（public方法，比如setter和getter）来与这个对象进行交流和交互。用户不知道对象的内部细节，但是通过该对象提供的接口来访问对象。其好处是：减少耦合，方便地在未来修改调整自己，更加有把握地（精确地）控制成员，隐藏信息，实现细节。</p>\n<ol start=\"4\">\n<li>多态</li>\n</ol>\n<p>使用相同的消息，使得类作出不同的反应（继承为我们使用多态打下了基础）。Java实现多态有三个必要条件：继承、重写、向上转型。</p>\n<ul>\n<li><p>面向对象的三个基本元素和五个原则</p>\n</li>\n<li><p>三个元素：</p>\n</li>\n</ul>\n<ol>\n<li><p>封装： 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</p>\n</li>\n<li><p>继承： 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。</p>\n</li>\n<li><p>多态： 多态性是指允许不同类的对象对同一消息作出 响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。</p>\n</li>\n</ol>\n<ul>\n<li>五个基本原则：</li>\n</ul>\n<ol>\n<li><p>单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。</p>\n</li>\n<li><p>开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。</p>\n</li>\n<li><p>Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。</p>\n</li>\n<li><p>依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。</p>\n</li>\n<li><p>接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口。</p>\n</li>\n</ol>\n<ul>\n<li>抽象类和接口的区别</li>\n</ul>\n<ol>\n<li><p>抽象类是一个可同时包含具体方法和抽象方法(方法未被实现)的类。抽象方法必须被该抽象类的子类实现。抽象类是可以继承的。</p>\n</li>\n<li><p>接口像是描述类的一张蓝图或者说是类的一种契约，它包含了许多空方法，这代表着它的所有的子类都应该拥有共同点。它的子类应该提供这些空方法的具体实现。一 个类需要用 implements 来实现接口，接口可以用 extends 来继承其他接口。</p>\n</li>\n<li><p>设计模式上面来看：</p>\n</li>\n</ol>\n<p>抽象的层次不同：抽象类对类的整体（包括属性，行为）都可以进行抽象，接口对类的局部进行抽象，具体来说接口仅仅是对类的行为进行抽象。</p>\n<p>跨域不同：抽象类是 从各种子类中提取相似的部分，然后泛化成抽象类，子类可以继承这样的抽象类。 实现接口是 不存在is-a的关系的类们，你不可以称同样可以飞行的飞机和鸟为同一个抽象类，但是他们可以有同样的接口fly-able。抽象类的父类和派生类在概念上一致，接口的原生类和派生类在仅仅在局部行为上一致。</p>\n<p>设计层次不同：抽象类是从一堆在底层的子类们来进行抽象提取，从下往上，从而产生抽象类；接口是在直接定义的高度来声明的，然后从这个高度上往下实现此接口。抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</p>\n<ul>\n<li>序列化是什么？如何实现？</li>\n</ul>\n<p>序列化是一种将对象转换为字节流的过程，目的是为了将对象存储到内存中，等后面再次构建该对象时可以获取到该对象先前的状态和数据信息。java中，使用Serializable和parcelable接口都可以实现，不过android中使用parcel效率高，性能高出10倍。</p>\n<ul>\n<li>什么是单例？</li>\n</ul>\n<p>单例模式指的是一个类只能被初始化一次，限定一个类只能拥有一个实例。使用一个实例来和其他模块协调工作是很实用的。</p>\n<ul>\n<li>什么是匿名内部类？</li>\n</ul>\n<p>普通的类可以自然的实例化自己吗，相反的，内部类却需要绑定上一个外部类才能实例。匿名内部类由于没有名字，只可以使用一次。</p>\n<ul>\n<li><p>对字符串进行 == 和 equals()操作时有什么区别？</p>\n<p>== 主要比较的是两个字符串的地址，equals()假如不重写，也仅仅用于比较地址，重写就不是。</p>\n</li>\n<li><p>hashcode()和equals()何时使用？</p>\n</li>\n</ul>\n<p>hashCode()的存在主要是用于查找的快捷性，如hashtable、 hashmap等，hashcode是用来在散列存储结构中确定对象的存储地址的。</p>\n<p>如果两个对象相同，就是适用于equals()方法，那么这两个对象的hashcode一定要相同。</p>\n<p>如果对象的equals方法被重写，那么对象的hashcode也尽量重写，并且产生hashcode使用的对象，一定要和equals方法中使用的一致。</p>\n<p>两个对象的hashcode相同，并不一定就表示两个对象就相同，也就是不一定适用于equals方法，只能够说明这两个对象在散列存储结构中，如hashtable，他们“存放在同一个篮子里”</p>\n<ul>\n<li>java中 final、 finally 和finalize？</li>\n</ul>\n<p>final: 修饰变量、方法、类；修饰变量时表示这对象的值不可变，不能为这个变量赋一个新的值。修饰方法时便是我们希望把这个方法锁定，以防止任何继承类修改它的含义，这样会确保在继承中，final方法的行为不会改变，并且不会覆盖。修饰类的时候表示不打算继承该类，并且也不允许别人这样做。</p>\n<p>finally: 是异常处理中进行收场处理的代码块，不管有没有异常，finally子句中的代码都会被执行。</p>\n<p>finalize: 垃圾回收器准备释放对象占用的存储空间的时候，将首先调用其finalize()方法</p>\n<ul>\n<li>什么是内存泄漏？java如何处理它？</li>\n</ul>\n<p>内存泄漏就是保留下来却永远不再使用的对象引用。java通过gc进行处理</p>\n<ul>\n<li>垃圾回收器是什么？它是如何工作的？</li>\n</ul>\n<p>所有的对象实例都在jvm管理的堆区域分配内存，只要对象被引用，jvm就会认为它还活在进程中，一旦对象不再被引用，就不能被应用程序所访问，垃圾收集器将删除它并重新声明未使用的内存。</p>\n<ul>\n<li>比较arrays 和arraylists</li>\n</ul>\n<p>Arrays:一个包含许多和操作数组有关方法的类，比如说排序和查找。<br>ArrayList:一个容器，可以实现数组的大小可变，方便地增加和删除元素。</p>\n<ul>\n<li>比较hashset和treeset</li>\n</ul>\n<p>treeset是基于二叉树实现的，其中的数据是自动排序好的，不允许放入null值<br>hashset是基于hash实现的，其中的数据是无序的，允许放入null值。</p>\n<ul>\n<li>java中的类型转换</li>\n</ul>\n<p>基本数据的类型转换：将一个数据范围较小的类型赋给一个数值范围较大的数值型变量，jvm在编译过程中会将此数值的类型进行自动提升。自动提升意味着数值精度至少不应该降低。而需要将数值范围较大的数值赋给数值范围较小的数值类型变量时，需要手动转换，成为强制类型转换。</p>\n<p>引用数据类型的类型转换：由于继承和向上转型，子类向父类的转换是很自然的，但是当把父类转换为子类时，强制类型转换会在运行时检查父类的真实类型，如果引用的父类对象的真实身份是子类类型，那就可以；否则如果真的是父类的类型，就会抛出ClassCastException的异常。</p>\n<ul>\n<li>方法重载和重写的区别。</li>\n</ul>\n<p>重载发生在编译时，重写发生在运行时，重载方法调用与其定义的绑定发生在编译时，重写方法调用与其定义的绑定在运行时发生。</p>\n<p>静态方法可以重载，但不能重写。</p>\n<p>最基本的区别是重载是在同一个类中完成的，重写父类的话需要子类。重写是给父类的继承方法一个具体的实现。</p>\n<p>静态绑定用于方法重载，动态绑定用于方法重写。重载比重写更有效率，因为重写是在运行时完成的。</p>\n<p>私有方法和用final修饰的方法可以重载但不能重写。这意味着一个类可以有多个同名的final/private方法，子类不能重写父类的private/final方法。</p>\n<p>方法重载的情况下不关心返回值类型，他可以相同，也可以不同，重写的情况下可以有多个具体的返回值类型。</p>\n<p>重载参数列表必须不同，方法重写时参数列表必须相同。</p>\n<ul>\n<li>什么是防卫修饰符？她们能做什么？</li>\n</ul>\n<p>public、protected、private、这几个关键字叫做访问修饰符。<br>作用是控制它所定义的域或者方法的访问权。</p>\n<ul>\n<li>接口可以继承另一个接口吗？</li>\n</ul>\n<p>可以</p>\n<ul>\n<li>java中static关键字什么意思？</li>\n</ul>\n<p>static是java里面的非访问修饰符，可以用来创建类方法和类变量。<br>当修饰一个变量的时候，此变量就成了独立于对象的静态变量，无论一个类实例化多少个对象，这个类只有一份这个静态变量的拷贝，所以static修饰的变量，即静态变量，也被叫做类变量。</p>\n<p>当修饰一个方法的时候，此方法就成了独立于对象的静态方法，静态方法不能使用类的非静态方法，因为静态变量先于非静态的其他成员初始化，静态方法先出来，然后才是非静态的，</p>\n<ul>\n<li>什么是多态？什么是继承？</li>\n</ul>\n<p>多态是：允许不同类的对象对同一消息作出响应</p>\n<p>继承是：子类继承父类的特征和行为，使得子类具有父类的各种属性和方法</p>\n<ul>\n<li>integer和int之间的区别</li>\n</ul>\n<p>integer是int提供的封装类，而int是java的基本数据类型；integer默认值是null，而int默认值是0，声明为integer的变量需要实例化，而声明为int的变量不需要实例化，integer是对象，用一个引用指向这个对象，而int是基本类型，直接存储数据。</p>\n<p>两个new出来的integer总是不一样的，当使用 == 时，因为其内存地址不同，所以进行 == 时返回false。</p>\n<p>两个不是new出来的integer，而是诸如integer i = x， 如果x的范围在 -128 ～ 127，其缓存指向同一个对象，所以此时使用 == 比较返回true，x范围在 -128 ～ 127之外的话，没有缓存存在，即使他们包裹的数值相同，他们也不能使用 == 得到true。</p>\n<p>int 和integer的比较，无论integer是否使用new， 其值和将平常与亮的一样：integer自动拆箱，然后和int比较，这里就不会被内存地址的不同所影响，该相等就相等。</p>\n<ul>\n<li>java中的对象是否会以引用传递或者值传递？</li>\n</ul>\n<p>java中的对象总是以值传递的。</p>\n<ul>\n<li>什么是ThreadPoolExecutor?</li>\n</ul>\n<p>线程池是用于管理一个池子的工作线程，一个任务队列保持着一些等待执行的任务，这些任务由任何一个空闲的线程为止服务。任务是被生产者假如到队列的，同时，工作线程就像一个消费者，每当线程池里有空闲的线程，他就会开启一个后台的服务来执行一个任务。</p>\n<p>ThreadPoolExecutor会使用线程池里的一个线程来执行一个任务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPoolExecutor threadPoolExecutor = </span><br><span class=\"line\">\tnew ThreadPoolExecutor(int corePoolSize,</span><br><span class=\"line\">\t\tint maximumPoolSize, long keepAliveTime, TimeUnit unit,</span><br><span class=\"line\">\t\tBlockingQueue&lt;Runnable&gt; workQueue);</span><br></pre></td></tr></table></figure>\n<p>corePoolSize: 保持在池中的最小线程数量。一开始，0个线程在池中，但是随着任务加入队列中，新的线程就会被创建。有空闲的线程，但是线程的数量小于corePoolSize，新的线程就会被继续创建。</p>\n<p>maximumPoolSize:最大能允许的待在池中的线程数量。如果这个超过了corePoolSize而且现在线程的数量大于等于corePoolSize，那么新的工作线程会被创建，直到队列满了。</p>\n<p>keepAliveTime: 当线程数量大于核心线程数，非核心的线程（超出空闲线程）会等着新任务来，然后如果任务到了keepAliveTime还没来，这些线程就会被冻结。</p>\n<p>unit: keepAliveTime的时间单位</p>\n<p>workQueue:任务队列，仅仅会维持一些runnable任务，一定要是一个blockingQueue</p>\n<p>ThreadPoolExecutor是一个强力的任务执行框架，它支持任务添加、任务取消、任务优先级。并且减少了之前的有关线程创建之类的开销，因为管理着一个给定数量的线程池。</p>\n<ul>\n<li>本地变量、实例变量以及类变量之间的区别？</li>\n</ul>\n<p>本地变量就是局部变量，他在方法或者代码块里面被声明并使用，其内存中的位置是栈，没有默认初始化值，生命周期很短。<br>实例变量是没有被static修饰的成员变量，它属于一个类的一个实例。每次new一个实例，这样的变量也new一遍，其位置在堆区，有默认初始化的值，生命周期和它所在的实例一样长。<br>类变量，又称静态变量，它是被static修饰的成员变量，它属于一个类，被所有实例共享。每次new一个实例，这样的变量并不会被new一遍，其内存存在于方法区内，可以通过类名直接访问。有默认的初始化值，生命周期很长。</p>\n<ul>\n<li>什么是反射？</li>\n</ul>\n<p>也就是说,在编译时,你获取了一个指向某个并不存在你的程序空间中的对象的引用;事实上在编译时你的程序无法获知这个对象所属的类</p>\n<ul>\n<li>在java中什么是强引用、软引用、弱引用以及虚引用？</li>\n</ul>\n<p>强引用：不会被gc轻易清理，只要引用存在，垃圾回收器永远不会回收。</p>\n<p>软引用：非必须引用，内存溢出之前进行回收</p>\n<p>弱引用：第二次垃圾回收时回收</p>\n<p>虚引用：垃圾回收时回收，无法通过引用取到对象值。</p>\n<ul>\n<li>关键字synchronized的作用是什么？</li>\n</ul>\n<p>synchronized通过修饰一个方法或者代码块，从而产生一个同步对象锁，以及对应的同步代码块。每当有线程要对该同步代码块进行访问时，线程就会首先尝试获取这个对象的锁，并在成功获取到对象锁之后，对这个同步代码块进行正常的访问。在同步代码块的访问过程中，线程会一直持有这个对象锁，直到同步代码块访问完毕，然后才会释放。<br>在上述线程中持有同步锁并且进行同步代码块访问过程中，其他线程无法获得该对象锁，也无法访问该同步代码，这些线程都会被阻塞直到上述线程访问完毕。</p>\n<ul>\n<li>为什么说string不可变？</li>\n</ul>\n<p>string类型在实现时，其内部变量全部使用final来修饰，保证成员变量的引用值只能通过构造函数来修改<br>string类型在实现时，在外部某个地方，可能修改一个string实例的内部存储值的函数实现中，在这个地方的调用返回时，一律构造新的string对象或者新的byte数组或者char数组，给赋值符号的左边变量</p>\n<ul>\n<li>修饰符transient和volatile的作用？</li>\n</ul>\n<p>volatile：易式修饰符，带有volatile修饰的变量，就是当其在某个线程自己的工作内存中发生改变时，会被强制地，写回公共成员变量所在的公共内存处。</p>\n<p>transient是一个类型修饰符，仅仅能用来修饰字段（变量）。在此字段所在的对象进行序列化的时候，这个字段不会被序列化。</p>\n<p>其他没有transient修饰的变量将会被序列化，然后进行传输，或者存储到本地磁盘，transient变量就在这个过程里丢失了</p>\n<ul>\n<li>StringBuffer和StringBuilder的区别在哪里？</li>\n</ul>\n<p>StringBuffer,StringBuilder和String一样，都用来代表字符串。<br>String类是不可变类，任何针对String的改变都会引起string对象的生成。而StringBuilder和StringBuffer则是可变类。StringBuilder不支持并发操作，线程不安全，不适合多线程。而StringBuffer支持并发操作，线程安全，单线程的性能低于StringBuilder</p>\n<ul>\n<li>StringBuilder怎么避免不可变字符串分配的问题？</li>\n</ul>\n<p>String类型在改变的时候都会生成一个新的string，然后指向这个string，因此经常改变内容的字符串最好不要用string，会导致gc。<br>stringbuffer则是每次结果都会对stringbuffer对象本身操作，而不是生成新的对象。</p>\n<ul>\n<li>什么是自动装箱和拆箱？</li>\n</ul>\n<p>装箱就是自动将数据类型转换为包装器类型，拆箱就是自动将包装齐类型转换为基本数据类型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i = 100;</span><br></pre></td></tr></table></figure>\n<p>这句话会被编译器执行为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i = Integer.valueOf(100);</span><br></pre></td></tr></table></figure>\n<p>这就是自动装箱</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i = 10; // autoboxing</span><br><span class=\"line\">int c = i; // unboxing</span><br></pre></td></tr></table></figure>\n<ul>\n<li>枚举和迭代器有什么区别？</li>\n</ul>\n<p>函数接口不同：枚举只有2个函数接口，只能读取集合的数据，而不能更改，迭代器有三个接口，出了读取集合的数据之外，还能进行删除操作</p>\n<p>迭代器支持failfast，而枚举不支持。</p>\n<ul>\n<li>java中fail-fast和fail-safe的区别？</li>\n</ul>\n<p>fail-fast： 当遍历一个集合时，集合结构若被修改，就会抛出ConcurrentModificationException。</p>\n<p>fail-safe:任何对集合的修改都会在一个复制的集合上进行修改，因此不会抛出ConcurrentModificationException。failsafe需要复制集合，产生大量的无效对象，开销大，而且无法保证读取的数据是目前原始数据结构中的数据。</p>\n<ul>\n<li>优先级队列</li>\n</ul>\n<p>priorityQueue类用来表示优先队列，优先队列是一个以集合为基础的抽象数据类型，队列中的每个元素都有一个优先级值，优先级值用来表示该元素的出列的优先级</p>\n<p>java中的优先队列基于堆，堆是一个完全二叉树，所以PriorityQueue不是线性结构，而是树形结构。</p>\n"},{"title":"okhttp+retrofit分析","date":"2019-01-02T14:45:01.000Z","_content":"\n# retrofit的设计思路\n\nretrofit自从接触的时候就知道是做了一层okhttp的封装，当时只知道retrofit做的，自己通过okhttp都可以做。但是细枝末节其实并未了解清楚。\n\n\n## 使用retrofit的方式\n```\nwebService = new Retrofit.Builder().baseUrl(config.getHost())\n                .addConverterFactory(MyGsonConverterFactory.create(gson))\n                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())\n                .client(builder.build())\n                .build().create(WebService.class);\n```\n首先是使用如上的方式创建一个retrofit实例。其中baseUrl指明的是host，ConverterFactory是指明的json转换工具，一般是使用gson。callAdapterFactory是加上了Rxjava的封装。\n\nclient中的builder是一个oktthp的builder，设置了一个okhttp的client，其中设置了需要的okhttp的客户端的配置。\n\n最后就是调用了build来build一个Retrofit的builder。同时通过create传入了webservice.class，这个类就是我们使用的retrofit web接口类，定义了我们项目中需要的网络接口。\n\n## retrofit.builder().build()\n\n```\n public Builder() {\n      this(Platform.get());\n    }\n```\n\nbuilder()是构造，其中只传入了一个platform，是选择平台\n\n```\nprivate static Platform findPlatform() {\n    try {\n      Class.forName(\"android.os.Build\");\n      if (Build.VERSION.SDK_INT != 0) {\n        return new Android();\n      }\n    } catch (ClassNotFoundException ignored) {\n    }\n    try {\n      Class.forName(\"java.util.Optional\");\n      return new Java8();\n    } catch (ClassNotFoundException ignored) {\n    }\n    return new Platform();\n  }\n```\n其功能就是选择是android平台还是java平台\n\n```\npublic Retrofit build() {\n      if (baseUrl == null) {\n        throw new IllegalStateException(\"Base URL required.\");\n      }\n\n      okhttp3.Call.Factory callFactory = this.callFactory;\n      if (callFactory == null) {\n        callFactory = new OkHttpClient();\n      }\n\n      Executor callbackExecutor = this.callbackExecutor;\n      if (callbackExecutor == null) {\n        callbackExecutor = platform.defaultCallbackExecutor();\n      }\n\n      // Make a defensive copy of the adapters and add the default Call adapter.\n      List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);\n      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));\n\n      // Make a defensive copy of the converters.\n      List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);\n\n      return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,\n          callbackExecutor, validateEagerly);\n    }\n```\nbuild的过程是将传入的参数进行赋值，如果没有传入okhttp的client会重新new一个。\n其中的calldapter就是我们使用的rxjava2calladapter，convertfactories就是gsonconvertfactory。除此之外，calldapterfactories又增加了一个platform.defaultCallAdapterFactory(callbackExecutor)\n\n```\nCallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {\n    if (callbackExecutor != null) {\n      return new ExecutorCallAdapterFactory(callbackExecutor);\n    }\n    return DefaultCallAdapterFactory.INSTANCE;\n  }\n```\n\n返回的是Executorcalladapter\n\n```\npublic <T> T create(final Class<T> service) {\n    Utils.validateServiceInterface(service);\n    if (validateEagerly) {\n      eagerlyValidateMethods(service);\n    }\n    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },\n        new InvocationHandler() {\n          private final Platform platform = Platform.get();\n\n          @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)\n              throws Throwable {\n            // If the method is a method from Object then defer to normal invocation.\n            if (method.getDeclaringClass() == Object.class) {\n              return method.invoke(this, args);\n            }\n            if (platform.isDefaultMethod(method)) {\n              return platform.invokeDefaultMethod(method, service, proxy, args);\n            }\n            ServiceMethod<Object, Object> serviceMethod =\n                (ServiceMethod<Object, Object>) loadServiceMethod(method);\n            OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);\n            return serviceMethod.callAdapter.adapt(okHttpCall);\n          }\n        });\n  }\n```\ncreate的过程如上，需要逐条分析。\n\n首先是\n```\nUtils.validateServiceInterface(service);\n```\n其功能就是分析该接口类是否有效，判断依据是否继承了额外的接口类，还有就是该类里面的接口方法数量是否大于0.\n\n```\nif (validateEagerly) {\n      eagerlyValidateMethods(service);\n    }\n```\n名字起的很奇特，功能就是预先加载传入的接口清单的接口。默认是不预先加载\n\n## 动态代理全过程\n\n首先是通过清单文件的classloader来进行hook这个清单文件，判断一下获取的class是否是object.class，就和一般的动态代理相同。\n\n当确认hook的这个方法不是object.class的方法的时候，就会走一遍判断是否是该平台可用的method，不过这里默认都是返回false，貌似是准备后期扩展用。\n\n万事具备之后，会走一次loadmethod，如果之前采取eagerlyValidateMethods的方式的话，此时是直接取出当时读出来的method，否则就是load一下。\n\n```\nServiceMethod<?, ?> loadServiceMethod(Method method) {\n    ServiceMethod<?, ?> result = serviceMethodCache.get(method);\n    if (result != null) return result;\n\n    synchronized (serviceMethodCache) {\n      result = serviceMethodCache.get(method);\n      if (result == null) {\n        result = new ServiceMethod.Builder<>(this, method).build();\n        serviceMethodCache.put(method, result);\n      }\n    }\n    return result;\n  }\n```\nload的方法很明显做了一个cache，此处**缓存下来了method和result**，划重点\n\n在之后就是将获取的method和清单中的方法的参数传入okhttpcall中，创建一个okhttpcall，最后通过\n\n```\nserviceMethod.callAdapter.adapt(okHttpCall);\n```\n来返回一个和清单类型一模一样的类型。\n\n至此，retrofit的代理过程就已经结束。\n\n## calladapter\n\n刚才传入的rxjava2calladapter有什么作用呢？\n\n回到刚才划重点的地方，缓存下来了method和result，result怎么来的呢？\n\n```\nresult = new ServiceMethod.Builder<>(this, method).build();\n```\n\n```\n\tBuilder(Retrofit retrofit, Method method) {\n      this.retrofit = retrofit;\n      this.method = method;\n      this.methodAnnotations = method.getAnnotations();\n      this.parameterTypes = method.getGenericParameterTypes();\n      this.parameterAnnotationsArray = method.getParameterAnnotations();\n    }\n\n    public ServiceMethod build() {\n      callAdapter = createCallAdapter();\n      responseType = callAdapter.responseType();\n      if (responseType == Response.class || responseType == okhttp3.Response.class) {\n        throw methodError(\"'\"\n            + Utils.getRawType(responseType).getName()\n            + \"' is not a valid response body type. Did you mean ResponseBody?\");\n      }\n      responseConverter = createResponseConverter();\n\n      for (Annotation annotation : methodAnnotations) {\n        parseMethodAnnotation(annotation);\n      }\n\n      if (httpMethod == null) {\n        throw methodError(\"HTTP method annotation is required (e.g., @GET, @POST, etc.).\");\n      }\n\n      if (!hasBody) {\n        if (isMultipart) {\n          throw methodError(\n              \"Multipart can only be specified on HTTP methods with request body (e.g., @POST).\");\n        }\n        if (isFormEncoded) {\n          throw methodError(\"FormUrlEncoded can only be specified on HTTP methods with \"\n              + \"request body (e.g., @POST).\");\n        }\n      }\n\n      int parameterCount = parameterAnnotationsArray.length;\n      parameterHandlers = new ParameterHandler<?>[parameterCount];\n      for (int p = 0; p < parameterCount; p++) {\n        Type parameterType = parameterTypes[p];\n        if (Utils.hasUnresolvableType(parameterType)) {\n          throw parameterError(p, \"Parameter type must not include a type variable or wildcard: %s\",\n              parameterType);\n        }\n\n        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];\n        if (parameterAnnotations == null) {\n          throw parameterError(p, \"No Retrofit annotation found.\");\n        }\n\n        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);\n      }\n\n      if (relativeUrl == null && !gotUrl) {\n        throw methodError(\"Missing either @%s URL or @Url parameter.\", httpMethod);\n      }\n      if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {\n        throw methodError(\"Non-body HTTP method cannot contain @Body.\");\n      }\n      if (isFormEncoded && !gotField) {\n        throw methodError(\"Form-encoded method must contain at least one @Field.\");\n      }\n      if (isMultipart && !gotPart) {\n        throw methodError(\"Multipart method must contain at least one @Part.\");\n      }\n\n      return new ServiceMethod<>(this);\n    }\n\n```\n可以看出来,builder()是将注释，方法，方法的形式参数类型和方法的形式参数注释类型给记录下来。\n\nbuild()的操作需要仔细分析\n\n第一步创建calladapter\n\n```\nprivate CallAdapter<T, R> createCallAdapter() {\n      Type returnType = method.getGenericReturnType();\n      if (Utils.hasUnresolvableType(returnType)) {\n        throw methodError(\n            \"Method return type must not include a type variable or wildcard: %s\", returnType);\n      }\n      if (returnType == void.class) {\n        throw methodError(\"Service methods cannot return void.\");\n      }\n      Annotation[] annotations = method.getAnnotations();\n      try {\n        //noinspection unchecked\n        return (CallAdapter<T, R>) retrofit.callAdapter(returnType, annotations);\n      } catch (RuntimeException e) { // Wide exception range because factories are user code.\n        throw methodError(e, \"Unable to create call adapter for %s\", returnType);\n      }\n    }\n```\n创建的过程就是将参数传入，通过调用retrofit这个实例的calladapter方法\n\n```\npublic CallAdapter<?, ?> callAdapter(Type returnType, Annotation[] annotations) {\n    return nextCallAdapter(null, returnType, annotations);\n  }\n```\n\n其中calladapter又调用了nextCallAdapter方法\n\n```\npublic CallAdapter<?, ?> nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,\n      Annotation[] annotations) {\n    checkNotNull(returnType, \"returnType == null\");\n    checkNotNull(annotations, \"annotations == null\");\n\n    int start = adapterFactories.indexOf(skipPast) + 1;\n    for (int i = start, count = adapterFactories.size(); i < count; i++) {\n      CallAdapter<?, ?> adapter = adapterFactories.get(i).get(returnType, annotations, this);\n      if (adapter != null) {\n        return adapter;\n      }\n    }\n\n    StringBuilder builder = new StringBuilder(\"Could not locate call adapter for \")\n        .append(returnType)\n        .append(\".\\n\");\n    if (skipPast != null) {\n      builder.append(\"  Skipped:\");\n      for (int i = 0; i < start; i++) {\n        builder.append(\"\\n   * \").append(adapterFactories.get(i).getClass().getName());\n      }\n      builder.append('\\n');\n    }\n    builder.append(\"  Tried:\");\n    for (int i = start, count = adapterFactories.size(); i < count; i++) {\n      builder.append(\"\\n   * \").append(adapterFactories.get(i).getClass().getName());\n    }\n    throw new IllegalArgumentException(builder.toString());\n  }\n```\n到这里就可以发现，通过adapterFactories将我们之前放入的rxjava2adapter给取出来了\n\n第二步，取出了rxjava2adapter的responseType()，这个type可以从rxjava2adapter里面查到，这里不追溯。\n\n第三步，创建了responseConverter,就是通过我们传入的gsonconverter来构建解析器\n\n第四步，逐个读取该方法的注释。\n\n第五步，进行一系列的检查，检查request的参数是否正确\n\n最后一步\n\n```\nreturn new ServiceMethod<>(this);\n```\n\n可以看出，这个result，其实就是通过将接口的方法进行整合，最后生成的一个结果。这个结果和方法共同被存储下来\n\n**切记，这里并没有缓存response，缓存的是result，result是对method的一个处理结果，调用的其实是rxjava2factory和gsonconvertfactory来配合处理的**\n\n## 请求过程\n\n由于之前传入了ExecutorCallAdapterFactory，此时一个retrofit的实例在app中也已经获取了。之后就看如何使用的\n\n```\nResponse<String> resp = webService.logoutRaw().execute();\n```\n\n执行execute就可以获取到了response。\n\n```\n/**\n   * Synchronously send the request and return its response.\n   *\n   * @throws IOException if a problem occurred talking to the server.\n   * @throws RuntimeException (and subclasses) if an unexpected error occurs creating the request\n   * or decoding the response.\n   */\n  Response<T> execute() throws IOException;\n```\n这个方法是在retrofit的call.java类中，实现是在ExecutorCallbackCall中，具体是操作了一个okhttpcall\n\n```\nstatic final class ExecutorCallbackCall<T> implements Call<T> {\n    final Executor callbackExecutor;\n    final Call<T> delegate;\n\n    ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {\n      this.callbackExecutor = callbackExecutor;\n      this.delegate = delegate;\n    }\n\n    @Override public void enqueue(final Callback<T> callback) {\n      checkNotNull(callback, \"callback == null\");\n\n      delegate.enqueue(new Callback<T>() {\n        @Override public void onResponse(Call<T> call, final Response<T> response) {\n          callbackExecutor.execute(new Runnable() {\n            @Override public void run() {\n              if (delegate.isCanceled()) {\n                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.\n                callback.onFailure(ExecutorCallbackCall.this, new IOException(\"Canceled\"));\n              } else {\n                callback.onResponse(ExecutorCallbackCall.this, response);\n              }\n            }\n          });\n        }\n\n        @Override public void onFailure(Call<T> call, final Throwable t) {\n          callbackExecutor.execute(new Runnable() {\n            @Override public void run() {\n              callback.onFailure(ExecutorCallbackCall.this, t);\n            }\n          });\n        }\n      });\n    }\n\n    @Override public boolean isExecuted() {\n      return delegate.isExecuted();\n    }\n\n    @Override public Response<T> execute() throws IOException {\n      return delegate.execute();\n    }\n\n    @Override public void cancel() {\n      delegate.cancel();\n    }\n\n    @Override public boolean isCanceled() {\n      return delegate.isCanceled();\n    }\n\n    @SuppressWarnings(\"CloneDoesntCallSuperClone\") // Performing deep clone.\n    @Override public Call<T> clone() {\n      return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());\n    }\n\n    @Override public Request request() {\n      return delegate.request();\n    }\n  }\n```\n\n从这里看就知道是执行了callback的方法，这个callback是取自retrofit的rxadapter里面和okhttpcall的realcall中\n\n反馈的细节在\n\n```\nfinal class CallEnqueueObservable<T> extends Observable<Response<T>> {\n  private final Call<T> originalCall;\n\n  CallEnqueueObservable(Call<T> originalCall) {\n    this.originalCall = originalCall;\n  }\n\n  @Override protected void subscribeActual(Observer<? super Response<T>> observer) {\n    // Since Call is a one-shot type, clone it for each new observer.\n    Call<T> call = originalCall.clone();\n    CallCallback<T> callback = new CallCallback<>(call, observer);\n    observer.onSubscribe(callback);\n    call.enqueue(callback);\n  }\n\n  private static final class CallCallback<T> implements Disposable, Callback<T> {\n    private final Call<?> call;\n    private final Observer<? super Response<T>> observer;\n    boolean terminated = false;\n\n    CallCallback(Call<?> call, Observer<? super Response<T>> observer) {\n      this.call = call;\n      this.observer = observer;\n    }\n\n    @Override public void onResponse(Call<T> call, Response<T> response) {\n      if (call.isCanceled()) return;\n\n      try {\n        observer.onNext(response);\n\n        if (!call.isCanceled()) {\n          terminated = true;\n          observer.onComplete();\n        }\n      } catch (Throwable t) {\n        if (terminated) {\n          RxJavaPlugins.onError(t);\n        } else if (!call.isCanceled()) {\n          try {\n            observer.onError(t);\n          } catch (Throwable inner) {\n            Exceptions.throwIfFatal(inner);\n            RxJavaPlugins.onError(new CompositeException(t, inner));\n          }\n        }\n      }\n    }\n\n    @Override public void onFailure(Call<T> call, Throwable t) {\n      if (call.isCanceled()) return;\n\n      try {\n        observer.onError(t);\n      } catch (Throwable inner) {\n        Exceptions.throwIfFatal(inner);\n        RxJavaPlugins.onError(new CompositeException(t, inner));\n      }\n    }\n\n    @Override public void dispose() {\n      call.cancel();\n    }\n\n    @Override public boolean isDisposed() {\n      return call.isCanceled();\n    }\n  }\n}\n```\n\n到这一步就能看懂了，后续的部分都是我们经常使用的地方\n\n## 处理response的部分\n\n```\n@Override public Response<T> execute() throws IOException {\n    okhttp3.Call call;\n\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already executed.\");\n      executed = true;\n\n      if (creationFailure != null) {\n        if (creationFailure instanceof IOException) {\n          throw (IOException) creationFailure;\n        } else {\n          throw (RuntimeException) creationFailure;\n        }\n      }\n\n      call = rawCall;\n      if (call == null) {\n        try {\n          call = rawCall = createRawCall();\n        } catch (IOException | RuntimeException e) {\n          creationFailure = e;\n          throw e;\n        }\n      }\n    }\n\n    if (canceled) {\n      call.cancel();\n    }\n\n    return parseResponse(call.execute());\n  }\n```\n\n可以看到在执行的过程中返回结果的时候直接调用了gson来解析\n\n到这里我看到了解析的过程，看到了执行rxjava的过程，也看到了执行okhttp的过程，理应串起来\n\n## 总结\n\n![retrofit个人理解图](/images/android/Retrofit个人理解图.png)\n\n# okHTTP的设计思路\n\n## 使用\n\n首先从使用看起\n\n```\nOkHttpClient.Builder builder = new OkHttpClient.Builder()\n                .connectTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(30, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .addInterceptor(chain -> {\n                    Request request = chain.request().newBuilder()\n                            //.addHeader(\"App\", headerEncoded(ac.getName()))\n                            .addHeader(\"api_version\", headerEncoded(Const.API_VERSION))\n                            .addHeader(\"App-Version\", headerEncoded(ac.getVersion() + \".\" + ac.getVersionCode()))\n                            .addHeader(\"PUSH-ENV\", headerEncoded(ac.isBuildVersion() ? \"DEV\" : \"PRODUCT\"))\n                            .addHeader(\"Device-Id\", headerEncoded(deviceInfo.getDeviceId()))\n                            .addHeader(\"cookie\", headerEncoded(cookie))\n                            .addHeader(\"x-platform\", \"android\")\n                            .build();\n                    Response response = chain.proceed(request);\n                    context.getSharedPreferences(\"global\", Context.MODE_PRIVATE).edit().putString(\"cookie\", response.header(\"Set-Cookie\")).apply();\n                    cookie = response.header(\"Set-Cookie\");\n                    return response;\n                })\n                .addInterceptor(embedAccessTokenInterceptor);\n```\n\n项目中的okhttp使用，首先需要build一个client，这个里面加了各种参数，读写和连接超时的参数，另外加了一些response处理链。这样一个builder就好了\n\n```\nwebService = new Retrofit.Builder().baseUrl(config.getHost())\n                .addConverterFactory(MyGsonConverterFactory.create(gson))\n                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())\n                .client(builder.build())\n                .build().create(WebService.class);\n```\n这之后就塞到retrofit里面去了。\n\n因此我们先来看一下builder的过程是怎么样的，以此为一个入口\n\n## builder\n\n```\npublic Builder() {\n      dispatcher = new Dispatcher();\n      protocols = DEFAULT_PROTOCOLS;\n      connectionSpecs = DEFAULT_CONNECTION_SPECS;\n      eventListenerFactory = EventListener.factory(EventListener.NONE);\n      proxySelector = ProxySelector.getDefault();\n      cookieJar = CookieJar.NO_COOKIES;\n      socketFactory = SocketFactory.getDefault();\n      hostnameVerifier = OkHostnameVerifier.INSTANCE;\n      certificatePinner = CertificatePinner.DEFAULT;\n      proxyAuthenticator = Authenticator.NONE;\n      authenticator = Authenticator.NONE;\n      connectionPool = new ConnectionPool();\n      dns = Dns.SYSTEM;\n      followSslRedirects = true;\n      followRedirects = true;\n      retryOnConnectionFailure = true;\n      connectTimeout = 10_000;\n      readTimeout = 10_000;\n      writeTimeout = 10_000;\n      pingInterval = 0;\n    }\n```\n\nbuilder构造中加了很多很多参数，而整个builder事实上就是一个参数记录类，记录了所有的类型。\n\n```\n    Dispatcher dispatcher;\n    @Nullable Proxy proxy;\n    List<Protocol> protocols;\n    List<ConnectionSpec> connectionSpecs;\n    final List<Interceptor> interceptors = new ArrayList<>();\n    final List<Interceptor> networkInterceptors = new ArrayList<>();\n    EventListener.Factory eventListenerFactory;\n    ProxySelector proxySelector;\n    CookieJar cookieJar;\n    @Nullable Cache cache;\n    @Nullable InternalCache internalCache;\n    SocketFactory socketFactory;\n    @Nullable SSLSocketFactory sslSocketFactory;\n    @Nullable CertificateChainCleaner certificateChainCleaner;\n    HostnameVerifier hostnameVerifier;\n    CertificatePinner certificatePinner;\n    Authenticator proxyAuthenticator;\n    Authenticator authenticator;\n    ConnectionPool connectionPool;\n    Dns dns;\n    boolean followSslRedirects;\n    boolean followRedirects;\n    boolean retryOnConnectionFailure;\n    int connectTimeout;\n    int readTimeout;\n    int writeTimeout;\n    int pingInterval;\n```\n\n这是其局部变量，基本上每个参数都是可以设置的。暂且掠过不表，因为这个都是可变的，默认的对我们来讲其实没有什么大作用。\n\n## newCall:构建请求\n\n```\nResponse response = client.newCall(request).execute();\n```\n\nresponse封装起来之后，是这样调用的。\n\n按流程捋下去。\n\n```\n@Override public Call newCall(Request request) {\n    return RealCall.newRealCall(this, request, false /* for web socket */);\n  }\n```\n```\nstatic RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {\n    // Safely publish the Call instance to the EventListener.\n    RealCall call = new RealCall(client, originalRequest, forWebSocket);\n    call.eventListener = client.eventListenerFactory().create(call);\n    return call;\n  }\n```\n\n从这里可以看到事实上构建了一个RealCall的端口，然后将其穿进去了一个叫client.eventListenerFactory()的接口里面，这个接口在builder初始化的时候添加的\n\n```\n eventListenerFactory = EventListener.factory(EventListener.NONE);\n```\n\n其内在并未做任何事情，仅仅算是将realcall的eventlistener做一层赋值。\n\n## newCall.execute()：执行请求\n\n```\n@Override public Response execute() throws IOException {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    captureCallStackTrace();\n    eventListener.callStart(this);\n    try {\n      client.dispatcher().executed(this);\n      Response result = getResponseWithInterceptorChain();\n      if (result == null) throw new IOException(\"Canceled\");\n      return result;\n    } catch (IOException e) {\n      eventListener.callFailed(this, e);\n      throw e;\n    } finally {\n      client.dispatcher().finished(this);\n    }\n  }\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/okhttp+retrofit.md","raw":"---\ntitle: okhttp+retrofit分析\ndate: 2019-01-02 22:45:01\ntags: android\n---\n\n# retrofit的设计思路\n\nretrofit自从接触的时候就知道是做了一层okhttp的封装，当时只知道retrofit做的，自己通过okhttp都可以做。但是细枝末节其实并未了解清楚。\n\n\n## 使用retrofit的方式\n```\nwebService = new Retrofit.Builder().baseUrl(config.getHost())\n                .addConverterFactory(MyGsonConverterFactory.create(gson))\n                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())\n                .client(builder.build())\n                .build().create(WebService.class);\n```\n首先是使用如上的方式创建一个retrofit实例。其中baseUrl指明的是host，ConverterFactory是指明的json转换工具，一般是使用gson。callAdapterFactory是加上了Rxjava的封装。\n\nclient中的builder是一个oktthp的builder，设置了一个okhttp的client，其中设置了需要的okhttp的客户端的配置。\n\n最后就是调用了build来build一个Retrofit的builder。同时通过create传入了webservice.class，这个类就是我们使用的retrofit web接口类，定义了我们项目中需要的网络接口。\n\n## retrofit.builder().build()\n\n```\n public Builder() {\n      this(Platform.get());\n    }\n```\n\nbuilder()是构造，其中只传入了一个platform，是选择平台\n\n```\nprivate static Platform findPlatform() {\n    try {\n      Class.forName(\"android.os.Build\");\n      if (Build.VERSION.SDK_INT != 0) {\n        return new Android();\n      }\n    } catch (ClassNotFoundException ignored) {\n    }\n    try {\n      Class.forName(\"java.util.Optional\");\n      return new Java8();\n    } catch (ClassNotFoundException ignored) {\n    }\n    return new Platform();\n  }\n```\n其功能就是选择是android平台还是java平台\n\n```\npublic Retrofit build() {\n      if (baseUrl == null) {\n        throw new IllegalStateException(\"Base URL required.\");\n      }\n\n      okhttp3.Call.Factory callFactory = this.callFactory;\n      if (callFactory == null) {\n        callFactory = new OkHttpClient();\n      }\n\n      Executor callbackExecutor = this.callbackExecutor;\n      if (callbackExecutor == null) {\n        callbackExecutor = platform.defaultCallbackExecutor();\n      }\n\n      // Make a defensive copy of the adapters and add the default Call adapter.\n      List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);\n      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));\n\n      // Make a defensive copy of the converters.\n      List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);\n\n      return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,\n          callbackExecutor, validateEagerly);\n    }\n```\nbuild的过程是将传入的参数进行赋值，如果没有传入okhttp的client会重新new一个。\n其中的calldapter就是我们使用的rxjava2calladapter，convertfactories就是gsonconvertfactory。除此之外，calldapterfactories又增加了一个platform.defaultCallAdapterFactory(callbackExecutor)\n\n```\nCallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {\n    if (callbackExecutor != null) {\n      return new ExecutorCallAdapterFactory(callbackExecutor);\n    }\n    return DefaultCallAdapterFactory.INSTANCE;\n  }\n```\n\n返回的是Executorcalladapter\n\n```\npublic <T> T create(final Class<T> service) {\n    Utils.validateServiceInterface(service);\n    if (validateEagerly) {\n      eagerlyValidateMethods(service);\n    }\n    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },\n        new InvocationHandler() {\n          private final Platform platform = Platform.get();\n\n          @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)\n              throws Throwable {\n            // If the method is a method from Object then defer to normal invocation.\n            if (method.getDeclaringClass() == Object.class) {\n              return method.invoke(this, args);\n            }\n            if (platform.isDefaultMethod(method)) {\n              return platform.invokeDefaultMethod(method, service, proxy, args);\n            }\n            ServiceMethod<Object, Object> serviceMethod =\n                (ServiceMethod<Object, Object>) loadServiceMethod(method);\n            OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);\n            return serviceMethod.callAdapter.adapt(okHttpCall);\n          }\n        });\n  }\n```\ncreate的过程如上，需要逐条分析。\n\n首先是\n```\nUtils.validateServiceInterface(service);\n```\n其功能就是分析该接口类是否有效，判断依据是否继承了额外的接口类，还有就是该类里面的接口方法数量是否大于0.\n\n```\nif (validateEagerly) {\n      eagerlyValidateMethods(service);\n    }\n```\n名字起的很奇特，功能就是预先加载传入的接口清单的接口。默认是不预先加载\n\n## 动态代理全过程\n\n首先是通过清单文件的classloader来进行hook这个清单文件，判断一下获取的class是否是object.class，就和一般的动态代理相同。\n\n当确认hook的这个方法不是object.class的方法的时候，就会走一遍判断是否是该平台可用的method，不过这里默认都是返回false，貌似是准备后期扩展用。\n\n万事具备之后，会走一次loadmethod，如果之前采取eagerlyValidateMethods的方式的话，此时是直接取出当时读出来的method，否则就是load一下。\n\n```\nServiceMethod<?, ?> loadServiceMethod(Method method) {\n    ServiceMethod<?, ?> result = serviceMethodCache.get(method);\n    if (result != null) return result;\n\n    synchronized (serviceMethodCache) {\n      result = serviceMethodCache.get(method);\n      if (result == null) {\n        result = new ServiceMethod.Builder<>(this, method).build();\n        serviceMethodCache.put(method, result);\n      }\n    }\n    return result;\n  }\n```\nload的方法很明显做了一个cache，此处**缓存下来了method和result**，划重点\n\n在之后就是将获取的method和清单中的方法的参数传入okhttpcall中，创建一个okhttpcall，最后通过\n\n```\nserviceMethod.callAdapter.adapt(okHttpCall);\n```\n来返回一个和清单类型一模一样的类型。\n\n至此，retrofit的代理过程就已经结束。\n\n## calladapter\n\n刚才传入的rxjava2calladapter有什么作用呢？\n\n回到刚才划重点的地方，缓存下来了method和result，result怎么来的呢？\n\n```\nresult = new ServiceMethod.Builder<>(this, method).build();\n```\n\n```\n\tBuilder(Retrofit retrofit, Method method) {\n      this.retrofit = retrofit;\n      this.method = method;\n      this.methodAnnotations = method.getAnnotations();\n      this.parameterTypes = method.getGenericParameterTypes();\n      this.parameterAnnotationsArray = method.getParameterAnnotations();\n    }\n\n    public ServiceMethod build() {\n      callAdapter = createCallAdapter();\n      responseType = callAdapter.responseType();\n      if (responseType == Response.class || responseType == okhttp3.Response.class) {\n        throw methodError(\"'\"\n            + Utils.getRawType(responseType).getName()\n            + \"' is not a valid response body type. Did you mean ResponseBody?\");\n      }\n      responseConverter = createResponseConverter();\n\n      for (Annotation annotation : methodAnnotations) {\n        parseMethodAnnotation(annotation);\n      }\n\n      if (httpMethod == null) {\n        throw methodError(\"HTTP method annotation is required (e.g., @GET, @POST, etc.).\");\n      }\n\n      if (!hasBody) {\n        if (isMultipart) {\n          throw methodError(\n              \"Multipart can only be specified on HTTP methods with request body (e.g., @POST).\");\n        }\n        if (isFormEncoded) {\n          throw methodError(\"FormUrlEncoded can only be specified on HTTP methods with \"\n              + \"request body (e.g., @POST).\");\n        }\n      }\n\n      int parameterCount = parameterAnnotationsArray.length;\n      parameterHandlers = new ParameterHandler<?>[parameterCount];\n      for (int p = 0; p < parameterCount; p++) {\n        Type parameterType = parameterTypes[p];\n        if (Utils.hasUnresolvableType(parameterType)) {\n          throw parameterError(p, \"Parameter type must not include a type variable or wildcard: %s\",\n              parameterType);\n        }\n\n        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];\n        if (parameterAnnotations == null) {\n          throw parameterError(p, \"No Retrofit annotation found.\");\n        }\n\n        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);\n      }\n\n      if (relativeUrl == null && !gotUrl) {\n        throw methodError(\"Missing either @%s URL or @Url parameter.\", httpMethod);\n      }\n      if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {\n        throw methodError(\"Non-body HTTP method cannot contain @Body.\");\n      }\n      if (isFormEncoded && !gotField) {\n        throw methodError(\"Form-encoded method must contain at least one @Field.\");\n      }\n      if (isMultipart && !gotPart) {\n        throw methodError(\"Multipart method must contain at least one @Part.\");\n      }\n\n      return new ServiceMethod<>(this);\n    }\n\n```\n可以看出来,builder()是将注释，方法，方法的形式参数类型和方法的形式参数注释类型给记录下来。\n\nbuild()的操作需要仔细分析\n\n第一步创建calladapter\n\n```\nprivate CallAdapter<T, R> createCallAdapter() {\n      Type returnType = method.getGenericReturnType();\n      if (Utils.hasUnresolvableType(returnType)) {\n        throw methodError(\n            \"Method return type must not include a type variable or wildcard: %s\", returnType);\n      }\n      if (returnType == void.class) {\n        throw methodError(\"Service methods cannot return void.\");\n      }\n      Annotation[] annotations = method.getAnnotations();\n      try {\n        //noinspection unchecked\n        return (CallAdapter<T, R>) retrofit.callAdapter(returnType, annotations);\n      } catch (RuntimeException e) { // Wide exception range because factories are user code.\n        throw methodError(e, \"Unable to create call adapter for %s\", returnType);\n      }\n    }\n```\n创建的过程就是将参数传入，通过调用retrofit这个实例的calladapter方法\n\n```\npublic CallAdapter<?, ?> callAdapter(Type returnType, Annotation[] annotations) {\n    return nextCallAdapter(null, returnType, annotations);\n  }\n```\n\n其中calladapter又调用了nextCallAdapter方法\n\n```\npublic CallAdapter<?, ?> nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,\n      Annotation[] annotations) {\n    checkNotNull(returnType, \"returnType == null\");\n    checkNotNull(annotations, \"annotations == null\");\n\n    int start = adapterFactories.indexOf(skipPast) + 1;\n    for (int i = start, count = adapterFactories.size(); i < count; i++) {\n      CallAdapter<?, ?> adapter = adapterFactories.get(i).get(returnType, annotations, this);\n      if (adapter != null) {\n        return adapter;\n      }\n    }\n\n    StringBuilder builder = new StringBuilder(\"Could not locate call adapter for \")\n        .append(returnType)\n        .append(\".\\n\");\n    if (skipPast != null) {\n      builder.append(\"  Skipped:\");\n      for (int i = 0; i < start; i++) {\n        builder.append(\"\\n   * \").append(adapterFactories.get(i).getClass().getName());\n      }\n      builder.append('\\n');\n    }\n    builder.append(\"  Tried:\");\n    for (int i = start, count = adapterFactories.size(); i < count; i++) {\n      builder.append(\"\\n   * \").append(adapterFactories.get(i).getClass().getName());\n    }\n    throw new IllegalArgumentException(builder.toString());\n  }\n```\n到这里就可以发现，通过adapterFactories将我们之前放入的rxjava2adapter给取出来了\n\n第二步，取出了rxjava2adapter的responseType()，这个type可以从rxjava2adapter里面查到，这里不追溯。\n\n第三步，创建了responseConverter,就是通过我们传入的gsonconverter来构建解析器\n\n第四步，逐个读取该方法的注释。\n\n第五步，进行一系列的检查，检查request的参数是否正确\n\n最后一步\n\n```\nreturn new ServiceMethod<>(this);\n```\n\n可以看出，这个result，其实就是通过将接口的方法进行整合，最后生成的一个结果。这个结果和方法共同被存储下来\n\n**切记，这里并没有缓存response，缓存的是result，result是对method的一个处理结果，调用的其实是rxjava2factory和gsonconvertfactory来配合处理的**\n\n## 请求过程\n\n由于之前传入了ExecutorCallAdapterFactory，此时一个retrofit的实例在app中也已经获取了。之后就看如何使用的\n\n```\nResponse<String> resp = webService.logoutRaw().execute();\n```\n\n执行execute就可以获取到了response。\n\n```\n/**\n   * Synchronously send the request and return its response.\n   *\n   * @throws IOException if a problem occurred talking to the server.\n   * @throws RuntimeException (and subclasses) if an unexpected error occurs creating the request\n   * or decoding the response.\n   */\n  Response<T> execute() throws IOException;\n```\n这个方法是在retrofit的call.java类中，实现是在ExecutorCallbackCall中，具体是操作了一个okhttpcall\n\n```\nstatic final class ExecutorCallbackCall<T> implements Call<T> {\n    final Executor callbackExecutor;\n    final Call<T> delegate;\n\n    ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {\n      this.callbackExecutor = callbackExecutor;\n      this.delegate = delegate;\n    }\n\n    @Override public void enqueue(final Callback<T> callback) {\n      checkNotNull(callback, \"callback == null\");\n\n      delegate.enqueue(new Callback<T>() {\n        @Override public void onResponse(Call<T> call, final Response<T> response) {\n          callbackExecutor.execute(new Runnable() {\n            @Override public void run() {\n              if (delegate.isCanceled()) {\n                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.\n                callback.onFailure(ExecutorCallbackCall.this, new IOException(\"Canceled\"));\n              } else {\n                callback.onResponse(ExecutorCallbackCall.this, response);\n              }\n            }\n          });\n        }\n\n        @Override public void onFailure(Call<T> call, final Throwable t) {\n          callbackExecutor.execute(new Runnable() {\n            @Override public void run() {\n              callback.onFailure(ExecutorCallbackCall.this, t);\n            }\n          });\n        }\n      });\n    }\n\n    @Override public boolean isExecuted() {\n      return delegate.isExecuted();\n    }\n\n    @Override public Response<T> execute() throws IOException {\n      return delegate.execute();\n    }\n\n    @Override public void cancel() {\n      delegate.cancel();\n    }\n\n    @Override public boolean isCanceled() {\n      return delegate.isCanceled();\n    }\n\n    @SuppressWarnings(\"CloneDoesntCallSuperClone\") // Performing deep clone.\n    @Override public Call<T> clone() {\n      return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());\n    }\n\n    @Override public Request request() {\n      return delegate.request();\n    }\n  }\n```\n\n从这里看就知道是执行了callback的方法，这个callback是取自retrofit的rxadapter里面和okhttpcall的realcall中\n\n反馈的细节在\n\n```\nfinal class CallEnqueueObservable<T> extends Observable<Response<T>> {\n  private final Call<T> originalCall;\n\n  CallEnqueueObservable(Call<T> originalCall) {\n    this.originalCall = originalCall;\n  }\n\n  @Override protected void subscribeActual(Observer<? super Response<T>> observer) {\n    // Since Call is a one-shot type, clone it for each new observer.\n    Call<T> call = originalCall.clone();\n    CallCallback<T> callback = new CallCallback<>(call, observer);\n    observer.onSubscribe(callback);\n    call.enqueue(callback);\n  }\n\n  private static final class CallCallback<T> implements Disposable, Callback<T> {\n    private final Call<?> call;\n    private final Observer<? super Response<T>> observer;\n    boolean terminated = false;\n\n    CallCallback(Call<?> call, Observer<? super Response<T>> observer) {\n      this.call = call;\n      this.observer = observer;\n    }\n\n    @Override public void onResponse(Call<T> call, Response<T> response) {\n      if (call.isCanceled()) return;\n\n      try {\n        observer.onNext(response);\n\n        if (!call.isCanceled()) {\n          terminated = true;\n          observer.onComplete();\n        }\n      } catch (Throwable t) {\n        if (terminated) {\n          RxJavaPlugins.onError(t);\n        } else if (!call.isCanceled()) {\n          try {\n            observer.onError(t);\n          } catch (Throwable inner) {\n            Exceptions.throwIfFatal(inner);\n            RxJavaPlugins.onError(new CompositeException(t, inner));\n          }\n        }\n      }\n    }\n\n    @Override public void onFailure(Call<T> call, Throwable t) {\n      if (call.isCanceled()) return;\n\n      try {\n        observer.onError(t);\n      } catch (Throwable inner) {\n        Exceptions.throwIfFatal(inner);\n        RxJavaPlugins.onError(new CompositeException(t, inner));\n      }\n    }\n\n    @Override public void dispose() {\n      call.cancel();\n    }\n\n    @Override public boolean isDisposed() {\n      return call.isCanceled();\n    }\n  }\n}\n```\n\n到这一步就能看懂了，后续的部分都是我们经常使用的地方\n\n## 处理response的部分\n\n```\n@Override public Response<T> execute() throws IOException {\n    okhttp3.Call call;\n\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already executed.\");\n      executed = true;\n\n      if (creationFailure != null) {\n        if (creationFailure instanceof IOException) {\n          throw (IOException) creationFailure;\n        } else {\n          throw (RuntimeException) creationFailure;\n        }\n      }\n\n      call = rawCall;\n      if (call == null) {\n        try {\n          call = rawCall = createRawCall();\n        } catch (IOException | RuntimeException e) {\n          creationFailure = e;\n          throw e;\n        }\n      }\n    }\n\n    if (canceled) {\n      call.cancel();\n    }\n\n    return parseResponse(call.execute());\n  }\n```\n\n可以看到在执行的过程中返回结果的时候直接调用了gson来解析\n\n到这里我看到了解析的过程，看到了执行rxjava的过程，也看到了执行okhttp的过程，理应串起来\n\n## 总结\n\n![retrofit个人理解图](/images/android/Retrofit个人理解图.png)\n\n# okHTTP的设计思路\n\n## 使用\n\n首先从使用看起\n\n```\nOkHttpClient.Builder builder = new OkHttpClient.Builder()\n                .connectTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(30, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .addInterceptor(chain -> {\n                    Request request = chain.request().newBuilder()\n                            //.addHeader(\"App\", headerEncoded(ac.getName()))\n                            .addHeader(\"api_version\", headerEncoded(Const.API_VERSION))\n                            .addHeader(\"App-Version\", headerEncoded(ac.getVersion() + \".\" + ac.getVersionCode()))\n                            .addHeader(\"PUSH-ENV\", headerEncoded(ac.isBuildVersion() ? \"DEV\" : \"PRODUCT\"))\n                            .addHeader(\"Device-Id\", headerEncoded(deviceInfo.getDeviceId()))\n                            .addHeader(\"cookie\", headerEncoded(cookie))\n                            .addHeader(\"x-platform\", \"android\")\n                            .build();\n                    Response response = chain.proceed(request);\n                    context.getSharedPreferences(\"global\", Context.MODE_PRIVATE).edit().putString(\"cookie\", response.header(\"Set-Cookie\")).apply();\n                    cookie = response.header(\"Set-Cookie\");\n                    return response;\n                })\n                .addInterceptor(embedAccessTokenInterceptor);\n```\n\n项目中的okhttp使用，首先需要build一个client，这个里面加了各种参数，读写和连接超时的参数，另外加了一些response处理链。这样一个builder就好了\n\n```\nwebService = new Retrofit.Builder().baseUrl(config.getHost())\n                .addConverterFactory(MyGsonConverterFactory.create(gson))\n                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())\n                .client(builder.build())\n                .build().create(WebService.class);\n```\n这之后就塞到retrofit里面去了。\n\n因此我们先来看一下builder的过程是怎么样的，以此为一个入口\n\n## builder\n\n```\npublic Builder() {\n      dispatcher = new Dispatcher();\n      protocols = DEFAULT_PROTOCOLS;\n      connectionSpecs = DEFAULT_CONNECTION_SPECS;\n      eventListenerFactory = EventListener.factory(EventListener.NONE);\n      proxySelector = ProxySelector.getDefault();\n      cookieJar = CookieJar.NO_COOKIES;\n      socketFactory = SocketFactory.getDefault();\n      hostnameVerifier = OkHostnameVerifier.INSTANCE;\n      certificatePinner = CertificatePinner.DEFAULT;\n      proxyAuthenticator = Authenticator.NONE;\n      authenticator = Authenticator.NONE;\n      connectionPool = new ConnectionPool();\n      dns = Dns.SYSTEM;\n      followSslRedirects = true;\n      followRedirects = true;\n      retryOnConnectionFailure = true;\n      connectTimeout = 10_000;\n      readTimeout = 10_000;\n      writeTimeout = 10_000;\n      pingInterval = 0;\n    }\n```\n\nbuilder构造中加了很多很多参数，而整个builder事实上就是一个参数记录类，记录了所有的类型。\n\n```\n    Dispatcher dispatcher;\n    @Nullable Proxy proxy;\n    List<Protocol> protocols;\n    List<ConnectionSpec> connectionSpecs;\n    final List<Interceptor> interceptors = new ArrayList<>();\n    final List<Interceptor> networkInterceptors = new ArrayList<>();\n    EventListener.Factory eventListenerFactory;\n    ProxySelector proxySelector;\n    CookieJar cookieJar;\n    @Nullable Cache cache;\n    @Nullable InternalCache internalCache;\n    SocketFactory socketFactory;\n    @Nullable SSLSocketFactory sslSocketFactory;\n    @Nullable CertificateChainCleaner certificateChainCleaner;\n    HostnameVerifier hostnameVerifier;\n    CertificatePinner certificatePinner;\n    Authenticator proxyAuthenticator;\n    Authenticator authenticator;\n    ConnectionPool connectionPool;\n    Dns dns;\n    boolean followSslRedirects;\n    boolean followRedirects;\n    boolean retryOnConnectionFailure;\n    int connectTimeout;\n    int readTimeout;\n    int writeTimeout;\n    int pingInterval;\n```\n\n这是其局部变量，基本上每个参数都是可以设置的。暂且掠过不表，因为这个都是可变的，默认的对我们来讲其实没有什么大作用。\n\n## newCall:构建请求\n\n```\nResponse response = client.newCall(request).execute();\n```\n\nresponse封装起来之后，是这样调用的。\n\n按流程捋下去。\n\n```\n@Override public Call newCall(Request request) {\n    return RealCall.newRealCall(this, request, false /* for web socket */);\n  }\n```\n```\nstatic RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {\n    // Safely publish the Call instance to the EventListener.\n    RealCall call = new RealCall(client, originalRequest, forWebSocket);\n    call.eventListener = client.eventListenerFactory().create(call);\n    return call;\n  }\n```\n\n从这里可以看到事实上构建了一个RealCall的端口，然后将其穿进去了一个叫client.eventListenerFactory()的接口里面，这个接口在builder初始化的时候添加的\n\n```\n eventListenerFactory = EventListener.factory(EventListener.NONE);\n```\n\n其内在并未做任何事情，仅仅算是将realcall的eventlistener做一层赋值。\n\n## newCall.execute()：执行请求\n\n```\n@Override public Response execute() throws IOException {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    captureCallStackTrace();\n    eventListener.callStart(this);\n    try {\n      client.dispatcher().executed(this);\n      Response result = getResponseWithInterceptorChain();\n      if (result == null) throw new IOException(\"Canceled\");\n      return result;\n    } catch (IOException e) {\n      eventListener.callFailed(this, e);\n      throw e;\n    } finally {\n      client.dispatcher().finished(this);\n    }\n  }\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"okhttp+retrofit","published":1,"updated":"2019-03-12T09:26:33.161Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltu0e00783a8kxz909yrt","content":"<h1 id=\"retrofit的设计思路\"><a href=\"#retrofit的设计思路\" class=\"headerlink\" title=\"retrofit的设计思路\"></a>retrofit的设计思路</h1><p>retrofit自从接触的时候就知道是做了一层okhttp的封装，当时只知道retrofit做的，自己通过okhttp都可以做。但是细枝末节其实并未了解清楚。</p>\n<h2 id=\"使用retrofit的方式\"><a href=\"#使用retrofit的方式\" class=\"headerlink\" title=\"使用retrofit的方式\"></a>使用retrofit的方式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webService = new Retrofit.Builder().baseUrl(config.getHost())</span><br><span class=\"line\">                .addConverterFactory(MyGsonConverterFactory.create(gson))</span><br><span class=\"line\">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class=\"line\">                .client(builder.build())</span><br><span class=\"line\">                .build().create(WebService.class);</span><br></pre></td></tr></table></figure>\n<p>首先是使用如上的方式创建一个retrofit实例。其中baseUrl指明的是host，ConverterFactory是指明的json转换工具，一般是使用gson。callAdapterFactory是加上了Rxjava的封装。</p>\n<p>client中的builder是一个oktthp的builder，设置了一个okhttp的client，其中设置了需要的okhttp的客户端的配置。</p>\n<p>最后就是调用了build来build一个Retrofit的builder。同时通过create传入了webservice.class，这个类就是我们使用的retrofit web接口类，定义了我们项目中需要的网络接口。</p>\n<h2 id=\"retrofit-builder-build\"><a href=\"#retrofit-builder-build\" class=\"headerlink\" title=\"retrofit.builder().build()\"></a>retrofit.builder().build()</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Builder() &#123;</span><br><span class=\"line\">     this(Platform.get());</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>builder()是构造，其中只传入了一个platform，是选择平台</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static Platform findPlatform() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      Class.forName(&quot;android.os.Build&quot;);</span><br><span class=\"line\">      if (Build.VERSION.SDK_INT != 0) &#123;</span><br><span class=\"line\">        return new Android();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; catch (ClassNotFoundException ignored) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      Class.forName(&quot;java.util.Optional&quot;);</span><br><span class=\"line\">      return new Java8();</span><br><span class=\"line\">    &#125; catch (ClassNotFoundException ignored) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return new Platform();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其功能就是选择是android平台还是java平台</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Retrofit build() &#123;</span><br><span class=\"line\">      if (baseUrl == null) &#123;</span><br><span class=\"line\">        throw new IllegalStateException(&quot;Base URL required.&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      okhttp3.Call.Factory callFactory = this.callFactory;</span><br><span class=\"line\">      if (callFactory == null) &#123;</span><br><span class=\"line\">        callFactory = new OkHttpClient();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      Executor callbackExecutor = this.callbackExecutor;</span><br><span class=\"line\">      if (callbackExecutor == null) &#123;</span><br><span class=\"line\">        callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      // Make a defensive copy of the adapters and add the default Call adapter.</span><br><span class=\"line\">      List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories);</span><br><span class=\"line\">      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</span><br><span class=\"line\"></span><br><span class=\"line\">      // Make a defensive copy of the converters.</span><br><span class=\"line\">      List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories);</span><br><span class=\"line\"></span><br><span class=\"line\">      return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,</span><br><span class=\"line\">          callbackExecutor, validateEagerly);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>build的过程是将传入的参数进行赋值，如果没有传入okhttp的client会重新new一个。<br>其中的calldapter就是我们使用的rxjava2calladapter，convertfactories就是gsonconvertfactory。除此之外，calldapterfactories又增加了一个platform.defaultCallAdapterFactory(callbackExecutor)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) &#123;</span><br><span class=\"line\">    if (callbackExecutor != null) &#123;</span><br><span class=\"line\">      return new ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return DefaultCallAdapterFactory.INSTANCE;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>返回的是Executorcalladapter</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</span><br><span class=\"line\">    Utils.validateServiceInterface(service);</span><br><span class=\"line\">    if (validateEagerly) &#123;</span><br><span class=\"line\">      eagerlyValidateMethods(service);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class=\"line\">        new InvocationHandler() &#123;</span><br><span class=\"line\">          private final Platform platform = Platform.get();</span><br><span class=\"line\"></span><br><span class=\"line\">          @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)</span><br><span class=\"line\">              throws Throwable &#123;</span><br><span class=\"line\">            // If the method is a method from Object then defer to normal invocation.</span><br><span class=\"line\">            if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class=\"line\">              return method.invoke(this, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (platform.isDefaultMethod(method)) &#123;</span><br><span class=\"line\">              return platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class=\"line\">                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class=\"line\">            OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class=\"line\">            return serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>create的过程如上，需要逐条分析。</p>\n<p>首先是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Utils.validateServiceInterface(service);</span><br></pre></td></tr></table></figure></p>\n<p>其功能就是分析该接口类是否有效，判断依据是否继承了额外的接口类，还有就是该类里面的接口方法数量是否大于0.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (validateEagerly) &#123;</span><br><span class=\"line\">      eagerlyValidateMethods(service);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>名字起的很奇特，功能就是预先加载传入的接口清单的接口。默认是不预先加载</p>\n<h2 id=\"动态代理全过程\"><a href=\"#动态代理全过程\" class=\"headerlink\" title=\"动态代理全过程\"></a>动态代理全过程</h2><p>首先是通过清单文件的classloader来进行hook这个清单文件，判断一下获取的class是否是object.class，就和一般的动态代理相同。</p>\n<p>当确认hook的这个方法不是object.class的方法的时候，就会走一遍判断是否是该平台可用的method，不过这里默认都是返回false，貌似是准备后期扩展用。</p>\n<p>万事具备之后，会走一次loadmethod，如果之前采取eagerlyValidateMethods的方式的话，此时是直接取出当时读出来的method，否则就是load一下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123;</span><br><span class=\"line\">    ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);</span><br><span class=\"line\">    if (result != null) return result;</span><br><span class=\"line\"></span><br><span class=\"line\">    synchronized (serviceMethodCache) &#123;</span><br><span class=\"line\">      result = serviceMethodCache.get(method);</span><br><span class=\"line\">      if (result == null) &#123;</span><br><span class=\"line\">        result = new ServiceMethod.Builder&lt;&gt;(this, method).build();</span><br><span class=\"line\">        serviceMethodCache.put(method, result);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>load的方法很明显做了一个cache，此处<strong>缓存下来了method和result</strong>，划重点</p>\n<p>在之后就是将获取的method和清单中的方法的参数传入okhttpcall中，创建一个okhttpcall，最后通过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">serviceMethod.callAdapter.adapt(okHttpCall);</span><br></pre></td></tr></table></figure>\n<p>来返回一个和清单类型一模一样的类型。</p>\n<p>至此，retrofit的代理过程就已经结束。</p>\n<h2 id=\"calladapter\"><a href=\"#calladapter\" class=\"headerlink\" title=\"calladapter\"></a>calladapter</h2><p>刚才传入的rxjava2calladapter有什么作用呢？</p>\n<p>回到刚才划重点的地方，缓存下来了method和result，result怎么来的呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = new ServiceMethod.Builder&lt;&gt;(this, method).build();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Builder(Retrofit retrofit, Method method) &#123;</span><br><span class=\"line\">     this.retrofit = retrofit;</span><br><span class=\"line\">     this.method = method;</span><br><span class=\"line\">     this.methodAnnotations = method.getAnnotations();</span><br><span class=\"line\">     this.parameterTypes = method.getGenericParameterTypes();</span><br><span class=\"line\">     this.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   public ServiceMethod build() &#123;</span><br><span class=\"line\">     callAdapter = createCallAdapter();</span><br><span class=\"line\">     responseType = callAdapter.responseType();</span><br><span class=\"line\">     if (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class=\"line\">       throw methodError(&quot;&apos;&quot;</span><br><span class=\"line\">           + Utils.getRawType(responseType).getName()</span><br><span class=\"line\">           + &quot;&apos; is not a valid response body type. Did you mean ResponseBody?&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     responseConverter = createResponseConverter();</span><br><span class=\"line\"></span><br><span class=\"line\">     for (Annotation annotation : methodAnnotations) &#123;</span><br><span class=\"line\">       parseMethodAnnotation(annotation);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     if (httpMethod == null) &#123;</span><br><span class=\"line\">       throw methodError(&quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     if (!hasBody) &#123;</span><br><span class=\"line\">       if (isMultipart) &#123;</span><br><span class=\"line\">         throw methodError(</span><br><span class=\"line\">             &quot;Multipart can only be specified on HTTP methods with request body (e.g., @POST).&quot;);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       if (isFormEncoded) &#123;</span><br><span class=\"line\">         throw methodError(&quot;FormUrlEncoded can only be specified on HTTP methods with &quot;</span><br><span class=\"line\">             + &quot;request body (e.g., @POST).&quot;);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     int parameterCount = parameterAnnotationsArray.length;</span><br><span class=\"line\">     parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class=\"line\">     for (int p = 0; p &lt; parameterCount; p++) &#123;</span><br><span class=\"line\">       Type parameterType = parameterTypes[p];</span><br><span class=\"line\">       if (Utils.hasUnresolvableType(parameterType)) &#123;</span><br><span class=\"line\">         throw parameterError(p, &quot;Parameter type must not include a type variable or wildcard: %s&quot;,</span><br><span class=\"line\">             parameterType);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</span><br><span class=\"line\">       if (parameterAnnotations == null) &#123;</span><br><span class=\"line\">         throw parameterError(p, &quot;No Retrofit annotation found.&quot;);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     if (relativeUrl == null &amp;&amp; !gotUrl) &#123;</span><br><span class=\"line\">       throw methodError(&quot;Missing either @%s URL or @Url parameter.&quot;, httpMethod);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</span><br><span class=\"line\">       throw methodError(&quot;Non-body HTTP method cannot contain @Body.&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     if (isFormEncoded &amp;&amp; !gotField) &#123;</span><br><span class=\"line\">       throw methodError(&quot;Form-encoded method must contain at least one @Field.&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     if (isMultipart &amp;&amp; !gotPart) &#123;</span><br><span class=\"line\">       throw methodError(&quot;Multipart method must contain at least one @Part.&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     return new ServiceMethod&lt;&gt;(this);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出来,builder()是将注释，方法，方法的形式参数类型和方法的形式参数注释类型给记录下来。</p>\n<p>build()的操作需要仔细分析</p>\n<p>第一步创建calladapter</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private CallAdapter&lt;T, R&gt; createCallAdapter() &#123;</span><br><span class=\"line\">      Type returnType = method.getGenericReturnType();</span><br><span class=\"line\">      if (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class=\"line\">        throw methodError(</span><br><span class=\"line\">            &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (returnType == void.class) &#123;</span><br><span class=\"line\">        throw methodError(&quot;Service methods cannot return void.&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      Annotation[] annotations = method.getAnnotations();</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        //noinspection unchecked</span><br><span class=\"line\">        return (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class=\"line\">      &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code.</span><br><span class=\"line\">        throw methodError(e, &quot;Unable to create call adapter for %s&quot;, returnType);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>创建的过程就是将参数传入，通过调用retrofit这个实例的calladapter方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;</span><br><span class=\"line\">    return nextCallAdapter(null, returnType, annotations);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其中calladapter又调用了nextCallAdapter方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public CallAdapter&lt;?, ?&gt; nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,</span><br><span class=\"line\">      Annotation[] annotations) &#123;</span><br><span class=\"line\">    checkNotNull(returnType, &quot;returnType == null&quot;);</span><br><span class=\"line\">    checkNotNull(annotations, &quot;annotations == null&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    int start = adapterFactories.indexOf(skipPast) + 1;</span><br><span class=\"line\">    for (int i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class=\"line\">      CallAdapter&lt;?, ?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, this);</span><br><span class=\"line\">      if (adapter != null) &#123;</span><br><span class=\"line\">        return adapter;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    StringBuilder builder = new StringBuilder(&quot;Could not locate call adapter for &quot;)</span><br><span class=\"line\">        .append(returnType)</span><br><span class=\"line\">        .append(&quot;.\\n&quot;);</span><br><span class=\"line\">    if (skipPast != null) &#123;</span><br><span class=\"line\">      builder.append(&quot;  Skipped:&quot;);</span><br><span class=\"line\">      for (int i = 0; i &lt; start; i++) &#123;</span><br><span class=\"line\">        builder.append(&quot;\\n   * &quot;).append(adapterFactories.get(i).getClass().getName());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      builder.append(&apos;\\n&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    builder.append(&quot;  Tried:&quot;);</span><br><span class=\"line\">    for (int i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class=\"line\">      builder.append(&quot;\\n   * &quot;).append(adapterFactories.get(i).getClass().getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    throw new IllegalArgumentException(builder.toString());</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>到这里就可以发现，通过adapterFactories将我们之前放入的rxjava2adapter给取出来了</p>\n<p>第二步，取出了rxjava2adapter的responseType()，这个type可以从rxjava2adapter里面查到，这里不追溯。</p>\n<p>第三步，创建了responseConverter,就是通过我们传入的gsonconverter来构建解析器</p>\n<p>第四步，逐个读取该方法的注释。</p>\n<p>第五步，进行一系列的检查，检查request的参数是否正确</p>\n<p>最后一步</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return new ServiceMethod&lt;&gt;(this);</span><br></pre></td></tr></table></figure>\n<p>可以看出，这个result，其实就是通过将接口的方法进行整合，最后生成的一个结果。这个结果和方法共同被存储下来</p>\n<p><strong>切记，这里并没有缓存response，缓存的是result，result是对method的一个处理结果，调用的其实是rxjava2factory和gsonconvertfactory来配合处理的</strong></p>\n<h2 id=\"请求过程\"><a href=\"#请求过程\" class=\"headerlink\" title=\"请求过程\"></a>请求过程</h2><p>由于之前传入了ExecutorCallAdapterFactory，此时一个retrofit的实例在app中也已经获取了。之后就看如何使用的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Response&lt;String&gt; resp = webService.logoutRaw().execute();</span><br></pre></td></tr></table></figure>\n<p>执行execute就可以获取到了response。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">   * Synchronously send the request and return its response.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @throws IOException if a problem occurred talking to the server.</span><br><span class=\"line\">   * @throws RuntimeException (and subclasses) if an unexpected error occurs creating the request</span><br><span class=\"line\">   * or decoding the response.</span><br><span class=\"line\">   */</span><br><span class=\"line\">  Response&lt;T&gt; execute() throws IOException;</span><br></pre></td></tr></table></figure>\n<p>这个方法是在retrofit的call.java类中，实现是在ExecutorCallbackCall中，具体是操作了一个okhttpcall</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class=\"line\">    final Executor callbackExecutor;</span><br><span class=\"line\">    final Call&lt;T&gt; delegate;</span><br><span class=\"line\"></span><br><span class=\"line\">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class=\"line\">      this.callbackExecutor = callbackExecutor;</span><br><span class=\"line\">      this.delegate = delegate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</span><br><span class=\"line\">      checkNotNull(callback, &quot;callback == null&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">      delegate.enqueue(new Callback&lt;T&gt;() &#123;</span><br><span class=\"line\">        @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</span><br><span class=\"line\">          callbackExecutor.execute(new Runnable() &#123;</span><br><span class=\"line\">            @Override public void run() &#123;</span><br><span class=\"line\">              if (delegate.isCanceled()) &#123;</span><br><span class=\"line\">                // Emulate OkHttp&apos;s behavior of throwing/delivering an IOException on cancellation.</span><br><span class=\"line\">                callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class=\"line\">              &#125; else &#123;</span><br><span class=\"line\">                callback.onResponse(ExecutorCallbackCall.this, response);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;</span><br><span class=\"line\">          callbackExecutor.execute(new Runnable() &#123;</span><br><span class=\"line\">            @Override public void run() &#123;</span><br><span class=\"line\">              callback.onFailure(ExecutorCallbackCall.this, t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public boolean isExecuted() &#123;</span><br><span class=\"line\">      return delegate.isExecuted();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public Response&lt;T&gt; execute() throws IOException &#123;</span><br><span class=\"line\">      return delegate.execute();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public void cancel() &#123;</span><br><span class=\"line\">      delegate.cancel();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public boolean isCanceled() &#123;</span><br><span class=\"line\">      return delegate.isCanceled();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @SuppressWarnings(&quot;CloneDoesntCallSuperClone&quot;) // Performing deep clone.</span><br><span class=\"line\">    @Override public Call&lt;T&gt; clone() &#123;</span><br><span class=\"line\">      return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, delegate.clone());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public Request request() &#123;</span><br><span class=\"line\">      return delegate.request();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>从这里看就知道是执行了callback的方法，这个callback是取自retrofit的rxadapter里面和okhttpcall的realcall中</p>\n<p>反馈的细节在</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final class CallEnqueueObservable&lt;T&gt; extends Observable&lt;Response&lt;T&gt;&gt; &#123;</span><br><span class=\"line\">  private final Call&lt;T&gt; originalCall;</span><br><span class=\"line\"></span><br><span class=\"line\">  CallEnqueueObservable(Call&lt;T&gt; originalCall) &#123;</span><br><span class=\"line\">    this.originalCall = originalCall;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  @Override protected void subscribeActual(Observer&lt;? super Response&lt;T&gt;&gt; observer) &#123;</span><br><span class=\"line\">    // Since Call is a one-shot type, clone it for each new observer.</span><br><span class=\"line\">    Call&lt;T&gt; call = originalCall.clone();</span><br><span class=\"line\">    CallCallback&lt;T&gt; callback = new CallCallback&lt;&gt;(call, observer);</span><br><span class=\"line\">    observer.onSubscribe(callback);</span><br><span class=\"line\">    call.enqueue(callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  private static final class CallCallback&lt;T&gt; implements Disposable, Callback&lt;T&gt; &#123;</span><br><span class=\"line\">    private final Call&lt;?&gt; call;</span><br><span class=\"line\">    private final Observer&lt;? super Response&lt;T&gt;&gt; observer;</span><br><span class=\"line\">    boolean terminated = false;</span><br><span class=\"line\"></span><br><span class=\"line\">    CallCallback(Call&lt;?&gt; call, Observer&lt;? super Response&lt;T&gt;&gt; observer) &#123;</span><br><span class=\"line\">      this.call = call;</span><br><span class=\"line\">      this.observer = observer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public void onResponse(Call&lt;T&gt; call, Response&lt;T&gt; response) &#123;</span><br><span class=\"line\">      if (call.isCanceled()) return;</span><br><span class=\"line\"></span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        observer.onNext(response);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (!call.isCanceled()) &#123;</span><br><span class=\"line\">          terminated = true;</span><br><span class=\"line\">          observer.onComplete();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; catch (Throwable t) &#123;</span><br><span class=\"line\">        if (terminated) &#123;</span><br><span class=\"line\">          RxJavaPlugins.onError(t);</span><br><span class=\"line\">        &#125; else if (!call.isCanceled()) &#123;</span><br><span class=\"line\">          try &#123;</span><br><span class=\"line\">            observer.onError(t);</span><br><span class=\"line\">          &#125; catch (Throwable inner) &#123;</span><br><span class=\"line\">            Exceptions.throwIfFatal(inner);</span><br><span class=\"line\">            RxJavaPlugins.onError(new CompositeException(t, inner));</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public void onFailure(Call&lt;T&gt; call, Throwable t) &#123;</span><br><span class=\"line\">      if (call.isCanceled()) return;</span><br><span class=\"line\"></span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        observer.onError(t);</span><br><span class=\"line\">      &#125; catch (Throwable inner) &#123;</span><br><span class=\"line\">        Exceptions.throwIfFatal(inner);</span><br><span class=\"line\">        RxJavaPlugins.onError(new CompositeException(t, inner));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public void dispose() &#123;</span><br><span class=\"line\">      call.cancel();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public boolean isDisposed() &#123;</span><br><span class=\"line\">      return call.isCanceled();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这一步就能看懂了，后续的部分都是我们经常使用的地方</p>\n<h2 id=\"处理response的部分\"><a href=\"#处理response的部分\" class=\"headerlink\" title=\"处理response的部分\"></a>处理response的部分</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override public Response&lt;T&gt; execute() throws IOException &#123;</span><br><span class=\"line\">    okhttp3.Call call;</span><br><span class=\"line\"></span><br><span class=\"line\">    synchronized (this) &#123;</span><br><span class=\"line\">      if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);</span><br><span class=\"line\">      executed = true;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (creationFailure != null) &#123;</span><br><span class=\"line\">        if (creationFailure instanceof IOException) &#123;</span><br><span class=\"line\">          throw (IOException) creationFailure;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          throw (RuntimeException) creationFailure;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      call = rawCall;</span><br><span class=\"line\">      if (call == null) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">          call = rawCall = createRawCall();</span><br><span class=\"line\">        &#125; catch (IOException | RuntimeException e) &#123;</span><br><span class=\"line\">          creationFailure = e;</span><br><span class=\"line\">          throw e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (canceled) &#123;</span><br><span class=\"line\">      call.cancel();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return parseResponse(call.execute());</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到在执行的过程中返回结果的时候直接调用了gson来解析</p>\n<p>到这里我看到了解析的过程，看到了执行rxjava的过程，也看到了执行okhttp的过程，理应串起来</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"/images/android/Retrofit个人理解图.png\" alt=\"retrofit个人理解图\"></p>\n<h1 id=\"okHTTP的设计思路\"><a href=\"#okHTTP的设计思路\" class=\"headerlink\" title=\"okHTTP的设计思路\"></a>okHTTP的设计思路</h1><h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>首先从使用看起</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OkHttpClient.Builder builder = new OkHttpClient.Builder()</span><br><span class=\"line\">                .connectTimeout(30, TimeUnit.SECONDS)</span><br><span class=\"line\">                .writeTimeout(30, TimeUnit.SECONDS)</span><br><span class=\"line\">                .readTimeout(30, TimeUnit.SECONDS)</span><br><span class=\"line\">                .addInterceptor(chain -&gt; &#123;</span><br><span class=\"line\">                    Request request = chain.request().newBuilder()</span><br><span class=\"line\">                            //.addHeader(&quot;App&quot;, headerEncoded(ac.getName()))</span><br><span class=\"line\">                            .addHeader(&quot;api_version&quot;, headerEncoded(Const.API_VERSION))</span><br><span class=\"line\">                            .addHeader(&quot;App-Version&quot;, headerEncoded(ac.getVersion() + &quot;.&quot; + ac.getVersionCode()))</span><br><span class=\"line\">                            .addHeader(&quot;PUSH-ENV&quot;, headerEncoded(ac.isBuildVersion() ? &quot;DEV&quot; : &quot;PRODUCT&quot;))</span><br><span class=\"line\">                            .addHeader(&quot;Device-Id&quot;, headerEncoded(deviceInfo.getDeviceId()))</span><br><span class=\"line\">                            .addHeader(&quot;cookie&quot;, headerEncoded(cookie))</span><br><span class=\"line\">                            .addHeader(&quot;x-platform&quot;, &quot;android&quot;)</span><br><span class=\"line\">                            .build();</span><br><span class=\"line\">                    Response response = chain.proceed(request);</span><br><span class=\"line\">                    context.getSharedPreferences(&quot;global&quot;, Context.MODE_PRIVATE).edit().putString(&quot;cookie&quot;, response.header(&quot;Set-Cookie&quot;)).apply();</span><br><span class=\"line\">                    cookie = response.header(&quot;Set-Cookie&quot;);</span><br><span class=\"line\">                    return response;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .addInterceptor(embedAccessTokenInterceptor);</span><br></pre></td></tr></table></figure>\n<p>项目中的okhttp使用，首先需要build一个client，这个里面加了各种参数，读写和连接超时的参数，另外加了一些response处理链。这样一个builder就好了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webService = new Retrofit.Builder().baseUrl(config.getHost())</span><br><span class=\"line\">                .addConverterFactory(MyGsonConverterFactory.create(gson))</span><br><span class=\"line\">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class=\"line\">                .client(builder.build())</span><br><span class=\"line\">                .build().create(WebService.class);</span><br></pre></td></tr></table></figure>\n<p>这之后就塞到retrofit里面去了。</p>\n<p>因此我们先来看一下builder的过程是怎么样的，以此为一个入口</p>\n<h2 id=\"builder\"><a href=\"#builder\" class=\"headerlink\" title=\"builder\"></a>builder</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Builder() &#123;</span><br><span class=\"line\">      dispatcher = new Dispatcher();</span><br><span class=\"line\">      protocols = DEFAULT_PROTOCOLS;</span><br><span class=\"line\">      connectionSpecs = DEFAULT_CONNECTION_SPECS;</span><br><span class=\"line\">      eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class=\"line\">      proxySelector = ProxySelector.getDefault();</span><br><span class=\"line\">      cookieJar = CookieJar.NO_COOKIES;</span><br><span class=\"line\">      socketFactory = SocketFactory.getDefault();</span><br><span class=\"line\">      hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class=\"line\">      certificatePinner = CertificatePinner.DEFAULT;</span><br><span class=\"line\">      proxyAuthenticator = Authenticator.NONE;</span><br><span class=\"line\">      authenticator = Authenticator.NONE;</span><br><span class=\"line\">      connectionPool = new ConnectionPool();</span><br><span class=\"line\">      dns = Dns.SYSTEM;</span><br><span class=\"line\">      followSslRedirects = true;</span><br><span class=\"line\">      followRedirects = true;</span><br><span class=\"line\">      retryOnConnectionFailure = true;</span><br><span class=\"line\">      connectTimeout = 10_000;</span><br><span class=\"line\">      readTimeout = 10_000;</span><br><span class=\"line\">      writeTimeout = 10_000;</span><br><span class=\"line\">      pingInterval = 0;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>builder构造中加了很多很多参数，而整个builder事实上就是一个参数记录类，记录了所有的类型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dispatcher dispatcher;</span><br><span class=\"line\">@Nullable Proxy proxy;</span><br><span class=\"line\">List&lt;Protocol&gt; protocols;</span><br><span class=\"line\">List&lt;ConnectionSpec&gt; connectionSpecs;</span><br><span class=\"line\">final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class=\"line\">final List&lt;Interceptor&gt; networkInterceptors = new ArrayList&lt;&gt;();</span><br><span class=\"line\">EventListener.Factory eventListenerFactory;</span><br><span class=\"line\">ProxySelector proxySelector;</span><br><span class=\"line\">CookieJar cookieJar;</span><br><span class=\"line\">@Nullable Cache cache;</span><br><span class=\"line\">@Nullable InternalCache internalCache;</span><br><span class=\"line\">SocketFactory socketFactory;</span><br><span class=\"line\">@Nullable SSLSocketFactory sslSocketFactory;</span><br><span class=\"line\">@Nullable CertificateChainCleaner certificateChainCleaner;</span><br><span class=\"line\">HostnameVerifier hostnameVerifier;</span><br><span class=\"line\">CertificatePinner certificatePinner;</span><br><span class=\"line\">Authenticator proxyAuthenticator;</span><br><span class=\"line\">Authenticator authenticator;</span><br><span class=\"line\">ConnectionPool connectionPool;</span><br><span class=\"line\">Dns dns;</span><br><span class=\"line\">boolean followSslRedirects;</span><br><span class=\"line\">boolean followRedirects;</span><br><span class=\"line\">boolean retryOnConnectionFailure;</span><br><span class=\"line\">int connectTimeout;</span><br><span class=\"line\">int readTimeout;</span><br><span class=\"line\">int writeTimeout;</span><br><span class=\"line\">int pingInterval;</span><br></pre></td></tr></table></figure>\n<p>这是其局部变量，基本上每个参数都是可以设置的。暂且掠过不表，因为这个都是可变的，默认的对我们来讲其实没有什么大作用。</p>\n<h2 id=\"newCall-构建请求\"><a href=\"#newCall-构建请求\" class=\"headerlink\" title=\"newCall:构建请求\"></a>newCall:构建请求</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Response response = client.newCall(request).execute();</span><br></pre></td></tr></table></figure>\n<p>response封装起来之后，是这样调用的。</p>\n<p>按流程捋下去。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override public Call newCall(Request request) &#123;</span><br><span class=\"line\">    return RealCall.newRealCall(this, request, false /* for web socket */);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123;</span><br><span class=\"line\">    // Safely publish the Call instance to the EventListener.</span><br><span class=\"line\">    RealCall call = new RealCall(client, originalRequest, forWebSocket);</span><br><span class=\"line\">    call.eventListener = client.eventListenerFactory().create(call);</span><br><span class=\"line\">    return call;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>从这里可以看到事实上构建了一个RealCall的端口，然后将其穿进去了一个叫client.eventListenerFactory()的接口里面，这个接口在builder初始化的时候添加的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br></pre></td></tr></table></figure>\n<p>其内在并未做任何事情，仅仅算是将realcall的eventlistener做一层赋值。</p>\n<h2 id=\"newCall-execute-：执行请求\"><a href=\"#newCall-execute-：执行请求\" class=\"headerlink\" title=\"newCall.execute()：执行请求\"></a>newCall.execute()：执行请求</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override public Response execute() throws IOException &#123;</span><br><span class=\"line\">    synchronized (this) &#123;</span><br><span class=\"line\">      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class=\"line\">      executed = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    captureCallStackTrace();</span><br><span class=\"line\">    eventListener.callStart(this);</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      client.dispatcher().executed(this);</span><br><span class=\"line\">      Response result = getResponseWithInterceptorChain();</span><br><span class=\"line\">      if (result == null) throw new IOException(&quot;Canceled&quot;);</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125; catch (IOException e) &#123;</span><br><span class=\"line\">      eventListener.callFailed(this, e);</span><br><span class=\"line\">      throw e;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">      client.dispatcher().finished(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"retrofit的设计思路\"><a href=\"#retrofit的设计思路\" class=\"headerlink\" title=\"retrofit的设计思路\"></a>retrofit的设计思路</h1><p>retrofit自从接触的时候就知道是做了一层okhttp的封装，当时只知道retrofit做的，自己通过okhttp都可以做。但是细枝末节其实并未了解清楚。</p>\n<h2 id=\"使用retrofit的方式\"><a href=\"#使用retrofit的方式\" class=\"headerlink\" title=\"使用retrofit的方式\"></a>使用retrofit的方式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webService = new Retrofit.Builder().baseUrl(config.getHost())</span><br><span class=\"line\">                .addConverterFactory(MyGsonConverterFactory.create(gson))</span><br><span class=\"line\">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class=\"line\">                .client(builder.build())</span><br><span class=\"line\">                .build().create(WebService.class);</span><br></pre></td></tr></table></figure>\n<p>首先是使用如上的方式创建一个retrofit实例。其中baseUrl指明的是host，ConverterFactory是指明的json转换工具，一般是使用gson。callAdapterFactory是加上了Rxjava的封装。</p>\n<p>client中的builder是一个oktthp的builder，设置了一个okhttp的client，其中设置了需要的okhttp的客户端的配置。</p>\n<p>最后就是调用了build来build一个Retrofit的builder。同时通过create传入了webservice.class，这个类就是我们使用的retrofit web接口类，定义了我们项目中需要的网络接口。</p>\n<h2 id=\"retrofit-builder-build\"><a href=\"#retrofit-builder-build\" class=\"headerlink\" title=\"retrofit.builder().build()\"></a>retrofit.builder().build()</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Builder() &#123;</span><br><span class=\"line\">     this(Platform.get());</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>builder()是构造，其中只传入了一个platform，是选择平台</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static Platform findPlatform() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      Class.forName(&quot;android.os.Build&quot;);</span><br><span class=\"line\">      if (Build.VERSION.SDK_INT != 0) &#123;</span><br><span class=\"line\">        return new Android();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; catch (ClassNotFoundException ignored) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      Class.forName(&quot;java.util.Optional&quot;);</span><br><span class=\"line\">      return new Java8();</span><br><span class=\"line\">    &#125; catch (ClassNotFoundException ignored) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return new Platform();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其功能就是选择是android平台还是java平台</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Retrofit build() &#123;</span><br><span class=\"line\">      if (baseUrl == null) &#123;</span><br><span class=\"line\">        throw new IllegalStateException(&quot;Base URL required.&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      okhttp3.Call.Factory callFactory = this.callFactory;</span><br><span class=\"line\">      if (callFactory == null) &#123;</span><br><span class=\"line\">        callFactory = new OkHttpClient();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      Executor callbackExecutor = this.callbackExecutor;</span><br><span class=\"line\">      if (callbackExecutor == null) &#123;</span><br><span class=\"line\">        callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      // Make a defensive copy of the adapters and add the default Call adapter.</span><br><span class=\"line\">      List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories);</span><br><span class=\"line\">      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</span><br><span class=\"line\"></span><br><span class=\"line\">      // Make a defensive copy of the converters.</span><br><span class=\"line\">      List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories);</span><br><span class=\"line\"></span><br><span class=\"line\">      return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,</span><br><span class=\"line\">          callbackExecutor, validateEagerly);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>build的过程是将传入的参数进行赋值，如果没有传入okhttp的client会重新new一个。<br>其中的calldapter就是我们使用的rxjava2calladapter，convertfactories就是gsonconvertfactory。除此之外，calldapterfactories又增加了一个platform.defaultCallAdapterFactory(callbackExecutor)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) &#123;</span><br><span class=\"line\">    if (callbackExecutor != null) &#123;</span><br><span class=\"line\">      return new ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return DefaultCallAdapterFactory.INSTANCE;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>返回的是Executorcalladapter</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</span><br><span class=\"line\">    Utils.validateServiceInterface(service);</span><br><span class=\"line\">    if (validateEagerly) &#123;</span><br><span class=\"line\">      eagerlyValidateMethods(service);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class=\"line\">        new InvocationHandler() &#123;</span><br><span class=\"line\">          private final Platform platform = Platform.get();</span><br><span class=\"line\"></span><br><span class=\"line\">          @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)</span><br><span class=\"line\">              throws Throwable &#123;</span><br><span class=\"line\">            // If the method is a method from Object then defer to normal invocation.</span><br><span class=\"line\">            if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class=\"line\">              return method.invoke(this, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (platform.isDefaultMethod(method)) &#123;</span><br><span class=\"line\">              return platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class=\"line\">                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class=\"line\">            OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class=\"line\">            return serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>create的过程如上，需要逐条分析。</p>\n<p>首先是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Utils.validateServiceInterface(service);</span><br></pre></td></tr></table></figure></p>\n<p>其功能就是分析该接口类是否有效，判断依据是否继承了额外的接口类，还有就是该类里面的接口方法数量是否大于0.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (validateEagerly) &#123;</span><br><span class=\"line\">      eagerlyValidateMethods(service);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>名字起的很奇特，功能就是预先加载传入的接口清单的接口。默认是不预先加载</p>\n<h2 id=\"动态代理全过程\"><a href=\"#动态代理全过程\" class=\"headerlink\" title=\"动态代理全过程\"></a>动态代理全过程</h2><p>首先是通过清单文件的classloader来进行hook这个清单文件，判断一下获取的class是否是object.class，就和一般的动态代理相同。</p>\n<p>当确认hook的这个方法不是object.class的方法的时候，就会走一遍判断是否是该平台可用的method，不过这里默认都是返回false，貌似是准备后期扩展用。</p>\n<p>万事具备之后，会走一次loadmethod，如果之前采取eagerlyValidateMethods的方式的话，此时是直接取出当时读出来的method，否则就是load一下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123;</span><br><span class=\"line\">    ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);</span><br><span class=\"line\">    if (result != null) return result;</span><br><span class=\"line\"></span><br><span class=\"line\">    synchronized (serviceMethodCache) &#123;</span><br><span class=\"line\">      result = serviceMethodCache.get(method);</span><br><span class=\"line\">      if (result == null) &#123;</span><br><span class=\"line\">        result = new ServiceMethod.Builder&lt;&gt;(this, method).build();</span><br><span class=\"line\">        serviceMethodCache.put(method, result);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>load的方法很明显做了一个cache，此处<strong>缓存下来了method和result</strong>，划重点</p>\n<p>在之后就是将获取的method和清单中的方法的参数传入okhttpcall中，创建一个okhttpcall，最后通过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">serviceMethod.callAdapter.adapt(okHttpCall);</span><br></pre></td></tr></table></figure>\n<p>来返回一个和清单类型一模一样的类型。</p>\n<p>至此，retrofit的代理过程就已经结束。</p>\n<h2 id=\"calladapter\"><a href=\"#calladapter\" class=\"headerlink\" title=\"calladapter\"></a>calladapter</h2><p>刚才传入的rxjava2calladapter有什么作用呢？</p>\n<p>回到刚才划重点的地方，缓存下来了method和result，result怎么来的呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = new ServiceMethod.Builder&lt;&gt;(this, method).build();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Builder(Retrofit retrofit, Method method) &#123;</span><br><span class=\"line\">     this.retrofit = retrofit;</span><br><span class=\"line\">     this.method = method;</span><br><span class=\"line\">     this.methodAnnotations = method.getAnnotations();</span><br><span class=\"line\">     this.parameterTypes = method.getGenericParameterTypes();</span><br><span class=\"line\">     this.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   public ServiceMethod build() &#123;</span><br><span class=\"line\">     callAdapter = createCallAdapter();</span><br><span class=\"line\">     responseType = callAdapter.responseType();</span><br><span class=\"line\">     if (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class=\"line\">       throw methodError(&quot;&apos;&quot;</span><br><span class=\"line\">           + Utils.getRawType(responseType).getName()</span><br><span class=\"line\">           + &quot;&apos; is not a valid response body type. Did you mean ResponseBody?&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     responseConverter = createResponseConverter();</span><br><span class=\"line\"></span><br><span class=\"line\">     for (Annotation annotation : methodAnnotations) &#123;</span><br><span class=\"line\">       parseMethodAnnotation(annotation);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     if (httpMethod == null) &#123;</span><br><span class=\"line\">       throw methodError(&quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     if (!hasBody) &#123;</span><br><span class=\"line\">       if (isMultipart) &#123;</span><br><span class=\"line\">         throw methodError(</span><br><span class=\"line\">             &quot;Multipart can only be specified on HTTP methods with request body (e.g., @POST).&quot;);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       if (isFormEncoded) &#123;</span><br><span class=\"line\">         throw methodError(&quot;FormUrlEncoded can only be specified on HTTP methods with &quot;</span><br><span class=\"line\">             + &quot;request body (e.g., @POST).&quot;);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     int parameterCount = parameterAnnotationsArray.length;</span><br><span class=\"line\">     parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class=\"line\">     for (int p = 0; p &lt; parameterCount; p++) &#123;</span><br><span class=\"line\">       Type parameterType = parameterTypes[p];</span><br><span class=\"line\">       if (Utils.hasUnresolvableType(parameterType)) &#123;</span><br><span class=\"line\">         throw parameterError(p, &quot;Parameter type must not include a type variable or wildcard: %s&quot;,</span><br><span class=\"line\">             parameterType);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</span><br><span class=\"line\">       if (parameterAnnotations == null) &#123;</span><br><span class=\"line\">         throw parameterError(p, &quot;No Retrofit annotation found.&quot;);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     if (relativeUrl == null &amp;&amp; !gotUrl) &#123;</span><br><span class=\"line\">       throw methodError(&quot;Missing either @%s URL or @Url parameter.&quot;, httpMethod);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</span><br><span class=\"line\">       throw methodError(&quot;Non-body HTTP method cannot contain @Body.&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     if (isFormEncoded &amp;&amp; !gotField) &#123;</span><br><span class=\"line\">       throw methodError(&quot;Form-encoded method must contain at least one @Field.&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     if (isMultipart &amp;&amp; !gotPart) &#123;</span><br><span class=\"line\">       throw methodError(&quot;Multipart method must contain at least one @Part.&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     return new ServiceMethod&lt;&gt;(this);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出来,builder()是将注释，方法，方法的形式参数类型和方法的形式参数注释类型给记录下来。</p>\n<p>build()的操作需要仔细分析</p>\n<p>第一步创建calladapter</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private CallAdapter&lt;T, R&gt; createCallAdapter() &#123;</span><br><span class=\"line\">      Type returnType = method.getGenericReturnType();</span><br><span class=\"line\">      if (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class=\"line\">        throw methodError(</span><br><span class=\"line\">            &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (returnType == void.class) &#123;</span><br><span class=\"line\">        throw methodError(&quot;Service methods cannot return void.&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      Annotation[] annotations = method.getAnnotations();</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        //noinspection unchecked</span><br><span class=\"line\">        return (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class=\"line\">      &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code.</span><br><span class=\"line\">        throw methodError(e, &quot;Unable to create call adapter for %s&quot;, returnType);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>创建的过程就是将参数传入，通过调用retrofit这个实例的calladapter方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;</span><br><span class=\"line\">    return nextCallAdapter(null, returnType, annotations);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其中calladapter又调用了nextCallAdapter方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public CallAdapter&lt;?, ?&gt; nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,</span><br><span class=\"line\">      Annotation[] annotations) &#123;</span><br><span class=\"line\">    checkNotNull(returnType, &quot;returnType == null&quot;);</span><br><span class=\"line\">    checkNotNull(annotations, &quot;annotations == null&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    int start = adapterFactories.indexOf(skipPast) + 1;</span><br><span class=\"line\">    for (int i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class=\"line\">      CallAdapter&lt;?, ?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, this);</span><br><span class=\"line\">      if (adapter != null) &#123;</span><br><span class=\"line\">        return adapter;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    StringBuilder builder = new StringBuilder(&quot;Could not locate call adapter for &quot;)</span><br><span class=\"line\">        .append(returnType)</span><br><span class=\"line\">        .append(&quot;.\\n&quot;);</span><br><span class=\"line\">    if (skipPast != null) &#123;</span><br><span class=\"line\">      builder.append(&quot;  Skipped:&quot;);</span><br><span class=\"line\">      for (int i = 0; i &lt; start; i++) &#123;</span><br><span class=\"line\">        builder.append(&quot;\\n   * &quot;).append(adapterFactories.get(i).getClass().getName());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      builder.append(&apos;\\n&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    builder.append(&quot;  Tried:&quot;);</span><br><span class=\"line\">    for (int i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class=\"line\">      builder.append(&quot;\\n   * &quot;).append(adapterFactories.get(i).getClass().getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    throw new IllegalArgumentException(builder.toString());</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>到这里就可以发现，通过adapterFactories将我们之前放入的rxjava2adapter给取出来了</p>\n<p>第二步，取出了rxjava2adapter的responseType()，这个type可以从rxjava2adapter里面查到，这里不追溯。</p>\n<p>第三步，创建了responseConverter,就是通过我们传入的gsonconverter来构建解析器</p>\n<p>第四步，逐个读取该方法的注释。</p>\n<p>第五步，进行一系列的检查，检查request的参数是否正确</p>\n<p>最后一步</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return new ServiceMethod&lt;&gt;(this);</span><br></pre></td></tr></table></figure>\n<p>可以看出，这个result，其实就是通过将接口的方法进行整合，最后生成的一个结果。这个结果和方法共同被存储下来</p>\n<p><strong>切记，这里并没有缓存response，缓存的是result，result是对method的一个处理结果，调用的其实是rxjava2factory和gsonconvertfactory来配合处理的</strong></p>\n<h2 id=\"请求过程\"><a href=\"#请求过程\" class=\"headerlink\" title=\"请求过程\"></a>请求过程</h2><p>由于之前传入了ExecutorCallAdapterFactory，此时一个retrofit的实例在app中也已经获取了。之后就看如何使用的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Response&lt;String&gt; resp = webService.logoutRaw().execute();</span><br></pre></td></tr></table></figure>\n<p>执行execute就可以获取到了response。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">   * Synchronously send the request and return its response.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @throws IOException if a problem occurred talking to the server.</span><br><span class=\"line\">   * @throws RuntimeException (and subclasses) if an unexpected error occurs creating the request</span><br><span class=\"line\">   * or decoding the response.</span><br><span class=\"line\">   */</span><br><span class=\"line\">  Response&lt;T&gt; execute() throws IOException;</span><br></pre></td></tr></table></figure>\n<p>这个方法是在retrofit的call.java类中，实现是在ExecutorCallbackCall中，具体是操作了一个okhttpcall</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class=\"line\">    final Executor callbackExecutor;</span><br><span class=\"line\">    final Call&lt;T&gt; delegate;</span><br><span class=\"line\"></span><br><span class=\"line\">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class=\"line\">      this.callbackExecutor = callbackExecutor;</span><br><span class=\"line\">      this.delegate = delegate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</span><br><span class=\"line\">      checkNotNull(callback, &quot;callback == null&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">      delegate.enqueue(new Callback&lt;T&gt;() &#123;</span><br><span class=\"line\">        @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</span><br><span class=\"line\">          callbackExecutor.execute(new Runnable() &#123;</span><br><span class=\"line\">            @Override public void run() &#123;</span><br><span class=\"line\">              if (delegate.isCanceled()) &#123;</span><br><span class=\"line\">                // Emulate OkHttp&apos;s behavior of throwing/delivering an IOException on cancellation.</span><br><span class=\"line\">                callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class=\"line\">              &#125; else &#123;</span><br><span class=\"line\">                callback.onResponse(ExecutorCallbackCall.this, response);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;</span><br><span class=\"line\">          callbackExecutor.execute(new Runnable() &#123;</span><br><span class=\"line\">            @Override public void run() &#123;</span><br><span class=\"line\">              callback.onFailure(ExecutorCallbackCall.this, t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public boolean isExecuted() &#123;</span><br><span class=\"line\">      return delegate.isExecuted();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public Response&lt;T&gt; execute() throws IOException &#123;</span><br><span class=\"line\">      return delegate.execute();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public void cancel() &#123;</span><br><span class=\"line\">      delegate.cancel();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public boolean isCanceled() &#123;</span><br><span class=\"line\">      return delegate.isCanceled();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @SuppressWarnings(&quot;CloneDoesntCallSuperClone&quot;) // Performing deep clone.</span><br><span class=\"line\">    @Override public Call&lt;T&gt; clone() &#123;</span><br><span class=\"line\">      return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, delegate.clone());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public Request request() &#123;</span><br><span class=\"line\">      return delegate.request();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>从这里看就知道是执行了callback的方法，这个callback是取自retrofit的rxadapter里面和okhttpcall的realcall中</p>\n<p>反馈的细节在</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final class CallEnqueueObservable&lt;T&gt; extends Observable&lt;Response&lt;T&gt;&gt; &#123;</span><br><span class=\"line\">  private final Call&lt;T&gt; originalCall;</span><br><span class=\"line\"></span><br><span class=\"line\">  CallEnqueueObservable(Call&lt;T&gt; originalCall) &#123;</span><br><span class=\"line\">    this.originalCall = originalCall;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  @Override protected void subscribeActual(Observer&lt;? super Response&lt;T&gt;&gt; observer) &#123;</span><br><span class=\"line\">    // Since Call is a one-shot type, clone it for each new observer.</span><br><span class=\"line\">    Call&lt;T&gt; call = originalCall.clone();</span><br><span class=\"line\">    CallCallback&lt;T&gt; callback = new CallCallback&lt;&gt;(call, observer);</span><br><span class=\"line\">    observer.onSubscribe(callback);</span><br><span class=\"line\">    call.enqueue(callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  private static final class CallCallback&lt;T&gt; implements Disposable, Callback&lt;T&gt; &#123;</span><br><span class=\"line\">    private final Call&lt;?&gt; call;</span><br><span class=\"line\">    private final Observer&lt;? super Response&lt;T&gt;&gt; observer;</span><br><span class=\"line\">    boolean terminated = false;</span><br><span class=\"line\"></span><br><span class=\"line\">    CallCallback(Call&lt;?&gt; call, Observer&lt;? super Response&lt;T&gt;&gt; observer) &#123;</span><br><span class=\"line\">      this.call = call;</span><br><span class=\"line\">      this.observer = observer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public void onResponse(Call&lt;T&gt; call, Response&lt;T&gt; response) &#123;</span><br><span class=\"line\">      if (call.isCanceled()) return;</span><br><span class=\"line\"></span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        observer.onNext(response);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (!call.isCanceled()) &#123;</span><br><span class=\"line\">          terminated = true;</span><br><span class=\"line\">          observer.onComplete();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; catch (Throwable t) &#123;</span><br><span class=\"line\">        if (terminated) &#123;</span><br><span class=\"line\">          RxJavaPlugins.onError(t);</span><br><span class=\"line\">        &#125; else if (!call.isCanceled()) &#123;</span><br><span class=\"line\">          try &#123;</span><br><span class=\"line\">            observer.onError(t);</span><br><span class=\"line\">          &#125; catch (Throwable inner) &#123;</span><br><span class=\"line\">            Exceptions.throwIfFatal(inner);</span><br><span class=\"line\">            RxJavaPlugins.onError(new CompositeException(t, inner));</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public void onFailure(Call&lt;T&gt; call, Throwable t) &#123;</span><br><span class=\"line\">      if (call.isCanceled()) return;</span><br><span class=\"line\"></span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        observer.onError(t);</span><br><span class=\"line\">      &#125; catch (Throwable inner) &#123;</span><br><span class=\"line\">        Exceptions.throwIfFatal(inner);</span><br><span class=\"line\">        RxJavaPlugins.onError(new CompositeException(t, inner));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public void dispose() &#123;</span><br><span class=\"line\">      call.cancel();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public boolean isDisposed() &#123;</span><br><span class=\"line\">      return call.isCanceled();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这一步就能看懂了，后续的部分都是我们经常使用的地方</p>\n<h2 id=\"处理response的部分\"><a href=\"#处理response的部分\" class=\"headerlink\" title=\"处理response的部分\"></a>处理response的部分</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override public Response&lt;T&gt; execute() throws IOException &#123;</span><br><span class=\"line\">    okhttp3.Call call;</span><br><span class=\"line\"></span><br><span class=\"line\">    synchronized (this) &#123;</span><br><span class=\"line\">      if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);</span><br><span class=\"line\">      executed = true;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (creationFailure != null) &#123;</span><br><span class=\"line\">        if (creationFailure instanceof IOException) &#123;</span><br><span class=\"line\">          throw (IOException) creationFailure;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          throw (RuntimeException) creationFailure;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      call = rawCall;</span><br><span class=\"line\">      if (call == null) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">          call = rawCall = createRawCall();</span><br><span class=\"line\">        &#125; catch (IOException | RuntimeException e) &#123;</span><br><span class=\"line\">          creationFailure = e;</span><br><span class=\"line\">          throw e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (canceled) &#123;</span><br><span class=\"line\">      call.cancel();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return parseResponse(call.execute());</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到在执行的过程中返回结果的时候直接调用了gson来解析</p>\n<p>到这里我看到了解析的过程，看到了执行rxjava的过程，也看到了执行okhttp的过程，理应串起来</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"/images/android/Retrofit个人理解图.png\" alt=\"retrofit个人理解图\"></p>\n<h1 id=\"okHTTP的设计思路\"><a href=\"#okHTTP的设计思路\" class=\"headerlink\" title=\"okHTTP的设计思路\"></a>okHTTP的设计思路</h1><h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>首先从使用看起</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OkHttpClient.Builder builder = new OkHttpClient.Builder()</span><br><span class=\"line\">                .connectTimeout(30, TimeUnit.SECONDS)</span><br><span class=\"line\">                .writeTimeout(30, TimeUnit.SECONDS)</span><br><span class=\"line\">                .readTimeout(30, TimeUnit.SECONDS)</span><br><span class=\"line\">                .addInterceptor(chain -&gt; &#123;</span><br><span class=\"line\">                    Request request = chain.request().newBuilder()</span><br><span class=\"line\">                            //.addHeader(&quot;App&quot;, headerEncoded(ac.getName()))</span><br><span class=\"line\">                            .addHeader(&quot;api_version&quot;, headerEncoded(Const.API_VERSION))</span><br><span class=\"line\">                            .addHeader(&quot;App-Version&quot;, headerEncoded(ac.getVersion() + &quot;.&quot; + ac.getVersionCode()))</span><br><span class=\"line\">                            .addHeader(&quot;PUSH-ENV&quot;, headerEncoded(ac.isBuildVersion() ? &quot;DEV&quot; : &quot;PRODUCT&quot;))</span><br><span class=\"line\">                            .addHeader(&quot;Device-Id&quot;, headerEncoded(deviceInfo.getDeviceId()))</span><br><span class=\"line\">                            .addHeader(&quot;cookie&quot;, headerEncoded(cookie))</span><br><span class=\"line\">                            .addHeader(&quot;x-platform&quot;, &quot;android&quot;)</span><br><span class=\"line\">                            .build();</span><br><span class=\"line\">                    Response response = chain.proceed(request);</span><br><span class=\"line\">                    context.getSharedPreferences(&quot;global&quot;, Context.MODE_PRIVATE).edit().putString(&quot;cookie&quot;, response.header(&quot;Set-Cookie&quot;)).apply();</span><br><span class=\"line\">                    cookie = response.header(&quot;Set-Cookie&quot;);</span><br><span class=\"line\">                    return response;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .addInterceptor(embedAccessTokenInterceptor);</span><br></pre></td></tr></table></figure>\n<p>项目中的okhttp使用，首先需要build一个client，这个里面加了各种参数，读写和连接超时的参数，另外加了一些response处理链。这样一个builder就好了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webService = new Retrofit.Builder().baseUrl(config.getHost())</span><br><span class=\"line\">                .addConverterFactory(MyGsonConverterFactory.create(gson))</span><br><span class=\"line\">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class=\"line\">                .client(builder.build())</span><br><span class=\"line\">                .build().create(WebService.class);</span><br></pre></td></tr></table></figure>\n<p>这之后就塞到retrofit里面去了。</p>\n<p>因此我们先来看一下builder的过程是怎么样的，以此为一个入口</p>\n<h2 id=\"builder\"><a href=\"#builder\" class=\"headerlink\" title=\"builder\"></a>builder</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Builder() &#123;</span><br><span class=\"line\">      dispatcher = new Dispatcher();</span><br><span class=\"line\">      protocols = DEFAULT_PROTOCOLS;</span><br><span class=\"line\">      connectionSpecs = DEFAULT_CONNECTION_SPECS;</span><br><span class=\"line\">      eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class=\"line\">      proxySelector = ProxySelector.getDefault();</span><br><span class=\"line\">      cookieJar = CookieJar.NO_COOKIES;</span><br><span class=\"line\">      socketFactory = SocketFactory.getDefault();</span><br><span class=\"line\">      hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class=\"line\">      certificatePinner = CertificatePinner.DEFAULT;</span><br><span class=\"line\">      proxyAuthenticator = Authenticator.NONE;</span><br><span class=\"line\">      authenticator = Authenticator.NONE;</span><br><span class=\"line\">      connectionPool = new ConnectionPool();</span><br><span class=\"line\">      dns = Dns.SYSTEM;</span><br><span class=\"line\">      followSslRedirects = true;</span><br><span class=\"line\">      followRedirects = true;</span><br><span class=\"line\">      retryOnConnectionFailure = true;</span><br><span class=\"line\">      connectTimeout = 10_000;</span><br><span class=\"line\">      readTimeout = 10_000;</span><br><span class=\"line\">      writeTimeout = 10_000;</span><br><span class=\"line\">      pingInterval = 0;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>builder构造中加了很多很多参数，而整个builder事实上就是一个参数记录类，记录了所有的类型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dispatcher dispatcher;</span><br><span class=\"line\">@Nullable Proxy proxy;</span><br><span class=\"line\">List&lt;Protocol&gt; protocols;</span><br><span class=\"line\">List&lt;ConnectionSpec&gt; connectionSpecs;</span><br><span class=\"line\">final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class=\"line\">final List&lt;Interceptor&gt; networkInterceptors = new ArrayList&lt;&gt;();</span><br><span class=\"line\">EventListener.Factory eventListenerFactory;</span><br><span class=\"line\">ProxySelector proxySelector;</span><br><span class=\"line\">CookieJar cookieJar;</span><br><span class=\"line\">@Nullable Cache cache;</span><br><span class=\"line\">@Nullable InternalCache internalCache;</span><br><span class=\"line\">SocketFactory socketFactory;</span><br><span class=\"line\">@Nullable SSLSocketFactory sslSocketFactory;</span><br><span class=\"line\">@Nullable CertificateChainCleaner certificateChainCleaner;</span><br><span class=\"line\">HostnameVerifier hostnameVerifier;</span><br><span class=\"line\">CertificatePinner certificatePinner;</span><br><span class=\"line\">Authenticator proxyAuthenticator;</span><br><span class=\"line\">Authenticator authenticator;</span><br><span class=\"line\">ConnectionPool connectionPool;</span><br><span class=\"line\">Dns dns;</span><br><span class=\"line\">boolean followSslRedirects;</span><br><span class=\"line\">boolean followRedirects;</span><br><span class=\"line\">boolean retryOnConnectionFailure;</span><br><span class=\"line\">int connectTimeout;</span><br><span class=\"line\">int readTimeout;</span><br><span class=\"line\">int writeTimeout;</span><br><span class=\"line\">int pingInterval;</span><br></pre></td></tr></table></figure>\n<p>这是其局部变量，基本上每个参数都是可以设置的。暂且掠过不表，因为这个都是可变的，默认的对我们来讲其实没有什么大作用。</p>\n<h2 id=\"newCall-构建请求\"><a href=\"#newCall-构建请求\" class=\"headerlink\" title=\"newCall:构建请求\"></a>newCall:构建请求</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Response response = client.newCall(request).execute();</span><br></pre></td></tr></table></figure>\n<p>response封装起来之后，是这样调用的。</p>\n<p>按流程捋下去。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override public Call newCall(Request request) &#123;</span><br><span class=\"line\">    return RealCall.newRealCall(this, request, false /* for web socket */);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123;</span><br><span class=\"line\">    // Safely publish the Call instance to the EventListener.</span><br><span class=\"line\">    RealCall call = new RealCall(client, originalRequest, forWebSocket);</span><br><span class=\"line\">    call.eventListener = client.eventListenerFactory().create(call);</span><br><span class=\"line\">    return call;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>从这里可以看到事实上构建了一个RealCall的端口，然后将其穿进去了一个叫client.eventListenerFactory()的接口里面，这个接口在builder初始化的时候添加的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br></pre></td></tr></table></figure>\n<p>其内在并未做任何事情，仅仅算是将realcall的eventlistener做一层赋值。</p>\n<h2 id=\"newCall-execute-：执行请求\"><a href=\"#newCall-execute-：执行请求\" class=\"headerlink\" title=\"newCall.execute()：执行请求\"></a>newCall.execute()：执行请求</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override public Response execute() throws IOException &#123;</span><br><span class=\"line\">    synchronized (this) &#123;</span><br><span class=\"line\">      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class=\"line\">      executed = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    captureCallStackTrace();</span><br><span class=\"line\">    eventListener.callStart(this);</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      client.dispatcher().executed(this);</span><br><span class=\"line\">      Response result = getResponseWithInterceptorChain();</span><br><span class=\"line\">      if (result == null) throw new IOException(&quot;Canceled&quot;);</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125; catch (IOException e) &#123;</span><br><span class=\"line\">      eventListener.callFailed(this, e);</span><br><span class=\"line\">      throw e;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">      client.dispatcher().finished(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"动态代理的好处","date":"2019-01-04T16:00:42.000Z","_content":"\n> 先有设计的思想，后才有设计的手段\n\n# 代理\n\n代理模式是java设计模式的一种。代理类具有和委托类相同的接口，代理类主要负责为委托类预处理消息、过滤消息、消息转发、以及事后处理消息等。\n\n## 静态代理\n\n由程序员创建或由特定工具自动生成源代码，在对其编译。在程序运行前，代理类的.class文件就已经存在\n\n静态代理通常只代理一个类。同时静态代理需要明白代理的是什么\n\nsample:\n\n```\n//定义代理接口\npublic interface ProxyInterface{\n\tvoid doSomething();\n}\n\npublic class A implements ProxyInterface{\n\t@Override\n\tvoid doSomething(){\n\t\t...\n\t}\n}\n\npublic class AProxy implements ProxyInterface{\n\tprivate ProxyInterface a;\n\tpublic AProxy(ProxyInterface a){\n\t\tthis.a = a;\n\t}\n\n\t@Override\n\tvoid doSomething(){\n\t\ta.doSomething();\n\t}\n}\n```\n\n### 优点\n\n静态代理从我们日常开发的角度来看，就是一个封装类，比较简单\n\n### 缺点\n\n局限性很大，尤其是限于对代理类的了解。在接手一个项目，发生问题的时候或许可以使用这种代理方式来进行优化\n\n## 动态代理\n\n动态代理类的字节码由java反射机制动态生成，无需手动编写源代码。\n\nsample:\n\n```\n//创建InvocationHandler\nInvocationHandler handler = new MyInvocationHandler(...);\n//创建动态代理类\nClass proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(),new Class[]{Foo.class});\n//创建动态代理类的实例\nFoo foo = (Foo)proxyClass.getConstructor(new Class[]{InvocationHandler.class}).newInstance(new Object[]{handler});\n```\n\n这样就获取了类了。\n\n### 原理\n\n\n### newProxyInstance\n```\npublic static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n        throws IllegalArgumentException\n    {\n        Objects.requireNonNull(h);\n\n        final Class<?>[] intfs = interfaces.clone();\n        // Android-changed: sm is always null\n        // final SecurityManager sm = System.getSecurityManager();\n        // if (sm != null) {\n        //     checkProxyAccess(Reflection.getCallerClass(), loader, intfs);\n        // }\n\n        /*\n         * Look up or generate the designated proxy class.\n         */\n        Class<?> cl = getProxyClass0(loader, intfs);\n\n        /*\n         * Invoke its constructor with the designated invocation handler.\n         */\n        try {\n            // Android-changed: sm is always null\n            // if (sm != null) {\n            //     checkNewProxyPermission(Reflection.getCallerClass(), cl);\n            // }\n\n            final Constructor<?> cons = cl.getConstructor(constructorParams);\n            final InvocationHandler ih = h;\n            if (!Modifier.isPublic(cl.getModifiers())) {\n                // Android-changed: Removed AccessController.doPrivileged\n                cons.setAccessible(true);\n            }\n            return cons.newInstance(new Object[]{h});\n        } catch (IllegalAccessException|InstantiationException e) {\n            throw new InternalError(e.toString(), e);\n        } catch (InvocationTargetException e) {\n            Throwable t = e.getCause();\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            } else {\n                throw new InternalError(t.toString(), t);\n            }\n        } catch (NoSuchMethodException e) {\n            throw new InternalError(e.toString(), e);\n        }\n    }\n```\n\n细致的看这个方法的内容\n\n第一步 检查handler是否是空，这个没得说的\n\n第二步 通过传入进去的classloader和class的方法来生成一个新的代理类（这中间有缓存）（class层级）\n\n第三步 调用代理的构造器，将handler传入，构造了一个相应的类。\n\n### getProxyClass0()：就是用来生产代理类的类对象\n\n```\nprivate static Class<?> getProxyClass0(ClassLoader loader,\n                                       Class<?>... interfaces) {\n    // 当目标类实现的接口数量大于 65535\n    if (interfaces.length > 65535) {\n\t    // 抛异常\n        throw new IllegalArgumentException(\"interface limit exceeded\");\n    }\n    \n    // 关键2：获取代理类，使用了缓存机制\n    return proxyClassCache.get(loader, interfaces);\n}\n```\n\n### WeakCache#get()\n\n```\n// 缓存的底层实现，key 为一级缓存，value 为二级缓存，一级缓存 key 类型为 Object，支持 null\nprivate final ConcurrentMap<Object, ConcurrentMap<Object, Supplier<V>>> map\n    = new ConcurrentHashMap<>();\n\n// key：classloader\n// parameter：interfaces\npublic V get(K key, P parameter) {\n\t// 判断接口数组是否为空，为空抛异常，不为空返回接口对应类型\n\tObjects.requireNonNull(parameter);\n\n\t// 清除过期的缓存\n\texpungeStaleEntries();\n\n\t// 将传入的 classloader 包装成 CacheKey，作为一级缓存\n\tObject cacheKey = CacheKey.valueOf(key, refQueue);\n\n\t// 根据一级缓存 cacheKey 获取二级缓存 valuesMap\n\tConcurrentMap<Object, Supplier<V>> valuesMap = map.get(cacheKey);\n\t// 如果根据 classLoader 没有获取到对应的值\n\tif (valuesMap == null) {\n\t\t// 以 CAS 方式放入，如果不存在则放入，否则返回原先的值\n\t\tConcurrentMap<Object, Supplier<V>> oldValuesMap = map.putIfAbsent(cacheKey,\n                              valuesMap = new ConcurrentHashMap<>());\n\t\t// 如果 oldValuesMap 有值，说明放入失败\n\t\tif (oldValuesMap != null) {\n\t\t\t// valuesMap 设置为原来的 oldValuesMap\n\t\t\tvaluesMap = oldValuesMap;\n\t\t}\n\t}\n    \n    // subKeyFactory 通过 WeakCache 构造函数传入，实际为 KeyFactory\n    // subKeyFactory.apply(key, parameter)：KeyFactory 根据代理类实现的接口数组来生成二级缓存 key\n\t// Objects.requireNonNull()：判断得到的二级缓存 key 是否为空，为空抛异常，不为空返回二级缓存 key 对应类型 Object\n\tObject subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));\n\t// 根据二级缓存的 key 获取二级缓存的值 supplier\n\tSupplier<V> supplier = valuesMap.get(subKey);\n\tFactory factory = null;\n\n\twhile (true) {\n\t\t// 如果二级缓存的值 supplier 不为 null\n\t\tif (supplier != null) {\n\t\t\t// 调用 get() 方法\n\t\t\t// 关键4：Factory implements Supplier，则此处实际调用的是 Factory#get()\n\t\t\tV value = supplier.get();\n\t\t\t// value 不为空\n\t\t\tif (value != null) {\n\t\t\t\t// 返回 value\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\t// else no supplier in cache\n\t\t// or a supplier that returned null (could be a cleared CacheValue\n\t\t// or a Factory that wasn't successful in installing the CacheValue)\n\n\t\t// 如果 factory 等于 null\n\t\tif (factory == null) {\n\t\t\t// 实例化一个 Factory（作为二级缓存的值），作为 subKey （二级缓存的 key）对应的 value\n\t\t\tfactory = new Factory(key, parameter, subKey, valuesMap);\n\t\t}\n\n\t\t// 如果 supplier 等于 null（根据二级缓存的 key 没有获取到二级缓存的值 supplier）\n\t\tif (supplier == null) {\n\t\t\t// 将实例化的 factory 作为 subKey 对应的值传入\n\t\t\tsupplier = valuesMap.putIfAbsent(subKey, factory);\n\t\t\t// supplier 等于 null（可能上一步成功执行后返回的是 null???）\n\t\t\tif (supplier == null) {\n\t\t\t\t// successfully installed Factory\n\t\t\t\tsupplier = factory;\n\t\t\t}\n\t\t\t// else retry with winning supplier\n\t\t} else { // 可能期间有其他线程修改了值，那么就不会再继续给 subKey 赋值，而是取出来直接用\n\t\t\t// 期间可能其它线程修改了值 factory，就用该值替换掉 supplier\n\t\t\tif (valuesMap.replace(subKey, supplier, factory)) {\n\t\t\t\t// 将 supplier 替换成 factory\n\t\t\t\tsupplier = factory;\n\t\t\t} else {\n\t\t\t\t// 替换失败，继续使用原先的值\n\t\t\t\tsupplier = valuesMap.get(subKey);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### Factory#get()\n\n```\npublic synchronized V get() { // serialize access\n    // 根据二级缓存的 key 获取 supplier\n    Supplier<V> supplier = valuesMap.get(subKey);\n    // 如果获取的 supplier 不是 Factory 类型\n    if (supplier != this) {\n        return null;\n    }\n    // else still us (supplier == this)\n\n    // create new value\n    V value = null;\n    try {\n\t    // valueFactory 通过 WeakCache 构造函数传入，实际为 ProxyClassFactory\n\t    // 关键5：valueFactory.apply()->ProxyClassFactory#apply()\n        value = Objects.requireNonNull(valueFactory.apply(key, parameter));\n    } finally {\n        if (value == null) { // remove us on failure\n            valuesMap.remove(subKey, this);\n        }\n    }\n    // the only path to reach here is with non-null value\n    assert value != null;\n\n    // wrap value with CacheValue (WeakReference)\n    CacheValue<V> cacheValue = new CacheValue<>(value);\n\n    // try replacing us with CacheValue (this should always succeed)\n    if (valuesMap.replace(subKey, this, cacheValue)) {\n        // put also in reverseMap\n        reverseMap.put(cacheValue, Boolean.TRUE);\n    } else {\n        throw new AssertionError(\"Should not reach here\");\n    }\n\n    // successfully replaced us with new CacheValue -> return the value\n    // wrapped by it\n    return value;\n}\n```\n\n### ProxyClassFactory#apply()\n\n```\n// Proxy 的类名前缀\nprivate static final String proxyClassNamePrefix = \"$Proxy\";\n\n// next number to use for generation of unique proxy class names\n// 生成自增的数字\nprivate static final AtomicLong nextUniqueNumber = new AtomicLong();\n\n@Override\npublic Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {\n\n    // 根据接口数组长度生成对应的 Map\n    Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);\n    // 遍历接口数组\n    for (Class<?> intf : interfaces) {\n        /*\n         * Verify that the class loader resolves the name of this\n         * interface to the same Class object.\n         * \n         * 验证类加载器将此 interface 的名字解析成同一类对象\n         */\n        Class<?> interfaceClass = null;\n        try {\n\t        // 根据接口名获取接口对应的类对象\n            interfaceClass = Class.forName(intf.getName(), false, loader);\n        } catch (ClassNotFoundException e) {\n        }\n        // 接口类对象不等于接口，不是同一对象\n        if (interfaceClass != intf) {\n\t        //抛异常，接口来自不同的类加载器\n            throw new IllegalArgumentException(\n                intf + \" is not visible from class loader\");\n        }\n        /*\n         * Verify that the Class object actually represents an\n         * interface.\n         * \n         * 验证生成的类对象是否是一个接口类型\n         */\n        // 类对象不是接口类型\n        if (!interfaceClass.isInterface()) {\n\t        // 抛异常，类对象不是一个接口类型\n            throw new IllegalArgumentException(\n                interfaceClass.getName() + \" is not an interface\");\n        }\n        /*\n         * Verify that this interface is not a duplicate.\n         * \n         * 验证此接口不是重复的\n         */\n        // 往接口数组对应的 map 中存入类对象，返回值不为 null\n        if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {\n\t        // 抛异常，来自当前类对象的接口重复\n            throw new IllegalArgumentException(\n                \"repeated interface: \" + interfaceClass.getName());\n        }\n    }\n\n    String proxyPkg = null;     // package to define proxy class in\n    int accessFlags = Modifier.PUBLIC | Modifier.FINAL;\n\n    /*\n     * Record the package of a non-public proxy interface so that the\n     * proxy class will be defined in the same package.  Verify that\n     * all non-public proxy interfaces are in the same package.\n     */\n    // 遍历接口数组\n    for (Class<?> intf : interfaces) {\n\t\t// 获取当前接口的修饰符\n        int flags = intf.getModifiers();\n        // 如果当前接口修饰符不是 public\n        if (!Modifier.isPublic(flags)) {\n\t\t\t// 设置为 final\n            accessFlags = Modifier.FINAL;\n            String name = intf.getName();\n            int n = name.lastIndexOf('.');\n            String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1));\n            // 包名为 null\n            if (proxyPkg == null) {\n\t            // 包名等于当前接口的包名\n                proxyPkg = pkg;\n            } else if (!pkg.equals(proxyPkg)) {// 如果包名不相等\n\t            // 抛异常，非 public 的接口集合来自不同的包\n                throw new IllegalArgumentException(\n                    \"non-public interfaces from different packages\");\n            }\n        }\n    }\n\n\t// 包名为 null\n    if (proxyPkg == null) {\n        // if no non-public proxy interfaces, use com.sun.proxy package\n        // 如果 no non-public（即是 public）的代理接口集合，则使用包名 com.sun.proxy\n        proxyPkg = ReflectUtil.PROXY_PACKAGE + \".\";\n    }\n\n    /*\n     * Choose a name for the proxy class to generate.\n     */\n    long num = nextUniqueNumber.getAndIncrement();\n    // 组成代理类全类名：包名 + 代理类前缀 + 唯一的自增长数字\n    String proxyName = proxyPkg + proxyClassNamePrefix + num;\n\n    /*\n     * Generate the specified proxy class.\n     * \n     * 关键6：生成指定的代理类\n     */\n    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(\n        proxyName, interfaces, accessFlags);\n    try {\n        return defineClass0(loader, proxyName,\n                            proxyClassFile, 0, proxyClassFile.length);\n    } catch (ClassFormatError e) {\n        /*\n         * A ClassFormatError here means that (barring bugs in the\n         * proxy class generation code) there was some other\n         * invalid aspect of the arguments supplied to the proxy\n         * class creation (such as virtual machine limitations\n         * exceeded).\n         */\n        throw new IllegalArgumentException(e.toString());\n    }\n}\n```\n### 生成代理类的字节码\n\n```\n最终生成的代理类：\npublic class Proxy0 extends Proxy implements IDinner {\n\t// 第一步：生成构造器\n\tprotected Proxy0(InvocationHandler h) {\n\t\tsuper(h);\n\t}\n\t// 第二步：生成静态域\n\tprivate static Method m1; // hashCode方法\n\tprivate static Method m2; // equals方法\n\tprivate static Method m3; // toString方法\n\tprivate static Method m4; //...\n\t// 第三步：生成代理方法\n\t@Override\n\tpublic int hashCode() {\n\t\ttry {\n\t\t\treturn (int) h.invoke(this, m1, null);\n\t\t}catch (Throwable e) {\n\t\t\tthrow new UndeclaredThrowableException(e);\n\t\t}\n\t}\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\ttry {\n\t\t\tObject[] args = new Object[] {obj};\n\t\t\treturn (boolean) h.invoke(this, m2, args);\n\t\t}catch (Throwable e) {\n\t\t\tthrow new UndeclaredThrowableException(e);\n\t\t}\n\t}\n\t@Override\n\tpublic String toString() {\n\t\ttry {\n\t\t\treturn (String) h.invoke(this, m3, null);\n\t\t}catch (Throwable e) {\n\t\t\tthrow new UndeclaredThrowableException(e);\n\t\t}\n\t}\n\t@Override\n\tpublic void dinner() {\n\t\ttry {\n\t\t\t// 构造参数数组，如果有多个参数往后面添加就行了\n\t\t\tObject[] args = new Object[] {};\n\t\t\t// h 为通过构造方法传进来的 InvocationHandler，即此处调用 InvocationHandler#invoke(...) 方法\n\t\t\th.invoke(this, m4, args);\n\t\t}catch (Throwable e) {\n\t\t\tthrow new UndeclaredThrowableException(e);\n\t\t}\n\t}\n\t// 第四步：生成静态初始化方法\n\tstatic {\n\t\ttry {\n\t\t\tClass c1 = Class.forName(Object.class.getName());\n\t\t\tClass c2 = Class.forName(IDinner.class.getName()); \n\t\t\tm1 = c1.getMethod(\"hashCode\", null);\n\t\t\tm2 = c1.getMethod(\"equals\", new Class[]{Object.class});\n\t\t\tm3 = c1.getMethod(\"toString\", null);\n\t\t\tm4 = c2.getMethod(\"dinner\", new Class[]{IDinner.class});\n\t\t\t//...\n\t\t}catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n### InvocationHandler\n\n```\n/**\n * {@code InvocationHandler} is the interface implemented by\n * the <i>invocation handler</i> of a proxy instance.\n *\n * <p>Each proxy instance has an associated invocation handler.\n * When a method is invoked on a proxy instance, the method\n * invocation is encoded and dispatched to the {@code invoke}\n * method of its invocation handler.\n *\n * @author      Peter Jones\n * @see         Proxy\n * @since       1.3\n */\n```\n\n从其类注释上面可以看出来，每一个代理实例都有一个相关的调用handler，当一个代理实例的方法被唤醒的时候，该被代理的方法将会被编码并且分发到invocation handler中\n\n具体来讲事实上是个回调接口类\n\n```\n /**\n     * Processes a method invocation on a proxy instance and returns\n     * the result.  This method will be invoked on an invocation handler\n     * when a method is invoked on a proxy instance that it is\n     * associated with.\n     *\n     * @param   proxy the proxy instance that the method was invoked on\n     *\n     * @param   method the {@code Method} instance corresponding to\n     * the interface method invoked on the proxy instance.  The declaring\n     * class of the {@code Method} object will be the interface that\n     * the method was declared in, which may be a superinterface of the\n     * proxy interface that the proxy class inherits the method through.\n     *\n     * @param   args an array of objects containing the values of the\n     * arguments passed in the method invocation on the proxy instance,\n     * or {@code null} if interface method takes no arguments.\n     * Arguments of primitive types are wrapped in instances of the\n     * appropriate primitive wrapper class, such as\n     * {@code java.lang.Integer} or {@code java.lang.Boolean}.\n     *\n     * @return  the value to return from the method invocation on the\n     * proxy instance.  If the declared return type of the interface\n     * method is a primitive type, then the value returned by\n     * this method must be an instance of the corresponding primitive\n     * wrapper class; otherwise, it must be a type assignable to the\n     * declared return type.  If the value returned by this method is\n     * {@code null} and the interface method's return type is\n     * primitive, then a {@code NullPointerException} will be\n     * thrown by the method invocation on the proxy instance.  If the\n     * value returned by this method is otherwise not compatible with\n     * the interface method's declared return type as described above,\n     * a {@code ClassCastException} will be thrown by the method\n     * invocation on the proxy instance.\n     *\n     * @throws  Throwable the exception to throw from the method\n     * invocation on the proxy instance.  The exception's type must be\n     * assignable either to any of the exception types declared in the\n     * {@code throws} clause of the interface method or to the\n     * unchecked exception types {@code java.lang.RuntimeException}\n     * or {@code java.lang.Error}.  If a checked exception is\n     * thrown by this method that is not assignable to any of the\n     * exception types declared in the {@code throws} clause of\n     * the interface method, then an\n     * {@link UndeclaredThrowableException} containing the\n     * exception that was thrown by this method will be thrown by the\n     * method invocation on the proxy instance.\n     *\n     * @see     UndeclaredThrowableException\n     */\n    public Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable;\n```\n\n参数的方法表现的就比较容易理解了。\n\nproxy是指代理类的实例，method是指代理类的方法，每当代理类有方法经过时，这个method就会变成那个方法，args是方法的形式参数，这个地方也会截断。\n\n返回值有几种情况\n\n1、声明的返回类型是基础类型，返回值必须是对应的包装类实例\n\n2、如果声明的返回类型是基础类型，但是返回了一个null的话，会报空指针异常\n\n3、如果这个方法的返回值和声明的返回值不兼容的话，会报类型转换异常\n\n# 总结\n\n类A写死持有B，就是B的静态代理。如果A代理的对象是不确定的，就是动态代理。动态代理借用反射机制，最终生成的代理类和静态代理生成的相同\n\n# Q&A\n\n## 动态代理模式和装饰者模式的区别\n\n- 装饰者模式的作用：在不使用继承、不改变原有对象的情况下增加或扩展对象行为，但是并不会禁用某个对象的行为\n\n- 代理模式：控制了这个对象的访问，决定执行或者不执行\n\n## 动态代理模式有缺点吗？\n\n由于是反射机制，创建一个动态代理类大约需要13ms，对比与反射一个方法只需要2ms来看，如果消耗过大还是需要考虑一下的\n","source":"_posts/动态代理的好处.md","raw":"---\ntitle: 动态代理的好处\ndate: 2019-01-05 00:00:42\ntags: java\n---\n\n> 先有设计的思想，后才有设计的手段\n\n# 代理\n\n代理模式是java设计模式的一种。代理类具有和委托类相同的接口，代理类主要负责为委托类预处理消息、过滤消息、消息转发、以及事后处理消息等。\n\n## 静态代理\n\n由程序员创建或由特定工具自动生成源代码，在对其编译。在程序运行前，代理类的.class文件就已经存在\n\n静态代理通常只代理一个类。同时静态代理需要明白代理的是什么\n\nsample:\n\n```\n//定义代理接口\npublic interface ProxyInterface{\n\tvoid doSomething();\n}\n\npublic class A implements ProxyInterface{\n\t@Override\n\tvoid doSomething(){\n\t\t...\n\t}\n}\n\npublic class AProxy implements ProxyInterface{\n\tprivate ProxyInterface a;\n\tpublic AProxy(ProxyInterface a){\n\t\tthis.a = a;\n\t}\n\n\t@Override\n\tvoid doSomething(){\n\t\ta.doSomething();\n\t}\n}\n```\n\n### 优点\n\n静态代理从我们日常开发的角度来看，就是一个封装类，比较简单\n\n### 缺点\n\n局限性很大，尤其是限于对代理类的了解。在接手一个项目，发生问题的时候或许可以使用这种代理方式来进行优化\n\n## 动态代理\n\n动态代理类的字节码由java反射机制动态生成，无需手动编写源代码。\n\nsample:\n\n```\n//创建InvocationHandler\nInvocationHandler handler = new MyInvocationHandler(...);\n//创建动态代理类\nClass proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(),new Class[]{Foo.class});\n//创建动态代理类的实例\nFoo foo = (Foo)proxyClass.getConstructor(new Class[]{InvocationHandler.class}).newInstance(new Object[]{handler});\n```\n\n这样就获取了类了。\n\n### 原理\n\n\n### newProxyInstance\n```\npublic static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n        throws IllegalArgumentException\n    {\n        Objects.requireNonNull(h);\n\n        final Class<?>[] intfs = interfaces.clone();\n        // Android-changed: sm is always null\n        // final SecurityManager sm = System.getSecurityManager();\n        // if (sm != null) {\n        //     checkProxyAccess(Reflection.getCallerClass(), loader, intfs);\n        // }\n\n        /*\n         * Look up or generate the designated proxy class.\n         */\n        Class<?> cl = getProxyClass0(loader, intfs);\n\n        /*\n         * Invoke its constructor with the designated invocation handler.\n         */\n        try {\n            // Android-changed: sm is always null\n            // if (sm != null) {\n            //     checkNewProxyPermission(Reflection.getCallerClass(), cl);\n            // }\n\n            final Constructor<?> cons = cl.getConstructor(constructorParams);\n            final InvocationHandler ih = h;\n            if (!Modifier.isPublic(cl.getModifiers())) {\n                // Android-changed: Removed AccessController.doPrivileged\n                cons.setAccessible(true);\n            }\n            return cons.newInstance(new Object[]{h});\n        } catch (IllegalAccessException|InstantiationException e) {\n            throw new InternalError(e.toString(), e);\n        } catch (InvocationTargetException e) {\n            Throwable t = e.getCause();\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            } else {\n                throw new InternalError(t.toString(), t);\n            }\n        } catch (NoSuchMethodException e) {\n            throw new InternalError(e.toString(), e);\n        }\n    }\n```\n\n细致的看这个方法的内容\n\n第一步 检查handler是否是空，这个没得说的\n\n第二步 通过传入进去的classloader和class的方法来生成一个新的代理类（这中间有缓存）（class层级）\n\n第三步 调用代理的构造器，将handler传入，构造了一个相应的类。\n\n### getProxyClass0()：就是用来生产代理类的类对象\n\n```\nprivate static Class<?> getProxyClass0(ClassLoader loader,\n                                       Class<?>... interfaces) {\n    // 当目标类实现的接口数量大于 65535\n    if (interfaces.length > 65535) {\n\t    // 抛异常\n        throw new IllegalArgumentException(\"interface limit exceeded\");\n    }\n    \n    // 关键2：获取代理类，使用了缓存机制\n    return proxyClassCache.get(loader, interfaces);\n}\n```\n\n### WeakCache#get()\n\n```\n// 缓存的底层实现，key 为一级缓存，value 为二级缓存，一级缓存 key 类型为 Object，支持 null\nprivate final ConcurrentMap<Object, ConcurrentMap<Object, Supplier<V>>> map\n    = new ConcurrentHashMap<>();\n\n// key：classloader\n// parameter：interfaces\npublic V get(K key, P parameter) {\n\t// 判断接口数组是否为空，为空抛异常，不为空返回接口对应类型\n\tObjects.requireNonNull(parameter);\n\n\t// 清除过期的缓存\n\texpungeStaleEntries();\n\n\t// 将传入的 classloader 包装成 CacheKey，作为一级缓存\n\tObject cacheKey = CacheKey.valueOf(key, refQueue);\n\n\t// 根据一级缓存 cacheKey 获取二级缓存 valuesMap\n\tConcurrentMap<Object, Supplier<V>> valuesMap = map.get(cacheKey);\n\t// 如果根据 classLoader 没有获取到对应的值\n\tif (valuesMap == null) {\n\t\t// 以 CAS 方式放入，如果不存在则放入，否则返回原先的值\n\t\tConcurrentMap<Object, Supplier<V>> oldValuesMap = map.putIfAbsent(cacheKey,\n                              valuesMap = new ConcurrentHashMap<>());\n\t\t// 如果 oldValuesMap 有值，说明放入失败\n\t\tif (oldValuesMap != null) {\n\t\t\t// valuesMap 设置为原来的 oldValuesMap\n\t\t\tvaluesMap = oldValuesMap;\n\t\t}\n\t}\n    \n    // subKeyFactory 通过 WeakCache 构造函数传入，实际为 KeyFactory\n    // subKeyFactory.apply(key, parameter)：KeyFactory 根据代理类实现的接口数组来生成二级缓存 key\n\t// Objects.requireNonNull()：判断得到的二级缓存 key 是否为空，为空抛异常，不为空返回二级缓存 key 对应类型 Object\n\tObject subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));\n\t// 根据二级缓存的 key 获取二级缓存的值 supplier\n\tSupplier<V> supplier = valuesMap.get(subKey);\n\tFactory factory = null;\n\n\twhile (true) {\n\t\t// 如果二级缓存的值 supplier 不为 null\n\t\tif (supplier != null) {\n\t\t\t// 调用 get() 方法\n\t\t\t// 关键4：Factory implements Supplier，则此处实际调用的是 Factory#get()\n\t\t\tV value = supplier.get();\n\t\t\t// value 不为空\n\t\t\tif (value != null) {\n\t\t\t\t// 返回 value\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\t// else no supplier in cache\n\t\t// or a supplier that returned null (could be a cleared CacheValue\n\t\t// or a Factory that wasn't successful in installing the CacheValue)\n\n\t\t// 如果 factory 等于 null\n\t\tif (factory == null) {\n\t\t\t// 实例化一个 Factory（作为二级缓存的值），作为 subKey （二级缓存的 key）对应的 value\n\t\t\tfactory = new Factory(key, parameter, subKey, valuesMap);\n\t\t}\n\n\t\t// 如果 supplier 等于 null（根据二级缓存的 key 没有获取到二级缓存的值 supplier）\n\t\tif (supplier == null) {\n\t\t\t// 将实例化的 factory 作为 subKey 对应的值传入\n\t\t\tsupplier = valuesMap.putIfAbsent(subKey, factory);\n\t\t\t// supplier 等于 null（可能上一步成功执行后返回的是 null???）\n\t\t\tif (supplier == null) {\n\t\t\t\t// successfully installed Factory\n\t\t\t\tsupplier = factory;\n\t\t\t}\n\t\t\t// else retry with winning supplier\n\t\t} else { // 可能期间有其他线程修改了值，那么就不会再继续给 subKey 赋值，而是取出来直接用\n\t\t\t// 期间可能其它线程修改了值 factory，就用该值替换掉 supplier\n\t\t\tif (valuesMap.replace(subKey, supplier, factory)) {\n\t\t\t\t// 将 supplier 替换成 factory\n\t\t\t\tsupplier = factory;\n\t\t\t} else {\n\t\t\t\t// 替换失败，继续使用原先的值\n\t\t\t\tsupplier = valuesMap.get(subKey);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### Factory#get()\n\n```\npublic synchronized V get() { // serialize access\n    // 根据二级缓存的 key 获取 supplier\n    Supplier<V> supplier = valuesMap.get(subKey);\n    // 如果获取的 supplier 不是 Factory 类型\n    if (supplier != this) {\n        return null;\n    }\n    // else still us (supplier == this)\n\n    // create new value\n    V value = null;\n    try {\n\t    // valueFactory 通过 WeakCache 构造函数传入，实际为 ProxyClassFactory\n\t    // 关键5：valueFactory.apply()->ProxyClassFactory#apply()\n        value = Objects.requireNonNull(valueFactory.apply(key, parameter));\n    } finally {\n        if (value == null) { // remove us on failure\n            valuesMap.remove(subKey, this);\n        }\n    }\n    // the only path to reach here is with non-null value\n    assert value != null;\n\n    // wrap value with CacheValue (WeakReference)\n    CacheValue<V> cacheValue = new CacheValue<>(value);\n\n    // try replacing us with CacheValue (this should always succeed)\n    if (valuesMap.replace(subKey, this, cacheValue)) {\n        // put also in reverseMap\n        reverseMap.put(cacheValue, Boolean.TRUE);\n    } else {\n        throw new AssertionError(\"Should not reach here\");\n    }\n\n    // successfully replaced us with new CacheValue -> return the value\n    // wrapped by it\n    return value;\n}\n```\n\n### ProxyClassFactory#apply()\n\n```\n// Proxy 的类名前缀\nprivate static final String proxyClassNamePrefix = \"$Proxy\";\n\n// next number to use for generation of unique proxy class names\n// 生成自增的数字\nprivate static final AtomicLong nextUniqueNumber = new AtomicLong();\n\n@Override\npublic Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {\n\n    // 根据接口数组长度生成对应的 Map\n    Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);\n    // 遍历接口数组\n    for (Class<?> intf : interfaces) {\n        /*\n         * Verify that the class loader resolves the name of this\n         * interface to the same Class object.\n         * \n         * 验证类加载器将此 interface 的名字解析成同一类对象\n         */\n        Class<?> interfaceClass = null;\n        try {\n\t        // 根据接口名获取接口对应的类对象\n            interfaceClass = Class.forName(intf.getName(), false, loader);\n        } catch (ClassNotFoundException e) {\n        }\n        // 接口类对象不等于接口，不是同一对象\n        if (interfaceClass != intf) {\n\t        //抛异常，接口来自不同的类加载器\n            throw new IllegalArgumentException(\n                intf + \" is not visible from class loader\");\n        }\n        /*\n         * Verify that the Class object actually represents an\n         * interface.\n         * \n         * 验证生成的类对象是否是一个接口类型\n         */\n        // 类对象不是接口类型\n        if (!interfaceClass.isInterface()) {\n\t        // 抛异常，类对象不是一个接口类型\n            throw new IllegalArgumentException(\n                interfaceClass.getName() + \" is not an interface\");\n        }\n        /*\n         * Verify that this interface is not a duplicate.\n         * \n         * 验证此接口不是重复的\n         */\n        // 往接口数组对应的 map 中存入类对象，返回值不为 null\n        if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {\n\t        // 抛异常，来自当前类对象的接口重复\n            throw new IllegalArgumentException(\n                \"repeated interface: \" + interfaceClass.getName());\n        }\n    }\n\n    String proxyPkg = null;     // package to define proxy class in\n    int accessFlags = Modifier.PUBLIC | Modifier.FINAL;\n\n    /*\n     * Record the package of a non-public proxy interface so that the\n     * proxy class will be defined in the same package.  Verify that\n     * all non-public proxy interfaces are in the same package.\n     */\n    // 遍历接口数组\n    for (Class<?> intf : interfaces) {\n\t\t// 获取当前接口的修饰符\n        int flags = intf.getModifiers();\n        // 如果当前接口修饰符不是 public\n        if (!Modifier.isPublic(flags)) {\n\t\t\t// 设置为 final\n            accessFlags = Modifier.FINAL;\n            String name = intf.getName();\n            int n = name.lastIndexOf('.');\n            String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1));\n            // 包名为 null\n            if (proxyPkg == null) {\n\t            // 包名等于当前接口的包名\n                proxyPkg = pkg;\n            } else if (!pkg.equals(proxyPkg)) {// 如果包名不相等\n\t            // 抛异常，非 public 的接口集合来自不同的包\n                throw new IllegalArgumentException(\n                    \"non-public interfaces from different packages\");\n            }\n        }\n    }\n\n\t// 包名为 null\n    if (proxyPkg == null) {\n        // if no non-public proxy interfaces, use com.sun.proxy package\n        // 如果 no non-public（即是 public）的代理接口集合，则使用包名 com.sun.proxy\n        proxyPkg = ReflectUtil.PROXY_PACKAGE + \".\";\n    }\n\n    /*\n     * Choose a name for the proxy class to generate.\n     */\n    long num = nextUniqueNumber.getAndIncrement();\n    // 组成代理类全类名：包名 + 代理类前缀 + 唯一的自增长数字\n    String proxyName = proxyPkg + proxyClassNamePrefix + num;\n\n    /*\n     * Generate the specified proxy class.\n     * \n     * 关键6：生成指定的代理类\n     */\n    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(\n        proxyName, interfaces, accessFlags);\n    try {\n        return defineClass0(loader, proxyName,\n                            proxyClassFile, 0, proxyClassFile.length);\n    } catch (ClassFormatError e) {\n        /*\n         * A ClassFormatError here means that (barring bugs in the\n         * proxy class generation code) there was some other\n         * invalid aspect of the arguments supplied to the proxy\n         * class creation (such as virtual machine limitations\n         * exceeded).\n         */\n        throw new IllegalArgumentException(e.toString());\n    }\n}\n```\n### 生成代理类的字节码\n\n```\n最终生成的代理类：\npublic class Proxy0 extends Proxy implements IDinner {\n\t// 第一步：生成构造器\n\tprotected Proxy0(InvocationHandler h) {\n\t\tsuper(h);\n\t}\n\t// 第二步：生成静态域\n\tprivate static Method m1; // hashCode方法\n\tprivate static Method m2; // equals方法\n\tprivate static Method m3; // toString方法\n\tprivate static Method m4; //...\n\t// 第三步：生成代理方法\n\t@Override\n\tpublic int hashCode() {\n\t\ttry {\n\t\t\treturn (int) h.invoke(this, m1, null);\n\t\t}catch (Throwable e) {\n\t\t\tthrow new UndeclaredThrowableException(e);\n\t\t}\n\t}\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\ttry {\n\t\t\tObject[] args = new Object[] {obj};\n\t\t\treturn (boolean) h.invoke(this, m2, args);\n\t\t}catch (Throwable e) {\n\t\t\tthrow new UndeclaredThrowableException(e);\n\t\t}\n\t}\n\t@Override\n\tpublic String toString() {\n\t\ttry {\n\t\t\treturn (String) h.invoke(this, m3, null);\n\t\t}catch (Throwable e) {\n\t\t\tthrow new UndeclaredThrowableException(e);\n\t\t}\n\t}\n\t@Override\n\tpublic void dinner() {\n\t\ttry {\n\t\t\t// 构造参数数组，如果有多个参数往后面添加就行了\n\t\t\tObject[] args = new Object[] {};\n\t\t\t// h 为通过构造方法传进来的 InvocationHandler，即此处调用 InvocationHandler#invoke(...) 方法\n\t\t\th.invoke(this, m4, args);\n\t\t}catch (Throwable e) {\n\t\t\tthrow new UndeclaredThrowableException(e);\n\t\t}\n\t}\n\t// 第四步：生成静态初始化方法\n\tstatic {\n\t\ttry {\n\t\t\tClass c1 = Class.forName(Object.class.getName());\n\t\t\tClass c2 = Class.forName(IDinner.class.getName()); \n\t\t\tm1 = c1.getMethod(\"hashCode\", null);\n\t\t\tm2 = c1.getMethod(\"equals\", new Class[]{Object.class});\n\t\t\tm3 = c1.getMethod(\"toString\", null);\n\t\t\tm4 = c2.getMethod(\"dinner\", new Class[]{IDinner.class});\n\t\t\t//...\n\t\t}catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n### InvocationHandler\n\n```\n/**\n * {@code InvocationHandler} is the interface implemented by\n * the <i>invocation handler</i> of a proxy instance.\n *\n * <p>Each proxy instance has an associated invocation handler.\n * When a method is invoked on a proxy instance, the method\n * invocation is encoded and dispatched to the {@code invoke}\n * method of its invocation handler.\n *\n * @author      Peter Jones\n * @see         Proxy\n * @since       1.3\n */\n```\n\n从其类注释上面可以看出来，每一个代理实例都有一个相关的调用handler，当一个代理实例的方法被唤醒的时候，该被代理的方法将会被编码并且分发到invocation handler中\n\n具体来讲事实上是个回调接口类\n\n```\n /**\n     * Processes a method invocation on a proxy instance and returns\n     * the result.  This method will be invoked on an invocation handler\n     * when a method is invoked on a proxy instance that it is\n     * associated with.\n     *\n     * @param   proxy the proxy instance that the method was invoked on\n     *\n     * @param   method the {@code Method} instance corresponding to\n     * the interface method invoked on the proxy instance.  The declaring\n     * class of the {@code Method} object will be the interface that\n     * the method was declared in, which may be a superinterface of the\n     * proxy interface that the proxy class inherits the method through.\n     *\n     * @param   args an array of objects containing the values of the\n     * arguments passed in the method invocation on the proxy instance,\n     * or {@code null} if interface method takes no arguments.\n     * Arguments of primitive types are wrapped in instances of the\n     * appropriate primitive wrapper class, such as\n     * {@code java.lang.Integer} or {@code java.lang.Boolean}.\n     *\n     * @return  the value to return from the method invocation on the\n     * proxy instance.  If the declared return type of the interface\n     * method is a primitive type, then the value returned by\n     * this method must be an instance of the corresponding primitive\n     * wrapper class; otherwise, it must be a type assignable to the\n     * declared return type.  If the value returned by this method is\n     * {@code null} and the interface method's return type is\n     * primitive, then a {@code NullPointerException} will be\n     * thrown by the method invocation on the proxy instance.  If the\n     * value returned by this method is otherwise not compatible with\n     * the interface method's declared return type as described above,\n     * a {@code ClassCastException} will be thrown by the method\n     * invocation on the proxy instance.\n     *\n     * @throws  Throwable the exception to throw from the method\n     * invocation on the proxy instance.  The exception's type must be\n     * assignable either to any of the exception types declared in the\n     * {@code throws} clause of the interface method or to the\n     * unchecked exception types {@code java.lang.RuntimeException}\n     * or {@code java.lang.Error}.  If a checked exception is\n     * thrown by this method that is not assignable to any of the\n     * exception types declared in the {@code throws} clause of\n     * the interface method, then an\n     * {@link UndeclaredThrowableException} containing the\n     * exception that was thrown by this method will be thrown by the\n     * method invocation on the proxy instance.\n     *\n     * @see     UndeclaredThrowableException\n     */\n    public Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable;\n```\n\n参数的方法表现的就比较容易理解了。\n\nproxy是指代理类的实例，method是指代理类的方法，每当代理类有方法经过时，这个method就会变成那个方法，args是方法的形式参数，这个地方也会截断。\n\n返回值有几种情况\n\n1、声明的返回类型是基础类型，返回值必须是对应的包装类实例\n\n2、如果声明的返回类型是基础类型，但是返回了一个null的话，会报空指针异常\n\n3、如果这个方法的返回值和声明的返回值不兼容的话，会报类型转换异常\n\n# 总结\n\n类A写死持有B，就是B的静态代理。如果A代理的对象是不确定的，就是动态代理。动态代理借用反射机制，最终生成的代理类和静态代理生成的相同\n\n# Q&A\n\n## 动态代理模式和装饰者模式的区别\n\n- 装饰者模式的作用：在不使用继承、不改变原有对象的情况下增加或扩展对象行为，但是并不会禁用某个对象的行为\n\n- 代理模式：控制了这个对象的访问，决定执行或者不执行\n\n## 动态代理模式有缺点吗？\n\n由于是反射机制，创建一个动态代理类大约需要13ms，对比与反射一个方法只需要2ms来看，如果消耗过大还是需要考虑一下的\n","slug":"动态代理的好处","published":1,"updated":"2019-03-12T09:26:33.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltu0e007a3a8k6505lj7q","content":"<blockquote>\n<p>先有设计的思想，后才有设计的手段</p>\n</blockquote>\n<h1 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h1><p>代理模式是java设计模式的一种。代理类具有和委托类相同的接口，代理类主要负责为委托类预处理消息、过滤消息、消息转发、以及事后处理消息等。</p>\n<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><p>由程序员创建或由特定工具自动生成源代码，在对其编译。在程序运行前，代理类的.class文件就已经存在</p>\n<p>静态代理通常只代理一个类。同时静态代理需要明白代理的是什么</p>\n<p>sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义代理接口</span><br><span class=\"line\">public interface ProxyInterface&#123;</span><br><span class=\"line\">\tvoid doSomething();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class A implements ProxyInterface&#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tvoid doSomething()&#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class AProxy implements ProxyInterface&#123;</span><br><span class=\"line\">\tprivate ProxyInterface a;</span><br><span class=\"line\">\tpublic AProxy(ProxyInterface a)&#123;</span><br><span class=\"line\">\t\tthis.a = a;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tvoid doSomething()&#123;</span><br><span class=\"line\">\t\ta.doSomething();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>静态代理从我们日常开发的角度来看，就是一个封装类，比较简单</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>局限性很大，尤其是限于对代理类的了解。在接手一个项目，发生问题的时候或许可以使用这种代理方式来进行优化</p>\n<h2 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h2><p>动态代理类的字节码由java反射机制动态生成，无需手动编写源代码。</p>\n<p>sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建InvocationHandler</span><br><span class=\"line\">InvocationHandler handler = new MyInvocationHandler(...);</span><br><span class=\"line\">//创建动态代理类</span><br><span class=\"line\">Class proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(),new Class[]&#123;Foo.class&#125;);</span><br><span class=\"line\">//创建动态代理类的实例</span><br><span class=\"line\">Foo foo = (Foo)proxyClass.getConstructor(new Class[]&#123;InvocationHandler.class&#125;).newInstance(new Object[]&#123;handler&#125;);</span><br></pre></td></tr></table></figure>\n<p>这样就获取了类了。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><h3 id=\"newProxyInstance\"><a href=\"#newProxyInstance\" class=\"headerlink\" title=\"newProxyInstance\"></a>newProxyInstance</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Object newProxyInstance(ClassLoader loader,</span><br><span class=\"line\">                                          Class&lt;?&gt;[] interfaces,</span><br><span class=\"line\">                                          InvocationHandler h)</span><br><span class=\"line\">        throws IllegalArgumentException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Objects.requireNonNull(h);</span><br><span class=\"line\"></span><br><span class=\"line\">        final Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class=\"line\">        // Android-changed: sm is always null</span><br><span class=\"line\">        // final SecurityManager sm = System.getSecurityManager();</span><br><span class=\"line\">        // if (sm != null) &#123;</span><br><span class=\"line\">        //     checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class=\"line\">        // &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Look up or generate the designated proxy class.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class=\"line\"></span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Invoke its constructor with the designated invocation handler.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            // Android-changed: sm is always null</span><br><span class=\"line\">            // if (sm != null) &#123;</span><br><span class=\"line\">            //     checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class=\"line\">            // &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class=\"line\">            final InvocationHandler ih = h;</span><br><span class=\"line\">            if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class=\"line\">                // Android-changed: Removed AccessController.doPrivileged</span><br><span class=\"line\">                cons.setAccessible(true);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class=\"line\">        &#125; catch (IllegalAccessException|InstantiationException e) &#123;</span><br><span class=\"line\">            throw new InternalError(e.toString(), e);</span><br><span class=\"line\">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class=\"line\">            Throwable t = e.getCause();</span><br><span class=\"line\">            if (t instanceof RuntimeException) &#123;</span><br><span class=\"line\">                throw (RuntimeException) t;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                throw new InternalError(t.toString(), t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class=\"line\">            throw new InternalError(e.toString(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>细致的看这个方法的内容</p>\n<p>第一步 检查handler是否是空，这个没得说的</p>\n<p>第二步 通过传入进去的classloader和class的方法来生成一个新的代理类（这中间有缓存）（class层级）</p>\n<p>第三步 调用代理的构造器，将handler传入，构造了一个相应的类。</p>\n<h3 id=\"getProxyClass0-：就是用来生产代理类的类对象\"><a href=\"#getProxyClass0-：就是用来生产代理类的类对象\" class=\"headerlink\" title=\"getProxyClass0()：就是用来生产代理类的类对象\"></a>getProxyClass0()：就是用来生产代理类的类对象</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class=\"line\">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class=\"line\">    // 当目标类实现的接口数量大于 65535</span><br><span class=\"line\">    if (interfaces.length &gt; 65535) &#123;</span><br><span class=\"line\">\t    // 抛异常</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 关键2：获取代理类，使用了缓存机制</span><br><span class=\"line\">    return proxyClassCache.get(loader, interfaces);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"WeakCache-get\"><a href=\"#WeakCache-get\" class=\"headerlink\" title=\"WeakCache#get()\"></a>WeakCache#get()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 缓存的底层实现，key 为一级缓存，value 为二级缓存，一级缓存 key 类型为 Object，支持 null</span><br><span class=\"line\">private final ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map</span><br><span class=\"line\">    = new ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">// key：classloader</span><br><span class=\"line\">// parameter：interfaces</span><br><span class=\"line\">public V get(K key, P parameter) &#123;</span><br><span class=\"line\">\t// 判断接口数组是否为空，为空抛异常，不为空返回接口对应类型</span><br><span class=\"line\">\tObjects.requireNonNull(parameter);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 清除过期的缓存</span><br><span class=\"line\">\texpungeStaleEntries();</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 将传入的 classloader 包装成 CacheKey，作为一级缓存</span><br><span class=\"line\">\tObject cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 根据一级缓存 cacheKey 获取二级缓存 valuesMap</span><br><span class=\"line\">\tConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class=\"line\">\t// 如果根据 classLoader 没有获取到对应的值</span><br><span class=\"line\">\tif (valuesMap == null) &#123;</span><br><span class=\"line\">\t\t// 以 CAS 方式放入，如果不存在则放入，否则返回原先的值</span><br><span class=\"line\">\t\tConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey,</span><br><span class=\"line\">                              valuesMap = new ConcurrentHashMap&lt;&gt;());</span><br><span class=\"line\">\t\t// 如果 oldValuesMap 有值，说明放入失败</span><br><span class=\"line\">\t\tif (oldValuesMap != null) &#123;</span><br><span class=\"line\">\t\t\t// valuesMap 设置为原来的 oldValuesMap</span><br><span class=\"line\">\t\t\tvaluesMap = oldValuesMap;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // subKeyFactory 通过 WeakCache 构造函数传入，实际为 KeyFactory</span><br><span class=\"line\">    // subKeyFactory.apply(key, parameter)：KeyFactory 根据代理类实现的接口数组来生成二级缓存 key</span><br><span class=\"line\">\t// Objects.requireNonNull()：判断得到的二级缓存 key 是否为空，为空抛异常，不为空返回二级缓存 key 对应类型 Object</span><br><span class=\"line\">\tObject subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class=\"line\">\t// 根据二级缓存的 key 获取二级缓存的值 supplier</span><br><span class=\"line\">\tSupplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class=\"line\">\tFactory factory = null;</span><br><span class=\"line\"></span><br><span class=\"line\">\twhile (true) &#123;</span><br><span class=\"line\">\t\t// 如果二级缓存的值 supplier 不为 null</span><br><span class=\"line\">\t\tif (supplier != null) &#123;</span><br><span class=\"line\">\t\t\t// 调用 get() 方法</span><br><span class=\"line\">\t\t\t// 关键4：Factory implements Supplier，则此处实际调用的是 Factory#get()</span><br><span class=\"line\">\t\t\tV value = supplier.get();</span><br><span class=\"line\">\t\t\t// value 不为空</span><br><span class=\"line\">\t\t\tif (value != null) &#123;</span><br><span class=\"line\">\t\t\t\t// 返回 value</span><br><span class=\"line\">\t\t\t\treturn value;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// else no supplier in cache</span><br><span class=\"line\">\t\t// or a supplier that returned null (could be a cleared CacheValue</span><br><span class=\"line\">\t\t// or a Factory that wasn&apos;t successful in installing the CacheValue)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 如果 factory 等于 null</span><br><span class=\"line\">\t\tif (factory == null) &#123;</span><br><span class=\"line\">\t\t\t// 实例化一个 Factory（作为二级缓存的值），作为 subKey （二级缓存的 key）对应的 value</span><br><span class=\"line\">\t\t\tfactory = new Factory(key, parameter, subKey, valuesMap);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 如果 supplier 等于 null（根据二级缓存的 key 没有获取到二级缓存的值 supplier）</span><br><span class=\"line\">\t\tif (supplier == null) &#123;</span><br><span class=\"line\">\t\t\t// 将实例化的 factory 作为 subKey 对应的值传入</span><br><span class=\"line\">\t\t\tsupplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class=\"line\">\t\t\t// supplier 等于 null（可能上一步成功执行后返回的是 null???）</span><br><span class=\"line\">\t\t\tif (supplier == null) &#123;</span><br><span class=\"line\">\t\t\t\t// successfully installed Factory</span><br><span class=\"line\">\t\t\t\tsupplier = factory;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t// else retry with winning supplier</span><br><span class=\"line\">\t\t&#125; else &#123; // 可能期间有其他线程修改了值，那么就不会再继续给 subKey 赋值，而是取出来直接用</span><br><span class=\"line\">\t\t\t// 期间可能其它线程修改了值 factory，就用该值替换掉 supplier</span><br><span class=\"line\">\t\t\tif (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class=\"line\">\t\t\t\t// 将 supplier 替换成 factory</span><br><span class=\"line\">\t\t\t\tsupplier = factory;</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t// 替换失败，继续使用原先的值</span><br><span class=\"line\">\t\t\t\tsupplier = valuesMap.get(subKey);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Factory-get\"><a href=\"#Factory-get\" class=\"headerlink\" title=\"Factory#get()\"></a>Factory#get()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public synchronized V get() &#123; // serialize access</span><br><span class=\"line\">    // 根据二级缓存的 key 获取 supplier</span><br><span class=\"line\">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class=\"line\">    // 如果获取的 supplier 不是 Factory 类型</span><br><span class=\"line\">    if (supplier != this) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // else still us (supplier == this)</span><br><span class=\"line\"></span><br><span class=\"line\">    // create new value</span><br><span class=\"line\">    V value = null;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">\t    // valueFactory 通过 WeakCache 构造函数传入，实际为 ProxyClassFactory</span><br><span class=\"line\">\t    // 关键5：valueFactory.apply()-&gt;ProxyClassFactory#apply()</span><br><span class=\"line\">        value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        if (value == null) &#123; // remove us on failure</span><br><span class=\"line\">            valuesMap.remove(subKey, this);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // the only path to reach here is with non-null value</span><br><span class=\"line\">    assert value != null;</span><br><span class=\"line\"></span><br><span class=\"line\">    // wrap value with CacheValue (WeakReference)</span><br><span class=\"line\">    CacheValue&lt;V&gt; cacheValue = new CacheValue&lt;&gt;(value);</span><br><span class=\"line\"></span><br><span class=\"line\">    // try replacing us with CacheValue (this should always succeed)</span><br><span class=\"line\">    if (valuesMap.replace(subKey, this, cacheValue)) &#123;</span><br><span class=\"line\">        // put also in reverseMap</span><br><span class=\"line\">        reverseMap.put(cacheValue, Boolean.TRUE);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        throw new AssertionError(&quot;Should not reach here&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // successfully replaced us with new CacheValue -&gt; return the value</span><br><span class=\"line\">    // wrapped by it</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ProxyClassFactory-apply\"><a href=\"#ProxyClassFactory-apply\" class=\"headerlink\" title=\"ProxyClassFactory#apply()\"></a>ProxyClassFactory#apply()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Proxy 的类名前缀</span><br><span class=\"line\">private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// next number to use for generation of unique proxy class names</span><br><span class=\"line\">// 生成自增的数字</span><br><span class=\"line\">private static final AtomicLong nextUniqueNumber = new AtomicLong();</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 根据接口数组长度生成对应的 Map</span><br><span class=\"line\">    Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class=\"line\">    // 遍历接口数组</span><br><span class=\"line\">    for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Verify that the class loader resolves the name of this</span><br><span class=\"line\">         * interface to the same Class object.</span><br><span class=\"line\">         * </span><br><span class=\"line\">         * 验证类加载器将此 interface 的名字解析成同一类对象</span><br><span class=\"line\">         */</span><br><span class=\"line\">        Class&lt;?&gt; interfaceClass = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">\t        // 根据接口名获取接口对应的类对象</span><br><span class=\"line\">            interfaceClass = Class.forName(intf.getName(), false, loader);</span><br><span class=\"line\">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 接口类对象不等于接口，不是同一对象</span><br><span class=\"line\">        if (interfaceClass != intf) &#123;</span><br><span class=\"line\">\t        //抛异常，接口来自不同的类加载器</span><br><span class=\"line\">            throw new IllegalArgumentException(</span><br><span class=\"line\">                intf + &quot; is not visible from class loader&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Verify that the Class object actually represents an</span><br><span class=\"line\">         * interface.</span><br><span class=\"line\">         * </span><br><span class=\"line\">         * 验证生成的类对象是否是一个接口类型</span><br><span class=\"line\">         */</span><br><span class=\"line\">        // 类对象不是接口类型</span><br><span class=\"line\">        if (!interfaceClass.isInterface()) &#123;</span><br><span class=\"line\">\t        // 抛异常，类对象不是一个接口类型</span><br><span class=\"line\">            throw new IllegalArgumentException(</span><br><span class=\"line\">                interfaceClass.getName() + &quot; is not an interface&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Verify that this interface is not a duplicate.</span><br><span class=\"line\">         * </span><br><span class=\"line\">         * 验证此接口不是重复的</span><br><span class=\"line\">         */</span><br><span class=\"line\">        // 往接口数组对应的 map 中存入类对象，返回值不为 null</span><br><span class=\"line\">        if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;</span><br><span class=\"line\">\t        // 抛异常，来自当前类对象的接口重复</span><br><span class=\"line\">            throw new IllegalArgumentException(</span><br><span class=\"line\">                &quot;repeated interface: &quot; + interfaceClass.getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    String proxyPkg = null;     // package to define proxy class in</span><br><span class=\"line\">    int accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * Record the package of a non-public proxy interface so that the</span><br><span class=\"line\">     * proxy class will be defined in the same package.  Verify that</span><br><span class=\"line\">     * all non-public proxy interfaces are in the same package.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    // 遍历接口数组</span><br><span class=\"line\">    for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class=\"line\">\t\t// 获取当前接口的修饰符</span><br><span class=\"line\">        int flags = intf.getModifiers();</span><br><span class=\"line\">        // 如果当前接口修饰符不是 public</span><br><span class=\"line\">        if (!Modifier.isPublic(flags)) &#123;</span><br><span class=\"line\">\t\t\t// 设置为 final</span><br><span class=\"line\">            accessFlags = Modifier.FINAL;</span><br><span class=\"line\">            String name = intf.getName();</span><br><span class=\"line\">            int n = name.lastIndexOf(&apos;.&apos;);</span><br><span class=\"line\">            String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));</span><br><span class=\"line\">            // 包名为 null</span><br><span class=\"line\">            if (proxyPkg == null) &#123;</span><br><span class=\"line\">\t            // 包名等于当前接口的包名</span><br><span class=\"line\">                proxyPkg = pkg;</span><br><span class=\"line\">            &#125; else if (!pkg.equals(proxyPkg)) &#123;// 如果包名不相等</span><br><span class=\"line\">\t            // 抛异常，非 public 的接口集合来自不同的包</span><br><span class=\"line\">                throw new IllegalArgumentException(</span><br><span class=\"line\">                    &quot;non-public interfaces from different packages&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 包名为 null</span><br><span class=\"line\">    if (proxyPkg == null) &#123;</span><br><span class=\"line\">        // if no non-public proxy interfaces, use com.sun.proxy package</span><br><span class=\"line\">        // 如果 no non-public（即是 public）的代理接口集合，则使用包名 com.sun.proxy</span><br><span class=\"line\">        proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * Choose a name for the proxy class to generate.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    long num = nextUniqueNumber.getAndIncrement();</span><br><span class=\"line\">    // 组成代理类全类名：包名 + 代理类前缀 + 唯一的自增长数字</span><br><span class=\"line\">    String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * Generate the specified proxy class.</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * 关键6：生成指定的代理类</span><br><span class=\"line\">     */</span><br><span class=\"line\">    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class=\"line\">        proxyName, interfaces, accessFlags);</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        return defineClass0(loader, proxyName,</span><br><span class=\"line\">                            proxyClassFile, 0, proxyClassFile.length);</span><br><span class=\"line\">    &#125; catch (ClassFormatError e) &#123;</span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * A ClassFormatError here means that (barring bugs in the</span><br><span class=\"line\">         * proxy class generation code) there was some other</span><br><span class=\"line\">         * invalid aspect of the arguments supplied to the proxy</span><br><span class=\"line\">         * class creation (such as virtual machine limitations</span><br><span class=\"line\">         * exceeded).</span><br><span class=\"line\">         */</span><br><span class=\"line\">        throw new IllegalArgumentException(e.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成代理类的字节码\"><a href=\"#生成代理类的字节码\" class=\"headerlink\" title=\"生成代理类的字节码\"></a>生成代理类的字节码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最终生成的代理类：</span><br><span class=\"line\">public class Proxy0 extends Proxy implements IDinner &#123;</span><br><span class=\"line\">\t// 第一步：生成构造器</span><br><span class=\"line\">\tprotected Proxy0(InvocationHandler h) &#123;</span><br><span class=\"line\">\t\tsuper(h);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// 第二步：生成静态域</span><br><span class=\"line\">\tprivate static Method m1; // hashCode方法</span><br><span class=\"line\">\tprivate static Method m2; // equals方法</span><br><span class=\"line\">\tprivate static Method m3; // toString方法</span><br><span class=\"line\">\tprivate static Method m4; //...</span><br><span class=\"line\">\t// 第三步：生成代理方法</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic int hashCode() &#123;</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\treturn (int) h.invoke(this, m1, null);</span><br><span class=\"line\">\t\t&#125;catch (Throwable e) &#123;</span><br><span class=\"line\">\t\t\tthrow new UndeclaredThrowableException(e);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic boolean equals(Object obj) &#123;</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tObject[] args = new Object[] &#123;obj&#125;;</span><br><span class=\"line\">\t\t\treturn (boolean) h.invoke(this, m2, args);</span><br><span class=\"line\">\t\t&#125;catch (Throwable e) &#123;</span><br><span class=\"line\">\t\t\tthrow new UndeclaredThrowableException(e);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic String toString() &#123;</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\treturn (String) h.invoke(this, m3, null);</span><br><span class=\"line\">\t\t&#125;catch (Throwable e) &#123;</span><br><span class=\"line\">\t\t\tthrow new UndeclaredThrowableException(e);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void dinner() &#123;</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\t// 构造参数数组，如果有多个参数往后面添加就行了</span><br><span class=\"line\">\t\t\tObject[] args = new Object[] &#123;&#125;;</span><br><span class=\"line\">\t\t\t// h 为通过构造方法传进来的 InvocationHandler，即此处调用 InvocationHandler#invoke(...) 方法</span><br><span class=\"line\">\t\t\th.invoke(this, m4, args);</span><br><span class=\"line\">\t\t&#125;catch (Throwable e) &#123;</span><br><span class=\"line\">\t\t\tthrow new UndeclaredThrowableException(e);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// 第四步：生成静态初始化方法</span><br><span class=\"line\">\tstatic &#123;</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tClass c1 = Class.forName(Object.class.getName());</span><br><span class=\"line\">\t\t\tClass c2 = Class.forName(IDinner.class.getName()); </span><br><span class=\"line\">\t\t\tm1 = c1.getMethod(&quot;hashCode&quot;, null);</span><br><span class=\"line\">\t\t\tm2 = c1.getMethod(&quot;equals&quot;, new Class[]&#123;Object.class&#125;);</span><br><span class=\"line\">\t\t\tm3 = c1.getMethod(&quot;toString&quot;, null);</span><br><span class=\"line\">\t\t\tm4 = c2.getMethod(&quot;dinner&quot;, new Class[]&#123;IDinner.class&#125;);</span><br><span class=\"line\">\t\t\t//...</span><br><span class=\"line\">\t\t&#125;catch (Exception e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"InvocationHandler\"><a href=\"#InvocationHandler\" class=\"headerlink\" title=\"InvocationHandler\"></a>InvocationHandler</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * &#123;@code InvocationHandler&#125; is the interface implemented by</span><br><span class=\"line\"> * the &lt;i&gt;invocation handler&lt;/i&gt; of a proxy instance.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * &lt;p&gt;Each proxy instance has an associated invocation handler.</span><br><span class=\"line\"> * When a method is invoked on a proxy instance, the method</span><br><span class=\"line\"> * invocation is encoded and dispatched to the &#123;@code invoke&#125;</span><br><span class=\"line\"> * method of its invocation handler.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author      Peter Jones</span><br><span class=\"line\"> * @see         Proxy</span><br><span class=\"line\"> * @since       1.3</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n<p>从其类注释上面可以看出来，每一个代理实例都有一个相关的调用handler，当一个代理实例的方法被唤醒的时候，该被代理的方法将会被编码并且分发到invocation handler中</p>\n<p>具体来讲事实上是个回调接口类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">    * Processes a method invocation on a proxy instance and returns</span><br><span class=\"line\">    * the result.  This method will be invoked on an invocation handler</span><br><span class=\"line\">    * when a method is invoked on a proxy instance that it is</span><br><span class=\"line\">    * associated with.</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @param   proxy the proxy instance that the method was invoked on</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @param   method the &#123;@code Method&#125; instance corresponding to</span><br><span class=\"line\">    * the interface method invoked on the proxy instance.  The declaring</span><br><span class=\"line\">    * class of the &#123;@code Method&#125; object will be the interface that</span><br><span class=\"line\">    * the method was declared in, which may be a superinterface of the</span><br><span class=\"line\">    * proxy interface that the proxy class inherits the method through.</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @param   args an array of objects containing the values of the</span><br><span class=\"line\">    * arguments passed in the method invocation on the proxy instance,</span><br><span class=\"line\">    * or &#123;@code null&#125; if interface method takes no arguments.</span><br><span class=\"line\">    * Arguments of primitive types are wrapped in instances of the</span><br><span class=\"line\">    * appropriate primitive wrapper class, such as</span><br><span class=\"line\">    * &#123;@code java.lang.Integer&#125; or &#123;@code java.lang.Boolean&#125;.</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @return  the value to return from the method invocation on the</span><br><span class=\"line\">    * proxy instance.  If the declared return type of the interface</span><br><span class=\"line\">    * method is a primitive type, then the value returned by</span><br><span class=\"line\">    * this method must be an instance of the corresponding primitive</span><br><span class=\"line\">    * wrapper class; otherwise, it must be a type assignable to the</span><br><span class=\"line\">    * declared return type.  If the value returned by this method is</span><br><span class=\"line\">    * &#123;@code null&#125; and the interface method&apos;s return type is</span><br><span class=\"line\">    * primitive, then a &#123;@code NullPointerException&#125; will be</span><br><span class=\"line\">    * thrown by the method invocation on the proxy instance.  If the</span><br><span class=\"line\">    * value returned by this method is otherwise not compatible with</span><br><span class=\"line\">    * the interface method&apos;s declared return type as described above,</span><br><span class=\"line\">    * a &#123;@code ClassCastException&#125; will be thrown by the method</span><br><span class=\"line\">    * invocation on the proxy instance.</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @throws  Throwable the exception to throw from the method</span><br><span class=\"line\">    * invocation on the proxy instance.  The exception&apos;s type must be</span><br><span class=\"line\">    * assignable either to any of the exception types declared in the</span><br><span class=\"line\">    * &#123;@code throws&#125; clause of the interface method or to the</span><br><span class=\"line\">    * unchecked exception types &#123;@code java.lang.RuntimeException&#125;</span><br><span class=\"line\">    * or &#123;@code java.lang.Error&#125;.  If a checked exception is</span><br><span class=\"line\">    * thrown by this method that is not assignable to any of the</span><br><span class=\"line\">    * exception types declared in the &#123;@code throws&#125; clause of</span><br><span class=\"line\">    * the interface method, then an</span><br><span class=\"line\">    * &#123;@link UndeclaredThrowableException&#125; containing the</span><br><span class=\"line\">    * exception that was thrown by this method will be thrown by the</span><br><span class=\"line\">    * method invocation on the proxy instance.</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @see     UndeclaredThrowableException</span><br><span class=\"line\">    */</span><br><span class=\"line\">   public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class=\"line\">       throws Throwable;</span><br></pre></td></tr></table></figure>\n<p>参数的方法表现的就比较容易理解了。</p>\n<p>proxy是指代理类的实例，method是指代理类的方法，每当代理类有方法经过时，这个method就会变成那个方法，args是方法的形式参数，这个地方也会截断。</p>\n<p>返回值有几种情况</p>\n<p>1、声明的返回类型是基础类型，返回值必须是对应的包装类实例</p>\n<p>2、如果声明的返回类型是基础类型，但是返回了一个null的话，会报空指针异常</p>\n<p>3、如果这个方法的返回值和声明的返回值不兼容的话，会报类型转换异常</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>类A写死持有B，就是B的静态代理。如果A代理的对象是不确定的，就是动态代理。动态代理借用反射机制，最终生成的代理类和静态代理生成的相同</p>\n<h1 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h1><h2 id=\"动态代理模式和装饰者模式的区别\"><a href=\"#动态代理模式和装饰者模式的区别\" class=\"headerlink\" title=\"动态代理模式和装饰者模式的区别\"></a>动态代理模式和装饰者模式的区别</h2><ul>\n<li><p>装饰者模式的作用：在不使用继承、不改变原有对象的情况下增加或扩展对象行为，但是并不会禁用某个对象的行为</p>\n</li>\n<li><p>代理模式：控制了这个对象的访问，决定执行或者不执行</p>\n</li>\n</ul>\n<h2 id=\"动态代理模式有缺点吗？\"><a href=\"#动态代理模式有缺点吗？\" class=\"headerlink\" title=\"动态代理模式有缺点吗？\"></a>动态代理模式有缺点吗？</h2><p>由于是反射机制，创建一个动态代理类大约需要13ms，对比与反射一个方法只需要2ms来看，如果消耗过大还是需要考虑一下的</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>先有设计的思想，后才有设计的手段</p>\n</blockquote>\n<h1 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h1><p>代理模式是java设计模式的一种。代理类具有和委托类相同的接口，代理类主要负责为委托类预处理消息、过滤消息、消息转发、以及事后处理消息等。</p>\n<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><p>由程序员创建或由特定工具自动生成源代码，在对其编译。在程序运行前，代理类的.class文件就已经存在</p>\n<p>静态代理通常只代理一个类。同时静态代理需要明白代理的是什么</p>\n<p>sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义代理接口</span><br><span class=\"line\">public interface ProxyInterface&#123;</span><br><span class=\"line\">\tvoid doSomething();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class A implements ProxyInterface&#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tvoid doSomething()&#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class AProxy implements ProxyInterface&#123;</span><br><span class=\"line\">\tprivate ProxyInterface a;</span><br><span class=\"line\">\tpublic AProxy(ProxyInterface a)&#123;</span><br><span class=\"line\">\t\tthis.a = a;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tvoid doSomething()&#123;</span><br><span class=\"line\">\t\ta.doSomething();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>静态代理从我们日常开发的角度来看，就是一个封装类，比较简单</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>局限性很大，尤其是限于对代理类的了解。在接手一个项目，发生问题的时候或许可以使用这种代理方式来进行优化</p>\n<h2 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h2><p>动态代理类的字节码由java反射机制动态生成，无需手动编写源代码。</p>\n<p>sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建InvocationHandler</span><br><span class=\"line\">InvocationHandler handler = new MyInvocationHandler(...);</span><br><span class=\"line\">//创建动态代理类</span><br><span class=\"line\">Class proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(),new Class[]&#123;Foo.class&#125;);</span><br><span class=\"line\">//创建动态代理类的实例</span><br><span class=\"line\">Foo foo = (Foo)proxyClass.getConstructor(new Class[]&#123;InvocationHandler.class&#125;).newInstance(new Object[]&#123;handler&#125;);</span><br></pre></td></tr></table></figure>\n<p>这样就获取了类了。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><h3 id=\"newProxyInstance\"><a href=\"#newProxyInstance\" class=\"headerlink\" title=\"newProxyInstance\"></a>newProxyInstance</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Object newProxyInstance(ClassLoader loader,</span><br><span class=\"line\">                                          Class&lt;?&gt;[] interfaces,</span><br><span class=\"line\">                                          InvocationHandler h)</span><br><span class=\"line\">        throws IllegalArgumentException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Objects.requireNonNull(h);</span><br><span class=\"line\"></span><br><span class=\"line\">        final Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class=\"line\">        // Android-changed: sm is always null</span><br><span class=\"line\">        // final SecurityManager sm = System.getSecurityManager();</span><br><span class=\"line\">        // if (sm != null) &#123;</span><br><span class=\"line\">        //     checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class=\"line\">        // &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Look up or generate the designated proxy class.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class=\"line\"></span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Invoke its constructor with the designated invocation handler.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            // Android-changed: sm is always null</span><br><span class=\"line\">            // if (sm != null) &#123;</span><br><span class=\"line\">            //     checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class=\"line\">            // &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class=\"line\">            final InvocationHandler ih = h;</span><br><span class=\"line\">            if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class=\"line\">                // Android-changed: Removed AccessController.doPrivileged</span><br><span class=\"line\">                cons.setAccessible(true);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class=\"line\">        &#125; catch (IllegalAccessException|InstantiationException e) &#123;</span><br><span class=\"line\">            throw new InternalError(e.toString(), e);</span><br><span class=\"line\">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class=\"line\">            Throwable t = e.getCause();</span><br><span class=\"line\">            if (t instanceof RuntimeException) &#123;</span><br><span class=\"line\">                throw (RuntimeException) t;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                throw new InternalError(t.toString(), t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class=\"line\">            throw new InternalError(e.toString(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>细致的看这个方法的内容</p>\n<p>第一步 检查handler是否是空，这个没得说的</p>\n<p>第二步 通过传入进去的classloader和class的方法来生成一个新的代理类（这中间有缓存）（class层级）</p>\n<p>第三步 调用代理的构造器，将handler传入，构造了一个相应的类。</p>\n<h3 id=\"getProxyClass0-：就是用来生产代理类的类对象\"><a href=\"#getProxyClass0-：就是用来生产代理类的类对象\" class=\"headerlink\" title=\"getProxyClass0()：就是用来生产代理类的类对象\"></a>getProxyClass0()：就是用来生产代理类的类对象</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class=\"line\">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class=\"line\">    // 当目标类实现的接口数量大于 65535</span><br><span class=\"line\">    if (interfaces.length &gt; 65535) &#123;</span><br><span class=\"line\">\t    // 抛异常</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 关键2：获取代理类，使用了缓存机制</span><br><span class=\"line\">    return proxyClassCache.get(loader, interfaces);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"WeakCache-get\"><a href=\"#WeakCache-get\" class=\"headerlink\" title=\"WeakCache#get()\"></a>WeakCache#get()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 缓存的底层实现，key 为一级缓存，value 为二级缓存，一级缓存 key 类型为 Object，支持 null</span><br><span class=\"line\">private final ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map</span><br><span class=\"line\">    = new ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">// key：classloader</span><br><span class=\"line\">// parameter：interfaces</span><br><span class=\"line\">public V get(K key, P parameter) &#123;</span><br><span class=\"line\">\t// 判断接口数组是否为空，为空抛异常，不为空返回接口对应类型</span><br><span class=\"line\">\tObjects.requireNonNull(parameter);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 清除过期的缓存</span><br><span class=\"line\">\texpungeStaleEntries();</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 将传入的 classloader 包装成 CacheKey，作为一级缓存</span><br><span class=\"line\">\tObject cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 根据一级缓存 cacheKey 获取二级缓存 valuesMap</span><br><span class=\"line\">\tConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class=\"line\">\t// 如果根据 classLoader 没有获取到对应的值</span><br><span class=\"line\">\tif (valuesMap == null) &#123;</span><br><span class=\"line\">\t\t// 以 CAS 方式放入，如果不存在则放入，否则返回原先的值</span><br><span class=\"line\">\t\tConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey,</span><br><span class=\"line\">                              valuesMap = new ConcurrentHashMap&lt;&gt;());</span><br><span class=\"line\">\t\t// 如果 oldValuesMap 有值，说明放入失败</span><br><span class=\"line\">\t\tif (oldValuesMap != null) &#123;</span><br><span class=\"line\">\t\t\t// valuesMap 设置为原来的 oldValuesMap</span><br><span class=\"line\">\t\t\tvaluesMap = oldValuesMap;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // subKeyFactory 通过 WeakCache 构造函数传入，实际为 KeyFactory</span><br><span class=\"line\">    // subKeyFactory.apply(key, parameter)：KeyFactory 根据代理类实现的接口数组来生成二级缓存 key</span><br><span class=\"line\">\t// Objects.requireNonNull()：判断得到的二级缓存 key 是否为空，为空抛异常，不为空返回二级缓存 key 对应类型 Object</span><br><span class=\"line\">\tObject subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class=\"line\">\t// 根据二级缓存的 key 获取二级缓存的值 supplier</span><br><span class=\"line\">\tSupplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class=\"line\">\tFactory factory = null;</span><br><span class=\"line\"></span><br><span class=\"line\">\twhile (true) &#123;</span><br><span class=\"line\">\t\t// 如果二级缓存的值 supplier 不为 null</span><br><span class=\"line\">\t\tif (supplier != null) &#123;</span><br><span class=\"line\">\t\t\t// 调用 get() 方法</span><br><span class=\"line\">\t\t\t// 关键4：Factory implements Supplier，则此处实际调用的是 Factory#get()</span><br><span class=\"line\">\t\t\tV value = supplier.get();</span><br><span class=\"line\">\t\t\t// value 不为空</span><br><span class=\"line\">\t\t\tif (value != null) &#123;</span><br><span class=\"line\">\t\t\t\t// 返回 value</span><br><span class=\"line\">\t\t\t\treturn value;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// else no supplier in cache</span><br><span class=\"line\">\t\t// or a supplier that returned null (could be a cleared CacheValue</span><br><span class=\"line\">\t\t// or a Factory that wasn&apos;t successful in installing the CacheValue)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 如果 factory 等于 null</span><br><span class=\"line\">\t\tif (factory == null) &#123;</span><br><span class=\"line\">\t\t\t// 实例化一个 Factory（作为二级缓存的值），作为 subKey （二级缓存的 key）对应的 value</span><br><span class=\"line\">\t\t\tfactory = new Factory(key, parameter, subKey, valuesMap);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 如果 supplier 等于 null（根据二级缓存的 key 没有获取到二级缓存的值 supplier）</span><br><span class=\"line\">\t\tif (supplier == null) &#123;</span><br><span class=\"line\">\t\t\t// 将实例化的 factory 作为 subKey 对应的值传入</span><br><span class=\"line\">\t\t\tsupplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class=\"line\">\t\t\t// supplier 等于 null（可能上一步成功执行后返回的是 null???）</span><br><span class=\"line\">\t\t\tif (supplier == null) &#123;</span><br><span class=\"line\">\t\t\t\t// successfully installed Factory</span><br><span class=\"line\">\t\t\t\tsupplier = factory;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t// else retry with winning supplier</span><br><span class=\"line\">\t\t&#125; else &#123; // 可能期间有其他线程修改了值，那么就不会再继续给 subKey 赋值，而是取出来直接用</span><br><span class=\"line\">\t\t\t// 期间可能其它线程修改了值 factory，就用该值替换掉 supplier</span><br><span class=\"line\">\t\t\tif (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class=\"line\">\t\t\t\t// 将 supplier 替换成 factory</span><br><span class=\"line\">\t\t\t\tsupplier = factory;</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t// 替换失败，继续使用原先的值</span><br><span class=\"line\">\t\t\t\tsupplier = valuesMap.get(subKey);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Factory-get\"><a href=\"#Factory-get\" class=\"headerlink\" title=\"Factory#get()\"></a>Factory#get()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public synchronized V get() &#123; // serialize access</span><br><span class=\"line\">    // 根据二级缓存的 key 获取 supplier</span><br><span class=\"line\">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class=\"line\">    // 如果获取的 supplier 不是 Factory 类型</span><br><span class=\"line\">    if (supplier != this) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // else still us (supplier == this)</span><br><span class=\"line\"></span><br><span class=\"line\">    // create new value</span><br><span class=\"line\">    V value = null;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">\t    // valueFactory 通过 WeakCache 构造函数传入，实际为 ProxyClassFactory</span><br><span class=\"line\">\t    // 关键5：valueFactory.apply()-&gt;ProxyClassFactory#apply()</span><br><span class=\"line\">        value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        if (value == null) &#123; // remove us on failure</span><br><span class=\"line\">            valuesMap.remove(subKey, this);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // the only path to reach here is with non-null value</span><br><span class=\"line\">    assert value != null;</span><br><span class=\"line\"></span><br><span class=\"line\">    // wrap value with CacheValue (WeakReference)</span><br><span class=\"line\">    CacheValue&lt;V&gt; cacheValue = new CacheValue&lt;&gt;(value);</span><br><span class=\"line\"></span><br><span class=\"line\">    // try replacing us with CacheValue (this should always succeed)</span><br><span class=\"line\">    if (valuesMap.replace(subKey, this, cacheValue)) &#123;</span><br><span class=\"line\">        // put also in reverseMap</span><br><span class=\"line\">        reverseMap.put(cacheValue, Boolean.TRUE);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        throw new AssertionError(&quot;Should not reach here&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // successfully replaced us with new CacheValue -&gt; return the value</span><br><span class=\"line\">    // wrapped by it</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ProxyClassFactory-apply\"><a href=\"#ProxyClassFactory-apply\" class=\"headerlink\" title=\"ProxyClassFactory#apply()\"></a>ProxyClassFactory#apply()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Proxy 的类名前缀</span><br><span class=\"line\">private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// next number to use for generation of unique proxy class names</span><br><span class=\"line\">// 生成自增的数字</span><br><span class=\"line\">private static final AtomicLong nextUniqueNumber = new AtomicLong();</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 根据接口数组长度生成对应的 Map</span><br><span class=\"line\">    Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class=\"line\">    // 遍历接口数组</span><br><span class=\"line\">    for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Verify that the class loader resolves the name of this</span><br><span class=\"line\">         * interface to the same Class object.</span><br><span class=\"line\">         * </span><br><span class=\"line\">         * 验证类加载器将此 interface 的名字解析成同一类对象</span><br><span class=\"line\">         */</span><br><span class=\"line\">        Class&lt;?&gt; interfaceClass = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">\t        // 根据接口名获取接口对应的类对象</span><br><span class=\"line\">            interfaceClass = Class.forName(intf.getName(), false, loader);</span><br><span class=\"line\">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 接口类对象不等于接口，不是同一对象</span><br><span class=\"line\">        if (interfaceClass != intf) &#123;</span><br><span class=\"line\">\t        //抛异常，接口来自不同的类加载器</span><br><span class=\"line\">            throw new IllegalArgumentException(</span><br><span class=\"line\">                intf + &quot; is not visible from class loader&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Verify that the Class object actually represents an</span><br><span class=\"line\">         * interface.</span><br><span class=\"line\">         * </span><br><span class=\"line\">         * 验证生成的类对象是否是一个接口类型</span><br><span class=\"line\">         */</span><br><span class=\"line\">        // 类对象不是接口类型</span><br><span class=\"line\">        if (!interfaceClass.isInterface()) &#123;</span><br><span class=\"line\">\t        // 抛异常，类对象不是一个接口类型</span><br><span class=\"line\">            throw new IllegalArgumentException(</span><br><span class=\"line\">                interfaceClass.getName() + &quot; is not an interface&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Verify that this interface is not a duplicate.</span><br><span class=\"line\">         * </span><br><span class=\"line\">         * 验证此接口不是重复的</span><br><span class=\"line\">         */</span><br><span class=\"line\">        // 往接口数组对应的 map 中存入类对象，返回值不为 null</span><br><span class=\"line\">        if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;</span><br><span class=\"line\">\t        // 抛异常，来自当前类对象的接口重复</span><br><span class=\"line\">            throw new IllegalArgumentException(</span><br><span class=\"line\">                &quot;repeated interface: &quot; + interfaceClass.getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    String proxyPkg = null;     // package to define proxy class in</span><br><span class=\"line\">    int accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * Record the package of a non-public proxy interface so that the</span><br><span class=\"line\">     * proxy class will be defined in the same package.  Verify that</span><br><span class=\"line\">     * all non-public proxy interfaces are in the same package.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    // 遍历接口数组</span><br><span class=\"line\">    for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class=\"line\">\t\t// 获取当前接口的修饰符</span><br><span class=\"line\">        int flags = intf.getModifiers();</span><br><span class=\"line\">        // 如果当前接口修饰符不是 public</span><br><span class=\"line\">        if (!Modifier.isPublic(flags)) &#123;</span><br><span class=\"line\">\t\t\t// 设置为 final</span><br><span class=\"line\">            accessFlags = Modifier.FINAL;</span><br><span class=\"line\">            String name = intf.getName();</span><br><span class=\"line\">            int n = name.lastIndexOf(&apos;.&apos;);</span><br><span class=\"line\">            String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));</span><br><span class=\"line\">            // 包名为 null</span><br><span class=\"line\">            if (proxyPkg == null) &#123;</span><br><span class=\"line\">\t            // 包名等于当前接口的包名</span><br><span class=\"line\">                proxyPkg = pkg;</span><br><span class=\"line\">            &#125; else if (!pkg.equals(proxyPkg)) &#123;// 如果包名不相等</span><br><span class=\"line\">\t            // 抛异常，非 public 的接口集合来自不同的包</span><br><span class=\"line\">                throw new IllegalArgumentException(</span><br><span class=\"line\">                    &quot;non-public interfaces from different packages&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 包名为 null</span><br><span class=\"line\">    if (proxyPkg == null) &#123;</span><br><span class=\"line\">        // if no non-public proxy interfaces, use com.sun.proxy package</span><br><span class=\"line\">        // 如果 no non-public（即是 public）的代理接口集合，则使用包名 com.sun.proxy</span><br><span class=\"line\">        proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * Choose a name for the proxy class to generate.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    long num = nextUniqueNumber.getAndIncrement();</span><br><span class=\"line\">    // 组成代理类全类名：包名 + 代理类前缀 + 唯一的自增长数字</span><br><span class=\"line\">    String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * Generate the specified proxy class.</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * 关键6：生成指定的代理类</span><br><span class=\"line\">     */</span><br><span class=\"line\">    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class=\"line\">        proxyName, interfaces, accessFlags);</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        return defineClass0(loader, proxyName,</span><br><span class=\"line\">                            proxyClassFile, 0, proxyClassFile.length);</span><br><span class=\"line\">    &#125; catch (ClassFormatError e) &#123;</span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * A ClassFormatError here means that (barring bugs in the</span><br><span class=\"line\">         * proxy class generation code) there was some other</span><br><span class=\"line\">         * invalid aspect of the arguments supplied to the proxy</span><br><span class=\"line\">         * class creation (such as virtual machine limitations</span><br><span class=\"line\">         * exceeded).</span><br><span class=\"line\">         */</span><br><span class=\"line\">        throw new IllegalArgumentException(e.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成代理类的字节码\"><a href=\"#生成代理类的字节码\" class=\"headerlink\" title=\"生成代理类的字节码\"></a>生成代理类的字节码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最终生成的代理类：</span><br><span class=\"line\">public class Proxy0 extends Proxy implements IDinner &#123;</span><br><span class=\"line\">\t// 第一步：生成构造器</span><br><span class=\"line\">\tprotected Proxy0(InvocationHandler h) &#123;</span><br><span class=\"line\">\t\tsuper(h);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// 第二步：生成静态域</span><br><span class=\"line\">\tprivate static Method m1; // hashCode方法</span><br><span class=\"line\">\tprivate static Method m2; // equals方法</span><br><span class=\"line\">\tprivate static Method m3; // toString方法</span><br><span class=\"line\">\tprivate static Method m4; //...</span><br><span class=\"line\">\t// 第三步：生成代理方法</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic int hashCode() &#123;</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\treturn (int) h.invoke(this, m1, null);</span><br><span class=\"line\">\t\t&#125;catch (Throwable e) &#123;</span><br><span class=\"line\">\t\t\tthrow new UndeclaredThrowableException(e);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic boolean equals(Object obj) &#123;</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tObject[] args = new Object[] &#123;obj&#125;;</span><br><span class=\"line\">\t\t\treturn (boolean) h.invoke(this, m2, args);</span><br><span class=\"line\">\t\t&#125;catch (Throwable e) &#123;</span><br><span class=\"line\">\t\t\tthrow new UndeclaredThrowableException(e);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic String toString() &#123;</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\treturn (String) h.invoke(this, m3, null);</span><br><span class=\"line\">\t\t&#125;catch (Throwable e) &#123;</span><br><span class=\"line\">\t\t\tthrow new UndeclaredThrowableException(e);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void dinner() &#123;</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\t// 构造参数数组，如果有多个参数往后面添加就行了</span><br><span class=\"line\">\t\t\tObject[] args = new Object[] &#123;&#125;;</span><br><span class=\"line\">\t\t\t// h 为通过构造方法传进来的 InvocationHandler，即此处调用 InvocationHandler#invoke(...) 方法</span><br><span class=\"line\">\t\t\th.invoke(this, m4, args);</span><br><span class=\"line\">\t\t&#125;catch (Throwable e) &#123;</span><br><span class=\"line\">\t\t\tthrow new UndeclaredThrowableException(e);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// 第四步：生成静态初始化方法</span><br><span class=\"line\">\tstatic &#123;</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tClass c1 = Class.forName(Object.class.getName());</span><br><span class=\"line\">\t\t\tClass c2 = Class.forName(IDinner.class.getName()); </span><br><span class=\"line\">\t\t\tm1 = c1.getMethod(&quot;hashCode&quot;, null);</span><br><span class=\"line\">\t\t\tm2 = c1.getMethod(&quot;equals&quot;, new Class[]&#123;Object.class&#125;);</span><br><span class=\"line\">\t\t\tm3 = c1.getMethod(&quot;toString&quot;, null);</span><br><span class=\"line\">\t\t\tm4 = c2.getMethod(&quot;dinner&quot;, new Class[]&#123;IDinner.class&#125;);</span><br><span class=\"line\">\t\t\t//...</span><br><span class=\"line\">\t\t&#125;catch (Exception e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"InvocationHandler\"><a href=\"#InvocationHandler\" class=\"headerlink\" title=\"InvocationHandler\"></a>InvocationHandler</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * &#123;@code InvocationHandler&#125; is the interface implemented by</span><br><span class=\"line\"> * the &lt;i&gt;invocation handler&lt;/i&gt; of a proxy instance.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * &lt;p&gt;Each proxy instance has an associated invocation handler.</span><br><span class=\"line\"> * When a method is invoked on a proxy instance, the method</span><br><span class=\"line\"> * invocation is encoded and dispatched to the &#123;@code invoke&#125;</span><br><span class=\"line\"> * method of its invocation handler.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author      Peter Jones</span><br><span class=\"line\"> * @see         Proxy</span><br><span class=\"line\"> * @since       1.3</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n<p>从其类注释上面可以看出来，每一个代理实例都有一个相关的调用handler，当一个代理实例的方法被唤醒的时候，该被代理的方法将会被编码并且分发到invocation handler中</p>\n<p>具体来讲事实上是个回调接口类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">    * Processes a method invocation on a proxy instance and returns</span><br><span class=\"line\">    * the result.  This method will be invoked on an invocation handler</span><br><span class=\"line\">    * when a method is invoked on a proxy instance that it is</span><br><span class=\"line\">    * associated with.</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @param   proxy the proxy instance that the method was invoked on</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @param   method the &#123;@code Method&#125; instance corresponding to</span><br><span class=\"line\">    * the interface method invoked on the proxy instance.  The declaring</span><br><span class=\"line\">    * class of the &#123;@code Method&#125; object will be the interface that</span><br><span class=\"line\">    * the method was declared in, which may be a superinterface of the</span><br><span class=\"line\">    * proxy interface that the proxy class inherits the method through.</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @param   args an array of objects containing the values of the</span><br><span class=\"line\">    * arguments passed in the method invocation on the proxy instance,</span><br><span class=\"line\">    * or &#123;@code null&#125; if interface method takes no arguments.</span><br><span class=\"line\">    * Arguments of primitive types are wrapped in instances of the</span><br><span class=\"line\">    * appropriate primitive wrapper class, such as</span><br><span class=\"line\">    * &#123;@code java.lang.Integer&#125; or &#123;@code java.lang.Boolean&#125;.</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @return  the value to return from the method invocation on the</span><br><span class=\"line\">    * proxy instance.  If the declared return type of the interface</span><br><span class=\"line\">    * method is a primitive type, then the value returned by</span><br><span class=\"line\">    * this method must be an instance of the corresponding primitive</span><br><span class=\"line\">    * wrapper class; otherwise, it must be a type assignable to the</span><br><span class=\"line\">    * declared return type.  If the value returned by this method is</span><br><span class=\"line\">    * &#123;@code null&#125; and the interface method&apos;s return type is</span><br><span class=\"line\">    * primitive, then a &#123;@code NullPointerException&#125; will be</span><br><span class=\"line\">    * thrown by the method invocation on the proxy instance.  If the</span><br><span class=\"line\">    * value returned by this method is otherwise not compatible with</span><br><span class=\"line\">    * the interface method&apos;s declared return type as described above,</span><br><span class=\"line\">    * a &#123;@code ClassCastException&#125; will be thrown by the method</span><br><span class=\"line\">    * invocation on the proxy instance.</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @throws  Throwable the exception to throw from the method</span><br><span class=\"line\">    * invocation on the proxy instance.  The exception&apos;s type must be</span><br><span class=\"line\">    * assignable either to any of the exception types declared in the</span><br><span class=\"line\">    * &#123;@code throws&#125; clause of the interface method or to the</span><br><span class=\"line\">    * unchecked exception types &#123;@code java.lang.RuntimeException&#125;</span><br><span class=\"line\">    * or &#123;@code java.lang.Error&#125;.  If a checked exception is</span><br><span class=\"line\">    * thrown by this method that is not assignable to any of the</span><br><span class=\"line\">    * exception types declared in the &#123;@code throws&#125; clause of</span><br><span class=\"line\">    * the interface method, then an</span><br><span class=\"line\">    * &#123;@link UndeclaredThrowableException&#125; containing the</span><br><span class=\"line\">    * exception that was thrown by this method will be thrown by the</span><br><span class=\"line\">    * method invocation on the proxy instance.</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @see     UndeclaredThrowableException</span><br><span class=\"line\">    */</span><br><span class=\"line\">   public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class=\"line\">       throws Throwable;</span><br></pre></td></tr></table></figure>\n<p>参数的方法表现的就比较容易理解了。</p>\n<p>proxy是指代理类的实例，method是指代理类的方法，每当代理类有方法经过时，这个method就会变成那个方法，args是方法的形式参数，这个地方也会截断。</p>\n<p>返回值有几种情况</p>\n<p>1、声明的返回类型是基础类型，返回值必须是对应的包装类实例</p>\n<p>2、如果声明的返回类型是基础类型，但是返回了一个null的话，会报空指针异常</p>\n<p>3、如果这个方法的返回值和声明的返回值不兼容的话，会报类型转换异常</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>类A写死持有B，就是B的静态代理。如果A代理的对象是不确定的，就是动态代理。动态代理借用反射机制，最终生成的代理类和静态代理生成的相同</p>\n<h1 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h1><h2 id=\"动态代理模式和装饰者模式的区别\"><a href=\"#动态代理模式和装饰者模式的区别\" class=\"headerlink\" title=\"动态代理模式和装饰者模式的区别\"></a>动态代理模式和装饰者模式的区别</h2><ul>\n<li><p>装饰者模式的作用：在不使用继承、不改变原有对象的情况下增加或扩展对象行为，但是并不会禁用某个对象的行为</p>\n</li>\n<li><p>代理模式：控制了这个对象的访问，决定执行或者不执行</p>\n</li>\n</ul>\n<h2 id=\"动态代理模式有缺点吗？\"><a href=\"#动态代理模式有缺点吗？\" class=\"headerlink\" title=\"动态代理模式有缺点吗？\"></a>动态代理模式有缺点吗？</h2><p>由于是反射机制，创建一个动态代理类大约需要13ms，对比与反射一个方法只需要2ms来看，如果消耗过大还是需要考虑一下的</p>\n"},{"title":"网络协议基础","date":"2018-11-16T03:22:09.000Z","_content":"\n# OSI网络分层\n\n网络分层就是OSI七层结构，另外还有个TCPIP五层结构，我从最底层开始总结\n\n## 物理层\n\n职责：建立、维护、断开物理连接\n\n物理层是一个点对点的数据直链，并不一定可靠，物理层是通过拓扑结构进行连接，但始终保障能够连通。\n\n### 物理层传输原理\n\n物理层主要功能是传输比特流。其传输原理是将需要传输的信息按照ASCII编码转化为二进制代码，然后将二进制代码通过数据信号编码器转换为一种电信号，最后信号由发送端的发送设备通过传输介质发送到接受端计算机。传输的信号分为模电和数电，解析方法是调制和解调\n\n### 物理层总结\n\n物理层的传输方式和解析方式大部分是本科阶段通信原理学习的内容，另外传输的协议比如说数电，模电，多路复用，时分复用，波分复用等等。对移动端来讲物理层可控太少，了解其职责和大致原理即可。\n\n## 数据链路层\n\n职责：建立逻辑连接，进行硬件地址寻址，差错校验等功能\n\n数据链路层是一个数据传输通道，位于物理层和网络层之间，是数据传输过程中比较重要的一层。物理层提供的的传输媒介、连接在通讯时只是暂时的，而数据链路的功能就是通过建立通信连接和拆除通信连接这种数据收发方式，而承担数据链路功能的设备就是数据链路层设备\n\n### 数据链路层设备\n\n1. 网卡\n\n作用：网卡是连接计算机与网络的硬件设备，不仅能实现与局域网传输介质之间的物理连接和电信号连接，还涉及了帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能\n\n2. 网桥\n\n作用：实现局域网互联的存储转发设备，网桥从一个局域网接收mac帧、拆封、校对、校验之后，按照另一个局域网的格式重新组装，发往它的物理层\n\n3. 交换机\n\n是一种用于电信号转发的网络设备，可以把传输的信息送到符合要求的设备上面\n\n### 数据链路层基础知识\n\n1. mac地址\n\nmac地址用来表示互联网上面每一个站点的标识符，采用十六进制，共6个字节\n输入ipconfig/all 中的物理地址及是mac地址\n\n2. 数据帧\n\n数据帧是数据链路层的协议数据单元，它包括三部分：帧头，数据部分，帧尾。帧头帧尾是控制信息，数据部分包含了需要传输的数据\n\n3. 载波监听多路访问技术 CSMA/CD\n\n发送数据前监听信道是否空闲，若空闲就立即发送信道，否则就等待一段时间直至信道中的信息传输结束后再发送数据，若在上一段信息发送结束后，同时又两个或两个以上节点都提出发送请求，则判定为冲突，冲突会立即停止发送数据，等待一段时间之后再重新尝试\n\n## 网络层\n\n职责：进行逻辑地址寻址，实现不同网络之间的路径选择\n\n网络层将多个通络通过路由器互连成一个互连网络，让网络中的多台计算机可以互相通信。网络层最重要的是ip协议，在网络层需要实现数据报文的分片与组装、同时需要提供路由选择。\n\n和网络层搭配使用的是ARP(地址解析协议)，ICMP(互联网控制报文协议)，IGMP(网际管理协议)\n\n### ARP (address resolution protocol)\n\n在实际过程中，知道一个主机或者路由器的ip地址，并不知道对应的mac地址，因此可以通过arp协议，用目的ip地址得到mac地址。\n\n原理：在每台安装tcpip协议的电脑路由器里都有一个arp缓存表，表里的ip地址与mac地址是一一对应的。当发送数据时，主机a会在自己的arp缓存表中寻找是否有目标ip地址，如果找到就知道目标对应的mac地址，直接将mac地址写入帧里面发送即可。如果没有找到，就会在网络上发送一个广播(ARP REQUEST)，这个request的目标mac地址是\"FF.FF.FF.FF.FF.FF\"，携带的信息是查询目标ip地址。网络上面不是这个ip地址的主机不会响应这个arp查询，只有ip地址为这个的目标主机才会响应，并且发送一个ARP RESPONSE, 携带的信息是目标ip的mac地址，这样就回复回来的时候就知道目标的mac地址了，并且会更新arp缓存表（arp缓存表使用的是老化机制，一段时间不使用就会删除，因此长度并不会特别长）\n\n### ICMP (internet control message protocol)\n\n通信环境中可能存在各种问题，这些问题的反馈需要让开发者知道并且应对，因此就有了ICMP协议，该协议与传输协议不同，他一般并不用于两点间传输数据，而常常用于返回错误的信息或分析路由。\n\nICMP主要功能：1、确认ip包是否成功到达目标地址 2、通知在发送过程中ip包被丢弃的原因 3、ICMP是基于ip协议制作的，但是并不是传输层的功能，因此仍然是网络层协议 4、ICMP只能用于IPV4, 能用于IPV6的icmp叫做ICMPV6\n\n常用的ICMP技术，像是 ping， traceroute命令\n\n### IGMP (internet group management protocol)\n\n跨越多个网络的组播转发必须要依赖于路由器，路由器为建立转发路由必须要了解每个组员在internet中的分布，这要求主机将自己所在的组播组通知给本地路由器，这也是建立组播转发路由的基础。主机与本地路由器之间使用igmp来进行组播组成员信息的交互。\n\nIGMP提供了再转发组播数据包到达目的地的最后阶段所需要的信息，实现双向的功能：\n1.主机通过igmp通知路由器希望接受或离开某个特定组播组的信息\n2.路由器通过IGMP周期性的查询局域网内的组播组成员是否处于活动状态，实现所连网段组成员关系的手机与维护。\n\n## 传输层\n\n职责：在网络的各个节点之间可靠的分发数据包，实现应用进程间的端到端通信，同时向应用层提供通信服务\n\n原理：通过多路复用和解复用技术，发送方的不同的应用进程都可以使用同一个传输层协议传送数据，接收方的传输层剥去报文首部之后能把这些数据正确的传输的正确的应用进程之间。\n\n传输层就是知名协议UDP和TCP的所在。\n\n### UDP(user datagram protocol) 用户数据协议\n\nUDP特性：一个数据包就能完成任务，不需要分段，不需要建立会话，不需要流量控制，是种不可靠的传输方式。\n\n#### UDP的优点\n1. 开销更小\n\n对比于tcp， udp的首部只有8个字节，而tcp有20个字节和40个字节的可选项\n\n2. 速度更快\n\nUDP发送数据之前没有TCP的连接建立过程，而TCP则提供了过多的保护，在及时性上面做了很多的妥协\n\n#### UDP的主要问题\n\n1. 丢失和乱序\n\n因为UDP不提供ACK、序列号等机制，所以是没有办法知道是否有报文丢失以及接收方到达等报文书序是否和发送方的报文数据一样\n\n2. 差错\n\n对于差错问题可以通过校验和等检测到，但是不提供差错纠正\n\n3. 数据完整性\n\nUDP协议头部虽然有16位的校验和，但是IPV4不强制执行，所以说UDP无法保证数据的完整性\n\n#### UDP如何解决传输的问题\n\n1、 数据完整性\n\n加上一个16或者32位的CRC验证字段\n\n2、 乱序\n\n加上一个数据包序列号SEQ\n\n3、 丢包\n\n加上和TCP类似的ACK机制，进行确认和重传\n\n因此推荐使用RUDP（reliable udp）\n\n### TCP(transmission control protocol) 传输控制协议\n\n#### TCP头部图\n\n![tcp头部图](/images/网络协议/TCP头部图.png)\n\ntcp头部添加了20个字节，总计160位来进行数据的控制\n\n其中选项还可以在多添加40个字节\n\n因此头部的必要信息比较多，也是确保数据可靠的基础\n\n#### TCP连接管理机制\n\n连接tcp需要三次握手，断开tcp需要四次挥手\n\n##### 三次握手\n\n第一次：\n\n客户端发送给服务器，通知服务器需要建立连接\n\n第二次：\n\n服务器发送给客户端，通知客户端服务器收到连接请求\n\n第三次：\n\n客户端发送给服务器，通知服务器客户端收到了服务器的回应\n\n详细解释：\n\n1, TCP服务器进程先创建传输控制块TCB, 时刻准备接受客户端进程的连接请求, 此时服务器就进入了 LISTEN（监听）状态 \n2, TCP客户端进程也是先创建传输控制块TCB, 然后向服务器发出连接请求报文，此时报文首部中的同步标志位SYN=1, 同时选择一个初始序列号 seq = x, 此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定, SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。 \n3, TCP服务器收到请求报文后, 如果同意连接, 则发出确认报文。确认报文中的 ACK=1, SYN=1, 确认序号是 x+1, 同时也要为自己初始化一个序列号 seq = y, 此时, TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据, 但是同样要消耗一个序号。 \n4, TCP客户端进程收到确认后还, 要向服务器给出确认。确认报文的ACK=1，确认序号是 y+1，自己的序列号是 x+1. \n5, 此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。\n\n- 为什么不用两次握手？\n\n主要是为了防止已经失效的连接请求报文突然又传回服务器，如果是已经失效的，第三次就无法成立，因此第三次是为了确保网络停滞时间不会导致连接失效\n\n- 为什么不用四次？\n\n四次的话其实就是服务器在通知一次客户端，其实没有必要了，多余了\n\n##### 四次挥手\n\n第一次：客户端通知服务器端，要释放连接了，并且客户端进入终止等待1状态\n\n第二次：服务器收到客户端的释放连接的请求，通知客户端自己已经收到释放连接的请求\n\n第三次：客户端收到服务器的确认释放连接请求，客户端进入终止等待2状态，而服务器将最后的数据发送完毕后，就向客户端发送连接释放报文\n\n第四次：客户端收到连接释放报文，向服务端发出确认释放，之后就进入了时间等待状态，等到2个最长报文段寿命时间结束后，客户端就撤销相应的TCB，并且进入close状态，而服务端在接收到了这个确认信息后，不需要等待，而直接进入close状态。因此服务端结束的时间比客户端早一些\n\n- 为什么客户端在第四次挥手的时候需要等待两个最长报文寿命时间呢？\n\n第一：保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，丢失的话服务端就无法知道收到回应，因此如果最后一个ACK报文丢失的话，服务端会再次发送，在两个最长报文寿命时间内，客户端有可能收到第二次请求确认的报文\n\n第二：防止已经失效的请求报文，客户端等待的两个最长报文寿命的时间中，可以确保本次tcp连接产生的所有报文段都从网络中消失，这样新的连接就不会出现旧连接的请求报文\n\n- 为什么建立连接需要三次，而释放连接需要四次？\n\n因为释放的时候不确定是否有数据没有发送完毕，因此需要确保数据全部发送完毕，这样多了一次，而如果释放的时候没有数据的话，其实可以看做三次，即第二次和第三次合并\n\n\n#### 窗口滑动\n\nTCP的滑动窗口以字节为单位，用三个指针进行表示，当窗口内连续报文段被确认收到后，可以将窗口向前滑动，窗口大小应等于缓存区大小\n\n#### 窗口滑动协议\n\n只有在接受窗口向前滑动时（与此同时也发送了确认），发送窗口才可能向前滑动，收发两端的窗口按照以上规律不断的向前滑动\n\n```\n当发送窗口和接受窗口的大小都等于1时，就是停止等待协议。\n当发送窗口大于1，而接收窗口小于1时，就是回退N步协议。\n当发送窗口和接受窗口的大小均大于1时，就是选择重发协议。\n```\n\n重发是对回退的补充，由于回退会导致从漏掉的帧到已接受的所有帧全部丢弃，浪费了带宽，而重发则是直接对漏掉的帧进行补充\n\n\n### 传输层其他协议\n\n传输层还有SPX, NetBIOS,NetBEUI等协议\n\n## 会话层\n\n职责：主机间通讯，管理应用程序之间的会话。建立在传输层之上，利用传输层提供的服务，使应用建立和维持会话，并能使会话得到同步。会话层使用校验点可使通信会话在通信失效时从校验点继续恢复通信。\n\n### 主要功能\n\n1、为会话实体间建立连接\n\n2、进行数据传输\n\n3、连接释放\n\n### 具体理解\n\n会话层主要是通过调用传输层来建立会话\n\n## 表示层\n\n职责：表示层向上对应用层服务，向下接受来自会话层的服务，表示层为在引用过程之间传送的信息提供表示方法的服务，只关心信息发出的语法和语义。\n\n### 主要功能\n\n表示层早期是用来转换字符数据的编码，提供格式化的表示和转换数据服务，数据的压缩和解压缩，加密和解密等工作，但是现在应用层可以做表示层可以做的事情，所以一般根据TCPIP五层协议，表示层会话层和应用层都可以合为应用层\n\n## 应用层\n\n职责：应用层直接和应用程序接口并且提供常见的网络应用服务，应用层也会向表示层发出请求，应用层是开放系统的最高层，是直接为应用进程提供服务的。\n\n应用层协议较多，有FTP、SMTP、HTTP等\n\n着重学习一下HTTPS\n\n### https\n\nhttps协议主要针对解决http协议以下不足：\n1.通信使用明文（不加密），内容可能会被窃听\n2.不验证通信方身份，应此可能遭遇伪装\n3.无法证明报文的完整性（即准确性），所以可能已遭篡改\nhttp+加密+认证+完整性保护=https\n\n#### https 和http主要的区别\n\n1. https需要ca证书\n2. https是具有安全性的ssl加密传输协议，http是明文传输\n3. http和https使用完全不同的连接方式，用的端口也不一样，http是80端口，https是443端口\n4. http是无状态的，而https是有ssl+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全\n\n#### 握手过程\n\n1. 客户端向服务器传送客户端ssl协议的版本号，加密算法的种类，产生的随机数、以及其他服务器和客户端之间通讯需要的各种信息\n2. 服务器向客户端传送ssl协议的版本号、加密算法的种类、随机数以及其他相关信息，同时服务器还向客户端传送自己的证书\n3. 客户端利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，ca证书是否可靠，证书的公钥能否解开服务器证书的发行者数字签名，证书上面的域名是否和服务器的实际域名相匹配。如果不合法，通讯将断开，否则将继续进行下面的步骤\n4. 客户端随机产生一个用于后面通讯的“对称密码”，然后服务器的公钥对其加密，然后将加密后的“预主密码“传给服务器\n5. 如果服务器要求客户的身份认证，用户可以建立一个随机数然后对其数据签名，然后将这个含有签名的随机数和客户自己的证书以及加密过的”预主密码“一起传给服务器\n6. 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性检验过程包括：客户的证书使用日期是否有效，提供的ca是否可靠，ca的公钥能否正确解开客户端证书的发行ca签名，检查客户的证书是否在证书废止列表中。如果不合法，通讯立即终端，否则服务器将用自己的私钥解药加密的预主密码，然后执行一系列步骤产生主通讯密码。客户端也同样的步骤产生主通讯密码\n7. 服务器和客户端用相同的主密码。一个对称秘钥用于ssl协议的安全数据通讯的加解密通讯，同时在ssl通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化\n8. 客户端向服务器发出信息，指明后续通讯将使用主密码为堆成密码，同时通知服务器本次握手过程结束\n9. 服务器向客户端发出信息，指明后续通讯将使用主密码为对称密码，同时通知客户端本次握手过程结束\n10. ssl的握手部分结束，安全通道的通讯开始，客户端和服务端开始使用相同的对称秘钥进行数据通讯，同时检查通讯完整性\n\n概括，https在客户端生成秘钥并传递给服务端的时候，采取的是非对称加密，而秘钥在服务端手里的时候，之后采取的就是对称加密。单向验证是指客户端对服务端进行身份验证，验证是否可靠，而双向验证则是服务端也同时验证客户端，双向验证常见于企业应用\n\n\n\n\n\n\n","source":"_posts/网络协议基础.md","raw":"---\ntitle: 网络协议基础\ndate: 2018-11-16 11:22:09\ntags: 网络协议\n---\n\n# OSI网络分层\n\n网络分层就是OSI七层结构，另外还有个TCPIP五层结构，我从最底层开始总结\n\n## 物理层\n\n职责：建立、维护、断开物理连接\n\n物理层是一个点对点的数据直链，并不一定可靠，物理层是通过拓扑结构进行连接，但始终保障能够连通。\n\n### 物理层传输原理\n\n物理层主要功能是传输比特流。其传输原理是将需要传输的信息按照ASCII编码转化为二进制代码，然后将二进制代码通过数据信号编码器转换为一种电信号，最后信号由发送端的发送设备通过传输介质发送到接受端计算机。传输的信号分为模电和数电，解析方法是调制和解调\n\n### 物理层总结\n\n物理层的传输方式和解析方式大部分是本科阶段通信原理学习的内容，另外传输的协议比如说数电，模电，多路复用，时分复用，波分复用等等。对移动端来讲物理层可控太少，了解其职责和大致原理即可。\n\n## 数据链路层\n\n职责：建立逻辑连接，进行硬件地址寻址，差错校验等功能\n\n数据链路层是一个数据传输通道，位于物理层和网络层之间，是数据传输过程中比较重要的一层。物理层提供的的传输媒介、连接在通讯时只是暂时的，而数据链路的功能就是通过建立通信连接和拆除通信连接这种数据收发方式，而承担数据链路功能的设备就是数据链路层设备\n\n### 数据链路层设备\n\n1. 网卡\n\n作用：网卡是连接计算机与网络的硬件设备，不仅能实现与局域网传输介质之间的物理连接和电信号连接，还涉及了帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能\n\n2. 网桥\n\n作用：实现局域网互联的存储转发设备，网桥从一个局域网接收mac帧、拆封、校对、校验之后，按照另一个局域网的格式重新组装，发往它的物理层\n\n3. 交换机\n\n是一种用于电信号转发的网络设备，可以把传输的信息送到符合要求的设备上面\n\n### 数据链路层基础知识\n\n1. mac地址\n\nmac地址用来表示互联网上面每一个站点的标识符，采用十六进制，共6个字节\n输入ipconfig/all 中的物理地址及是mac地址\n\n2. 数据帧\n\n数据帧是数据链路层的协议数据单元，它包括三部分：帧头，数据部分，帧尾。帧头帧尾是控制信息，数据部分包含了需要传输的数据\n\n3. 载波监听多路访问技术 CSMA/CD\n\n发送数据前监听信道是否空闲，若空闲就立即发送信道，否则就等待一段时间直至信道中的信息传输结束后再发送数据，若在上一段信息发送结束后，同时又两个或两个以上节点都提出发送请求，则判定为冲突，冲突会立即停止发送数据，等待一段时间之后再重新尝试\n\n## 网络层\n\n职责：进行逻辑地址寻址，实现不同网络之间的路径选择\n\n网络层将多个通络通过路由器互连成一个互连网络，让网络中的多台计算机可以互相通信。网络层最重要的是ip协议，在网络层需要实现数据报文的分片与组装、同时需要提供路由选择。\n\n和网络层搭配使用的是ARP(地址解析协议)，ICMP(互联网控制报文协议)，IGMP(网际管理协议)\n\n### ARP (address resolution protocol)\n\n在实际过程中，知道一个主机或者路由器的ip地址，并不知道对应的mac地址，因此可以通过arp协议，用目的ip地址得到mac地址。\n\n原理：在每台安装tcpip协议的电脑路由器里都有一个arp缓存表，表里的ip地址与mac地址是一一对应的。当发送数据时，主机a会在自己的arp缓存表中寻找是否有目标ip地址，如果找到就知道目标对应的mac地址，直接将mac地址写入帧里面发送即可。如果没有找到，就会在网络上发送一个广播(ARP REQUEST)，这个request的目标mac地址是\"FF.FF.FF.FF.FF.FF\"，携带的信息是查询目标ip地址。网络上面不是这个ip地址的主机不会响应这个arp查询，只有ip地址为这个的目标主机才会响应，并且发送一个ARP RESPONSE, 携带的信息是目标ip的mac地址，这样就回复回来的时候就知道目标的mac地址了，并且会更新arp缓存表（arp缓存表使用的是老化机制，一段时间不使用就会删除，因此长度并不会特别长）\n\n### ICMP (internet control message protocol)\n\n通信环境中可能存在各种问题，这些问题的反馈需要让开发者知道并且应对，因此就有了ICMP协议，该协议与传输协议不同，他一般并不用于两点间传输数据，而常常用于返回错误的信息或分析路由。\n\nICMP主要功能：1、确认ip包是否成功到达目标地址 2、通知在发送过程中ip包被丢弃的原因 3、ICMP是基于ip协议制作的，但是并不是传输层的功能，因此仍然是网络层协议 4、ICMP只能用于IPV4, 能用于IPV6的icmp叫做ICMPV6\n\n常用的ICMP技术，像是 ping， traceroute命令\n\n### IGMP (internet group management protocol)\n\n跨越多个网络的组播转发必须要依赖于路由器，路由器为建立转发路由必须要了解每个组员在internet中的分布，这要求主机将自己所在的组播组通知给本地路由器，这也是建立组播转发路由的基础。主机与本地路由器之间使用igmp来进行组播组成员信息的交互。\n\nIGMP提供了再转发组播数据包到达目的地的最后阶段所需要的信息，实现双向的功能：\n1.主机通过igmp通知路由器希望接受或离开某个特定组播组的信息\n2.路由器通过IGMP周期性的查询局域网内的组播组成员是否处于活动状态，实现所连网段组成员关系的手机与维护。\n\n## 传输层\n\n职责：在网络的各个节点之间可靠的分发数据包，实现应用进程间的端到端通信，同时向应用层提供通信服务\n\n原理：通过多路复用和解复用技术，发送方的不同的应用进程都可以使用同一个传输层协议传送数据，接收方的传输层剥去报文首部之后能把这些数据正确的传输的正确的应用进程之间。\n\n传输层就是知名协议UDP和TCP的所在。\n\n### UDP(user datagram protocol) 用户数据协议\n\nUDP特性：一个数据包就能完成任务，不需要分段，不需要建立会话，不需要流量控制，是种不可靠的传输方式。\n\n#### UDP的优点\n1. 开销更小\n\n对比于tcp， udp的首部只有8个字节，而tcp有20个字节和40个字节的可选项\n\n2. 速度更快\n\nUDP发送数据之前没有TCP的连接建立过程，而TCP则提供了过多的保护，在及时性上面做了很多的妥协\n\n#### UDP的主要问题\n\n1. 丢失和乱序\n\n因为UDP不提供ACK、序列号等机制，所以是没有办法知道是否有报文丢失以及接收方到达等报文书序是否和发送方的报文数据一样\n\n2. 差错\n\n对于差错问题可以通过校验和等检测到，但是不提供差错纠正\n\n3. 数据完整性\n\nUDP协议头部虽然有16位的校验和，但是IPV4不强制执行，所以说UDP无法保证数据的完整性\n\n#### UDP如何解决传输的问题\n\n1、 数据完整性\n\n加上一个16或者32位的CRC验证字段\n\n2、 乱序\n\n加上一个数据包序列号SEQ\n\n3、 丢包\n\n加上和TCP类似的ACK机制，进行确认和重传\n\n因此推荐使用RUDP（reliable udp）\n\n### TCP(transmission control protocol) 传输控制协议\n\n#### TCP头部图\n\n![tcp头部图](/images/网络协议/TCP头部图.png)\n\ntcp头部添加了20个字节，总计160位来进行数据的控制\n\n其中选项还可以在多添加40个字节\n\n因此头部的必要信息比较多，也是确保数据可靠的基础\n\n#### TCP连接管理机制\n\n连接tcp需要三次握手，断开tcp需要四次挥手\n\n##### 三次握手\n\n第一次：\n\n客户端发送给服务器，通知服务器需要建立连接\n\n第二次：\n\n服务器发送给客户端，通知客户端服务器收到连接请求\n\n第三次：\n\n客户端发送给服务器，通知服务器客户端收到了服务器的回应\n\n详细解释：\n\n1, TCP服务器进程先创建传输控制块TCB, 时刻准备接受客户端进程的连接请求, 此时服务器就进入了 LISTEN（监听）状态 \n2, TCP客户端进程也是先创建传输控制块TCB, 然后向服务器发出连接请求报文，此时报文首部中的同步标志位SYN=1, 同时选择一个初始序列号 seq = x, 此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定, SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。 \n3, TCP服务器收到请求报文后, 如果同意连接, 则发出确认报文。确认报文中的 ACK=1, SYN=1, 确认序号是 x+1, 同时也要为自己初始化一个序列号 seq = y, 此时, TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据, 但是同样要消耗一个序号。 \n4, TCP客户端进程收到确认后还, 要向服务器给出确认。确认报文的ACK=1，确认序号是 y+1，自己的序列号是 x+1. \n5, 此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。\n\n- 为什么不用两次握手？\n\n主要是为了防止已经失效的连接请求报文突然又传回服务器，如果是已经失效的，第三次就无法成立，因此第三次是为了确保网络停滞时间不会导致连接失效\n\n- 为什么不用四次？\n\n四次的话其实就是服务器在通知一次客户端，其实没有必要了，多余了\n\n##### 四次挥手\n\n第一次：客户端通知服务器端，要释放连接了，并且客户端进入终止等待1状态\n\n第二次：服务器收到客户端的释放连接的请求，通知客户端自己已经收到释放连接的请求\n\n第三次：客户端收到服务器的确认释放连接请求，客户端进入终止等待2状态，而服务器将最后的数据发送完毕后，就向客户端发送连接释放报文\n\n第四次：客户端收到连接释放报文，向服务端发出确认释放，之后就进入了时间等待状态，等到2个最长报文段寿命时间结束后，客户端就撤销相应的TCB，并且进入close状态，而服务端在接收到了这个确认信息后，不需要等待，而直接进入close状态。因此服务端结束的时间比客户端早一些\n\n- 为什么客户端在第四次挥手的时候需要等待两个最长报文寿命时间呢？\n\n第一：保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，丢失的话服务端就无法知道收到回应，因此如果最后一个ACK报文丢失的话，服务端会再次发送，在两个最长报文寿命时间内，客户端有可能收到第二次请求确认的报文\n\n第二：防止已经失效的请求报文，客户端等待的两个最长报文寿命的时间中，可以确保本次tcp连接产生的所有报文段都从网络中消失，这样新的连接就不会出现旧连接的请求报文\n\n- 为什么建立连接需要三次，而释放连接需要四次？\n\n因为释放的时候不确定是否有数据没有发送完毕，因此需要确保数据全部发送完毕，这样多了一次，而如果释放的时候没有数据的话，其实可以看做三次，即第二次和第三次合并\n\n\n#### 窗口滑动\n\nTCP的滑动窗口以字节为单位，用三个指针进行表示，当窗口内连续报文段被确认收到后，可以将窗口向前滑动，窗口大小应等于缓存区大小\n\n#### 窗口滑动协议\n\n只有在接受窗口向前滑动时（与此同时也发送了确认），发送窗口才可能向前滑动，收发两端的窗口按照以上规律不断的向前滑动\n\n```\n当发送窗口和接受窗口的大小都等于1时，就是停止等待协议。\n当发送窗口大于1，而接收窗口小于1时，就是回退N步协议。\n当发送窗口和接受窗口的大小均大于1时，就是选择重发协议。\n```\n\n重发是对回退的补充，由于回退会导致从漏掉的帧到已接受的所有帧全部丢弃，浪费了带宽，而重发则是直接对漏掉的帧进行补充\n\n\n### 传输层其他协议\n\n传输层还有SPX, NetBIOS,NetBEUI等协议\n\n## 会话层\n\n职责：主机间通讯，管理应用程序之间的会话。建立在传输层之上，利用传输层提供的服务，使应用建立和维持会话，并能使会话得到同步。会话层使用校验点可使通信会话在通信失效时从校验点继续恢复通信。\n\n### 主要功能\n\n1、为会话实体间建立连接\n\n2、进行数据传输\n\n3、连接释放\n\n### 具体理解\n\n会话层主要是通过调用传输层来建立会话\n\n## 表示层\n\n职责：表示层向上对应用层服务，向下接受来自会话层的服务，表示层为在引用过程之间传送的信息提供表示方法的服务，只关心信息发出的语法和语义。\n\n### 主要功能\n\n表示层早期是用来转换字符数据的编码，提供格式化的表示和转换数据服务，数据的压缩和解压缩，加密和解密等工作，但是现在应用层可以做表示层可以做的事情，所以一般根据TCPIP五层协议，表示层会话层和应用层都可以合为应用层\n\n## 应用层\n\n职责：应用层直接和应用程序接口并且提供常见的网络应用服务，应用层也会向表示层发出请求，应用层是开放系统的最高层，是直接为应用进程提供服务的。\n\n应用层协议较多，有FTP、SMTP、HTTP等\n\n着重学习一下HTTPS\n\n### https\n\nhttps协议主要针对解决http协议以下不足：\n1.通信使用明文（不加密），内容可能会被窃听\n2.不验证通信方身份，应此可能遭遇伪装\n3.无法证明报文的完整性（即准确性），所以可能已遭篡改\nhttp+加密+认证+完整性保护=https\n\n#### https 和http主要的区别\n\n1. https需要ca证书\n2. https是具有安全性的ssl加密传输协议，http是明文传输\n3. http和https使用完全不同的连接方式，用的端口也不一样，http是80端口，https是443端口\n4. http是无状态的，而https是有ssl+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全\n\n#### 握手过程\n\n1. 客户端向服务器传送客户端ssl协议的版本号，加密算法的种类，产生的随机数、以及其他服务器和客户端之间通讯需要的各种信息\n2. 服务器向客户端传送ssl协议的版本号、加密算法的种类、随机数以及其他相关信息，同时服务器还向客户端传送自己的证书\n3. 客户端利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，ca证书是否可靠，证书的公钥能否解开服务器证书的发行者数字签名，证书上面的域名是否和服务器的实际域名相匹配。如果不合法，通讯将断开，否则将继续进行下面的步骤\n4. 客户端随机产生一个用于后面通讯的“对称密码”，然后服务器的公钥对其加密，然后将加密后的“预主密码“传给服务器\n5. 如果服务器要求客户的身份认证，用户可以建立一个随机数然后对其数据签名，然后将这个含有签名的随机数和客户自己的证书以及加密过的”预主密码“一起传给服务器\n6. 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性检验过程包括：客户的证书使用日期是否有效，提供的ca是否可靠，ca的公钥能否正确解开客户端证书的发行ca签名，检查客户的证书是否在证书废止列表中。如果不合法，通讯立即终端，否则服务器将用自己的私钥解药加密的预主密码，然后执行一系列步骤产生主通讯密码。客户端也同样的步骤产生主通讯密码\n7. 服务器和客户端用相同的主密码。一个对称秘钥用于ssl协议的安全数据通讯的加解密通讯，同时在ssl通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化\n8. 客户端向服务器发出信息，指明后续通讯将使用主密码为堆成密码，同时通知服务器本次握手过程结束\n9. 服务器向客户端发出信息，指明后续通讯将使用主密码为对称密码，同时通知客户端本次握手过程结束\n10. ssl的握手部分结束，安全通道的通讯开始，客户端和服务端开始使用相同的对称秘钥进行数据通讯，同时检查通讯完整性\n\n概括，https在客户端生成秘钥并传递给服务端的时候，采取的是非对称加密，而秘钥在服务端手里的时候，之后采取的就是对称加密。单向验证是指客户端对服务端进行身份验证，验证是否可靠，而双向验证则是服务端也同时验证客户端，双向验证常见于企业应用\n\n\n\n\n\n\n","slug":"网络协议基础","published":1,"updated":"2019-03-12T09:26:33.169Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltu0f007c3a8kw9nage12","content":"<h1 id=\"OSI网络分层\"><a href=\"#OSI网络分层\" class=\"headerlink\" title=\"OSI网络分层\"></a>OSI网络分层</h1><p>网络分层就是OSI七层结构，另外还有个TCPIP五层结构，我从最底层开始总结</p>\n<h2 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h2><p>职责：建立、维护、断开物理连接</p>\n<p>物理层是一个点对点的数据直链，并不一定可靠，物理层是通过拓扑结构进行连接，但始终保障能够连通。</p>\n<h3 id=\"物理层传输原理\"><a href=\"#物理层传输原理\" class=\"headerlink\" title=\"物理层传输原理\"></a>物理层传输原理</h3><p>物理层主要功能是传输比特流。其传输原理是将需要传输的信息按照ASCII编码转化为二进制代码，然后将二进制代码通过数据信号编码器转换为一种电信号，最后信号由发送端的发送设备通过传输介质发送到接受端计算机。传输的信号分为模电和数电，解析方法是调制和解调</p>\n<h3 id=\"物理层总结\"><a href=\"#物理层总结\" class=\"headerlink\" title=\"物理层总结\"></a>物理层总结</h3><p>物理层的传输方式和解析方式大部分是本科阶段通信原理学习的内容，另外传输的协议比如说数电，模电，多路复用，时分复用，波分复用等等。对移动端来讲物理层可控太少，了解其职责和大致原理即可。</p>\n<h2 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h2><p>职责：建立逻辑连接，进行硬件地址寻址，差错校验等功能</p>\n<p>数据链路层是一个数据传输通道，位于物理层和网络层之间，是数据传输过程中比较重要的一层。物理层提供的的传输媒介、连接在通讯时只是暂时的，而数据链路的功能就是通过建立通信连接和拆除通信连接这种数据收发方式，而承担数据链路功能的设备就是数据链路层设备</p>\n<h3 id=\"数据链路层设备\"><a href=\"#数据链路层设备\" class=\"headerlink\" title=\"数据链路层设备\"></a>数据链路层设备</h3><ol>\n<li>网卡</li>\n</ol>\n<p>作用：网卡是连接计算机与网络的硬件设备，不仅能实现与局域网传输介质之间的物理连接和电信号连接，还涉及了帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能</p>\n<ol start=\"2\">\n<li>网桥</li>\n</ol>\n<p>作用：实现局域网互联的存储转发设备，网桥从一个局域网接收mac帧、拆封、校对、校验之后，按照另一个局域网的格式重新组装，发往它的物理层</p>\n<ol start=\"3\">\n<li>交换机</li>\n</ol>\n<p>是一种用于电信号转发的网络设备，可以把传输的信息送到符合要求的设备上面</p>\n<h3 id=\"数据链路层基础知识\"><a href=\"#数据链路层基础知识\" class=\"headerlink\" title=\"数据链路层基础知识\"></a>数据链路层基础知识</h3><ol>\n<li>mac地址</li>\n</ol>\n<p>mac地址用来表示互联网上面每一个站点的标识符，采用十六进制，共6个字节<br>输入ipconfig/all 中的物理地址及是mac地址</p>\n<ol start=\"2\">\n<li>数据帧</li>\n</ol>\n<p>数据帧是数据链路层的协议数据单元，它包括三部分：帧头，数据部分，帧尾。帧头帧尾是控制信息，数据部分包含了需要传输的数据</p>\n<ol start=\"3\">\n<li>载波监听多路访问技术 CSMA/CD</li>\n</ol>\n<p>发送数据前监听信道是否空闲，若空闲就立即发送信道，否则就等待一段时间直至信道中的信息传输结束后再发送数据，若在上一段信息发送结束后，同时又两个或两个以上节点都提出发送请求，则判定为冲突，冲突会立即停止发送数据，等待一段时间之后再重新尝试</p>\n<h2 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h2><p>职责：进行逻辑地址寻址，实现不同网络之间的路径选择</p>\n<p>网络层将多个通络通过路由器互连成一个互连网络，让网络中的多台计算机可以互相通信。网络层最重要的是ip协议，在网络层需要实现数据报文的分片与组装、同时需要提供路由选择。</p>\n<p>和网络层搭配使用的是ARP(地址解析协议)，ICMP(互联网控制报文协议)，IGMP(网际管理协议)</p>\n<h3 id=\"ARP-address-resolution-protocol\"><a href=\"#ARP-address-resolution-protocol\" class=\"headerlink\" title=\"ARP (address resolution protocol)\"></a>ARP (address resolution protocol)</h3><p>在实际过程中，知道一个主机或者路由器的ip地址，并不知道对应的mac地址，因此可以通过arp协议，用目的ip地址得到mac地址。</p>\n<p>原理：在每台安装tcpip协议的电脑路由器里都有一个arp缓存表，表里的ip地址与mac地址是一一对应的。当发送数据时，主机a会在自己的arp缓存表中寻找是否有目标ip地址，如果找到就知道目标对应的mac地址，直接将mac地址写入帧里面发送即可。如果没有找到，就会在网络上发送一个广播(ARP REQUEST)，这个request的目标mac地址是”FF.FF.FF.FF.FF.FF”，携带的信息是查询目标ip地址。网络上面不是这个ip地址的主机不会响应这个arp查询，只有ip地址为这个的目标主机才会响应，并且发送一个ARP RESPONSE, 携带的信息是目标ip的mac地址，这样就回复回来的时候就知道目标的mac地址了，并且会更新arp缓存表（arp缓存表使用的是老化机制，一段时间不使用就会删除，因此长度并不会特别长）</p>\n<h3 id=\"ICMP-internet-control-message-protocol\"><a href=\"#ICMP-internet-control-message-protocol\" class=\"headerlink\" title=\"ICMP (internet control message protocol)\"></a>ICMP (internet control message protocol)</h3><p>通信环境中可能存在各种问题，这些问题的反馈需要让开发者知道并且应对，因此就有了ICMP协议，该协议与传输协议不同，他一般并不用于两点间传输数据，而常常用于返回错误的信息或分析路由。</p>\n<p>ICMP主要功能：1、确认ip包是否成功到达目标地址 2、通知在发送过程中ip包被丢弃的原因 3、ICMP是基于ip协议制作的，但是并不是传输层的功能，因此仍然是网络层协议 4、ICMP只能用于IPV4, 能用于IPV6的icmp叫做ICMPV6</p>\n<p>常用的ICMP技术，像是 ping， traceroute命令</p>\n<h3 id=\"IGMP-internet-group-management-protocol\"><a href=\"#IGMP-internet-group-management-protocol\" class=\"headerlink\" title=\"IGMP (internet group management protocol)\"></a>IGMP (internet group management protocol)</h3><p>跨越多个网络的组播转发必须要依赖于路由器，路由器为建立转发路由必须要了解每个组员在internet中的分布，这要求主机将自己所在的组播组通知给本地路由器，这也是建立组播转发路由的基础。主机与本地路由器之间使用igmp来进行组播组成员信息的交互。</p>\n<p>IGMP提供了再转发组播数据包到达目的地的最后阶段所需要的信息，实现双向的功能：<br>1.主机通过igmp通知路由器希望接受或离开某个特定组播组的信息<br>2.路由器通过IGMP周期性的查询局域网内的组播组成员是否处于活动状态，实现所连网段组成员关系的手机与维护。</p>\n<h2 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h2><p>职责：在网络的各个节点之间可靠的分发数据包，实现应用进程间的端到端通信，同时向应用层提供通信服务</p>\n<p>原理：通过多路复用和解复用技术，发送方的不同的应用进程都可以使用同一个传输层协议传送数据，接收方的传输层剥去报文首部之后能把这些数据正确的传输的正确的应用进程之间。</p>\n<p>传输层就是知名协议UDP和TCP的所在。</p>\n<h3 id=\"UDP-user-datagram-protocol-用户数据协议\"><a href=\"#UDP-user-datagram-protocol-用户数据协议\" class=\"headerlink\" title=\"UDP(user datagram protocol) 用户数据协议\"></a>UDP(user datagram protocol) 用户数据协议</h3><p>UDP特性：一个数据包就能完成任务，不需要分段，不需要建立会话，不需要流量控制，是种不可靠的传输方式。</p>\n<h4 id=\"UDP的优点\"><a href=\"#UDP的优点\" class=\"headerlink\" title=\"UDP的优点\"></a>UDP的优点</h4><ol>\n<li>开销更小</li>\n</ol>\n<p>对比于tcp， udp的首部只有8个字节，而tcp有20个字节和40个字节的可选项</p>\n<ol start=\"2\">\n<li>速度更快</li>\n</ol>\n<p>UDP发送数据之前没有TCP的连接建立过程，而TCP则提供了过多的保护，在及时性上面做了很多的妥协</p>\n<h4 id=\"UDP的主要问题\"><a href=\"#UDP的主要问题\" class=\"headerlink\" title=\"UDP的主要问题\"></a>UDP的主要问题</h4><ol>\n<li>丢失和乱序</li>\n</ol>\n<p>因为UDP不提供ACK、序列号等机制，所以是没有办法知道是否有报文丢失以及接收方到达等报文书序是否和发送方的报文数据一样</p>\n<ol start=\"2\">\n<li>差错</li>\n</ol>\n<p>对于差错问题可以通过校验和等检测到，但是不提供差错纠正</p>\n<ol start=\"3\">\n<li>数据完整性</li>\n</ol>\n<p>UDP协议头部虽然有16位的校验和，但是IPV4不强制执行，所以说UDP无法保证数据的完整性</p>\n<h4 id=\"UDP如何解决传输的问题\"><a href=\"#UDP如何解决传输的问题\" class=\"headerlink\" title=\"UDP如何解决传输的问题\"></a>UDP如何解决传输的问题</h4><p>1、 数据完整性</p>\n<p>加上一个16或者32位的CRC验证字段</p>\n<p>2、 乱序</p>\n<p>加上一个数据包序列号SEQ</p>\n<p>3、 丢包</p>\n<p>加上和TCP类似的ACK机制，进行确认和重传</p>\n<p>因此推荐使用RUDP（reliable udp）</p>\n<h3 id=\"TCP-transmission-control-protocol-传输控制协议\"><a href=\"#TCP-transmission-control-protocol-传输控制协议\" class=\"headerlink\" title=\"TCP(transmission control protocol) 传输控制协议\"></a>TCP(transmission control protocol) 传输控制协议</h3><h4 id=\"TCP头部图\"><a href=\"#TCP头部图\" class=\"headerlink\" title=\"TCP头部图\"></a>TCP头部图</h4><p><img src=\"/images/网络协议/TCP头部图.png\" alt=\"tcp头部图\"></p>\n<p>tcp头部添加了20个字节，总计160位来进行数据的控制</p>\n<p>其中选项还可以在多添加40个字节</p>\n<p>因此头部的必要信息比较多，也是确保数据可靠的基础</p>\n<h4 id=\"TCP连接管理机制\"><a href=\"#TCP连接管理机制\" class=\"headerlink\" title=\"TCP连接管理机制\"></a>TCP连接管理机制</h4><p>连接tcp需要三次握手，断开tcp需要四次挥手</p>\n<h5 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h5><p>第一次：</p>\n<p>客户端发送给服务器，通知服务器需要建立连接</p>\n<p>第二次：</p>\n<p>服务器发送给客户端，通知客户端服务器收到连接请求</p>\n<p>第三次：</p>\n<p>客户端发送给服务器，通知服务器客户端收到了服务器的回应</p>\n<p>详细解释：</p>\n<p>1, TCP服务器进程先创建传输控制块TCB, 时刻准备接受客户端进程的连接请求, 此时服务器就进入了 LISTEN（监听）状态<br>2, TCP客户端进程也是先创建传输控制块TCB, 然后向服务器发出连接请求报文，此时报文首部中的同步标志位SYN=1, 同时选择一个初始序列号 seq = x, 此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定, SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。<br>3, TCP服务器收到请求报文后, 如果同意连接, 则发出确认报文。确认报文中的 ACK=1, SYN=1, 确认序号是 x+1, 同时也要为自己初始化一个序列号 seq = y, 此时, TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据, 但是同样要消耗一个序号。<br>4, TCP客户端进程收到确认后还, 要向服务器给出确认。确认报文的ACK=1，确认序号是 y+1，自己的序列号是 x+1.<br>5, 此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</p>\n<ul>\n<li>为什么不用两次握手？</li>\n</ul>\n<p>主要是为了防止已经失效的连接请求报文突然又传回服务器，如果是已经失效的，第三次就无法成立，因此第三次是为了确保网络停滞时间不会导致连接失效</p>\n<ul>\n<li>为什么不用四次？</li>\n</ul>\n<p>四次的话其实就是服务器在通知一次客户端，其实没有必要了，多余了</p>\n<h5 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h5><p>第一次：客户端通知服务器端，要释放连接了，并且客户端进入终止等待1状态</p>\n<p>第二次：服务器收到客户端的释放连接的请求，通知客户端自己已经收到释放连接的请求</p>\n<p>第三次：客户端收到服务器的确认释放连接请求，客户端进入终止等待2状态，而服务器将最后的数据发送完毕后，就向客户端发送连接释放报文</p>\n<p>第四次：客户端收到连接释放报文，向服务端发出确认释放，之后就进入了时间等待状态，等到2个最长报文段寿命时间结束后，客户端就撤销相应的TCB，并且进入close状态，而服务端在接收到了这个确认信息后，不需要等待，而直接进入close状态。因此服务端结束的时间比客户端早一些</p>\n<ul>\n<li>为什么客户端在第四次挥手的时候需要等待两个最长报文寿命时间呢？</li>\n</ul>\n<p>第一：保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，丢失的话服务端就无法知道收到回应，因此如果最后一个ACK报文丢失的话，服务端会再次发送，在两个最长报文寿命时间内，客户端有可能收到第二次请求确认的报文</p>\n<p>第二：防止已经失效的请求报文，客户端等待的两个最长报文寿命的时间中，可以确保本次tcp连接产生的所有报文段都从网络中消失，这样新的连接就不会出现旧连接的请求报文</p>\n<ul>\n<li>为什么建立连接需要三次，而释放连接需要四次？</li>\n</ul>\n<p>因为释放的时候不确定是否有数据没有发送完毕，因此需要确保数据全部发送完毕，这样多了一次，而如果释放的时候没有数据的话，其实可以看做三次，即第二次和第三次合并</p>\n<h4 id=\"窗口滑动\"><a href=\"#窗口滑动\" class=\"headerlink\" title=\"窗口滑动\"></a>窗口滑动</h4><p>TCP的滑动窗口以字节为单位，用三个指针进行表示，当窗口内连续报文段被确认收到后，可以将窗口向前滑动，窗口大小应等于缓存区大小</p>\n<h4 id=\"窗口滑动协议\"><a href=\"#窗口滑动协议\" class=\"headerlink\" title=\"窗口滑动协议\"></a>窗口滑动协议</h4><p>只有在接受窗口向前滑动时（与此同时也发送了确认），发送窗口才可能向前滑动，收发两端的窗口按照以上规律不断的向前滑动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当发送窗口和接受窗口的大小都等于1时，就是停止等待协议。</span><br><span class=\"line\">当发送窗口大于1，而接收窗口小于1时，就是回退N步协议。</span><br><span class=\"line\">当发送窗口和接受窗口的大小均大于1时，就是选择重发协议。</span><br></pre></td></tr></table></figure>\n<p>重发是对回退的补充，由于回退会导致从漏掉的帧到已接受的所有帧全部丢弃，浪费了带宽，而重发则是直接对漏掉的帧进行补充</p>\n<h3 id=\"传输层其他协议\"><a href=\"#传输层其他协议\" class=\"headerlink\" title=\"传输层其他协议\"></a>传输层其他协议</h3><p>传输层还有SPX, NetBIOS,NetBEUI等协议</p>\n<h2 id=\"会话层\"><a href=\"#会话层\" class=\"headerlink\" title=\"会话层\"></a>会话层</h2><p>职责：主机间通讯，管理应用程序之间的会话。建立在传输层之上，利用传输层提供的服务，使应用建立和维持会话，并能使会话得到同步。会话层使用校验点可使通信会话在通信失效时从校验点继续恢复通信。</p>\n<h3 id=\"主要功能\"><a href=\"#主要功能\" class=\"headerlink\" title=\"主要功能\"></a>主要功能</h3><p>1、为会话实体间建立连接</p>\n<p>2、进行数据传输</p>\n<p>3、连接释放</p>\n<h3 id=\"具体理解\"><a href=\"#具体理解\" class=\"headerlink\" title=\"具体理解\"></a>具体理解</h3><p>会话层主要是通过调用传输层来建立会话</p>\n<h2 id=\"表示层\"><a href=\"#表示层\" class=\"headerlink\" title=\"表示层\"></a>表示层</h2><p>职责：表示层向上对应用层服务，向下接受来自会话层的服务，表示层为在引用过程之间传送的信息提供表示方法的服务，只关心信息发出的语法和语义。</p>\n<h3 id=\"主要功能-1\"><a href=\"#主要功能-1\" class=\"headerlink\" title=\"主要功能\"></a>主要功能</h3><p>表示层早期是用来转换字符数据的编码，提供格式化的表示和转换数据服务，数据的压缩和解压缩，加密和解密等工作，但是现在应用层可以做表示层可以做的事情，所以一般根据TCPIP五层协议，表示层会话层和应用层都可以合为应用层</p>\n<h2 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h2><p>职责：应用层直接和应用程序接口并且提供常见的网络应用服务，应用层也会向表示层发出请求，应用层是开放系统的最高层，是直接为应用进程提供服务的。</p>\n<p>应用层协议较多，有FTP、SMTP、HTTP等</p>\n<p>着重学习一下HTTPS</p>\n<h3 id=\"https\"><a href=\"#https\" class=\"headerlink\" title=\"https\"></a>https</h3><p>https协议主要针对解决http协议以下不足：<br>1.通信使用明文（不加密），内容可能会被窃听<br>2.不验证通信方身份，应此可能遭遇伪装<br>3.无法证明报文的完整性（即准确性），所以可能已遭篡改<br>http+加密+认证+完整性保护=https</p>\n<h4 id=\"https-和http主要的区别\"><a href=\"#https-和http主要的区别\" class=\"headerlink\" title=\"https 和http主要的区别\"></a>https 和http主要的区别</h4><ol>\n<li>https需要ca证书</li>\n<li>https是具有安全性的ssl加密传输协议，http是明文传输</li>\n<li>http和https使用完全不同的连接方式，用的端口也不一样，http是80端口，https是443端口</li>\n<li>http是无状态的，而https是有ssl+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全</li>\n</ol>\n<h4 id=\"握手过程\"><a href=\"#握手过程\" class=\"headerlink\" title=\"握手过程\"></a>握手过程</h4><ol>\n<li>客户端向服务器传送客户端ssl协议的版本号，加密算法的种类，产生的随机数、以及其他服务器和客户端之间通讯需要的各种信息</li>\n<li>服务器向客户端传送ssl协议的版本号、加密算法的种类、随机数以及其他相关信息，同时服务器还向客户端传送自己的证书</li>\n<li>客户端利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，ca证书是否可靠，证书的公钥能否解开服务器证书的发行者数字签名，证书上面的域名是否和服务器的实际域名相匹配。如果不合法，通讯将断开，否则将继续进行下面的步骤</li>\n<li>客户端随机产生一个用于后面通讯的“对称密码”，然后服务器的公钥对其加密，然后将加密后的“预主密码“传给服务器</li>\n<li>如果服务器要求客户的身份认证，用户可以建立一个随机数然后对其数据签名，然后将这个含有签名的随机数和客户自己的证书以及加密过的”预主密码“一起传给服务器</li>\n<li>如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性检验过程包括：客户的证书使用日期是否有效，提供的ca是否可靠，ca的公钥能否正确解开客户端证书的发行ca签名，检查客户的证书是否在证书废止列表中。如果不合法，通讯立即终端，否则服务器将用自己的私钥解药加密的预主密码，然后执行一系列步骤产生主通讯密码。客户端也同样的步骤产生主通讯密码</li>\n<li>服务器和客户端用相同的主密码。一个对称秘钥用于ssl协议的安全数据通讯的加解密通讯，同时在ssl通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化</li>\n<li>客户端向服务器发出信息，指明后续通讯将使用主密码为堆成密码，同时通知服务器本次握手过程结束</li>\n<li>服务器向客户端发出信息，指明后续通讯将使用主密码为对称密码，同时通知客户端本次握手过程结束</li>\n<li>ssl的握手部分结束，安全通道的通讯开始，客户端和服务端开始使用相同的对称秘钥进行数据通讯，同时检查通讯完整性</li>\n</ol>\n<p>概括，https在客户端生成秘钥并传递给服务端的时候，采取的是非对称加密，而秘钥在服务端手里的时候，之后采取的就是对称加密。单向验证是指客户端对服务端进行身份验证，验证是否可靠，而双向验证则是服务端也同时验证客户端，双向验证常见于企业应用</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"OSI网络分层\"><a href=\"#OSI网络分层\" class=\"headerlink\" title=\"OSI网络分层\"></a>OSI网络分层</h1><p>网络分层就是OSI七层结构，另外还有个TCPIP五层结构，我从最底层开始总结</p>\n<h2 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h2><p>职责：建立、维护、断开物理连接</p>\n<p>物理层是一个点对点的数据直链，并不一定可靠，物理层是通过拓扑结构进行连接，但始终保障能够连通。</p>\n<h3 id=\"物理层传输原理\"><a href=\"#物理层传输原理\" class=\"headerlink\" title=\"物理层传输原理\"></a>物理层传输原理</h3><p>物理层主要功能是传输比特流。其传输原理是将需要传输的信息按照ASCII编码转化为二进制代码，然后将二进制代码通过数据信号编码器转换为一种电信号，最后信号由发送端的发送设备通过传输介质发送到接受端计算机。传输的信号分为模电和数电，解析方法是调制和解调</p>\n<h3 id=\"物理层总结\"><a href=\"#物理层总结\" class=\"headerlink\" title=\"物理层总结\"></a>物理层总结</h3><p>物理层的传输方式和解析方式大部分是本科阶段通信原理学习的内容，另外传输的协议比如说数电，模电，多路复用，时分复用，波分复用等等。对移动端来讲物理层可控太少，了解其职责和大致原理即可。</p>\n<h2 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h2><p>职责：建立逻辑连接，进行硬件地址寻址，差错校验等功能</p>\n<p>数据链路层是一个数据传输通道，位于物理层和网络层之间，是数据传输过程中比较重要的一层。物理层提供的的传输媒介、连接在通讯时只是暂时的，而数据链路的功能就是通过建立通信连接和拆除通信连接这种数据收发方式，而承担数据链路功能的设备就是数据链路层设备</p>\n<h3 id=\"数据链路层设备\"><a href=\"#数据链路层设备\" class=\"headerlink\" title=\"数据链路层设备\"></a>数据链路层设备</h3><ol>\n<li>网卡</li>\n</ol>\n<p>作用：网卡是连接计算机与网络的硬件设备，不仅能实现与局域网传输介质之间的物理连接和电信号连接，还涉及了帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能</p>\n<ol start=\"2\">\n<li>网桥</li>\n</ol>\n<p>作用：实现局域网互联的存储转发设备，网桥从一个局域网接收mac帧、拆封、校对、校验之后，按照另一个局域网的格式重新组装，发往它的物理层</p>\n<ol start=\"3\">\n<li>交换机</li>\n</ol>\n<p>是一种用于电信号转发的网络设备，可以把传输的信息送到符合要求的设备上面</p>\n<h3 id=\"数据链路层基础知识\"><a href=\"#数据链路层基础知识\" class=\"headerlink\" title=\"数据链路层基础知识\"></a>数据链路层基础知识</h3><ol>\n<li>mac地址</li>\n</ol>\n<p>mac地址用来表示互联网上面每一个站点的标识符，采用十六进制，共6个字节<br>输入ipconfig/all 中的物理地址及是mac地址</p>\n<ol start=\"2\">\n<li>数据帧</li>\n</ol>\n<p>数据帧是数据链路层的协议数据单元，它包括三部分：帧头，数据部分，帧尾。帧头帧尾是控制信息，数据部分包含了需要传输的数据</p>\n<ol start=\"3\">\n<li>载波监听多路访问技术 CSMA/CD</li>\n</ol>\n<p>发送数据前监听信道是否空闲，若空闲就立即发送信道，否则就等待一段时间直至信道中的信息传输结束后再发送数据，若在上一段信息发送结束后，同时又两个或两个以上节点都提出发送请求，则判定为冲突，冲突会立即停止发送数据，等待一段时间之后再重新尝试</p>\n<h2 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h2><p>职责：进行逻辑地址寻址，实现不同网络之间的路径选择</p>\n<p>网络层将多个通络通过路由器互连成一个互连网络，让网络中的多台计算机可以互相通信。网络层最重要的是ip协议，在网络层需要实现数据报文的分片与组装、同时需要提供路由选择。</p>\n<p>和网络层搭配使用的是ARP(地址解析协议)，ICMP(互联网控制报文协议)，IGMP(网际管理协议)</p>\n<h3 id=\"ARP-address-resolution-protocol\"><a href=\"#ARP-address-resolution-protocol\" class=\"headerlink\" title=\"ARP (address resolution protocol)\"></a>ARP (address resolution protocol)</h3><p>在实际过程中，知道一个主机或者路由器的ip地址，并不知道对应的mac地址，因此可以通过arp协议，用目的ip地址得到mac地址。</p>\n<p>原理：在每台安装tcpip协议的电脑路由器里都有一个arp缓存表，表里的ip地址与mac地址是一一对应的。当发送数据时，主机a会在自己的arp缓存表中寻找是否有目标ip地址，如果找到就知道目标对应的mac地址，直接将mac地址写入帧里面发送即可。如果没有找到，就会在网络上发送一个广播(ARP REQUEST)，这个request的目标mac地址是”FF.FF.FF.FF.FF.FF”，携带的信息是查询目标ip地址。网络上面不是这个ip地址的主机不会响应这个arp查询，只有ip地址为这个的目标主机才会响应，并且发送一个ARP RESPONSE, 携带的信息是目标ip的mac地址，这样就回复回来的时候就知道目标的mac地址了，并且会更新arp缓存表（arp缓存表使用的是老化机制，一段时间不使用就会删除，因此长度并不会特别长）</p>\n<h3 id=\"ICMP-internet-control-message-protocol\"><a href=\"#ICMP-internet-control-message-protocol\" class=\"headerlink\" title=\"ICMP (internet control message protocol)\"></a>ICMP (internet control message protocol)</h3><p>通信环境中可能存在各种问题，这些问题的反馈需要让开发者知道并且应对，因此就有了ICMP协议，该协议与传输协议不同，他一般并不用于两点间传输数据，而常常用于返回错误的信息或分析路由。</p>\n<p>ICMP主要功能：1、确认ip包是否成功到达目标地址 2、通知在发送过程中ip包被丢弃的原因 3、ICMP是基于ip协议制作的，但是并不是传输层的功能，因此仍然是网络层协议 4、ICMP只能用于IPV4, 能用于IPV6的icmp叫做ICMPV6</p>\n<p>常用的ICMP技术，像是 ping， traceroute命令</p>\n<h3 id=\"IGMP-internet-group-management-protocol\"><a href=\"#IGMP-internet-group-management-protocol\" class=\"headerlink\" title=\"IGMP (internet group management protocol)\"></a>IGMP (internet group management protocol)</h3><p>跨越多个网络的组播转发必须要依赖于路由器，路由器为建立转发路由必须要了解每个组员在internet中的分布，这要求主机将自己所在的组播组通知给本地路由器，这也是建立组播转发路由的基础。主机与本地路由器之间使用igmp来进行组播组成员信息的交互。</p>\n<p>IGMP提供了再转发组播数据包到达目的地的最后阶段所需要的信息，实现双向的功能：<br>1.主机通过igmp通知路由器希望接受或离开某个特定组播组的信息<br>2.路由器通过IGMP周期性的查询局域网内的组播组成员是否处于活动状态，实现所连网段组成员关系的手机与维护。</p>\n<h2 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h2><p>职责：在网络的各个节点之间可靠的分发数据包，实现应用进程间的端到端通信，同时向应用层提供通信服务</p>\n<p>原理：通过多路复用和解复用技术，发送方的不同的应用进程都可以使用同一个传输层协议传送数据，接收方的传输层剥去报文首部之后能把这些数据正确的传输的正确的应用进程之间。</p>\n<p>传输层就是知名协议UDP和TCP的所在。</p>\n<h3 id=\"UDP-user-datagram-protocol-用户数据协议\"><a href=\"#UDP-user-datagram-protocol-用户数据协议\" class=\"headerlink\" title=\"UDP(user datagram protocol) 用户数据协议\"></a>UDP(user datagram protocol) 用户数据协议</h3><p>UDP特性：一个数据包就能完成任务，不需要分段，不需要建立会话，不需要流量控制，是种不可靠的传输方式。</p>\n<h4 id=\"UDP的优点\"><a href=\"#UDP的优点\" class=\"headerlink\" title=\"UDP的优点\"></a>UDP的优点</h4><ol>\n<li>开销更小</li>\n</ol>\n<p>对比于tcp， udp的首部只有8个字节，而tcp有20个字节和40个字节的可选项</p>\n<ol start=\"2\">\n<li>速度更快</li>\n</ol>\n<p>UDP发送数据之前没有TCP的连接建立过程，而TCP则提供了过多的保护，在及时性上面做了很多的妥协</p>\n<h4 id=\"UDP的主要问题\"><a href=\"#UDP的主要问题\" class=\"headerlink\" title=\"UDP的主要问题\"></a>UDP的主要问题</h4><ol>\n<li>丢失和乱序</li>\n</ol>\n<p>因为UDP不提供ACK、序列号等机制，所以是没有办法知道是否有报文丢失以及接收方到达等报文书序是否和发送方的报文数据一样</p>\n<ol start=\"2\">\n<li>差错</li>\n</ol>\n<p>对于差错问题可以通过校验和等检测到，但是不提供差错纠正</p>\n<ol start=\"3\">\n<li>数据完整性</li>\n</ol>\n<p>UDP协议头部虽然有16位的校验和，但是IPV4不强制执行，所以说UDP无法保证数据的完整性</p>\n<h4 id=\"UDP如何解决传输的问题\"><a href=\"#UDP如何解决传输的问题\" class=\"headerlink\" title=\"UDP如何解决传输的问题\"></a>UDP如何解决传输的问题</h4><p>1、 数据完整性</p>\n<p>加上一个16或者32位的CRC验证字段</p>\n<p>2、 乱序</p>\n<p>加上一个数据包序列号SEQ</p>\n<p>3、 丢包</p>\n<p>加上和TCP类似的ACK机制，进行确认和重传</p>\n<p>因此推荐使用RUDP（reliable udp）</p>\n<h3 id=\"TCP-transmission-control-protocol-传输控制协议\"><a href=\"#TCP-transmission-control-protocol-传输控制协议\" class=\"headerlink\" title=\"TCP(transmission control protocol) 传输控制协议\"></a>TCP(transmission control protocol) 传输控制协议</h3><h4 id=\"TCP头部图\"><a href=\"#TCP头部图\" class=\"headerlink\" title=\"TCP头部图\"></a>TCP头部图</h4><p><img src=\"/images/网络协议/TCP头部图.png\" alt=\"tcp头部图\"></p>\n<p>tcp头部添加了20个字节，总计160位来进行数据的控制</p>\n<p>其中选项还可以在多添加40个字节</p>\n<p>因此头部的必要信息比较多，也是确保数据可靠的基础</p>\n<h4 id=\"TCP连接管理机制\"><a href=\"#TCP连接管理机制\" class=\"headerlink\" title=\"TCP连接管理机制\"></a>TCP连接管理机制</h4><p>连接tcp需要三次握手，断开tcp需要四次挥手</p>\n<h5 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h5><p>第一次：</p>\n<p>客户端发送给服务器，通知服务器需要建立连接</p>\n<p>第二次：</p>\n<p>服务器发送给客户端，通知客户端服务器收到连接请求</p>\n<p>第三次：</p>\n<p>客户端发送给服务器，通知服务器客户端收到了服务器的回应</p>\n<p>详细解释：</p>\n<p>1, TCP服务器进程先创建传输控制块TCB, 时刻准备接受客户端进程的连接请求, 此时服务器就进入了 LISTEN（监听）状态<br>2, TCP客户端进程也是先创建传输控制块TCB, 然后向服务器发出连接请求报文，此时报文首部中的同步标志位SYN=1, 同时选择一个初始序列号 seq = x, 此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定, SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。<br>3, TCP服务器收到请求报文后, 如果同意连接, 则发出确认报文。确认报文中的 ACK=1, SYN=1, 确认序号是 x+1, 同时也要为自己初始化一个序列号 seq = y, 此时, TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据, 但是同样要消耗一个序号。<br>4, TCP客户端进程收到确认后还, 要向服务器给出确认。确认报文的ACK=1，确认序号是 y+1，自己的序列号是 x+1.<br>5, 此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</p>\n<ul>\n<li>为什么不用两次握手？</li>\n</ul>\n<p>主要是为了防止已经失效的连接请求报文突然又传回服务器，如果是已经失效的，第三次就无法成立，因此第三次是为了确保网络停滞时间不会导致连接失效</p>\n<ul>\n<li>为什么不用四次？</li>\n</ul>\n<p>四次的话其实就是服务器在通知一次客户端，其实没有必要了，多余了</p>\n<h5 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h5><p>第一次：客户端通知服务器端，要释放连接了，并且客户端进入终止等待1状态</p>\n<p>第二次：服务器收到客户端的释放连接的请求，通知客户端自己已经收到释放连接的请求</p>\n<p>第三次：客户端收到服务器的确认释放连接请求，客户端进入终止等待2状态，而服务器将最后的数据发送完毕后，就向客户端发送连接释放报文</p>\n<p>第四次：客户端收到连接释放报文，向服务端发出确认释放，之后就进入了时间等待状态，等到2个最长报文段寿命时间结束后，客户端就撤销相应的TCB，并且进入close状态，而服务端在接收到了这个确认信息后，不需要等待，而直接进入close状态。因此服务端结束的时间比客户端早一些</p>\n<ul>\n<li>为什么客户端在第四次挥手的时候需要等待两个最长报文寿命时间呢？</li>\n</ul>\n<p>第一：保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，丢失的话服务端就无法知道收到回应，因此如果最后一个ACK报文丢失的话，服务端会再次发送，在两个最长报文寿命时间内，客户端有可能收到第二次请求确认的报文</p>\n<p>第二：防止已经失效的请求报文，客户端等待的两个最长报文寿命的时间中，可以确保本次tcp连接产生的所有报文段都从网络中消失，这样新的连接就不会出现旧连接的请求报文</p>\n<ul>\n<li>为什么建立连接需要三次，而释放连接需要四次？</li>\n</ul>\n<p>因为释放的时候不确定是否有数据没有发送完毕，因此需要确保数据全部发送完毕，这样多了一次，而如果释放的时候没有数据的话，其实可以看做三次，即第二次和第三次合并</p>\n<h4 id=\"窗口滑动\"><a href=\"#窗口滑动\" class=\"headerlink\" title=\"窗口滑动\"></a>窗口滑动</h4><p>TCP的滑动窗口以字节为单位，用三个指针进行表示，当窗口内连续报文段被确认收到后，可以将窗口向前滑动，窗口大小应等于缓存区大小</p>\n<h4 id=\"窗口滑动协议\"><a href=\"#窗口滑动协议\" class=\"headerlink\" title=\"窗口滑动协议\"></a>窗口滑动协议</h4><p>只有在接受窗口向前滑动时（与此同时也发送了确认），发送窗口才可能向前滑动，收发两端的窗口按照以上规律不断的向前滑动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当发送窗口和接受窗口的大小都等于1时，就是停止等待协议。</span><br><span class=\"line\">当发送窗口大于1，而接收窗口小于1时，就是回退N步协议。</span><br><span class=\"line\">当发送窗口和接受窗口的大小均大于1时，就是选择重发协议。</span><br></pre></td></tr></table></figure>\n<p>重发是对回退的补充，由于回退会导致从漏掉的帧到已接受的所有帧全部丢弃，浪费了带宽，而重发则是直接对漏掉的帧进行补充</p>\n<h3 id=\"传输层其他协议\"><a href=\"#传输层其他协议\" class=\"headerlink\" title=\"传输层其他协议\"></a>传输层其他协议</h3><p>传输层还有SPX, NetBIOS,NetBEUI等协议</p>\n<h2 id=\"会话层\"><a href=\"#会话层\" class=\"headerlink\" title=\"会话层\"></a>会话层</h2><p>职责：主机间通讯，管理应用程序之间的会话。建立在传输层之上，利用传输层提供的服务，使应用建立和维持会话，并能使会话得到同步。会话层使用校验点可使通信会话在通信失效时从校验点继续恢复通信。</p>\n<h3 id=\"主要功能\"><a href=\"#主要功能\" class=\"headerlink\" title=\"主要功能\"></a>主要功能</h3><p>1、为会话实体间建立连接</p>\n<p>2、进行数据传输</p>\n<p>3、连接释放</p>\n<h3 id=\"具体理解\"><a href=\"#具体理解\" class=\"headerlink\" title=\"具体理解\"></a>具体理解</h3><p>会话层主要是通过调用传输层来建立会话</p>\n<h2 id=\"表示层\"><a href=\"#表示层\" class=\"headerlink\" title=\"表示层\"></a>表示层</h2><p>职责：表示层向上对应用层服务，向下接受来自会话层的服务，表示层为在引用过程之间传送的信息提供表示方法的服务，只关心信息发出的语法和语义。</p>\n<h3 id=\"主要功能-1\"><a href=\"#主要功能-1\" class=\"headerlink\" title=\"主要功能\"></a>主要功能</h3><p>表示层早期是用来转换字符数据的编码，提供格式化的表示和转换数据服务，数据的压缩和解压缩，加密和解密等工作，但是现在应用层可以做表示层可以做的事情，所以一般根据TCPIP五层协议，表示层会话层和应用层都可以合为应用层</p>\n<h2 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h2><p>职责：应用层直接和应用程序接口并且提供常见的网络应用服务，应用层也会向表示层发出请求，应用层是开放系统的最高层，是直接为应用进程提供服务的。</p>\n<p>应用层协议较多，有FTP、SMTP、HTTP等</p>\n<p>着重学习一下HTTPS</p>\n<h3 id=\"https\"><a href=\"#https\" class=\"headerlink\" title=\"https\"></a>https</h3><p>https协议主要针对解决http协议以下不足：<br>1.通信使用明文（不加密），内容可能会被窃听<br>2.不验证通信方身份，应此可能遭遇伪装<br>3.无法证明报文的完整性（即准确性），所以可能已遭篡改<br>http+加密+认证+完整性保护=https</p>\n<h4 id=\"https-和http主要的区别\"><a href=\"#https-和http主要的区别\" class=\"headerlink\" title=\"https 和http主要的区别\"></a>https 和http主要的区别</h4><ol>\n<li>https需要ca证书</li>\n<li>https是具有安全性的ssl加密传输协议，http是明文传输</li>\n<li>http和https使用完全不同的连接方式，用的端口也不一样，http是80端口，https是443端口</li>\n<li>http是无状态的，而https是有ssl+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全</li>\n</ol>\n<h4 id=\"握手过程\"><a href=\"#握手过程\" class=\"headerlink\" title=\"握手过程\"></a>握手过程</h4><ol>\n<li>客户端向服务器传送客户端ssl协议的版本号，加密算法的种类，产生的随机数、以及其他服务器和客户端之间通讯需要的各种信息</li>\n<li>服务器向客户端传送ssl协议的版本号、加密算法的种类、随机数以及其他相关信息，同时服务器还向客户端传送自己的证书</li>\n<li>客户端利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，ca证书是否可靠，证书的公钥能否解开服务器证书的发行者数字签名，证书上面的域名是否和服务器的实际域名相匹配。如果不合法，通讯将断开，否则将继续进行下面的步骤</li>\n<li>客户端随机产生一个用于后面通讯的“对称密码”，然后服务器的公钥对其加密，然后将加密后的“预主密码“传给服务器</li>\n<li>如果服务器要求客户的身份认证，用户可以建立一个随机数然后对其数据签名，然后将这个含有签名的随机数和客户自己的证书以及加密过的”预主密码“一起传给服务器</li>\n<li>如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性检验过程包括：客户的证书使用日期是否有效，提供的ca是否可靠，ca的公钥能否正确解开客户端证书的发行ca签名，检查客户的证书是否在证书废止列表中。如果不合法，通讯立即终端，否则服务器将用自己的私钥解药加密的预主密码，然后执行一系列步骤产生主通讯密码。客户端也同样的步骤产生主通讯密码</li>\n<li>服务器和客户端用相同的主密码。一个对称秘钥用于ssl协议的安全数据通讯的加解密通讯，同时在ssl通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化</li>\n<li>客户端向服务器发出信息，指明后续通讯将使用主密码为堆成密码，同时通知服务器本次握手过程结束</li>\n<li>服务器向客户端发出信息，指明后续通讯将使用主密码为对称密码，同时通知客户端本次握手过程结束</li>\n<li>ssl的握手部分结束，安全通道的通讯开始，客户端和服务端开始使用相同的对称秘钥进行数据通讯，同时检查通讯完整性</li>\n</ol>\n<p>概括，https在客户端生成秘钥并传递给服务端的时候，采取的是非对称加密，而秘钥在服务端手里的时候，之后采取的就是对称加密。单向验证是指客户端对服务端进行身份验证，验证是否可靠，而双向验证则是服务端也同时验证客户端，双向验证常见于企业应用</p>\n"},{"title":"android1.0-7.0各版本feature","date":"2018-03-23T02:03:03.000Z","_content":"\n# 5.0 - api 21\n\n## 新出material design\n## view增加了z属性\n\n在5.0之前，我们如果想给view添加阴影效果，以体现其层次感，通常的做法是给view设置一个带阴影的背景图片，现在，我们只需要简单的修改view的Z属性，就能让其具备阴影的层次感。\n\nZ属性会扩大view的显示区域，如果它的大小大于或等于父视图的大小，那么它的阴影效果就无法显示了，view并不会因为z属性而把自身缩小腾出空间显示阴影。\n\nZ属性不仅影响着view的阴影效果，还影响着view的绘制顺序，在同一个父view内部，Z属性越小，绘制的时机就越早。也就是优先被绘制，而z属性越大，则绘制时间越晚，后绘制的将会遮盖住先绘制的，只有Z属性相同，才按照添加的顺序绘制。\n\n## view增加了轮廓\n\n在xml布局中，可以通过android:outlineProvider来指定轮廓的判定方式：\n\nnone 即使设置了Z属性，也不会显示阴影\nbackground 会按照背景来设置阴影形状\nbounds 会按照View的大小来描绘阴影\npaddedBounds 和bounds类似，不过阴影会稍微向右偏移一点\n\n在代码中，我们可以通过setOutlineProvider来指定一个View的轮廓：\n```\nViewOutlineProvider viewOutlineProvider = new ViewOutlineProvider() {\n    public void getOutline(View view, Outline outline) {\n        // 可以指定圆形，矩形，圆角矩形，path\n        outline.setOval(0, 0, view.getWidth(), view.getHeight());\n    }\n};\nView.setOutlineProvider(viewOutlineProvider );\n```\n\n## view的裁剪\n\n给View指定轮廓，可以决定阴影的显示形状，如果给View指定一个小于自身大小的轮廓，正常情况下阴影会被View遮住，这个时候View的显示内容并没有因为轮廓的缩小而缩小。\n\n如果想根据轮廓来缩小一个View，则可以通过剪裁。如果一个View指定了轮廓，调用setClipToOutline方法，就可以根据轮廓来剪裁一个View。想要剪裁轮廓，必须要给View先指定轮廓，并且轮廓是可以被剪裁的，目前只有圆形，矩形，圆角矩形支持剪裁，可以通过outline.canClip()来判断一个轮廓是否支持剪裁。\n\nPath剪裁不会改变View的大小，但是如果Path的范围比View要的bounds要小，则剪裁后会改变View的位置，位置偏移和Z属性有关，这可能是一个BUG，view的设计者可能在绘制阴影时根据轮廓偏移了画布，而在绘制完后忘记把画布还原了。\n\n剪裁不会改变View的测量大小和布局大小，也不会改变View的触摸区域，剪裁只是在onDraw的时候对画布做了剪裁处理，剪裁也不同于scale，scale是调整画布matrix的缩放属性，调整后，View仍然能完整显示，而剪裁是缩小画布的剪裁区域，剪裁后我们只能看到View的一部分。\n\n试图给View一个比较大的轮廓进行剪裁也是不成功的，实验证明剪裁后的View只能比原有体积小，扩大轮廓只会扩大轮廓的绘制区域。\n\n剪裁是一个非常消耗资源的操作，我们不应该用此来做动画效果，如果要实现这样的动画，可以使用Reveal Effect\n\n## tint属性\n\ntint属性是一个颜色值，可以对图片做颜色渲染，我们可以给view的背景设置tint色值，给ImageView的图片设置tint色值，也可以给任意Drawable或者NinePatchDrawable设置tint色值。\n\n在应用的主题中也可以通过设置 android:tint 来给主题设置统一的颜色渲染。\n\ntint的渲染模式有总共有16种，xml文件中可以使用6种，代码中我们可以设置16种，渲染模式决定了渲染颜色和原图颜色的取舍和合成规则：\n\nPorterDuff.Mode.CLEAR 所绘制不会提交到画布上。\nPorterDuff.Mode.SRC 显示上层绘制图片\nPorterDuff.Mode.DST 显示下层绘制图片\nPorterDuff.Mode.SRC_OVER 正常绘制显示，上下层绘制叠盖。\nPorterDuff.Mode.DST_OVER 上下层都显示。下层居上显示。\nPorterDuff.Mode.SRC_IN 取两层绘制交集。显示上层。\nPorterDuff.Mode.DST_IN 取两层绘制交集。显示下层。\nPorterDuff.Mode.SRC_OUT 取上层绘制非交集部分。\nPorterDuff.Mode.DST_OUT 取下层绘制非交集部分。\nPorterDuff.Mode.SRC_ATOP 取下层非交集部分与上层交集部分\nPorterDuff.Mode.DST_ATOP 取上层非交集部分与下层交集部分\nPorterDuff.Mode.XOR 取两层绘制非交集。两层绘制非交集。\nPorterDuff.Mode.DARKEN 上下层都显示。变暗\nPorterDuff.Mode.LIGHTEN 上下层都显示。变亮\nPorterDuff.Mode.MULTIPLY 取两层绘制交集\nPorterDuff.Mode.SCREEN 上下层都显示。\n\n通过tint属性处理后的图片会和原图显示出不一样的颜色，我们可以通过这种方式利用一张图片做出图片选择器的效果，让控件在按压状态下显示另外一种颜色:\n```\n通过给图片设置tint色生成另外一种图片\n<bitmap xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:src=\"@drawable/ring\"\n        android:tintMode=\"multiply\"\n        android:tint=\"#5677fc\" />\n利用新的图片生成图片选择器\n<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n        <item android:drawable=\"@drawable/tint_bitmap\" android:state_pressed=\"true\"/>\n        <item android:drawable=\"@drawable/ring\" />\n</selector>\n```\n\n## Palette调色版\n\nPalette调色板，可以很方便的让我们从图片中提取颜色。并且可以指定提取某种类型的颜色。\nVibrant 鲜艳的\nVibrant dark鲜艳的暗色\nVibrant light鲜艳的亮色\nMuted 柔和的\nMuted dark柔和的暗色\nMuted light柔和的亮色\n\n对图片取色是一个比较消耗性能的操作，其内部会对图片的像素值进来遍历以分析对比，所以我们要在异步线程中去完成。\n\n```\n如果操作本来就属于后台线程，可以使用：\nPalette p = Palette.generate(Bitmap bitmap);\n如果在主线程中，我们可以使用异步的方式：\nPalette.generateAsync(bitmap, new Palette.PaletteAsyncListener() {\n        public void onGenerated(Palette palette) {  }\n});\n```\n\n当操作完成后或者异步回调后，我们就可以使用以下方式来获取对应的色值了，并且可以在没有获取到的情况下之指定默认值：\n```\np.getVibrantColor(int defaultColor);\np.getDarkVibrantColor(int defaultColor);\np.getLightVibrantColor(int defaultColor);\np.getMutedColor(int defaultColor);\np.getDarkMutedColor(int defaultColor);\np.getLightMutedColor(int defaultColor);\n```\n\n在使用palette之前，bitmap提供获取指定位置的像素值：\n```\nbitmap.getPixel(x,y)\n```\n\n但是该方式只能获取某一点的像素值，palette是对整个bitmap的所有像素值进行分析，并选出几个像素占比比较多的像素值，这样选择出来的色值更符合图片的整体色值。\n\n## vector矢量图\n\n矢量图也称为面向对象的图像或绘图图像，是计算机图形学中用点、直线或者多边形等基于数学方程的几何图元表示的图像。矢量图形最大的优点是无论放大、缩小或旋转等不会失真；最大的缺点是难以表现色彩层次丰富、逼真的图像效果。\n\nAndroid L开始支持矢量图，我们可以用它来处理一些图形简单的icon，方便我们的适配。\n\nAndroid L中对矢量图的支持是通过xml文件构建，通过矢量图的path描述来生成一个矢量图，对应的java对象为VectorDrawable。\n\n下面是官方文档提供的一个矢量图，利用改文件，我们可以创建一个随意放大缩小都不会失真的心形。\n\n```\n<vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:height=\"300dp\"\n        android:width=\"300dp\"\n        android:viewportHeight=\"40\"\n        android:viewportWidth=\"40\">\n        <path android:fillColor=\"#ff00ff\"\n                android:pathData=\"M20.5,9.5\n                        c-1.955,0,-3.83,1.268,-4.5,3\n                        c-0.67,-1.732,-2.547,-3,-4.5,-3\n                        C8.957,9.5,7,11.432,7,14\n                        c0,3.53,3.793,6.257,9,11.5\n                        c5.207,-5.242,9,-7.97,9,-11.5\n                        C25,11.432,23.043,9.5,20.5,9.5z\"/>\n</vector>\n```\n\n矢量图的pathData数据就是用来描述矢量图的数学公式，其含义如下表：\n\n命令类型\t使用描述\t代表含义\t\t\t\t\t举例说明\n移动指令\tM x,y\tM移动绝对位置\t\t\t\tM 100,240\n移动指令\tm x,y\tm移动相对于上一个点\t\tm 100,240\n绘制\t\tL 或 l\t从当前点绘制直线到指定点\tL 100,100\n绘制\t\tH 或 h\t水平直线\t\t\t\t\th 100\n绘制\t\tV 或 v\t垂直直线\t\t\t\t\tv 100\n绘制\t\tC 或 c\t三次方程式贝塞尔曲线\t\tC 100,200 200,400 300,200\n绘制\t\tQ 或 q\t二次方程式贝塞尔曲线\t\tQ 100,200 300,200\n绘制\t\tS 或 s\t平滑三次方程式贝塞尔曲线\tS 100,200 200,400 300,200\n绘制\t\tT 或 t\t平滑二次方程式贝塞尔曲线\tT 100,200 300,200\n绘制\t\tA 或 a\t椭圆\t\t\t\t\t\tA 5,5 0 0 1 10,10\n关闭指令\tZ 或 z\t将图形的首、尾点用直线连接\tZ\n填充\t\tF0\tEvenOdd 填充规则\t\n填充\t\tF1\tNonzero 填充规则\t\n\n通过path命令来进行简单的图形还是可行的，但是复杂的图形我们就需要借助工具来生成了，比如使用 Expression Design，就可以直接粘贴来自其它软件的矢量图形，然后选择导出，导出时做如后选择：文件->导出->导出属性->格式->XAML Silverlight 画布，即可得到XAML格式的矢量图形，也就是Path。\n\n更多矢量图学习可参考：http://www.w3.org/TR/SVG11/paths.html#PathData 我们可以访问http://editor.method.ac 在线制作矢量图并导出path。\n\n\n## 新增widget\n\n## RecyclerView\n\nRecyclerView是ListView的升级版，它具备了更好的性能，且更容易使用。和ListView一样，RecyclerView是用来显示大量数据的容器，并通过复用有限数量的View，来提高滚动时的性能。当你的视图上的元素经常动态的且有规律的改变时候，可以使用RecyclerView控件。\n\n与ListView不同的是RecyclerView不再负责布局，只专注于复用机制，布局交由LayoutManager来管理。 RecyclerView仍然通过Adapter来获取需要显示的对象。\n\n要使用RecyclerView组件，创建Adapter不再继承自BaseAdapter，而是应该继承自RecyclerView.Adapter类，并且最好指定一个继承自RecyclerView.ViewHolder的范型，Adapter不再要求你返回一个View，而是一个ViewHolder。\n\n继承自Adapter后，需要实现3个抽象方法：\n\n```\n// 当RecyclerView需要一个ViewHolder时会回调该方法，如果有可复用的View则该方法不会得倒回调\npublic RecyclerView.ViewHolder onCreateViewHolder(ViewGroup viewGroup, int i)；\n// 当一个View需要出现在屏幕上时，该方法会被回调，你需要在该方法中根据数据来更改视图\npublic void onBindViewHolder(RecyclerView.ViewHolder viewHolder, int i)；\n// 用于告诉RecyclerView有多个视图需要显示\npublic int getItemCount()；\n```\n\n新的Adapter和原有的Adapter并没有太多的差别，只是不再需要我们写复用判断的逻辑，因为复用逻辑其实都是相似的，它已经有了自身的实现。和原有的Adapter一样，仍然可以通过notifyDataSetChanged来刷新UI，通过getItemViewType来获取对应位置的类型，但是它不再需要你指定有多少类型了，因为该方法已经能够判断出有多少类型。新增的onViewRecycled方法可以让使用者监听View被移除屏幕的时机，并且还提供了一个AdapterDataObserver的观察者，对外提供数据改变时的回调。\n\nViewHolder是对所有的单个item的封装，不仅包含了item需要显示的View，并且还包含和item相关的其它数据，例如：当前的position、之前的position、即将显示的position、被回收的次数、View的类型、是否处于显示中等信息。创建一个ViewHolder需要传递一个View对象，这个View就是该holder的显示视图，该View中通常会包含一些子视图，我们最好把这些子视图都记录在holder中，便于复用时设置不同的数据。\n\nRecyclerView不再对布局进行管理，而是通过LayoutManager管理布局，我们可以通过继承自LayoutManager来实现特殊的布局，系统提供了三种常用的布局管理器：\n\nLinearLayoutManager 线性布局\nGridLayoutManager 九宫格布局\nStaggeredGridLayoutManager 瀑布流布局\n\n并且每一种都可以设置横行和纵向的布局，可惜的均不能添加header，如果要添加header，我们可以在Adapter中使用不同的类型来达到该效果。\n\nRecyclerView默认提供了item的增加和删除的动画效果，如果我们使用自定义的动画，需要继承继承RecyclerView.ItemAnimator类，通过RecyclerView.setItemAnimator()方法来设置我们自定义的动画。\n\n## cardview\n\n在实现扁平化的UI处理上，通常离不开阴影和圆角，我们通常是让美工提供一个带有阴影和圆角效果的背景图片，现在我们有了更好的实现方式，那就是CardView。\n\nCardView实际是一个FrameLayout类的子类，它为视图提供卡片样式，并保持在不同平台上拥有统一的风格。CardView组件可以设定阴影和圆角。\n\n我们可以使用cardElevation属性在xml布局中设置阴影效果，在代码中可以通过setCardElevation达到同样的效果。阴影的设置和Android L中的Z属性类似。\n\n设置圆角也相当容易，在xml中通过cardCornerRadius来设置，在代码中则使用setRadius，圆角的设置和Android L中的剪裁很相似。\n\n如果我们想设置cardview的背景，请注意使用carBackgroundColor方法，setBackgroundColor也许会影响我们的圆角效果\n\n## toolbar\n\nToolbar是android L引入的一个新控件，用于取代ActionBar，它提供了ActionBar类似的功能，但是更灵活。不像ActionBar那么固定，Toolbar更像是一般的View元素，可以被放置在view树体系的任意位置，可以应用动画，可以跟着ScrollView滚动，可以与布局中的其他View交互。当然，你还可以用Toolbar替换掉ActionBar，只需调用Activity.setActionBar()。\n\n为了兼容更多的设备一般我们都是通过AppCompat中的android.support.v7.widget.Toolbar来使用Toolbar。\n\n有两种使用Toolbar的方式：\n\n将Toolbar当作actionbar来使用。这种情况一般发生在你想利用actionbar现有的一些功能（比如能够显示菜单中的操作项，响应菜单点击事件，使用ActionBarDrawerToggle等），但是又想获得比actionbar更多的控制权限。\n将Toolbar当作一个独立的控件来使用，这种方式又名Standalone。\n\n如果你要将Toolbar当作actionbar来使用，你首先要去掉actionbar，最简单的方法是使用Theme.AppCompat.NoActionBar主题。或者是设置主题的属性android:windowNoTitle为true。然后在Activity的onCreate中调用setSupportActionBar(toolbar)，原本应该出现在ActionBar上的menu会自动出现在actionbar上。\n\nToolbar的高度、宽度、背景颜色等等一切View的属性完全取决于你，这都是因为Toolbar本质上只是个ViewGroup。将Toolbar当作一个独立的控件来使用是不需要去掉actionbar的（两者可以共存），可以使用任意主题。但是在这种情况下，menu菜单并不会自动的显示在Toolbar上，Toolbar也不会响应菜单的回调函数，如果你想让menu菜单项显示在Toolbar上，必须手动inflate menu。\n\n```\ntoolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() {\n    @Override\n    public boolean onMenuItemClick(MenuItem item) {\n        // 处理menu事件\n        return true;\n    }\n});\n// 创建一个menu添加到toolbar上\ntoolbar.inflateMenu(R.menu.your_toolbar_menu);\n```\n\n## 兼容性\n\n虽然Material Design新增了许多新特性，但是并不是所有新内容对对下保持了兼容。\n\n### 使用v7包\nv7 support libraries r21 及更高版本包含了以下Material Design特性：\n\n使用Theme.AppCompat主题包含调色板主体属性，可以对应用的主题做统一的配色，但是不包括状态栏和底部操作栏\nRecyclerView和CardView被独立出来，只要引入jar包，即可适配7以上的所有版本。\nPalette类用于从图片提取主色调\n\n### 系统组件\n\nTheme.AppCompat主题中提供了这些组件的Material Design style：\n\nEditText\nSpinner\nCheckBox\nRadioButton\nSwitchCompat\nCheckedTextView\nColor Palette\n\n### 创建多个value和layout\n\n针对Android L我们可以创建value-v21指定Material Design主题，而在其他value中指定Theme.AppCompat。layout布局也可以采用该方式，在Android L中使用系统控件，在低版本中使用我们自定义的控件活着第三方包来达到该效果。\n\n### 版本检查\n\n以下特性只在Android 5.0 (API level 21) 及以上版本中可用：\n\n转场动画\n触摸反馈\n圆形展示动画\n路径动画\n矢量图\ntint染色\n所以在代码中遇上使用这些api的地方需要进行版本判断：\n\n```\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n    // 使用新特性\n} else {\n    // 用其他替代方式\n}\n```\n\n## 支持64位art虚拟机\n\n# 6.0 - api 23\n\n## 指纹身份验证\n\n6.0上面可以使用指纹进行身份验证\n\n## 应用链接\n\n此版本通过提供功能更强大的应用链接，增强了 Android 的 intent 系统。您可以利用此功能将应用与您拥有的某个 Web 域关联。平台可以根据此关联确定在处理特定 Web 链接时默认使用的应用，跳过提示用户选择应用的步骤。\n\n## 自动备份应用\n\n现在，系统可以自动为应用执行完整数据备份和恢复。您的应用的目标平台必须是 Android 6.0（API 级别 23），才能启用此行为；您无需额外添加任何代码。如果用户删除其 Google 帐户，其备份数据也会随之删除。要了解该功能的工作方式以及配置文件系统备份内容的方法，请参阅配置应用自动备份。\n\n## 语音交互\n\n调用 isVoiceInteraction() 方法可确定是否是响应语音操作触发了您的 Activity。如果是这样，则您的应用可以使用 VoiceInteractor 类请求用户进行语音确认、从选项列表中进行选择以及执行其他操作。\n大多数语音交互都由用户语音操作发起。但语音交互 Activity 也可在没有用户输入的情况下启动。例如，通过语音交互启动的另一应用也可发送 intent 来启动语音交互。要确定您的 Activity 是由用户语音查询还是另一语音交互应用启动，请调用 isVoiceInteractionRoot() 方法。如果另一应用启动了您的 Activity，该方法会返回 false。您的应用可能随即提示用户确认其有意执行此操作。\n\n## Assist API\n\n此版本提供了一种让用户通过助手程序与应用进行互动的新方式。要使用此功能，用户必须启用助手以使用当前上下文。启用助手后，用户可通过长按首页按钮在任何应用内召唤助手。\n\n您的应用可通过设置 FLAG_SECURE 标记选择不与助手共享当前上下文。除了平台传递给助手的一组标准信息外，您的应用还可利用新增的 AssistContent 类共享其他信息。\n\n要为助手提供您的应用内的其他上下文，请执行以下步骤：\n\n实现 Application.OnProvideAssistDataListener 接口。\n利用 registerOnProvideAssistDataListener() 注册此侦听器。\n要提供特定于 Activity 的上下文信息，请重写 onProvideAssistData() 回调和新的 onProvideAssistContent() 回调（可选操作）\n\n## 可采用的存储设备\n\n使用此版本时，用户可以采用 SD 卡等外部存储设备。采用外部存储设备可加密和格式化设备，使其具有类似内部存储设备的行为。用户可以利用此特性在存储设备之间移动应用及其私有数据。移动应用时，系统会遵守清单中的 android:installLocation 首选项。\n\n请注意，在内部存储设备与外部存储设备之间移动应用时，如果您的应用访问以下 API 或字段，它们返回的文件路径将会动态变化。强烈建议：在生成文件路径时，请始终动态调用这些 API。请勿使用硬编码文件路径或之前生成的永久性完全限定文件路径。\n\nContext 方法：\ngetFilesDir()\ngetCacheDir()\ngetCodeCacheDir()\ngetDatabasePath()\ngetDir()\ngetNoBackupFilesDir()\ngetFileStreamPath()\ngetPackageCodePath()\ngetPackageResourcePath()\nApplicationInfo 字段：\ndataDir\nsourceDir\nnativeLibraryDir\npublicSourceDir\nsplitSourceDirs\nsplitPublicSourceDirs\n\n## 通知\n\n此版本针对通知功能引入了下列 API 变更：\n\n新增了 INTERRUPTION_FILTER_ALARMS 过滤级别，它对应于新增的“仅闹铃”免打扰模式。\n新增了 CATEGORY_REMINDER 类别值，用于区分用户安排的提醒与其他事件 (CATEGORY_EVENT) 和闹铃 (CATEGORY_ALARM)。\n新增了 Icon 类，您可以通过 setSmallIcon()方法和 setLargeIcon()方法将其附加到通知上。同理，addAction() 方法现在接受 Icon 对象，而不接受可绘制资源 ID。\n新增了 getActiveNotifications() 方法，让您的应用能够了解哪些通知目前处于活动状态。要查看使用此功能的应用实现，请参阅 ActiveNotifications 示例。\n\n\n## 相机功能\n\n此版本提供了下列用于访问相机闪光灯和相机图像再处理的新 API：\n\nFlashlight API\n如果相机设备带有闪光灯，您可以通过调用 setTorchMode() 方法，在不打开相机设备的情况下打开或关闭闪光灯的火炬模式。应用对闪光灯或相机设备不享有独占所有权。每当相机设备不可用，或者开启火炬的其他相机资源不可用时，火炬模式即会被关闭并变为不可用状态。其他应用也可调用 setTorchMode() 来关闭火炬模式。当最后一个开启火炬模式的应用关闭时，火炬模式就会被关闭。\n\n您可以注册一个回调，通过调用 registerTorchCallback() 方法接收有关火炬模式状态的通知。第一次注册回调时，系统会立即调用它，并返回所有当前已知配备闪光灯的相机设备的火炬模式状态。如果成功开启或关闭火炬模式，系统会调用 onTorchModeChanged() 方法。\n\nReprocessing API\nCamera2 API 进行了扩展，以支持 YUV 和专用不透明格式图像再处理。要确定这些再处理功能是否可用，请调用 getCameraCharacteristics() 并检查有无 REPROCESS_MAX_CAPTURE_STALL 密钥。如果设备支持再处理，您可以通过调用 createReprocessableCaptureSession() 创建一个可再处理的相机采集会话并创建输入缓冲区再处理请求。\n\n使用 ImageWriter 类可将输入缓冲区流与相机再处理输入相连。要获得空白缓冲区，请遵循以下编程模型：\n\n调用 dequeueInputImage() 方法。\n在输入缓冲区中填充数据。\n通过调用 queueInputImage() 方法将缓冲区发送至相机。\n如果您将 ImageWriter 对象与 PRIVATE 图像一起使用，您的应用并不能直接访问图像数据。请改为调用 queueInputImage() 方法，将 PRIVATE 图像直接传递给 ImageWriter，而不进行任何缓冲区复制。\n\nImageReader 类现在支持 PRIVATE 格式图像流。凭借此支持特性，您的应用可使 ImageReader 输出图像保持为循环图像队列，还可选择一个或多个图像并将其发送给 ImageWriter 进行相机再处理。\n\n# 7.0\n\n## 多窗口支持\n\n就是分屏\n\n## 通知增强功能\n\n在 Android 7.0 中，我们重新设计了通知，使其更易于使用并且速度更快。部分变更包括：\n\n模板更新：我们正在更新通知模板，新强调了英雄形象和化身。开发者将能够充分利用新模板，只需进行少量的代码调整。\n消息传递样式自定义：您可以自定义更多与您的使用 MessagingStyle 类的通知相关的用户界面标签。您可以配置消息、会话标题和内容视图。\n捆绑通知：系统可以将消息组合在一起（例如，按消息主题）并显示组。用户可以适当地进行拒绝或归档等操作。如果您已实现 Android Wear 的通知，那么您已经很熟悉此模式。\n直接回复：对于实时通信应用，Android 系统支持内联回复，以便用户可以直接在通知界面中快速回复短信。\n自定义视图：两个新的 API 让您在通知中使用自定义视图时可以充分利用系统装饰元素，如通知标题和操作。\n\n## Android 中的 ICU4J API\n\nAndroid 7.0 目前在 Android 框架（位于 android.icu 软件包下）中提供 ICU4J API 的子集。迁移很简单，主要是需要从 com.java.icu 命名空间更改为 android.icu。如果您已在您的应用中使用 ICU4J 捆绑包，切换到 Android 框架中提供的 android.icu API 可以大量节省 APK 大小。\n\n## webview\n\nJavascript 在页面加载之前运行\n从以 Android 7.0 为目标平台的应用开始，JavaScript 上下文会在加载新页面时重置。目前，新 WebView 实例中加载的第一个页面会继承上下文。\n\n想要在 WebView 中注入 Javascript 的开发者应在页面开始加载后执行脚本。\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/android1-0-7-0各版本feature.md","raw":"---\ntitle: android1.0-7.0各版本feature\ndate: 2018-03-23 10:03:03\ntags: android\n---\n\n# 5.0 - api 21\n\n## 新出material design\n## view增加了z属性\n\n在5.0之前，我们如果想给view添加阴影效果，以体现其层次感，通常的做法是给view设置一个带阴影的背景图片，现在，我们只需要简单的修改view的Z属性，就能让其具备阴影的层次感。\n\nZ属性会扩大view的显示区域，如果它的大小大于或等于父视图的大小，那么它的阴影效果就无法显示了，view并不会因为z属性而把自身缩小腾出空间显示阴影。\n\nZ属性不仅影响着view的阴影效果，还影响着view的绘制顺序，在同一个父view内部，Z属性越小，绘制的时机就越早。也就是优先被绘制，而z属性越大，则绘制时间越晚，后绘制的将会遮盖住先绘制的，只有Z属性相同，才按照添加的顺序绘制。\n\n## view增加了轮廓\n\n在xml布局中，可以通过android:outlineProvider来指定轮廓的判定方式：\n\nnone 即使设置了Z属性，也不会显示阴影\nbackground 会按照背景来设置阴影形状\nbounds 会按照View的大小来描绘阴影\npaddedBounds 和bounds类似，不过阴影会稍微向右偏移一点\n\n在代码中，我们可以通过setOutlineProvider来指定一个View的轮廓：\n```\nViewOutlineProvider viewOutlineProvider = new ViewOutlineProvider() {\n    public void getOutline(View view, Outline outline) {\n        // 可以指定圆形，矩形，圆角矩形，path\n        outline.setOval(0, 0, view.getWidth(), view.getHeight());\n    }\n};\nView.setOutlineProvider(viewOutlineProvider );\n```\n\n## view的裁剪\n\n给View指定轮廓，可以决定阴影的显示形状，如果给View指定一个小于自身大小的轮廓，正常情况下阴影会被View遮住，这个时候View的显示内容并没有因为轮廓的缩小而缩小。\n\n如果想根据轮廓来缩小一个View，则可以通过剪裁。如果一个View指定了轮廓，调用setClipToOutline方法，就可以根据轮廓来剪裁一个View。想要剪裁轮廓，必须要给View先指定轮廓，并且轮廓是可以被剪裁的，目前只有圆形，矩形，圆角矩形支持剪裁，可以通过outline.canClip()来判断一个轮廓是否支持剪裁。\n\nPath剪裁不会改变View的大小，但是如果Path的范围比View要的bounds要小，则剪裁后会改变View的位置，位置偏移和Z属性有关，这可能是一个BUG，view的设计者可能在绘制阴影时根据轮廓偏移了画布，而在绘制完后忘记把画布还原了。\n\n剪裁不会改变View的测量大小和布局大小，也不会改变View的触摸区域，剪裁只是在onDraw的时候对画布做了剪裁处理，剪裁也不同于scale，scale是调整画布matrix的缩放属性，调整后，View仍然能完整显示，而剪裁是缩小画布的剪裁区域，剪裁后我们只能看到View的一部分。\n\n试图给View一个比较大的轮廓进行剪裁也是不成功的，实验证明剪裁后的View只能比原有体积小，扩大轮廓只会扩大轮廓的绘制区域。\n\n剪裁是一个非常消耗资源的操作，我们不应该用此来做动画效果，如果要实现这样的动画，可以使用Reveal Effect\n\n## tint属性\n\ntint属性是一个颜色值，可以对图片做颜色渲染，我们可以给view的背景设置tint色值，给ImageView的图片设置tint色值，也可以给任意Drawable或者NinePatchDrawable设置tint色值。\n\n在应用的主题中也可以通过设置 android:tint 来给主题设置统一的颜色渲染。\n\ntint的渲染模式有总共有16种，xml文件中可以使用6种，代码中我们可以设置16种，渲染模式决定了渲染颜色和原图颜色的取舍和合成规则：\n\nPorterDuff.Mode.CLEAR 所绘制不会提交到画布上。\nPorterDuff.Mode.SRC 显示上层绘制图片\nPorterDuff.Mode.DST 显示下层绘制图片\nPorterDuff.Mode.SRC_OVER 正常绘制显示，上下层绘制叠盖。\nPorterDuff.Mode.DST_OVER 上下层都显示。下层居上显示。\nPorterDuff.Mode.SRC_IN 取两层绘制交集。显示上层。\nPorterDuff.Mode.DST_IN 取两层绘制交集。显示下层。\nPorterDuff.Mode.SRC_OUT 取上层绘制非交集部分。\nPorterDuff.Mode.DST_OUT 取下层绘制非交集部分。\nPorterDuff.Mode.SRC_ATOP 取下层非交集部分与上层交集部分\nPorterDuff.Mode.DST_ATOP 取上层非交集部分与下层交集部分\nPorterDuff.Mode.XOR 取两层绘制非交集。两层绘制非交集。\nPorterDuff.Mode.DARKEN 上下层都显示。变暗\nPorterDuff.Mode.LIGHTEN 上下层都显示。变亮\nPorterDuff.Mode.MULTIPLY 取两层绘制交集\nPorterDuff.Mode.SCREEN 上下层都显示。\n\n通过tint属性处理后的图片会和原图显示出不一样的颜色，我们可以通过这种方式利用一张图片做出图片选择器的效果，让控件在按压状态下显示另外一种颜色:\n```\n通过给图片设置tint色生成另外一种图片\n<bitmap xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:src=\"@drawable/ring\"\n        android:tintMode=\"multiply\"\n        android:tint=\"#5677fc\" />\n利用新的图片生成图片选择器\n<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n        <item android:drawable=\"@drawable/tint_bitmap\" android:state_pressed=\"true\"/>\n        <item android:drawable=\"@drawable/ring\" />\n</selector>\n```\n\n## Palette调色版\n\nPalette调色板，可以很方便的让我们从图片中提取颜色。并且可以指定提取某种类型的颜色。\nVibrant 鲜艳的\nVibrant dark鲜艳的暗色\nVibrant light鲜艳的亮色\nMuted 柔和的\nMuted dark柔和的暗色\nMuted light柔和的亮色\n\n对图片取色是一个比较消耗性能的操作，其内部会对图片的像素值进来遍历以分析对比，所以我们要在异步线程中去完成。\n\n```\n如果操作本来就属于后台线程，可以使用：\nPalette p = Palette.generate(Bitmap bitmap);\n如果在主线程中，我们可以使用异步的方式：\nPalette.generateAsync(bitmap, new Palette.PaletteAsyncListener() {\n        public void onGenerated(Palette palette) {  }\n});\n```\n\n当操作完成后或者异步回调后，我们就可以使用以下方式来获取对应的色值了，并且可以在没有获取到的情况下之指定默认值：\n```\np.getVibrantColor(int defaultColor);\np.getDarkVibrantColor(int defaultColor);\np.getLightVibrantColor(int defaultColor);\np.getMutedColor(int defaultColor);\np.getDarkMutedColor(int defaultColor);\np.getLightMutedColor(int defaultColor);\n```\n\n在使用palette之前，bitmap提供获取指定位置的像素值：\n```\nbitmap.getPixel(x,y)\n```\n\n但是该方式只能获取某一点的像素值，palette是对整个bitmap的所有像素值进行分析，并选出几个像素占比比较多的像素值，这样选择出来的色值更符合图片的整体色值。\n\n## vector矢量图\n\n矢量图也称为面向对象的图像或绘图图像，是计算机图形学中用点、直线或者多边形等基于数学方程的几何图元表示的图像。矢量图形最大的优点是无论放大、缩小或旋转等不会失真；最大的缺点是难以表现色彩层次丰富、逼真的图像效果。\n\nAndroid L开始支持矢量图，我们可以用它来处理一些图形简单的icon，方便我们的适配。\n\nAndroid L中对矢量图的支持是通过xml文件构建，通过矢量图的path描述来生成一个矢量图，对应的java对象为VectorDrawable。\n\n下面是官方文档提供的一个矢量图，利用改文件，我们可以创建一个随意放大缩小都不会失真的心形。\n\n```\n<vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:height=\"300dp\"\n        android:width=\"300dp\"\n        android:viewportHeight=\"40\"\n        android:viewportWidth=\"40\">\n        <path android:fillColor=\"#ff00ff\"\n                android:pathData=\"M20.5,9.5\n                        c-1.955,0,-3.83,1.268,-4.5,3\n                        c-0.67,-1.732,-2.547,-3,-4.5,-3\n                        C8.957,9.5,7,11.432,7,14\n                        c0,3.53,3.793,6.257,9,11.5\n                        c5.207,-5.242,9,-7.97,9,-11.5\n                        C25,11.432,23.043,9.5,20.5,9.5z\"/>\n</vector>\n```\n\n矢量图的pathData数据就是用来描述矢量图的数学公式，其含义如下表：\n\n命令类型\t使用描述\t代表含义\t\t\t\t\t举例说明\n移动指令\tM x,y\tM移动绝对位置\t\t\t\tM 100,240\n移动指令\tm x,y\tm移动相对于上一个点\t\tm 100,240\n绘制\t\tL 或 l\t从当前点绘制直线到指定点\tL 100,100\n绘制\t\tH 或 h\t水平直线\t\t\t\t\th 100\n绘制\t\tV 或 v\t垂直直线\t\t\t\t\tv 100\n绘制\t\tC 或 c\t三次方程式贝塞尔曲线\t\tC 100,200 200,400 300,200\n绘制\t\tQ 或 q\t二次方程式贝塞尔曲线\t\tQ 100,200 300,200\n绘制\t\tS 或 s\t平滑三次方程式贝塞尔曲线\tS 100,200 200,400 300,200\n绘制\t\tT 或 t\t平滑二次方程式贝塞尔曲线\tT 100,200 300,200\n绘制\t\tA 或 a\t椭圆\t\t\t\t\t\tA 5,5 0 0 1 10,10\n关闭指令\tZ 或 z\t将图形的首、尾点用直线连接\tZ\n填充\t\tF0\tEvenOdd 填充规则\t\n填充\t\tF1\tNonzero 填充规则\t\n\n通过path命令来进行简单的图形还是可行的，但是复杂的图形我们就需要借助工具来生成了，比如使用 Expression Design，就可以直接粘贴来自其它软件的矢量图形，然后选择导出，导出时做如后选择：文件->导出->导出属性->格式->XAML Silverlight 画布，即可得到XAML格式的矢量图形，也就是Path。\n\n更多矢量图学习可参考：http://www.w3.org/TR/SVG11/paths.html#PathData 我们可以访问http://editor.method.ac 在线制作矢量图并导出path。\n\n\n## 新增widget\n\n## RecyclerView\n\nRecyclerView是ListView的升级版，它具备了更好的性能，且更容易使用。和ListView一样，RecyclerView是用来显示大量数据的容器，并通过复用有限数量的View，来提高滚动时的性能。当你的视图上的元素经常动态的且有规律的改变时候，可以使用RecyclerView控件。\n\n与ListView不同的是RecyclerView不再负责布局，只专注于复用机制，布局交由LayoutManager来管理。 RecyclerView仍然通过Adapter来获取需要显示的对象。\n\n要使用RecyclerView组件，创建Adapter不再继承自BaseAdapter，而是应该继承自RecyclerView.Adapter类，并且最好指定一个继承自RecyclerView.ViewHolder的范型，Adapter不再要求你返回一个View，而是一个ViewHolder。\n\n继承自Adapter后，需要实现3个抽象方法：\n\n```\n// 当RecyclerView需要一个ViewHolder时会回调该方法，如果有可复用的View则该方法不会得倒回调\npublic RecyclerView.ViewHolder onCreateViewHolder(ViewGroup viewGroup, int i)；\n// 当一个View需要出现在屏幕上时，该方法会被回调，你需要在该方法中根据数据来更改视图\npublic void onBindViewHolder(RecyclerView.ViewHolder viewHolder, int i)；\n// 用于告诉RecyclerView有多个视图需要显示\npublic int getItemCount()；\n```\n\n新的Adapter和原有的Adapter并没有太多的差别，只是不再需要我们写复用判断的逻辑，因为复用逻辑其实都是相似的，它已经有了自身的实现。和原有的Adapter一样，仍然可以通过notifyDataSetChanged来刷新UI，通过getItemViewType来获取对应位置的类型，但是它不再需要你指定有多少类型了，因为该方法已经能够判断出有多少类型。新增的onViewRecycled方法可以让使用者监听View被移除屏幕的时机，并且还提供了一个AdapterDataObserver的观察者，对外提供数据改变时的回调。\n\nViewHolder是对所有的单个item的封装，不仅包含了item需要显示的View，并且还包含和item相关的其它数据，例如：当前的position、之前的position、即将显示的position、被回收的次数、View的类型、是否处于显示中等信息。创建一个ViewHolder需要传递一个View对象，这个View就是该holder的显示视图，该View中通常会包含一些子视图，我们最好把这些子视图都记录在holder中，便于复用时设置不同的数据。\n\nRecyclerView不再对布局进行管理，而是通过LayoutManager管理布局，我们可以通过继承自LayoutManager来实现特殊的布局，系统提供了三种常用的布局管理器：\n\nLinearLayoutManager 线性布局\nGridLayoutManager 九宫格布局\nStaggeredGridLayoutManager 瀑布流布局\n\n并且每一种都可以设置横行和纵向的布局，可惜的均不能添加header，如果要添加header，我们可以在Adapter中使用不同的类型来达到该效果。\n\nRecyclerView默认提供了item的增加和删除的动画效果，如果我们使用自定义的动画，需要继承继承RecyclerView.ItemAnimator类，通过RecyclerView.setItemAnimator()方法来设置我们自定义的动画。\n\n## cardview\n\n在实现扁平化的UI处理上，通常离不开阴影和圆角，我们通常是让美工提供一个带有阴影和圆角效果的背景图片，现在我们有了更好的实现方式，那就是CardView。\n\nCardView实际是一个FrameLayout类的子类，它为视图提供卡片样式，并保持在不同平台上拥有统一的风格。CardView组件可以设定阴影和圆角。\n\n我们可以使用cardElevation属性在xml布局中设置阴影效果，在代码中可以通过setCardElevation达到同样的效果。阴影的设置和Android L中的Z属性类似。\n\n设置圆角也相当容易，在xml中通过cardCornerRadius来设置，在代码中则使用setRadius，圆角的设置和Android L中的剪裁很相似。\n\n如果我们想设置cardview的背景，请注意使用carBackgroundColor方法，setBackgroundColor也许会影响我们的圆角效果\n\n## toolbar\n\nToolbar是android L引入的一个新控件，用于取代ActionBar，它提供了ActionBar类似的功能，但是更灵活。不像ActionBar那么固定，Toolbar更像是一般的View元素，可以被放置在view树体系的任意位置，可以应用动画，可以跟着ScrollView滚动，可以与布局中的其他View交互。当然，你还可以用Toolbar替换掉ActionBar，只需调用Activity.setActionBar()。\n\n为了兼容更多的设备一般我们都是通过AppCompat中的android.support.v7.widget.Toolbar来使用Toolbar。\n\n有两种使用Toolbar的方式：\n\n将Toolbar当作actionbar来使用。这种情况一般发生在你想利用actionbar现有的一些功能（比如能够显示菜单中的操作项，响应菜单点击事件，使用ActionBarDrawerToggle等），但是又想获得比actionbar更多的控制权限。\n将Toolbar当作一个独立的控件来使用，这种方式又名Standalone。\n\n如果你要将Toolbar当作actionbar来使用，你首先要去掉actionbar，最简单的方法是使用Theme.AppCompat.NoActionBar主题。或者是设置主题的属性android:windowNoTitle为true。然后在Activity的onCreate中调用setSupportActionBar(toolbar)，原本应该出现在ActionBar上的menu会自动出现在actionbar上。\n\nToolbar的高度、宽度、背景颜色等等一切View的属性完全取决于你，这都是因为Toolbar本质上只是个ViewGroup。将Toolbar当作一个独立的控件来使用是不需要去掉actionbar的（两者可以共存），可以使用任意主题。但是在这种情况下，menu菜单并不会自动的显示在Toolbar上，Toolbar也不会响应菜单的回调函数，如果你想让menu菜单项显示在Toolbar上，必须手动inflate menu。\n\n```\ntoolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() {\n    @Override\n    public boolean onMenuItemClick(MenuItem item) {\n        // 处理menu事件\n        return true;\n    }\n});\n// 创建一个menu添加到toolbar上\ntoolbar.inflateMenu(R.menu.your_toolbar_menu);\n```\n\n## 兼容性\n\n虽然Material Design新增了许多新特性，但是并不是所有新内容对对下保持了兼容。\n\n### 使用v7包\nv7 support libraries r21 及更高版本包含了以下Material Design特性：\n\n使用Theme.AppCompat主题包含调色板主体属性，可以对应用的主题做统一的配色，但是不包括状态栏和底部操作栏\nRecyclerView和CardView被独立出来，只要引入jar包，即可适配7以上的所有版本。\nPalette类用于从图片提取主色调\n\n### 系统组件\n\nTheme.AppCompat主题中提供了这些组件的Material Design style：\n\nEditText\nSpinner\nCheckBox\nRadioButton\nSwitchCompat\nCheckedTextView\nColor Palette\n\n### 创建多个value和layout\n\n针对Android L我们可以创建value-v21指定Material Design主题，而在其他value中指定Theme.AppCompat。layout布局也可以采用该方式，在Android L中使用系统控件，在低版本中使用我们自定义的控件活着第三方包来达到该效果。\n\n### 版本检查\n\n以下特性只在Android 5.0 (API level 21) 及以上版本中可用：\n\n转场动画\n触摸反馈\n圆形展示动画\n路径动画\n矢量图\ntint染色\n所以在代码中遇上使用这些api的地方需要进行版本判断：\n\n```\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n    // 使用新特性\n} else {\n    // 用其他替代方式\n}\n```\n\n## 支持64位art虚拟机\n\n# 6.0 - api 23\n\n## 指纹身份验证\n\n6.0上面可以使用指纹进行身份验证\n\n## 应用链接\n\n此版本通过提供功能更强大的应用链接，增强了 Android 的 intent 系统。您可以利用此功能将应用与您拥有的某个 Web 域关联。平台可以根据此关联确定在处理特定 Web 链接时默认使用的应用，跳过提示用户选择应用的步骤。\n\n## 自动备份应用\n\n现在，系统可以自动为应用执行完整数据备份和恢复。您的应用的目标平台必须是 Android 6.0（API 级别 23），才能启用此行为；您无需额外添加任何代码。如果用户删除其 Google 帐户，其备份数据也会随之删除。要了解该功能的工作方式以及配置文件系统备份内容的方法，请参阅配置应用自动备份。\n\n## 语音交互\n\n调用 isVoiceInteraction() 方法可确定是否是响应语音操作触发了您的 Activity。如果是这样，则您的应用可以使用 VoiceInteractor 类请求用户进行语音确认、从选项列表中进行选择以及执行其他操作。\n大多数语音交互都由用户语音操作发起。但语音交互 Activity 也可在没有用户输入的情况下启动。例如，通过语音交互启动的另一应用也可发送 intent 来启动语音交互。要确定您的 Activity 是由用户语音查询还是另一语音交互应用启动，请调用 isVoiceInteractionRoot() 方法。如果另一应用启动了您的 Activity，该方法会返回 false。您的应用可能随即提示用户确认其有意执行此操作。\n\n## Assist API\n\n此版本提供了一种让用户通过助手程序与应用进行互动的新方式。要使用此功能，用户必须启用助手以使用当前上下文。启用助手后，用户可通过长按首页按钮在任何应用内召唤助手。\n\n您的应用可通过设置 FLAG_SECURE 标记选择不与助手共享当前上下文。除了平台传递给助手的一组标准信息外，您的应用还可利用新增的 AssistContent 类共享其他信息。\n\n要为助手提供您的应用内的其他上下文，请执行以下步骤：\n\n实现 Application.OnProvideAssistDataListener 接口。\n利用 registerOnProvideAssistDataListener() 注册此侦听器。\n要提供特定于 Activity 的上下文信息，请重写 onProvideAssistData() 回调和新的 onProvideAssistContent() 回调（可选操作）\n\n## 可采用的存储设备\n\n使用此版本时，用户可以采用 SD 卡等外部存储设备。采用外部存储设备可加密和格式化设备，使其具有类似内部存储设备的行为。用户可以利用此特性在存储设备之间移动应用及其私有数据。移动应用时，系统会遵守清单中的 android:installLocation 首选项。\n\n请注意，在内部存储设备与外部存储设备之间移动应用时，如果您的应用访问以下 API 或字段，它们返回的文件路径将会动态变化。强烈建议：在生成文件路径时，请始终动态调用这些 API。请勿使用硬编码文件路径或之前生成的永久性完全限定文件路径。\n\nContext 方法：\ngetFilesDir()\ngetCacheDir()\ngetCodeCacheDir()\ngetDatabasePath()\ngetDir()\ngetNoBackupFilesDir()\ngetFileStreamPath()\ngetPackageCodePath()\ngetPackageResourcePath()\nApplicationInfo 字段：\ndataDir\nsourceDir\nnativeLibraryDir\npublicSourceDir\nsplitSourceDirs\nsplitPublicSourceDirs\n\n## 通知\n\n此版本针对通知功能引入了下列 API 变更：\n\n新增了 INTERRUPTION_FILTER_ALARMS 过滤级别，它对应于新增的“仅闹铃”免打扰模式。\n新增了 CATEGORY_REMINDER 类别值，用于区分用户安排的提醒与其他事件 (CATEGORY_EVENT) 和闹铃 (CATEGORY_ALARM)。\n新增了 Icon 类，您可以通过 setSmallIcon()方法和 setLargeIcon()方法将其附加到通知上。同理，addAction() 方法现在接受 Icon 对象，而不接受可绘制资源 ID。\n新增了 getActiveNotifications() 方法，让您的应用能够了解哪些通知目前处于活动状态。要查看使用此功能的应用实现，请参阅 ActiveNotifications 示例。\n\n\n## 相机功能\n\n此版本提供了下列用于访问相机闪光灯和相机图像再处理的新 API：\n\nFlashlight API\n如果相机设备带有闪光灯，您可以通过调用 setTorchMode() 方法，在不打开相机设备的情况下打开或关闭闪光灯的火炬模式。应用对闪光灯或相机设备不享有独占所有权。每当相机设备不可用，或者开启火炬的其他相机资源不可用时，火炬模式即会被关闭并变为不可用状态。其他应用也可调用 setTorchMode() 来关闭火炬模式。当最后一个开启火炬模式的应用关闭时，火炬模式就会被关闭。\n\n您可以注册一个回调，通过调用 registerTorchCallback() 方法接收有关火炬模式状态的通知。第一次注册回调时，系统会立即调用它，并返回所有当前已知配备闪光灯的相机设备的火炬模式状态。如果成功开启或关闭火炬模式，系统会调用 onTorchModeChanged() 方法。\n\nReprocessing API\nCamera2 API 进行了扩展，以支持 YUV 和专用不透明格式图像再处理。要确定这些再处理功能是否可用，请调用 getCameraCharacteristics() 并检查有无 REPROCESS_MAX_CAPTURE_STALL 密钥。如果设备支持再处理，您可以通过调用 createReprocessableCaptureSession() 创建一个可再处理的相机采集会话并创建输入缓冲区再处理请求。\n\n使用 ImageWriter 类可将输入缓冲区流与相机再处理输入相连。要获得空白缓冲区，请遵循以下编程模型：\n\n调用 dequeueInputImage() 方法。\n在输入缓冲区中填充数据。\n通过调用 queueInputImage() 方法将缓冲区发送至相机。\n如果您将 ImageWriter 对象与 PRIVATE 图像一起使用，您的应用并不能直接访问图像数据。请改为调用 queueInputImage() 方法，将 PRIVATE 图像直接传递给 ImageWriter，而不进行任何缓冲区复制。\n\nImageReader 类现在支持 PRIVATE 格式图像流。凭借此支持特性，您的应用可使 ImageReader 输出图像保持为循环图像队列，还可选择一个或多个图像并将其发送给 ImageWriter 进行相机再处理。\n\n# 7.0\n\n## 多窗口支持\n\n就是分屏\n\n## 通知增强功能\n\n在 Android 7.0 中，我们重新设计了通知，使其更易于使用并且速度更快。部分变更包括：\n\n模板更新：我们正在更新通知模板，新强调了英雄形象和化身。开发者将能够充分利用新模板，只需进行少量的代码调整。\n消息传递样式自定义：您可以自定义更多与您的使用 MessagingStyle 类的通知相关的用户界面标签。您可以配置消息、会话标题和内容视图。\n捆绑通知：系统可以将消息组合在一起（例如，按消息主题）并显示组。用户可以适当地进行拒绝或归档等操作。如果您已实现 Android Wear 的通知，那么您已经很熟悉此模式。\n直接回复：对于实时通信应用，Android 系统支持内联回复，以便用户可以直接在通知界面中快速回复短信。\n自定义视图：两个新的 API 让您在通知中使用自定义视图时可以充分利用系统装饰元素，如通知标题和操作。\n\n## Android 中的 ICU4J API\n\nAndroid 7.0 目前在 Android 框架（位于 android.icu 软件包下）中提供 ICU4J API 的子集。迁移很简单，主要是需要从 com.java.icu 命名空间更改为 android.icu。如果您已在您的应用中使用 ICU4J 捆绑包，切换到 Android 框架中提供的 android.icu API 可以大量节省 APK 大小。\n\n## webview\n\nJavascript 在页面加载之前运行\n从以 Android 7.0 为目标平台的应用开始，JavaScript 上下文会在加载新页面时重置。目前，新 WebView 实例中加载的第一个页面会继承上下文。\n\n想要在 WebView 中注入 Javascript 的开发者应在页面开始加载后执行脚本。\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"android1-0-7-0各版本feature","published":1,"updated":"2019-03-12T09:26:33.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltu0i007g3a8k6xovy918","content":"<h1 id=\"5-0-api-21\"><a href=\"#5-0-api-21\" class=\"headerlink\" title=\"5.0 - api 21\"></a>5.0 - api 21</h1><h2 id=\"新出material-design\"><a href=\"#新出material-design\" class=\"headerlink\" title=\"新出material design\"></a>新出material design</h2><h2 id=\"view增加了z属性\"><a href=\"#view增加了z属性\" class=\"headerlink\" title=\"view增加了z属性\"></a>view增加了z属性</h2><p>在5.0之前，我们如果想给view添加阴影效果，以体现其层次感，通常的做法是给view设置一个带阴影的背景图片，现在，我们只需要简单的修改view的Z属性，就能让其具备阴影的层次感。</p>\n<p>Z属性会扩大view的显示区域，如果它的大小大于或等于父视图的大小，那么它的阴影效果就无法显示了，view并不会因为z属性而把自身缩小腾出空间显示阴影。</p>\n<p>Z属性不仅影响着view的阴影效果，还影响着view的绘制顺序，在同一个父view内部，Z属性越小，绘制的时机就越早。也就是优先被绘制，而z属性越大，则绘制时间越晚，后绘制的将会遮盖住先绘制的，只有Z属性相同，才按照添加的顺序绘制。</p>\n<h2 id=\"view增加了轮廓\"><a href=\"#view增加了轮廓\" class=\"headerlink\" title=\"view增加了轮廓\"></a>view增加了轮廓</h2><p>在xml布局中，可以通过android:outlineProvider来指定轮廓的判定方式：</p>\n<p>none 即使设置了Z属性，也不会显示阴影<br>background 会按照背景来设置阴影形状<br>bounds 会按照View的大小来描绘阴影<br>paddedBounds 和bounds类似，不过阴影会稍微向右偏移一点</p>\n<p>在代码中，我们可以通过setOutlineProvider来指定一个View的轮廓：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ViewOutlineProvider viewOutlineProvider = new ViewOutlineProvider() &#123;</span><br><span class=\"line\">    public void getOutline(View view, Outline outline) &#123;</span><br><span class=\"line\">        // 可以指定圆形，矩形，圆角矩形，path</span><br><span class=\"line\">        outline.setOval(0, 0, view.getWidth(), view.getHeight());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">View.setOutlineProvider(viewOutlineProvider );</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"view的裁剪\"><a href=\"#view的裁剪\" class=\"headerlink\" title=\"view的裁剪\"></a>view的裁剪</h2><p>给View指定轮廓，可以决定阴影的显示形状，如果给View指定一个小于自身大小的轮廓，正常情况下阴影会被View遮住，这个时候View的显示内容并没有因为轮廓的缩小而缩小。</p>\n<p>如果想根据轮廓来缩小一个View，则可以通过剪裁。如果一个View指定了轮廓，调用setClipToOutline方法，就可以根据轮廓来剪裁一个View。想要剪裁轮廓，必须要给View先指定轮廓，并且轮廓是可以被剪裁的，目前只有圆形，矩形，圆角矩形支持剪裁，可以通过outline.canClip()来判断一个轮廓是否支持剪裁。</p>\n<p>Path剪裁不会改变View的大小，但是如果Path的范围比View要的bounds要小，则剪裁后会改变View的位置，位置偏移和Z属性有关，这可能是一个BUG，view的设计者可能在绘制阴影时根据轮廓偏移了画布，而在绘制完后忘记把画布还原了。</p>\n<p>剪裁不会改变View的测量大小和布局大小，也不会改变View的触摸区域，剪裁只是在onDraw的时候对画布做了剪裁处理，剪裁也不同于scale，scale是调整画布matrix的缩放属性，调整后，View仍然能完整显示，而剪裁是缩小画布的剪裁区域，剪裁后我们只能看到View的一部分。</p>\n<p>试图给View一个比较大的轮廓进行剪裁也是不成功的，实验证明剪裁后的View只能比原有体积小，扩大轮廓只会扩大轮廓的绘制区域。</p>\n<p>剪裁是一个非常消耗资源的操作，我们不应该用此来做动画效果，如果要实现这样的动画，可以使用Reveal Effect</p>\n<h2 id=\"tint属性\"><a href=\"#tint属性\" class=\"headerlink\" title=\"tint属性\"></a>tint属性</h2><p>tint属性是一个颜色值，可以对图片做颜色渲染，我们可以给view的背景设置tint色值，给ImageView的图片设置tint色值，也可以给任意Drawable或者NinePatchDrawable设置tint色值。</p>\n<p>在应用的主题中也可以通过设置 android:tint 来给主题设置统一的颜色渲染。</p>\n<p>tint的渲染模式有总共有16种，xml文件中可以使用6种，代码中我们可以设置16种，渲染模式决定了渲染颜色和原图颜色的取舍和合成规则：</p>\n<p>PorterDuff.Mode.CLEAR 所绘制不会提交到画布上。<br>PorterDuff.Mode.SRC 显示上层绘制图片<br>PorterDuff.Mode.DST 显示下层绘制图片<br>PorterDuff.Mode.SRC_OVER 正常绘制显示，上下层绘制叠盖。<br>PorterDuff.Mode.DST_OVER 上下层都显示。下层居上显示。<br>PorterDuff.Mode.SRC_IN 取两层绘制交集。显示上层。<br>PorterDuff.Mode.DST_IN 取两层绘制交集。显示下层。<br>PorterDuff.Mode.SRC_OUT 取上层绘制非交集部分。<br>PorterDuff.Mode.DST_OUT 取下层绘制非交集部分。<br>PorterDuff.Mode.SRC_ATOP 取下层非交集部分与上层交集部分<br>PorterDuff.Mode.DST_ATOP 取上层非交集部分与下层交集部分<br>PorterDuff.Mode.XOR 取两层绘制非交集。两层绘制非交集。<br>PorterDuff.Mode.DARKEN 上下层都显示。变暗<br>PorterDuff.Mode.LIGHTEN 上下层都显示。变亮<br>PorterDuff.Mode.MULTIPLY 取两层绘制交集<br>PorterDuff.Mode.SCREEN 上下层都显示。</p>\n<p>通过tint属性处理后的图片会和原图显示出不一样的颜色，我们可以通过这种方式利用一张图片做出图片选择器的效果，让控件在按压状态下显示另外一种颜色:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过给图片设置tint色生成另外一种图片</span><br><span class=\"line\">&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">        android:src=&quot;@drawable/ring&quot;</span><br><span class=\"line\">        android:tintMode=&quot;multiply&quot;</span><br><span class=\"line\">        android:tint=&quot;#5677fc&quot; /&gt;</span><br><span class=\"line\">利用新的图片生成图片选择器</span><br><span class=\"line\">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class=\"line\">        &lt;item android:drawable=&quot;@drawable/tint_bitmap&quot; android:state_pressed=&quot;true&quot;/&gt;</span><br><span class=\"line\">        &lt;item android:drawable=&quot;@drawable/ring&quot; /&gt;</span><br><span class=\"line\">&lt;/selector&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Palette调色版\"><a href=\"#Palette调色版\" class=\"headerlink\" title=\"Palette调色版\"></a>Palette调色版</h2><p>Palette调色板，可以很方便的让我们从图片中提取颜色。并且可以指定提取某种类型的颜色。<br>Vibrant 鲜艳的<br>Vibrant dark鲜艳的暗色<br>Vibrant light鲜艳的亮色<br>Muted 柔和的<br>Muted dark柔和的暗色<br>Muted light柔和的亮色</p>\n<p>对图片取色是一个比较消耗性能的操作，其内部会对图片的像素值进来遍历以分析对比，所以我们要在异步线程中去完成。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果操作本来就属于后台线程，可以使用：</span><br><span class=\"line\">Palette p = Palette.generate(Bitmap bitmap);</span><br><span class=\"line\">如果在主线程中，我们可以使用异步的方式：</span><br><span class=\"line\">Palette.generateAsync(bitmap, new Palette.PaletteAsyncListener() &#123;</span><br><span class=\"line\">        public void onGenerated(Palette palette) &#123;  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>当操作完成后或者异步回调后，我们就可以使用以下方式来获取对应的色值了，并且可以在没有获取到的情况下之指定默认值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.getVibrantColor(int defaultColor);</span><br><span class=\"line\">p.getDarkVibrantColor(int defaultColor);</span><br><span class=\"line\">p.getLightVibrantColor(int defaultColor);</span><br><span class=\"line\">p.getMutedColor(int defaultColor);</span><br><span class=\"line\">p.getDarkMutedColor(int defaultColor);</span><br><span class=\"line\">p.getLightMutedColor(int defaultColor);</span><br></pre></td></tr></table></figure></p>\n<p>在使用palette之前，bitmap提供获取指定位置的像素值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bitmap.getPixel(x,y)</span><br></pre></td></tr></table></figure></p>\n<p>但是该方式只能获取某一点的像素值，palette是对整个bitmap的所有像素值进行分析，并选出几个像素占比比较多的像素值，这样选择出来的色值更符合图片的整体色值。</p>\n<h2 id=\"vector矢量图\"><a href=\"#vector矢量图\" class=\"headerlink\" title=\"vector矢量图\"></a>vector矢量图</h2><p>矢量图也称为面向对象的图像或绘图图像，是计算机图形学中用点、直线或者多边形等基于数学方程的几何图元表示的图像。矢量图形最大的优点是无论放大、缩小或旋转等不会失真；最大的缺点是难以表现色彩层次丰富、逼真的图像效果。</p>\n<p>Android L开始支持矢量图，我们可以用它来处理一些图形简单的icon，方便我们的适配。</p>\n<p>Android L中对矢量图的支持是通过xml文件构建，通过矢量图的path描述来生成一个矢量图，对应的java对象为VectorDrawable。</p>\n<p>下面是官方文档提供的一个矢量图，利用改文件，我们可以创建一个随意放大缩小都不会失真的心形。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">        android:height=&quot;300dp&quot;</span><br><span class=\"line\">        android:width=&quot;300dp&quot;</span><br><span class=\"line\">        android:viewportHeight=&quot;40&quot;</span><br><span class=\"line\">        android:viewportWidth=&quot;40&quot;&gt;</span><br><span class=\"line\">        &lt;path android:fillColor=&quot;#ff00ff&quot;</span><br><span class=\"line\">                android:pathData=&quot;M20.5,9.5</span><br><span class=\"line\">                        c-1.955,0,-3.83,1.268,-4.5,3</span><br><span class=\"line\">                        c-0.67,-1.732,-2.547,-3,-4.5,-3</span><br><span class=\"line\">                        C8.957,9.5,7,11.432,7,14</span><br><span class=\"line\">                        c0,3.53,3.793,6.257,9,11.5</span><br><span class=\"line\">                        c5.207,-5.242,9,-7.97,9,-11.5</span><br><span class=\"line\">                        C25,11.432,23.043,9.5,20.5,9.5z&quot;/&gt;</span><br><span class=\"line\">&lt;/vector&gt;</span><br></pre></td></tr></table></figure>\n<p>矢量图的pathData数据就是用来描述矢量图的数学公式，其含义如下表：</p>\n<p>命令类型    使用描述    代表含义                    举例说明<br>移动指令    M x,y    M移动绝对位置                M 100,240<br>移动指令    m x,y    m移动相对于上一个点        m 100,240<br>绘制        L 或 l    从当前点绘制直线到指定点    L 100,100<br>绘制        H 或 h    水平直线                    h 100<br>绘制        V 或 v    垂直直线                    v 100<br>绘制        C 或 c    三次方程式贝塞尔曲线        C 100,200 200,400 300,200<br>绘制        Q 或 q    二次方程式贝塞尔曲线        Q 100,200 300,200<br>绘制        S 或 s    平滑三次方程式贝塞尔曲线    S 100,200 200,400 300,200<br>绘制        T 或 t    平滑二次方程式贝塞尔曲线    T 100,200 300,200<br>绘制        A 或 a    椭圆                        A 5,5 0 0 1 10,10<br>关闭指令    Z 或 z    将图形的首、尾点用直线连接    Z<br>填充        F0    EvenOdd 填充规则<br>填充        F1    Nonzero 填充规则    </p>\n<p>通过path命令来进行简单的图形还是可行的，但是复杂的图形我们就需要借助工具来生成了，比如使用 Expression Design，就可以直接粘贴来自其它软件的矢量图形，然后选择导出，导出时做如后选择：文件-&gt;导出-&gt;导出属性-&gt;格式-&gt;XAML Silverlight 画布，即可得到XAML格式的矢量图形，也就是Path。</p>\n<p>更多矢量图学习可参考：<a href=\"http://www.w3.org/TR/SVG11/paths.html#PathData\" target=\"_blank\" rel=\"noopener\">http://www.w3.org/TR/SVG11/paths.html#PathData</a> 我们可以访问<a href=\"http://editor.method.ac\" target=\"_blank\" rel=\"noopener\">http://editor.method.ac</a> 在线制作矢量图并导出path。</p>\n<h2 id=\"新增widget\"><a href=\"#新增widget\" class=\"headerlink\" title=\"新增widget\"></a>新增widget</h2><h2 id=\"RecyclerView\"><a href=\"#RecyclerView\" class=\"headerlink\" title=\"RecyclerView\"></a>RecyclerView</h2><p>RecyclerView是ListView的升级版，它具备了更好的性能，且更容易使用。和ListView一样，RecyclerView是用来显示大量数据的容器，并通过复用有限数量的View，来提高滚动时的性能。当你的视图上的元素经常动态的且有规律的改变时候，可以使用RecyclerView控件。</p>\n<p>与ListView不同的是RecyclerView不再负责布局，只专注于复用机制，布局交由LayoutManager来管理。 RecyclerView仍然通过Adapter来获取需要显示的对象。</p>\n<p>要使用RecyclerView组件，创建Adapter不再继承自BaseAdapter，而是应该继承自RecyclerView.Adapter类，并且最好指定一个继承自RecyclerView.ViewHolder的范型，Adapter不再要求你返回一个View，而是一个ViewHolder。</p>\n<p>继承自Adapter后，需要实现3个抽象方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 当RecyclerView需要一个ViewHolder时会回调该方法，如果有可复用的View则该方法不会得倒回调</span><br><span class=\"line\">public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup viewGroup, int i)；</span><br><span class=\"line\">// 当一个View需要出现在屏幕上时，该方法会被回调，你需要在该方法中根据数据来更改视图</span><br><span class=\"line\">public void onBindViewHolder(RecyclerView.ViewHolder viewHolder, int i)；</span><br><span class=\"line\">// 用于告诉RecyclerView有多个视图需要显示</span><br><span class=\"line\">public int getItemCount()；</span><br></pre></td></tr></table></figure>\n<p>新的Adapter和原有的Adapter并没有太多的差别，只是不再需要我们写复用判断的逻辑，因为复用逻辑其实都是相似的，它已经有了自身的实现。和原有的Adapter一样，仍然可以通过notifyDataSetChanged来刷新UI，通过getItemViewType来获取对应位置的类型，但是它不再需要你指定有多少类型了，因为该方法已经能够判断出有多少类型。新增的onViewRecycled方法可以让使用者监听View被移除屏幕的时机，并且还提供了一个AdapterDataObserver的观察者，对外提供数据改变时的回调。</p>\n<p>ViewHolder是对所有的单个item的封装，不仅包含了item需要显示的View，并且还包含和item相关的其它数据，例如：当前的position、之前的position、即将显示的position、被回收的次数、View的类型、是否处于显示中等信息。创建一个ViewHolder需要传递一个View对象，这个View就是该holder的显示视图，该View中通常会包含一些子视图，我们最好把这些子视图都记录在holder中，便于复用时设置不同的数据。</p>\n<p>RecyclerView不再对布局进行管理，而是通过LayoutManager管理布局，我们可以通过继承自LayoutManager来实现特殊的布局，系统提供了三种常用的布局管理器：</p>\n<p>LinearLayoutManager 线性布局<br>GridLayoutManager 九宫格布局<br>StaggeredGridLayoutManager 瀑布流布局</p>\n<p>并且每一种都可以设置横行和纵向的布局，可惜的均不能添加header，如果要添加header，我们可以在Adapter中使用不同的类型来达到该效果。</p>\n<p>RecyclerView默认提供了item的增加和删除的动画效果，如果我们使用自定义的动画，需要继承继承RecyclerView.ItemAnimator类，通过RecyclerView.setItemAnimator()方法来设置我们自定义的动画。</p>\n<h2 id=\"cardview\"><a href=\"#cardview\" class=\"headerlink\" title=\"cardview\"></a>cardview</h2><p>在实现扁平化的UI处理上，通常离不开阴影和圆角，我们通常是让美工提供一个带有阴影和圆角效果的背景图片，现在我们有了更好的实现方式，那就是CardView。</p>\n<p>CardView实际是一个FrameLayout类的子类，它为视图提供卡片样式，并保持在不同平台上拥有统一的风格。CardView组件可以设定阴影和圆角。</p>\n<p>我们可以使用cardElevation属性在xml布局中设置阴影效果，在代码中可以通过setCardElevation达到同样的效果。阴影的设置和Android L中的Z属性类似。</p>\n<p>设置圆角也相当容易，在xml中通过cardCornerRadius来设置，在代码中则使用setRadius，圆角的设置和Android L中的剪裁很相似。</p>\n<p>如果我们想设置cardview的背景，请注意使用carBackgroundColor方法，setBackgroundColor也许会影响我们的圆角效果</p>\n<h2 id=\"toolbar\"><a href=\"#toolbar\" class=\"headerlink\" title=\"toolbar\"></a>toolbar</h2><p>Toolbar是android L引入的一个新控件，用于取代ActionBar，它提供了ActionBar类似的功能，但是更灵活。不像ActionBar那么固定，Toolbar更像是一般的View元素，可以被放置在view树体系的任意位置，可以应用动画，可以跟着ScrollView滚动，可以与布局中的其他View交互。当然，你还可以用Toolbar替换掉ActionBar，只需调用Activity.setActionBar()。</p>\n<p>为了兼容更多的设备一般我们都是通过AppCompat中的android.support.v7.widget.Toolbar来使用Toolbar。</p>\n<p>有两种使用Toolbar的方式：</p>\n<p>将Toolbar当作actionbar来使用。这种情况一般发生在你想利用actionbar现有的一些功能（比如能够显示菜单中的操作项，响应菜单点击事件，使用ActionBarDrawerToggle等），但是又想获得比actionbar更多的控制权限。<br>将Toolbar当作一个独立的控件来使用，这种方式又名Standalone。</p>\n<p>如果你要将Toolbar当作actionbar来使用，你首先要去掉actionbar，最简单的方法是使用Theme.AppCompat.NoActionBar主题。或者是设置主题的属性android:windowNoTitle为true。然后在Activity的onCreate中调用setSupportActionBar(toolbar)，原本应该出现在ActionBar上的menu会自动出现在actionbar上。</p>\n<p>Toolbar的高度、宽度、背景颜色等等一切View的属性完全取决于你，这都是因为Toolbar本质上只是个ViewGroup。将Toolbar当作一个独立的控件来使用是不需要去掉actionbar的（两者可以共存），可以使用任意主题。但是在这种情况下，menu菜单并不会自动的显示在Toolbar上，Toolbar也不会响应菜单的回调函数，如果你想让menu菜单项显示在Toolbar上，必须手动inflate menu。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onMenuItemClick(MenuItem item) &#123;</span><br><span class=\"line\">        // 处理menu事件</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 创建一个menu添加到toolbar上</span><br><span class=\"line\">toolbar.inflateMenu(R.menu.your_toolbar_menu);</span><br></pre></td></tr></table></figure>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><p>虽然Material Design新增了许多新特性，但是并不是所有新内容对对下保持了兼容。</p>\n<h3 id=\"使用v7包\"><a href=\"#使用v7包\" class=\"headerlink\" title=\"使用v7包\"></a>使用v7包</h3><p>v7 support libraries r21 及更高版本包含了以下Material Design特性：</p>\n<p>使用Theme.AppCompat主题包含调色板主体属性，可以对应用的主题做统一的配色，但是不包括状态栏和底部操作栏<br>RecyclerView和CardView被独立出来，只要引入jar包，即可适配7以上的所有版本。<br>Palette类用于从图片提取主色调</p>\n<h3 id=\"系统组件\"><a href=\"#系统组件\" class=\"headerlink\" title=\"系统组件\"></a>系统组件</h3><p>Theme.AppCompat主题中提供了这些组件的Material Design style：</p>\n<p>EditText<br>Spinner<br>CheckBox<br>RadioButton<br>SwitchCompat<br>CheckedTextView<br>Color Palette</p>\n<h3 id=\"创建多个value和layout\"><a href=\"#创建多个value和layout\" class=\"headerlink\" title=\"创建多个value和layout\"></a>创建多个value和layout</h3><p>针对Android L我们可以创建value-v21指定Material Design主题，而在其他value中指定Theme.AppCompat。layout布局也可以采用该方式，在Android L中使用系统控件，在低版本中使用我们自定义的控件活着第三方包来达到该效果。</p>\n<h3 id=\"版本检查\"><a href=\"#版本检查\" class=\"headerlink\" title=\"版本检查\"></a>版本检查</h3><p>以下特性只在Android 5.0 (API level 21) 及以上版本中可用：</p>\n<p>转场动画<br>触摸反馈<br>圆形展示动画<br>路径动画<br>矢量图<br>tint染色<br>所以在代码中遇上使用这些api的地方需要进行版本判断：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class=\"line\">    // 使用新特性</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    // 用其他替代方式</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"支持64位art虚拟机\"><a href=\"#支持64位art虚拟机\" class=\"headerlink\" title=\"支持64位art虚拟机\"></a>支持64位art虚拟机</h2><h1 id=\"6-0-api-23\"><a href=\"#6-0-api-23\" class=\"headerlink\" title=\"6.0 - api 23\"></a>6.0 - api 23</h1><h2 id=\"指纹身份验证\"><a href=\"#指纹身份验证\" class=\"headerlink\" title=\"指纹身份验证\"></a>指纹身份验证</h2><p>6.0上面可以使用指纹进行身份验证</p>\n<h2 id=\"应用链接\"><a href=\"#应用链接\" class=\"headerlink\" title=\"应用链接\"></a>应用链接</h2><p>此版本通过提供功能更强大的应用链接，增强了 Android 的 intent 系统。您可以利用此功能将应用与您拥有的某个 Web 域关联。平台可以根据此关联确定在处理特定 Web 链接时默认使用的应用，跳过提示用户选择应用的步骤。</p>\n<h2 id=\"自动备份应用\"><a href=\"#自动备份应用\" class=\"headerlink\" title=\"自动备份应用\"></a>自动备份应用</h2><p>现在，系统可以自动为应用执行完整数据备份和恢复。您的应用的目标平台必须是 Android 6.0（API 级别 23），才能启用此行为；您无需额外添加任何代码。如果用户删除其 Google 帐户，其备份数据也会随之删除。要了解该功能的工作方式以及配置文件系统备份内容的方法，请参阅配置应用自动备份。</p>\n<h2 id=\"语音交互\"><a href=\"#语音交互\" class=\"headerlink\" title=\"语音交互\"></a>语音交互</h2><p>调用 isVoiceInteraction() 方法可确定是否是响应语音操作触发了您的 Activity。如果是这样，则您的应用可以使用 VoiceInteractor 类请求用户进行语音确认、从选项列表中进行选择以及执行其他操作。<br>大多数语音交互都由用户语音操作发起。但语音交互 Activity 也可在没有用户输入的情况下启动。例如，通过语音交互启动的另一应用也可发送 intent 来启动语音交互。要确定您的 Activity 是由用户语音查询还是另一语音交互应用启动，请调用 isVoiceInteractionRoot() 方法。如果另一应用启动了您的 Activity，该方法会返回 false。您的应用可能随即提示用户确认其有意执行此操作。</p>\n<h2 id=\"Assist-API\"><a href=\"#Assist-API\" class=\"headerlink\" title=\"Assist API\"></a>Assist API</h2><p>此版本提供了一种让用户通过助手程序与应用进行互动的新方式。要使用此功能，用户必须启用助手以使用当前上下文。启用助手后，用户可通过长按首页按钮在任何应用内召唤助手。</p>\n<p>您的应用可通过设置 FLAG_SECURE 标记选择不与助手共享当前上下文。除了平台传递给助手的一组标准信息外，您的应用还可利用新增的 AssistContent 类共享其他信息。</p>\n<p>要为助手提供您的应用内的其他上下文，请执行以下步骤：</p>\n<p>实现 Application.OnProvideAssistDataListener 接口。<br>利用 registerOnProvideAssistDataListener() 注册此侦听器。<br>要提供特定于 Activity 的上下文信息，请重写 onProvideAssistData() 回调和新的 onProvideAssistContent() 回调（可选操作）</p>\n<h2 id=\"可采用的存储设备\"><a href=\"#可采用的存储设备\" class=\"headerlink\" title=\"可采用的存储设备\"></a>可采用的存储设备</h2><p>使用此版本时，用户可以采用 SD 卡等外部存储设备。采用外部存储设备可加密和格式化设备，使其具有类似内部存储设备的行为。用户可以利用此特性在存储设备之间移动应用及其私有数据。移动应用时，系统会遵守清单中的 android:installLocation 首选项。</p>\n<p>请注意，在内部存储设备与外部存储设备之间移动应用时，如果您的应用访问以下 API 或字段，它们返回的文件路径将会动态变化。强烈建议：在生成文件路径时，请始终动态调用这些 API。请勿使用硬编码文件路径或之前生成的永久性完全限定文件路径。</p>\n<p>Context 方法：<br>getFilesDir()<br>getCacheDir()<br>getCodeCacheDir()<br>getDatabasePath()<br>getDir()<br>getNoBackupFilesDir()<br>getFileStreamPath()<br>getPackageCodePath()<br>getPackageResourcePath()<br>ApplicationInfo 字段：<br>dataDir<br>sourceDir<br>nativeLibraryDir<br>publicSourceDir<br>splitSourceDirs<br>splitPublicSourceDirs</p>\n<h2 id=\"通知\"><a href=\"#通知\" class=\"headerlink\" title=\"通知\"></a>通知</h2><p>此版本针对通知功能引入了下列 API 变更：</p>\n<p>新增了 INTERRUPTION_FILTER_ALARMS 过滤级别，它对应于新增的“仅闹铃”免打扰模式。<br>新增了 CATEGORY_REMINDER 类别值，用于区分用户安排的提醒与其他事件 (CATEGORY_EVENT) 和闹铃 (CATEGORY_ALARM)。<br>新增了 Icon 类，您可以通过 setSmallIcon()方法和 setLargeIcon()方法将其附加到通知上。同理，addAction() 方法现在接受 Icon 对象，而不接受可绘制资源 ID。<br>新增了 getActiveNotifications() 方法，让您的应用能够了解哪些通知目前处于活动状态。要查看使用此功能的应用实现，请参阅 ActiveNotifications 示例。</p>\n<h2 id=\"相机功能\"><a href=\"#相机功能\" class=\"headerlink\" title=\"相机功能\"></a>相机功能</h2><p>此版本提供了下列用于访问相机闪光灯和相机图像再处理的新 API：</p>\n<p>Flashlight API<br>如果相机设备带有闪光灯，您可以通过调用 setTorchMode() 方法，在不打开相机设备的情况下打开或关闭闪光灯的火炬模式。应用对闪光灯或相机设备不享有独占所有权。每当相机设备不可用，或者开启火炬的其他相机资源不可用时，火炬模式即会被关闭并变为不可用状态。其他应用也可调用 setTorchMode() 来关闭火炬模式。当最后一个开启火炬模式的应用关闭时，火炬模式就会被关闭。</p>\n<p>您可以注册一个回调，通过调用 registerTorchCallback() 方法接收有关火炬模式状态的通知。第一次注册回调时，系统会立即调用它，并返回所有当前已知配备闪光灯的相机设备的火炬模式状态。如果成功开启或关闭火炬模式，系统会调用 onTorchModeChanged() 方法。</p>\n<p>Reprocessing API<br>Camera2 API 进行了扩展，以支持 YUV 和专用不透明格式图像再处理。要确定这些再处理功能是否可用，请调用 getCameraCharacteristics() 并检查有无 REPROCESS_MAX_CAPTURE_STALL 密钥。如果设备支持再处理，您可以通过调用 createReprocessableCaptureSession() 创建一个可再处理的相机采集会话并创建输入缓冲区再处理请求。</p>\n<p>使用 ImageWriter 类可将输入缓冲区流与相机再处理输入相连。要获得空白缓冲区，请遵循以下编程模型：</p>\n<p>调用 dequeueInputImage() 方法。<br>在输入缓冲区中填充数据。<br>通过调用 queueInputImage() 方法将缓冲区发送至相机。<br>如果您将 ImageWriter 对象与 PRIVATE 图像一起使用，您的应用并不能直接访问图像数据。请改为调用 queueInputImage() 方法，将 PRIVATE 图像直接传递给 ImageWriter，而不进行任何缓冲区复制。</p>\n<p>ImageReader 类现在支持 PRIVATE 格式图像流。凭借此支持特性，您的应用可使 ImageReader 输出图像保持为循环图像队列，还可选择一个或多个图像并将其发送给 ImageWriter 进行相机再处理。</p>\n<h1 id=\"7-0\"><a href=\"#7-0\" class=\"headerlink\" title=\"7.0\"></a>7.0</h1><h2 id=\"多窗口支持\"><a href=\"#多窗口支持\" class=\"headerlink\" title=\"多窗口支持\"></a>多窗口支持</h2><p>就是分屏</p>\n<h2 id=\"通知增强功能\"><a href=\"#通知增强功能\" class=\"headerlink\" title=\"通知增强功能\"></a>通知增强功能</h2><p>在 Android 7.0 中，我们重新设计了通知，使其更易于使用并且速度更快。部分变更包括：</p>\n<p>模板更新：我们正在更新通知模板，新强调了英雄形象和化身。开发者将能够充分利用新模板，只需进行少量的代码调整。<br>消息传递样式自定义：您可以自定义更多与您的使用 MessagingStyle 类的通知相关的用户界面标签。您可以配置消息、会话标题和内容视图。<br>捆绑通知：系统可以将消息组合在一起（例如，按消息主题）并显示组。用户可以适当地进行拒绝或归档等操作。如果您已实现 Android Wear 的通知，那么您已经很熟悉此模式。<br>直接回复：对于实时通信应用，Android 系统支持内联回复，以便用户可以直接在通知界面中快速回复短信。<br>自定义视图：两个新的 API 让您在通知中使用自定义视图时可以充分利用系统装饰元素，如通知标题和操作。</p>\n<h2 id=\"Android-中的-ICU4J-API\"><a href=\"#Android-中的-ICU4J-API\" class=\"headerlink\" title=\"Android 中的 ICU4J API\"></a>Android 中的 ICU4J API</h2><p>Android 7.0 目前在 Android 框架（位于 android.icu 软件包下）中提供 ICU4J API 的子集。迁移很简单，主要是需要从 com.java.icu 命名空间更改为 android.icu。如果您已在您的应用中使用 ICU4J 捆绑包，切换到 Android 框架中提供的 android.icu API 可以大量节省 APK 大小。</p>\n<h2 id=\"webview\"><a href=\"#webview\" class=\"headerlink\" title=\"webview\"></a>webview</h2><p>Javascript 在页面加载之前运行<br>从以 Android 7.0 为目标平台的应用开始，JavaScript 上下文会在加载新页面时重置。目前，新 WebView 实例中加载的第一个页面会继承上下文。</p>\n<p>想要在 WebView 中注入 Javascript 的开发者应在页面开始加载后执行脚本。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"5-0-api-21\"><a href=\"#5-0-api-21\" class=\"headerlink\" title=\"5.0 - api 21\"></a>5.0 - api 21</h1><h2 id=\"新出material-design\"><a href=\"#新出material-design\" class=\"headerlink\" title=\"新出material design\"></a>新出material design</h2><h2 id=\"view增加了z属性\"><a href=\"#view增加了z属性\" class=\"headerlink\" title=\"view增加了z属性\"></a>view增加了z属性</h2><p>在5.0之前，我们如果想给view添加阴影效果，以体现其层次感，通常的做法是给view设置一个带阴影的背景图片，现在，我们只需要简单的修改view的Z属性，就能让其具备阴影的层次感。</p>\n<p>Z属性会扩大view的显示区域，如果它的大小大于或等于父视图的大小，那么它的阴影效果就无法显示了，view并不会因为z属性而把自身缩小腾出空间显示阴影。</p>\n<p>Z属性不仅影响着view的阴影效果，还影响着view的绘制顺序，在同一个父view内部，Z属性越小，绘制的时机就越早。也就是优先被绘制，而z属性越大，则绘制时间越晚，后绘制的将会遮盖住先绘制的，只有Z属性相同，才按照添加的顺序绘制。</p>\n<h2 id=\"view增加了轮廓\"><a href=\"#view增加了轮廓\" class=\"headerlink\" title=\"view增加了轮廓\"></a>view增加了轮廓</h2><p>在xml布局中，可以通过android:outlineProvider来指定轮廓的判定方式：</p>\n<p>none 即使设置了Z属性，也不会显示阴影<br>background 会按照背景来设置阴影形状<br>bounds 会按照View的大小来描绘阴影<br>paddedBounds 和bounds类似，不过阴影会稍微向右偏移一点</p>\n<p>在代码中，我们可以通过setOutlineProvider来指定一个View的轮廓：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ViewOutlineProvider viewOutlineProvider = new ViewOutlineProvider() &#123;</span><br><span class=\"line\">    public void getOutline(View view, Outline outline) &#123;</span><br><span class=\"line\">        // 可以指定圆形，矩形，圆角矩形，path</span><br><span class=\"line\">        outline.setOval(0, 0, view.getWidth(), view.getHeight());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">View.setOutlineProvider(viewOutlineProvider );</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"view的裁剪\"><a href=\"#view的裁剪\" class=\"headerlink\" title=\"view的裁剪\"></a>view的裁剪</h2><p>给View指定轮廓，可以决定阴影的显示形状，如果给View指定一个小于自身大小的轮廓，正常情况下阴影会被View遮住，这个时候View的显示内容并没有因为轮廓的缩小而缩小。</p>\n<p>如果想根据轮廓来缩小一个View，则可以通过剪裁。如果一个View指定了轮廓，调用setClipToOutline方法，就可以根据轮廓来剪裁一个View。想要剪裁轮廓，必须要给View先指定轮廓，并且轮廓是可以被剪裁的，目前只有圆形，矩形，圆角矩形支持剪裁，可以通过outline.canClip()来判断一个轮廓是否支持剪裁。</p>\n<p>Path剪裁不会改变View的大小，但是如果Path的范围比View要的bounds要小，则剪裁后会改变View的位置，位置偏移和Z属性有关，这可能是一个BUG，view的设计者可能在绘制阴影时根据轮廓偏移了画布，而在绘制完后忘记把画布还原了。</p>\n<p>剪裁不会改变View的测量大小和布局大小，也不会改变View的触摸区域，剪裁只是在onDraw的时候对画布做了剪裁处理，剪裁也不同于scale，scale是调整画布matrix的缩放属性，调整后，View仍然能完整显示，而剪裁是缩小画布的剪裁区域，剪裁后我们只能看到View的一部分。</p>\n<p>试图给View一个比较大的轮廓进行剪裁也是不成功的，实验证明剪裁后的View只能比原有体积小，扩大轮廓只会扩大轮廓的绘制区域。</p>\n<p>剪裁是一个非常消耗资源的操作，我们不应该用此来做动画效果，如果要实现这样的动画，可以使用Reveal Effect</p>\n<h2 id=\"tint属性\"><a href=\"#tint属性\" class=\"headerlink\" title=\"tint属性\"></a>tint属性</h2><p>tint属性是一个颜色值，可以对图片做颜色渲染，我们可以给view的背景设置tint色值，给ImageView的图片设置tint色值，也可以给任意Drawable或者NinePatchDrawable设置tint色值。</p>\n<p>在应用的主题中也可以通过设置 android:tint 来给主题设置统一的颜色渲染。</p>\n<p>tint的渲染模式有总共有16种，xml文件中可以使用6种，代码中我们可以设置16种，渲染模式决定了渲染颜色和原图颜色的取舍和合成规则：</p>\n<p>PorterDuff.Mode.CLEAR 所绘制不会提交到画布上。<br>PorterDuff.Mode.SRC 显示上层绘制图片<br>PorterDuff.Mode.DST 显示下层绘制图片<br>PorterDuff.Mode.SRC_OVER 正常绘制显示，上下层绘制叠盖。<br>PorterDuff.Mode.DST_OVER 上下层都显示。下层居上显示。<br>PorterDuff.Mode.SRC_IN 取两层绘制交集。显示上层。<br>PorterDuff.Mode.DST_IN 取两层绘制交集。显示下层。<br>PorterDuff.Mode.SRC_OUT 取上层绘制非交集部分。<br>PorterDuff.Mode.DST_OUT 取下层绘制非交集部分。<br>PorterDuff.Mode.SRC_ATOP 取下层非交集部分与上层交集部分<br>PorterDuff.Mode.DST_ATOP 取上层非交集部分与下层交集部分<br>PorterDuff.Mode.XOR 取两层绘制非交集。两层绘制非交集。<br>PorterDuff.Mode.DARKEN 上下层都显示。变暗<br>PorterDuff.Mode.LIGHTEN 上下层都显示。变亮<br>PorterDuff.Mode.MULTIPLY 取两层绘制交集<br>PorterDuff.Mode.SCREEN 上下层都显示。</p>\n<p>通过tint属性处理后的图片会和原图显示出不一样的颜色，我们可以通过这种方式利用一张图片做出图片选择器的效果，让控件在按压状态下显示另外一种颜色:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过给图片设置tint色生成另外一种图片</span><br><span class=\"line\">&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">        android:src=&quot;@drawable/ring&quot;</span><br><span class=\"line\">        android:tintMode=&quot;multiply&quot;</span><br><span class=\"line\">        android:tint=&quot;#5677fc&quot; /&gt;</span><br><span class=\"line\">利用新的图片生成图片选择器</span><br><span class=\"line\">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class=\"line\">        &lt;item android:drawable=&quot;@drawable/tint_bitmap&quot; android:state_pressed=&quot;true&quot;/&gt;</span><br><span class=\"line\">        &lt;item android:drawable=&quot;@drawable/ring&quot; /&gt;</span><br><span class=\"line\">&lt;/selector&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Palette调色版\"><a href=\"#Palette调色版\" class=\"headerlink\" title=\"Palette调色版\"></a>Palette调色版</h2><p>Palette调色板，可以很方便的让我们从图片中提取颜色。并且可以指定提取某种类型的颜色。<br>Vibrant 鲜艳的<br>Vibrant dark鲜艳的暗色<br>Vibrant light鲜艳的亮色<br>Muted 柔和的<br>Muted dark柔和的暗色<br>Muted light柔和的亮色</p>\n<p>对图片取色是一个比较消耗性能的操作，其内部会对图片的像素值进来遍历以分析对比，所以我们要在异步线程中去完成。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果操作本来就属于后台线程，可以使用：</span><br><span class=\"line\">Palette p = Palette.generate(Bitmap bitmap);</span><br><span class=\"line\">如果在主线程中，我们可以使用异步的方式：</span><br><span class=\"line\">Palette.generateAsync(bitmap, new Palette.PaletteAsyncListener() &#123;</span><br><span class=\"line\">        public void onGenerated(Palette palette) &#123;  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>当操作完成后或者异步回调后，我们就可以使用以下方式来获取对应的色值了，并且可以在没有获取到的情况下之指定默认值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.getVibrantColor(int defaultColor);</span><br><span class=\"line\">p.getDarkVibrantColor(int defaultColor);</span><br><span class=\"line\">p.getLightVibrantColor(int defaultColor);</span><br><span class=\"line\">p.getMutedColor(int defaultColor);</span><br><span class=\"line\">p.getDarkMutedColor(int defaultColor);</span><br><span class=\"line\">p.getLightMutedColor(int defaultColor);</span><br></pre></td></tr></table></figure></p>\n<p>在使用palette之前，bitmap提供获取指定位置的像素值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bitmap.getPixel(x,y)</span><br></pre></td></tr></table></figure></p>\n<p>但是该方式只能获取某一点的像素值，palette是对整个bitmap的所有像素值进行分析，并选出几个像素占比比较多的像素值，这样选择出来的色值更符合图片的整体色值。</p>\n<h2 id=\"vector矢量图\"><a href=\"#vector矢量图\" class=\"headerlink\" title=\"vector矢量图\"></a>vector矢量图</h2><p>矢量图也称为面向对象的图像或绘图图像，是计算机图形学中用点、直线或者多边形等基于数学方程的几何图元表示的图像。矢量图形最大的优点是无论放大、缩小或旋转等不会失真；最大的缺点是难以表现色彩层次丰富、逼真的图像效果。</p>\n<p>Android L开始支持矢量图，我们可以用它来处理一些图形简单的icon，方便我们的适配。</p>\n<p>Android L中对矢量图的支持是通过xml文件构建，通过矢量图的path描述来生成一个矢量图，对应的java对象为VectorDrawable。</p>\n<p>下面是官方文档提供的一个矢量图，利用改文件，我们可以创建一个随意放大缩小都不会失真的心形。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">        android:height=&quot;300dp&quot;</span><br><span class=\"line\">        android:width=&quot;300dp&quot;</span><br><span class=\"line\">        android:viewportHeight=&quot;40&quot;</span><br><span class=\"line\">        android:viewportWidth=&quot;40&quot;&gt;</span><br><span class=\"line\">        &lt;path android:fillColor=&quot;#ff00ff&quot;</span><br><span class=\"line\">                android:pathData=&quot;M20.5,9.5</span><br><span class=\"line\">                        c-1.955,0,-3.83,1.268,-4.5,3</span><br><span class=\"line\">                        c-0.67,-1.732,-2.547,-3,-4.5,-3</span><br><span class=\"line\">                        C8.957,9.5,7,11.432,7,14</span><br><span class=\"line\">                        c0,3.53,3.793,6.257,9,11.5</span><br><span class=\"line\">                        c5.207,-5.242,9,-7.97,9,-11.5</span><br><span class=\"line\">                        C25,11.432,23.043,9.5,20.5,9.5z&quot;/&gt;</span><br><span class=\"line\">&lt;/vector&gt;</span><br></pre></td></tr></table></figure>\n<p>矢量图的pathData数据就是用来描述矢量图的数学公式，其含义如下表：</p>\n<p>命令类型    使用描述    代表含义                    举例说明<br>移动指令    M x,y    M移动绝对位置                M 100,240<br>移动指令    m x,y    m移动相对于上一个点        m 100,240<br>绘制        L 或 l    从当前点绘制直线到指定点    L 100,100<br>绘制        H 或 h    水平直线                    h 100<br>绘制        V 或 v    垂直直线                    v 100<br>绘制        C 或 c    三次方程式贝塞尔曲线        C 100,200 200,400 300,200<br>绘制        Q 或 q    二次方程式贝塞尔曲线        Q 100,200 300,200<br>绘制        S 或 s    平滑三次方程式贝塞尔曲线    S 100,200 200,400 300,200<br>绘制        T 或 t    平滑二次方程式贝塞尔曲线    T 100,200 300,200<br>绘制        A 或 a    椭圆                        A 5,5 0 0 1 10,10<br>关闭指令    Z 或 z    将图形的首、尾点用直线连接    Z<br>填充        F0    EvenOdd 填充规则<br>填充        F1    Nonzero 填充规则    </p>\n<p>通过path命令来进行简单的图形还是可行的，但是复杂的图形我们就需要借助工具来生成了，比如使用 Expression Design，就可以直接粘贴来自其它软件的矢量图形，然后选择导出，导出时做如后选择：文件-&gt;导出-&gt;导出属性-&gt;格式-&gt;XAML Silverlight 画布，即可得到XAML格式的矢量图形，也就是Path。</p>\n<p>更多矢量图学习可参考：<a href=\"http://www.w3.org/TR/SVG11/paths.html#PathData\" target=\"_blank\" rel=\"noopener\">http://www.w3.org/TR/SVG11/paths.html#PathData</a> 我们可以访问<a href=\"http://editor.method.ac\" target=\"_blank\" rel=\"noopener\">http://editor.method.ac</a> 在线制作矢量图并导出path。</p>\n<h2 id=\"新增widget\"><a href=\"#新增widget\" class=\"headerlink\" title=\"新增widget\"></a>新增widget</h2><h2 id=\"RecyclerView\"><a href=\"#RecyclerView\" class=\"headerlink\" title=\"RecyclerView\"></a>RecyclerView</h2><p>RecyclerView是ListView的升级版，它具备了更好的性能，且更容易使用。和ListView一样，RecyclerView是用来显示大量数据的容器，并通过复用有限数量的View，来提高滚动时的性能。当你的视图上的元素经常动态的且有规律的改变时候，可以使用RecyclerView控件。</p>\n<p>与ListView不同的是RecyclerView不再负责布局，只专注于复用机制，布局交由LayoutManager来管理。 RecyclerView仍然通过Adapter来获取需要显示的对象。</p>\n<p>要使用RecyclerView组件，创建Adapter不再继承自BaseAdapter，而是应该继承自RecyclerView.Adapter类，并且最好指定一个继承自RecyclerView.ViewHolder的范型，Adapter不再要求你返回一个View，而是一个ViewHolder。</p>\n<p>继承自Adapter后，需要实现3个抽象方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 当RecyclerView需要一个ViewHolder时会回调该方法，如果有可复用的View则该方法不会得倒回调</span><br><span class=\"line\">public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup viewGroup, int i)；</span><br><span class=\"line\">// 当一个View需要出现在屏幕上时，该方法会被回调，你需要在该方法中根据数据来更改视图</span><br><span class=\"line\">public void onBindViewHolder(RecyclerView.ViewHolder viewHolder, int i)；</span><br><span class=\"line\">// 用于告诉RecyclerView有多个视图需要显示</span><br><span class=\"line\">public int getItemCount()；</span><br></pre></td></tr></table></figure>\n<p>新的Adapter和原有的Adapter并没有太多的差别，只是不再需要我们写复用判断的逻辑，因为复用逻辑其实都是相似的，它已经有了自身的实现。和原有的Adapter一样，仍然可以通过notifyDataSetChanged来刷新UI，通过getItemViewType来获取对应位置的类型，但是它不再需要你指定有多少类型了，因为该方法已经能够判断出有多少类型。新增的onViewRecycled方法可以让使用者监听View被移除屏幕的时机，并且还提供了一个AdapterDataObserver的观察者，对外提供数据改变时的回调。</p>\n<p>ViewHolder是对所有的单个item的封装，不仅包含了item需要显示的View，并且还包含和item相关的其它数据，例如：当前的position、之前的position、即将显示的position、被回收的次数、View的类型、是否处于显示中等信息。创建一个ViewHolder需要传递一个View对象，这个View就是该holder的显示视图，该View中通常会包含一些子视图，我们最好把这些子视图都记录在holder中，便于复用时设置不同的数据。</p>\n<p>RecyclerView不再对布局进行管理，而是通过LayoutManager管理布局，我们可以通过继承自LayoutManager来实现特殊的布局，系统提供了三种常用的布局管理器：</p>\n<p>LinearLayoutManager 线性布局<br>GridLayoutManager 九宫格布局<br>StaggeredGridLayoutManager 瀑布流布局</p>\n<p>并且每一种都可以设置横行和纵向的布局，可惜的均不能添加header，如果要添加header，我们可以在Adapter中使用不同的类型来达到该效果。</p>\n<p>RecyclerView默认提供了item的增加和删除的动画效果，如果我们使用自定义的动画，需要继承继承RecyclerView.ItemAnimator类，通过RecyclerView.setItemAnimator()方法来设置我们自定义的动画。</p>\n<h2 id=\"cardview\"><a href=\"#cardview\" class=\"headerlink\" title=\"cardview\"></a>cardview</h2><p>在实现扁平化的UI处理上，通常离不开阴影和圆角，我们通常是让美工提供一个带有阴影和圆角效果的背景图片，现在我们有了更好的实现方式，那就是CardView。</p>\n<p>CardView实际是一个FrameLayout类的子类，它为视图提供卡片样式，并保持在不同平台上拥有统一的风格。CardView组件可以设定阴影和圆角。</p>\n<p>我们可以使用cardElevation属性在xml布局中设置阴影效果，在代码中可以通过setCardElevation达到同样的效果。阴影的设置和Android L中的Z属性类似。</p>\n<p>设置圆角也相当容易，在xml中通过cardCornerRadius来设置，在代码中则使用setRadius，圆角的设置和Android L中的剪裁很相似。</p>\n<p>如果我们想设置cardview的背景，请注意使用carBackgroundColor方法，setBackgroundColor也许会影响我们的圆角效果</p>\n<h2 id=\"toolbar\"><a href=\"#toolbar\" class=\"headerlink\" title=\"toolbar\"></a>toolbar</h2><p>Toolbar是android L引入的一个新控件，用于取代ActionBar，它提供了ActionBar类似的功能，但是更灵活。不像ActionBar那么固定，Toolbar更像是一般的View元素，可以被放置在view树体系的任意位置，可以应用动画，可以跟着ScrollView滚动，可以与布局中的其他View交互。当然，你还可以用Toolbar替换掉ActionBar，只需调用Activity.setActionBar()。</p>\n<p>为了兼容更多的设备一般我们都是通过AppCompat中的android.support.v7.widget.Toolbar来使用Toolbar。</p>\n<p>有两种使用Toolbar的方式：</p>\n<p>将Toolbar当作actionbar来使用。这种情况一般发生在你想利用actionbar现有的一些功能（比如能够显示菜单中的操作项，响应菜单点击事件，使用ActionBarDrawerToggle等），但是又想获得比actionbar更多的控制权限。<br>将Toolbar当作一个独立的控件来使用，这种方式又名Standalone。</p>\n<p>如果你要将Toolbar当作actionbar来使用，你首先要去掉actionbar，最简单的方法是使用Theme.AppCompat.NoActionBar主题。或者是设置主题的属性android:windowNoTitle为true。然后在Activity的onCreate中调用setSupportActionBar(toolbar)，原本应该出现在ActionBar上的menu会自动出现在actionbar上。</p>\n<p>Toolbar的高度、宽度、背景颜色等等一切View的属性完全取决于你，这都是因为Toolbar本质上只是个ViewGroup。将Toolbar当作一个独立的控件来使用是不需要去掉actionbar的（两者可以共存），可以使用任意主题。但是在这种情况下，menu菜单并不会自动的显示在Toolbar上，Toolbar也不会响应菜单的回调函数，如果你想让menu菜单项显示在Toolbar上，必须手动inflate menu。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onMenuItemClick(MenuItem item) &#123;</span><br><span class=\"line\">        // 处理menu事件</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 创建一个menu添加到toolbar上</span><br><span class=\"line\">toolbar.inflateMenu(R.menu.your_toolbar_menu);</span><br></pre></td></tr></table></figure>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><p>虽然Material Design新增了许多新特性，但是并不是所有新内容对对下保持了兼容。</p>\n<h3 id=\"使用v7包\"><a href=\"#使用v7包\" class=\"headerlink\" title=\"使用v7包\"></a>使用v7包</h3><p>v7 support libraries r21 及更高版本包含了以下Material Design特性：</p>\n<p>使用Theme.AppCompat主题包含调色板主体属性，可以对应用的主题做统一的配色，但是不包括状态栏和底部操作栏<br>RecyclerView和CardView被独立出来，只要引入jar包，即可适配7以上的所有版本。<br>Palette类用于从图片提取主色调</p>\n<h3 id=\"系统组件\"><a href=\"#系统组件\" class=\"headerlink\" title=\"系统组件\"></a>系统组件</h3><p>Theme.AppCompat主题中提供了这些组件的Material Design style：</p>\n<p>EditText<br>Spinner<br>CheckBox<br>RadioButton<br>SwitchCompat<br>CheckedTextView<br>Color Palette</p>\n<h3 id=\"创建多个value和layout\"><a href=\"#创建多个value和layout\" class=\"headerlink\" title=\"创建多个value和layout\"></a>创建多个value和layout</h3><p>针对Android L我们可以创建value-v21指定Material Design主题，而在其他value中指定Theme.AppCompat。layout布局也可以采用该方式，在Android L中使用系统控件，在低版本中使用我们自定义的控件活着第三方包来达到该效果。</p>\n<h3 id=\"版本检查\"><a href=\"#版本检查\" class=\"headerlink\" title=\"版本检查\"></a>版本检查</h3><p>以下特性只在Android 5.0 (API level 21) 及以上版本中可用：</p>\n<p>转场动画<br>触摸反馈<br>圆形展示动画<br>路径动画<br>矢量图<br>tint染色<br>所以在代码中遇上使用这些api的地方需要进行版本判断：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class=\"line\">    // 使用新特性</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    // 用其他替代方式</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"支持64位art虚拟机\"><a href=\"#支持64位art虚拟机\" class=\"headerlink\" title=\"支持64位art虚拟机\"></a>支持64位art虚拟机</h2><h1 id=\"6-0-api-23\"><a href=\"#6-0-api-23\" class=\"headerlink\" title=\"6.0 - api 23\"></a>6.0 - api 23</h1><h2 id=\"指纹身份验证\"><a href=\"#指纹身份验证\" class=\"headerlink\" title=\"指纹身份验证\"></a>指纹身份验证</h2><p>6.0上面可以使用指纹进行身份验证</p>\n<h2 id=\"应用链接\"><a href=\"#应用链接\" class=\"headerlink\" title=\"应用链接\"></a>应用链接</h2><p>此版本通过提供功能更强大的应用链接，增强了 Android 的 intent 系统。您可以利用此功能将应用与您拥有的某个 Web 域关联。平台可以根据此关联确定在处理特定 Web 链接时默认使用的应用，跳过提示用户选择应用的步骤。</p>\n<h2 id=\"自动备份应用\"><a href=\"#自动备份应用\" class=\"headerlink\" title=\"自动备份应用\"></a>自动备份应用</h2><p>现在，系统可以自动为应用执行完整数据备份和恢复。您的应用的目标平台必须是 Android 6.0（API 级别 23），才能启用此行为；您无需额外添加任何代码。如果用户删除其 Google 帐户，其备份数据也会随之删除。要了解该功能的工作方式以及配置文件系统备份内容的方法，请参阅配置应用自动备份。</p>\n<h2 id=\"语音交互\"><a href=\"#语音交互\" class=\"headerlink\" title=\"语音交互\"></a>语音交互</h2><p>调用 isVoiceInteraction() 方法可确定是否是响应语音操作触发了您的 Activity。如果是这样，则您的应用可以使用 VoiceInteractor 类请求用户进行语音确认、从选项列表中进行选择以及执行其他操作。<br>大多数语音交互都由用户语音操作发起。但语音交互 Activity 也可在没有用户输入的情况下启动。例如，通过语音交互启动的另一应用也可发送 intent 来启动语音交互。要确定您的 Activity 是由用户语音查询还是另一语音交互应用启动，请调用 isVoiceInteractionRoot() 方法。如果另一应用启动了您的 Activity，该方法会返回 false。您的应用可能随即提示用户确认其有意执行此操作。</p>\n<h2 id=\"Assist-API\"><a href=\"#Assist-API\" class=\"headerlink\" title=\"Assist API\"></a>Assist API</h2><p>此版本提供了一种让用户通过助手程序与应用进行互动的新方式。要使用此功能，用户必须启用助手以使用当前上下文。启用助手后，用户可通过长按首页按钮在任何应用内召唤助手。</p>\n<p>您的应用可通过设置 FLAG_SECURE 标记选择不与助手共享当前上下文。除了平台传递给助手的一组标准信息外，您的应用还可利用新增的 AssistContent 类共享其他信息。</p>\n<p>要为助手提供您的应用内的其他上下文，请执行以下步骤：</p>\n<p>实现 Application.OnProvideAssistDataListener 接口。<br>利用 registerOnProvideAssistDataListener() 注册此侦听器。<br>要提供特定于 Activity 的上下文信息，请重写 onProvideAssistData() 回调和新的 onProvideAssistContent() 回调（可选操作）</p>\n<h2 id=\"可采用的存储设备\"><a href=\"#可采用的存储设备\" class=\"headerlink\" title=\"可采用的存储设备\"></a>可采用的存储设备</h2><p>使用此版本时，用户可以采用 SD 卡等外部存储设备。采用外部存储设备可加密和格式化设备，使其具有类似内部存储设备的行为。用户可以利用此特性在存储设备之间移动应用及其私有数据。移动应用时，系统会遵守清单中的 android:installLocation 首选项。</p>\n<p>请注意，在内部存储设备与外部存储设备之间移动应用时，如果您的应用访问以下 API 或字段，它们返回的文件路径将会动态变化。强烈建议：在生成文件路径时，请始终动态调用这些 API。请勿使用硬编码文件路径或之前生成的永久性完全限定文件路径。</p>\n<p>Context 方法：<br>getFilesDir()<br>getCacheDir()<br>getCodeCacheDir()<br>getDatabasePath()<br>getDir()<br>getNoBackupFilesDir()<br>getFileStreamPath()<br>getPackageCodePath()<br>getPackageResourcePath()<br>ApplicationInfo 字段：<br>dataDir<br>sourceDir<br>nativeLibraryDir<br>publicSourceDir<br>splitSourceDirs<br>splitPublicSourceDirs</p>\n<h2 id=\"通知\"><a href=\"#通知\" class=\"headerlink\" title=\"通知\"></a>通知</h2><p>此版本针对通知功能引入了下列 API 变更：</p>\n<p>新增了 INTERRUPTION_FILTER_ALARMS 过滤级别，它对应于新增的“仅闹铃”免打扰模式。<br>新增了 CATEGORY_REMINDER 类别值，用于区分用户安排的提醒与其他事件 (CATEGORY_EVENT) 和闹铃 (CATEGORY_ALARM)。<br>新增了 Icon 类，您可以通过 setSmallIcon()方法和 setLargeIcon()方法将其附加到通知上。同理，addAction() 方法现在接受 Icon 对象，而不接受可绘制资源 ID。<br>新增了 getActiveNotifications() 方法，让您的应用能够了解哪些通知目前处于活动状态。要查看使用此功能的应用实现，请参阅 ActiveNotifications 示例。</p>\n<h2 id=\"相机功能\"><a href=\"#相机功能\" class=\"headerlink\" title=\"相机功能\"></a>相机功能</h2><p>此版本提供了下列用于访问相机闪光灯和相机图像再处理的新 API：</p>\n<p>Flashlight API<br>如果相机设备带有闪光灯，您可以通过调用 setTorchMode() 方法，在不打开相机设备的情况下打开或关闭闪光灯的火炬模式。应用对闪光灯或相机设备不享有独占所有权。每当相机设备不可用，或者开启火炬的其他相机资源不可用时，火炬模式即会被关闭并变为不可用状态。其他应用也可调用 setTorchMode() 来关闭火炬模式。当最后一个开启火炬模式的应用关闭时，火炬模式就会被关闭。</p>\n<p>您可以注册一个回调，通过调用 registerTorchCallback() 方法接收有关火炬模式状态的通知。第一次注册回调时，系统会立即调用它，并返回所有当前已知配备闪光灯的相机设备的火炬模式状态。如果成功开启或关闭火炬模式，系统会调用 onTorchModeChanged() 方法。</p>\n<p>Reprocessing API<br>Camera2 API 进行了扩展，以支持 YUV 和专用不透明格式图像再处理。要确定这些再处理功能是否可用，请调用 getCameraCharacteristics() 并检查有无 REPROCESS_MAX_CAPTURE_STALL 密钥。如果设备支持再处理，您可以通过调用 createReprocessableCaptureSession() 创建一个可再处理的相机采集会话并创建输入缓冲区再处理请求。</p>\n<p>使用 ImageWriter 类可将输入缓冲区流与相机再处理输入相连。要获得空白缓冲区，请遵循以下编程模型：</p>\n<p>调用 dequeueInputImage() 方法。<br>在输入缓冲区中填充数据。<br>通过调用 queueInputImage() 方法将缓冲区发送至相机。<br>如果您将 ImageWriter 对象与 PRIVATE 图像一起使用，您的应用并不能直接访问图像数据。请改为调用 queueInputImage() 方法，将 PRIVATE 图像直接传递给 ImageWriter，而不进行任何缓冲区复制。</p>\n<p>ImageReader 类现在支持 PRIVATE 格式图像流。凭借此支持特性，您的应用可使 ImageReader 输出图像保持为循环图像队列，还可选择一个或多个图像并将其发送给 ImageWriter 进行相机再处理。</p>\n<h1 id=\"7-0\"><a href=\"#7-0\" class=\"headerlink\" title=\"7.0\"></a>7.0</h1><h2 id=\"多窗口支持\"><a href=\"#多窗口支持\" class=\"headerlink\" title=\"多窗口支持\"></a>多窗口支持</h2><p>就是分屏</p>\n<h2 id=\"通知增强功能\"><a href=\"#通知增强功能\" class=\"headerlink\" title=\"通知增强功能\"></a>通知增强功能</h2><p>在 Android 7.0 中，我们重新设计了通知，使其更易于使用并且速度更快。部分变更包括：</p>\n<p>模板更新：我们正在更新通知模板，新强调了英雄形象和化身。开发者将能够充分利用新模板，只需进行少量的代码调整。<br>消息传递样式自定义：您可以自定义更多与您的使用 MessagingStyle 类的通知相关的用户界面标签。您可以配置消息、会话标题和内容视图。<br>捆绑通知：系统可以将消息组合在一起（例如，按消息主题）并显示组。用户可以适当地进行拒绝或归档等操作。如果您已实现 Android Wear 的通知，那么您已经很熟悉此模式。<br>直接回复：对于实时通信应用，Android 系统支持内联回复，以便用户可以直接在通知界面中快速回复短信。<br>自定义视图：两个新的 API 让您在通知中使用自定义视图时可以充分利用系统装饰元素，如通知标题和操作。</p>\n<h2 id=\"Android-中的-ICU4J-API\"><a href=\"#Android-中的-ICU4J-API\" class=\"headerlink\" title=\"Android 中的 ICU4J API\"></a>Android 中的 ICU4J API</h2><p>Android 7.0 目前在 Android 框架（位于 android.icu 软件包下）中提供 ICU4J API 的子集。迁移很简单，主要是需要从 com.java.icu 命名空间更改为 android.icu。如果您已在您的应用中使用 ICU4J 捆绑包，切换到 Android 框架中提供的 android.icu API 可以大量节省 APK 大小。</p>\n<h2 id=\"webview\"><a href=\"#webview\" class=\"headerlink\" title=\"webview\"></a>webview</h2><p>Javascript 在页面加载之前运行<br>从以 Android 7.0 为目标平台的应用开始，JavaScript 上下文会在加载新页面时重置。目前，新 WebView 实例中加载的第一个页面会继承上下文。</p>\n<p>想要在 WebView 中注入 Javascript 的开发者应在页面开始加载后执行脚本。</p>\n"},{"title":"effective-java学习笔记","date":"2018-05-07T08:45:46.000Z","_content":"\n## 创建和销毁对象。\n\n### 使用静态工厂方法代替构造器\n\n优势：\n\n1 - 静态工厂方法与构造器不同的第一大优势：它们有名称。\n\n由于一个类只能有一个指定签名的构造器，及时我们使用替换顺序来构造不同的构造器，也会产生困扰，不知道该使用哪个。但是静态工厂方法则可以代替构造器，使用不同的名称以显示不同的区别。\n\n2 - 静态工厂方法与构造器不同的第二大优势：不必在每次调用它们的时候都创建一个新的对象。\n\n静态工厂方法可以使用预先构建好的实例，或者将实例缓存起来，进行重复利用。如果程序进场请求创建相同的对象，并且创建对象的代价很高的话，可以考虑使用该方法。\n\n3 - 静态工厂方法与构造器不同的第三大优势：它们可以返回原返回类型的任何子类型的对象。\n\napi可以返回对象，又不会使对象的类变成公有的，类的实现在客户端看来是不可见的。\n\n由于静态工厂方法返回的对象所属的类，在编写包含该静态方法的类时可以不必存在。因此衍生了“服务提供者框架”。\n\n服务提供者框架有三个重要的组件：服务接口，提供者注册api，服务访问api。第四个组件可选，是服务提供者接口。这些提供者负责创建其服务实现的实例，如果没有服务提供者接口，实现就按照类名称注册，并通过反射方式进行实例化。\n\n4 - 静态工厂方法的第四大优势：在创建参数化类型实例的时候，它们使代码变得更加简洁。\n\n例如\n```\nMap<String, List<String>> m = new HashMap<String, List<String>>();\n```\n\n可以通过\n```\npublic static <K, V> HashMap<K, V> newInstance(){\n\treturn new HashMap<K, V>();\n}\n```\n\n改成\n```\nMap<String, List<String>> m = HashMap.newInstance();\n```\n\n缺点：\n\n1 - 类如果不含公有的或者受保护的构造器，就不能子类化。\n\n针对这一条，“复合“好过”继承“\n\n2 - 它们与其他的静态方法实际上没有任何区别。\n\n由于不是构造器，因此没有办法像构造器一样明确标识出来。因此对于提供了静态工厂方法而不是构造器的类来讲，想要查明如何实例化一个类，比较困难。\n\n我们需要遵守一些惯用名称：\n\n- valueOf ---- 该方法返回的实例与他的参数具有相同的值，这样的静态工厂方法世纪上是类转换的方法。\n\n- of ---- valueOf的另一个更加简洁的方法\n\n- getInstance ---- 返回的实例是通过方法的参数来描述的，但是不能说与参数具有相同的值。对于singleton来说，该方法没有参数，并返回唯一的实例。\n\n- newInstance ---- newinstance能够确保返回的每个实例都与所有的其他实例不同\n\n- getType ---- 像getinstance一样，但是gettype表示返回的使用类型。\n\n- newType ---- 和gettype一样。\n\n### 遇到多个构造器参数时要考虑使用构建器\n\n静态工厂和构造器有个共同的局限性，它们都不能很好的扩展到大量的可选参数。\n\n构建器就是使用set方法来设置参数，不过是build模式的。可以利用单个builder构建多个对象，builder的参数可以在创建对象期间进行调整，也可以随着不同的对象而改变。builder可以自动填充某些域，例如每次创建对象时自动增加序列号。\n\n### 用私有构造器或者枚举类型强化singleton属性\n\n- 使用公有静态域\n\n```\npublic class Elvis{\n\tpublic static final Elvis INSTANCE = new Elvis();\n\tprivate Elvis(){\n\t\t...\n\t}\n}\n```\n\n该方法确保只有一个全局变量，但是该方法容易被反射。\n\n- 使用静态工厂方法来实现singleton\n\n```\npublic class Elvis{\n\tprivate static final Elvis INSTANCE = new Elvis();\n\tprivate Elvis{\n\t\t...\n\t}\n\tpublic static Elivs getInstance(){\n\t\treturn INSTANCE;\n\t}\n}\n```\n\ngetInstance()方法的所有调用都会返回同一个对象引用，所以永远不会创建别的对象。\n\n工厂方法的优势在于提供了灵活性，不改变api的前提下，可以改变该类是否是singleton的想法，可序列化但是维护singleton的话需要申明所有实例域是瞬时的，并且要提供一个readResolve方法\n\n```\nprivate Object readResolve(){\n\treturn Instance;\n}\n```\n\n- 编写一个包含单个元素的枚举类型\n\n```\npublic enum Elvis {\n\tINSTANCE;\n}\n```\n\n该方法在功能上与公有域相近，但是更加简洁，并且无偿的提供了序列化机制，绝对防止多次实例化，哪怕是反射的时候。\n\n### 通过私有化构造器强化不可实例化的能力\n\n对于类似于Collections这种，不需要也不希望实例化的类，避免自动构建其无参构造，可以使用以下方法。\n\n```\npublic class UtilityClass{\n\tprivate UtilityClass(){\n\t\tthrow new AssertionError();\n\t}\n}\n```\n\n该方法会导致子类没有构造器。\n\n### 避免创建不必要的对象\n\n对于同时提供静态方法和构造器的不可变类，通常可以使用静态工厂方法而不是构造器，以避免创建不必要的对象。例如Boolean.valueOf(String)几乎总是优先于构造器Boolean(String)。这是由于构造器每次构造的时候都会创建一个对象，而静态方法则不会。\n\n除了重用这种方法之外，还可以重用已知的不会修改的可变对象。\n\n```\npublic class Person{\n\t\n\tprivate final Date birthDate;\n\n\tpublic boolean isBabyBoomer(){\n\t\tCalendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n\t\tgmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);\n\t\tDate boomStart = gmtCal.getTime();\n\t\tgmtCal.set(1956, Calendar.JANUARY, 1, 0, 0, 0);\n\t\tDate boomEnd = gmtCal.getTime();\n\t\treturn birthDate.compare(boomStart) >= 0 && birthDate.compare(boomEnd) < 0;\n\t}\n\n}\n```\n\n如上方法，每次调用都会新建一个Calendar, 一个TimeZone, 和两个Date实例。\n\n```\nclass Person{\n\tprivate final Date birthDate;\n\n\tprivate static final Date BOOM_START;\n\tprivate static final Date BOOM_END;\n\n\tstatic{\n\t\tCalendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n\t\tgmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);\n\t\tBOOM_START = gmtCal.getTime();\n\t\tgmtCal.set(1956, Calendar.JANUARY, 1, 0, 0, 0);\n\t\tBOOM_END = gmtCal.getTime();\n\t}\n\n\tpublic boolean isBabyBoomer(){\n\t\treturn birthDate.compare(BOOM_START) >= 0 && birthDate.compare(BOOM_END) < 0;\n\t}\n\n}\n```\n\n改进后只会创建一个Calendar, 一个TimeZone和一个Date\n\n另外关于基本类型和装箱基本类型之前的变换，如今有自动拆箱和自动拆箱，不过在需要的时候，使用基本类型总是效率好过装箱类型，要小心无意识的自动装箱行为。\n\n### 消除过期的对象引用\n\n该题主要针对内存泄漏现象的分析，对过期引用的分析处理主要在清空引用方法。在android方面的分析处理看着的话用处不大。\n\n仍然是缓存和监听器回调泄漏这些方面。\n\n### 避免使用终结（finalizer）方法\n\n终结方法通常不可预测，一般不可使用。\n\njvm正确的执行对象的终结方法是顺利的回收。但是由于jvm不同，很有可能在不同的平台上不同的算法不同，导致产生的现象大相庭径。\n\n终结方法是以队列的形式进行回收，但是由于终结方法的优先级很低，不确定哪些线程会执行终结方法。因此会造成在终结方法中执行方法的速度小于进入终结方法的速度，会导致大量的回收对象堆积，以此产生oom。\n\n\n## 对于所有对象都通用的方法\n\n这一章是针对Object类\n\n### 覆盖equals是遵守通用约定\n\n#### 针对以下四点，不应该覆盖equals方法，同时不能让其他人调用使用\n\n1. 类的每个实例本质上都是唯一的：对于代表活动实体而不是值的类来说，object提供的equals是正确的。\n\n2. 不关心类是否提供了“逻辑相等”的测试功能：\n\n3. 超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的\n\n4. 类是私有的或是包级私有的，可以确定它的equals方法永远不会被调用：此时需要覆盖以防被意外调用。\n\n```\n@Override\npublic boolean equals(Object o ){\n\tthrow new AssertionError();\n}\n```\n\n#### 如果需要覆盖时，需要遵守以下的规范，来自JavaSE6\n\n1. 自反性：对于任何非null的引用值x，x.equals(x)必须返回true\n\n2. 对称性：对于任何非null的引用值x,y,z，如果x.equals(y) == true, 那么y.equals(x) == true也必须成立\n\n3. 传递性：对于任何非null的引用值x,y,z，如果x.equals(y) == true, y.equals(z) == true,那么x.equals(z) == true也必须成立\n\n4. 一致性：对于任何非null的引用值x，y，只要equals的比较操作在对象中所用的信息没有被修改，那么无论调用多少次equals，返回结果必须是一样的\n\n5. 非空性：对于任何非null的引用值x，x.equals(null)必须返回false\n\n#### 根据以上两个原则以及引申出来的原则，总结实现equals的窍门\n\n1. 使用 == 操作符检查“参数是否为这个对象的引用”\n\n2. 使用 instanceof 操作符检查“参数是否为正确的类型”\n\n3. 把参数转换成正确的类型\n\n4. 对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配（不能只针对某些关键条件来判断，而不是全部关键条件）\n\n5. 当编写完equals方法之后，应该检查对称性、传递性、一致性。\n\n### 覆盖equals时总要覆盖hashcode\n\n由于HashMap,HashSet和HashTable这些散列集合。\n\n散列集合的关键域，就有hashcode，若不覆盖的话，就会产生问题。例如由于hashcode不同，导致两个equals为true的对象，放到了不同的散列桶中，因此导致get出来的值是不同的，违反了上面的规则。\n\n#### 覆盖hashcode的方法\n\n1. 将某个非零的常数值，保存在名为result的int类型的变量中。\n\n2. 对于对象中每个关键域f，完成以下步骤：\n\n\ta. 为该域计算int类型的散列码c：\n\t\ti. f类型是boolean，则计算f?1:0\n\t\tii. 如果该域是byte，char，short或者int类型，则计算(int)f\n\t\tiii. 如果该域是long类型，则计算(int)(f^(f>>32))\n\t\tiv. 如果该域是float类型，则计算Float.floatToIntBits(f)\n\t\tv. 如果该域是double类型，则计算Double.doubleToLongBits(f),然后跳到iii\n\t\tvi. 如果是对象引用，可以设计一个范式，针对这个范式来计算hashcode\n\t\tvii. 如果该域是一个数组，需要针对每一个元素计算一下，然后依据b来计算\n\tb. 按照 result = result * 31 + c\n\n### 始终覆盖toString\n\n使用tostring来进行关键的提示\n\n### 谨慎的覆盖clone\n\n克隆部分主要是针对object的clone来进行浅克隆的缺点分析，和深克隆的优点介绍。\n\n提供了一种不断调用构造器来进行clone的深克隆方法。事实上目前深克隆有了更好的stream方法，所以略过不讲。\n\n之前说过的newinstance方法，其实就是浅克隆\n\n### 考虑实现comparable接口\n\n类实现了comparable接口，可以与许多泛型算法，以及依赖于该接口的集合实现进行协作。不过也同样要遵从自反性，对称性和传递性。\n\n由于类可能有很多个关键域，因此需要由最关键的域开始进行比较，直到所有的域都比较结束，才能算一个comparable接口实现结束\n\n## 类和接口\n\n### 使类和成员的可访问性最小化\n\n出于“封装”的特性，需要将类的方法进行访问性变更，仅仅暴露出一些需要暴露的方法进行模块间的沟通。\n\n有几个规定\n\n实例域不可公有，对于非final的实例域不可公有主要是针对线程安全。另外对于静态final域的对象来讲，需要确保其引用对象不是可变对象，否则也不可公有\n\n长度非0的数组，无论如何声明，也是可变的，因此对于数组的静态域返回，需要使用如下方法。\n\n```\nprivate final static Thing[] PRIVATE_VALUES = {...};\npublic static final Thing[] values(){\n\treturn PRIVATE_VALUES.clone();\n}\n```\n\n### 在公有域方法中使用访问方法，而不是公有域\n\n这就是使用get set等方法，而不是直接暴露出参数，来使用公有域。由于使用这种方法，可以确保通过自设的一些限制，确保返回的参数和自己需要的参数条件相当。\n\n### 使可变性最小化\n\n该例主要是针对不可变类的处理。不可变类是第一次构造时就赋予内部参数的类，类似String类。\n\n使类变成不可变类，需要遵循五条规则：\n\n1. 不要提供任何会修改对象状态的方法\n\n2. 保证类不会被扩展：防止子类化，一般可以将这个类做成final的\n\n3. 使所有的域都是final的：使用系统的强制方式，可以清楚的表明意图\n\n4. 使所有的域都成为私有的：防止客户端获得访问可变对象的权限，并防止客户端直接修改这些对象。\n\n5. 确保对于任何可变组件的互斥访问：如果类具有指向可变对象的域，必须确保该类的客户端无法获得指向这些对象的引用。因此如果需要修改对象，提供set方法。\n\n\n不可变对象比较简单，只有一种状态，即被创建时的状态，本质上是线程安全的，它们不要求同步。并发访问时不会破坏属性，因此可以被自由的共享，同时也不需要进行保护性拷贝。\n\n不仅可以共享不可变对象，甚至也可以共享它们的内部信息。\n\n不可变对象的唯一的缺点是，对于每个不同的值都要一个单独的对象。由于创建对象的代价可能很大，对于大型的对象，这样操作实在是损耗太大。\n\n```\npublic class Complex{\n\tprivate final double re;\n\tprivate final double im;\n\n\tprivate Complex(double re, double im){\n\t\tthis.re = re;\n\t\tthis.im = im;\n\t}\n\n\tpublic static Complex valueOf(double re, double im){\n\t\treturn new Complex(re, im);\n\t}\n}\n```\n\n### 复合优先于继承\n\n继承打破了封装性，当版本的升级导致父类的变化，会造成子类的破坏。因此需要进行复合。\n\n复合的意义是：不拓展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例，这种设计被称作复合。\n\n现有的类变成了新类的一个组件，新类的每个实例方法都可以调用被包含的现有实例中对应的方法，并返回他的结果，这种方式称为转发。新的类被称为包装类。\n\n缺点：包装类不适合用于回调框架\n\n### 要么为继承而设计，并提供文档说明，要么就禁止继承\n\n不是为了继承而设计，并且没有文档说明，会导致子类的继承出现破坏性的问题。\n\n文档必须要精确的描述覆盖每个方法所带来的影响。\n\n\n### 接口优于抽象类\n\n1. 现有的类可以很容易被更新，以实现新的接口\n\n2. 接口是定义mixin(混合类型)的理想选择\n\n3. 接口允许构造非层次接口的类型框架\n\n鉴于上上条“复合优先于继承”，如果使用接口的方式实现，包装类仍然完美使用\n\n### 接口只用于定义类型\n\n接口仅仅用于定义引用这个实例的类型，因此除此之外的接口都是不恰当的。\n\n### 类层次由于标签类\n\n标签类很少有适用的时候，当编写一个包含显式标签域的类时，应当考虑是否应该不使用标签类，而是将标签放到同一个层次的结构中去。\n\n### 用函数对象表示策略\n\njava虽然没有高阶语言的函数式编程，也没有c语言类似的函数指针，但是可以使用对象引用来实现同样的功能。\n\n如\n```\nclass StringLengthComparator{\n\tpublic int compare(String s1, String s2){\n\t\treturn s1.length() - s2.length();\n\t}\n}\n```\n改为\n\n```\nclass StringLengthComparator{\n\tprivate StringLengthComparator(){};\n\tpublic static final StringLengthComparator INSTANCE = new StringLengthComparator();\n\tpublic int compare(String s1, String s2){\n\t\treturn s1.length() - s2.length();\n\t}\n}\n```\n\n典型的具体策略类，是无状态的，没有域，所以所有的实例在功能上面都是等价的。\n\n### 优先考虑静态成员类\n\n嵌套类是指被定义在另一个类的内部的类。嵌套类存在的目的应该只是为他的外围类提供服务。\n\n嵌套类分为四种：静态成员类，非静态成员类，匿名类和局部类，除了第一种之外，其他三种都被称为内部类。\n\n非静态成员类的每个实例都隐含着与外围类的一个外围实例相关联，创建需要外围类的存在。没有外围实例，想创建非静态成员类是基本上不存在的。\n\n一般非静态成员类都是使用常见的adapter来实现，他允许外部类的实例被看做是另一个不相关的类的实例。\n\n因此，成员类不要求访问外部实例，希望外部实例以外的对象调用，就需要将static修饰符放在声明中。\n\n#### 私有静态成员类\n\n私有静态成员类的一中常见用法是用来代表外围类所代表的对象的组件。\n\n例如一个map实例，它把键和值对应起来，许多map实现的内部都有一个entry对象，对应于map中的每个键值对。虽然每个entry都与一个map关联，但是entry上的方法并不需要访问该map，因此，使用非静态成员来标识entry是很浪费的，如果不用static修饰，那么每个entry中将会包含一个指向该map的引用。\n\n#### 匿名类\n\n匿名类没有名字，他不是外围类的成员，他并不与其他的成员一起被申明，匿名类除了被申明的时候之外，是无法实例化的，无法进行instanceof测试，或者任何需要命名类的其他事情。\n\n```\nabstract class Father(){\n....\n}\npublic class Test{\n   Father f1 = new Father(){ .... }  //这里就是有个匿名内部类\n}\n```\n\n#### 局部类\n\n局部类用的很少，局部类只在本地范围内有效。\n\n```\npublic class Test {\n    {\n        class AA{}//块内局部类\n    }\n    public Test(){\n        class AA{}//构造器内局部类\n    }\n    public static void main(String[] args){\n    }\n    public void test(){\n        class AA{}//方法内局部类\n    }\n}\n```\n局部类最多只能有final修饰，但不同的是，块内局部类有enclose class属性，而构造器局部类有enclose constructor属性，方法局部类有enclose method属性，嘛，其实很好理解的吧，一看就知道。\n\n## 泛型\n\n### 请不要在新代码中使用原生态类型\n\n每种范型其实都是一组参数化的类型，他是一种原生态类型（rawtype），即不带任何实际类型参数的泛型名称。\n\n在不确定或者不在乎集合中元素类型的情况下，可以参考以下方式\n\n```\nstatic int numElementsInCommon(Set s1, Set s2){\n\tint result = 0;\n\tfor (Object o1 : s1){\n\t\tif(s2.contains(o1)){\n\t\t\tresult ++;\n\t\t}\n\t}\n\treturn result;\n}\n```\n\n使用原生类型是可以在不关心参数类型的情况下替代泛型，缺很危险，不过泛型也提供了一种安全的替代方式。\n\n```\nSet<E>   --->   Set<?> //可以持有任何集合\n```\n\n对于泛型使用instanceof的首选方法：\n```\nif (o instanceof Set){\n\tSet<?> m = (Set<?>)o;\n\t//一旦确定这个o是个set，就必须将它装换位通配符类型Set<?>而不是原生的Set，这是个受检的转换。\n}\n```\n\n### 消除非受检警告\n\n类似非受检警告如下：\n```\nSet<Lark> exaltation = new HashSet();\n\n[unchecked] unchecked conversion\n```\n\n需要改为如下：\n```\nSet<Lark> exaltation = new HashSet<Lark>();\n```\n\n 无法消除的时候，可以使用注解来压制这条警告。但是压制的时候代表仍然可能是有问题的，所以最好做一些备注或者catch\n\n\n### 列表优先于数组\n\n数组是covariant的，代表如果某个对象a是对象b的子类型，那么a[]也一定是b[]的子类型。\n\n而数组就是invariant的，对于任意两个不同的类型ab，并不能说a的list是b的list的子类，也不能说b的list是a的list的父类。\n\n事实上，本来就应该是如同list这样，数组这样反而是有缺陷的。\n\n数组会在运行时才知道并检查他们的类型，而泛型则是通过擦除来实现的。正因如此，泛型可以与没有使用泛型的代码随意进行互用。\n\n而泛型数组则是不建议创建的，每个不可具化的数组会得到一条警告，除了禁止并且避免在api中混合使用泛型和可变参数之外，别无他法。\n\n创建泛型数组，可以使用\n```\nelements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];\n```\n\n### 优先使用泛型\n\n使用泛型的步骤，可以先使用object，在不使用任何object内在方法以及实例方法的时候，可以完整实现一个类，即可替换使用泛型。\n\n### 优先考虑泛型方法\n\n核心步骤是使用泛型单例工厂方法，不单单可以通过泛型进行类型擦除，也适配了针对不同对象进行不同创建的问题\n\n```\npublic interface Comparable<T>{\n\tint compareTo(T o);\n}\n```\n\n\n```\npublic static <T extends Comparable<T>> T max(List<T> list){\n\t....\n}\n```\n\n类似上述这种，就解决了不同类型的对象比较的问题，所需要的对象仅仅需要在编译过程中实现了comparable，即可参与到比较中来。而回避了类似string和int之间的比较类型。\n\n### 利用有限的通配符来提升api的灵活性\n\n在部分情况下面，使用<? extends E>的方式来进行处理参数类型，有效的避免了部分不兼容接口的数据问题。和上一章讲的类似。\n```\npublic void pushAll(Iterable<? extends E> src){\n\tfor (E e: src){\n\t\tpush(e);\n\t}\n}\n```\n另外提到了一个<? super E>的方式，同上面的不同，这种方式是指?是E的超类\n对应的方法就是popAll\n```\npublic void popAll(Collection<? super E> dst){\n\twhile(!isEmpty()){\n\t\tdst.add(pop());\n\t}\n}\n```\n需要记得步骤PECS： producer-extends, consumer-super\n\n针对既可以消费，也可以生产的，可以使用下述方式\n```\n\tstatic <E> E reduce(List<? extends E> list, Function<E> f, E initVal);\n```\n这样基本上可以确保，list的值可以被f消费，同时list又可以作为一个消费者返回正确的结果。\n\nps:\n\n```\n   static <E> E reduce(List<E> list, Function<? super E> f, E initVal);\n```\n应该也是可以的，相同的意义\n\n### 优先考虑类型安全的异构容器\n\n一般来讲，泛型用于实现一些容器，这些容器大部分包含了单个参数或者类似map的2个参数。如果想要实现更多参数，就需要使用到这章的内容。\n\n实现一个简单的多参数泛型结构\n\n```\npublic class Favorites{\n\tpublic <T> void putFavourite(Class<T> type, T instance);\n\tpublic <T> getFavourite(Class<T> type);\n}\n```\n使用的方法如下：\n```\npublic static void main(String[] args){\n\tFavourite f = new Favourites();\n\tf.putFavourite(String.class, \"Java\");\n\tf.putFavourite(Integer.class, 0x000fffff);\n\tf.putFavourite(Class.class, Favourite.class);\n\tString favouritString = f.getFavourite(String.class);\n\tint favouriteInteger = f.getFavourite(Integer.class);\n\tClass<?> favouritClass = f.getFavourite(Class.class);\n\tSystem.out.printf(\"%s %x %s %n\", favouritString, favouriteInteger, favouritClass.getName());\n}\n```\n\n其中涉及到了Favourites的实现\n\n```\npublic class Favourites{\n\tprivate Map<Class<?>, Object> favourites = new HashMap<Class<?>, Object>();\n\n\tpublic <T> void putFavourite(Class<T> type, T instance){\n\t\tif(type == null){\n\t\t\tthrow new NullPointerException(\"Type is null\");\n\t\t}\n\t\tfavourites.put(type, instance);\n\t}\n\n\tpublic <T> T getFavourite(Class<T> type){\n\t\treturn type.cast(favourites.get(type));\n\t}\n}\n```\n\n这种模式是单key的，所以一个类，只可以对应一个值，实现一个数据库的单列是可以的\n\n其中注意到一点，type.cast()方法，是Class的方法，通过这个方法基本上可以活用泛型。这种type被称为类型，type token被称为类型令牌\n\n```\n@SuppressWarnings(\"unchecked\")\npublic T cast(Object obj) {\n    if (obj != null && !isInstance(obj))\n        throw new ClassCastException(cannotCastMsg(obj));\n    return (T) obj;\n}\n```\nps: Class类中自带了很多有用的方法，有空的时候可以看看\n\n## 枚举和注解\n\n枚举和注解都是jdk1.5发布的\n\n### 用enum代替int常量\n\n一般情况下使用int常量来做flag，会出现常量重复的现象，尤其是自己不注意的时候，可能两个命名不同的变量，却有相同的int值。在部分情况下会导致判断失误的现象\n\n而采用枚举类型则可以完全避免这些问题\n\n```\npublic enum Apple{ FUJI, PIPPIN, GRANNY_SMITH }\n\npublic enum Orange{ NAVEL, TEMPLE, BLOOD }\n```\n\n枚举的本质是通过公有的静态final域为每个枚举常量导出类型的类，由于没有可以访问的构造器，枚举类型是真正的final，并且是实例受控的，不可能进行拓展。他们是单例的泛型化，本质上是单元素的枚举\n\n枚举还提供了多个同名常量的在多个枚举类型中可以有自己的命名空间，可以和平相处。\n\n一个正常的有些复杂度的枚举类型：\n\n```\npublic enum Planet{\n\tMERCURY(3.302e+23, 2.439e6),\n\tVENUS(4.869e+24, 6.052e6),\n\tEARTH(5.975e+24, 6.378e6);\n\tprivate final double mass;\n\tprivate final double radius;\n\tprivate final double surfaceGravity;\n\tprivate static final double G = 6.67300e-11;\n\n\tPlanet(double mass, double radius){\n\t\tthis.mass = mass;\n\t\tthis.radius = radius;\n\t\tsurfaceGravity = G * mass / (radius * radius);\n\t}\n\n\tpublic double mass(){\n\t\treturn mass;\n\t}\n\n\tpublic double radius(){\n\t\treturn radius;\n\t}\n\n\tpublic double surfaceGravity(){\n\t\treturn surfaceGravity;\n\t}\n\n\tpublic double surfaceWeight(double mass){\n\t\treturn mass * surfaceGravity;\n\t}\n}\n```\n使用的方法如下：\n\n```\npublic class WeightTable{\n\tpublic static void main(String[] args){\n\t\tdouble earthWeight = Double.parseDouble(args[0]);\n\t\tdouble nass = earthWeight/ Planet.EARTH.surfaceGravity();\n\t\tfor  (Planet p : Planet.values()){\n\t\t\tSystem.out.printf(\"Weight on %s is %f%n\",p, p.surfaceWeight(mass));\n\t\t}\n\t}\n}\n```\n\n另外枚举类覆盖toString方法，亦可以直接在String中进行处理，这样在算术表达式中比较好处理\n\nps:尝试了一下，枚举类也可以有多态构造方法，内部类也是可以的，但是枚举实例只能放在头部。\n\n### 用实例域代替序数\n\n所有的枚举都有一个方法，叫做ordinal(),代表每个枚举常量在类型中的数字位置。\n\n但是实现的时候不能滥用这个方法，我们假如构造一个枚举类，千万不要无参，而通过这个方法来获取位置。而最起码应该带有一个数字参数\n\n### 用EnumSet代替位域\n\n用位域的好处是可以比较好的使用flag，类似经常用到的比如说intent的flag，textview的flag。\n\n位域有一系列的缺点，尤其是当打印出来的时候，这个我深受其害，在观察view的tree结构时，很多状态位看不懂，还需要翻代码对比才能看出来。\n\n使用enumset代替的确有规避这方面的好处，自己写代码的时候可以注意一下，但是framework的代码其实很难更改这个了。\n\n### 用EnumMap代替序数索引\n\n之前讲过用ordinal方法来进行索引，但是若是出现多个数组的情况，单ordinal就不满足了，需要进行状态的保存。\n\nenummap可以规避这个问题，但是看起来其实可用性不是很高。map的使用场景在android里面不如list。不过在构造容器的时候，使用enummap比较好\n\n### 用接口模拟可伸缩的枚举\n\n通过接口使得枚举拓展化，通过枚举来实现接口，这样使得枚举可以伸缩，虽然无法编写可拓展的枚举类型，但是这样却可以进行枚举的模拟\n\n### 注解优先于命名模式\n\n命名模式有几个缺点:\n1 文字拼写错误会导致失败，比如说测试用例需要test开头，这样就会导致写错test就失败\n\n2 无法确保他们只用于相应的元素上面\n\n3 没有提供参数值与程序元素关联起来的好方法\n\n通过注解可以完美的处理上述问题\n\n### 坚持使用override接口\n\n有助于编译器检查\n\n### 用标记接口定义类型\n\n标记接口类似于retrofit的标记方式，优点是可以精确的被锁定\n\n## 方法\n\n### 检查参数的有效性\n\n对于公开的方法，可以直接使用@throws标签进行标注，然后代码中判断\n\n非公开的方法，使用assert即可\n\n### 必要时进行保护性拷贝\n\n一个例子\n\n```\npublic Period(Data start, Data end){\n\tif(start.compareTo(end)){\n\t\tthrow new IllegalArgumentException(start + \"after\" + end);\n\t}\n\tthis.start = start;\n\tthis.end = end;\n}\n```\n\n由于传入的Data事实上是可变的，因此一旦在构造完之后，再次修改的话，会造成条件不成立。\n\n```\npublic Period(Data start, Data end){\n\tif(start.compareTo(end)){\n\t\tthrow new IllegalArgumentException(start + \"after\" + end);\n\t}\n\tthis.start = new Data(start.getTime());\n\tthis.end = new Data(end.getTime());\n}\n```\n使用这种方式就可以避免上述问题\n\n但是仍然有一种无法避免，就是暴露了相关参数，然后通过get接口获取之后直接更改。\n\n```\npublic Data getStart(){\n\treturn new Data(start.getTime());\n}\n```\n因此在get中也需要进行保护措施\n\n### 谨慎设计方法签名\n\n1 谨慎的选择方法的名称\n\n2 不要过分追求提供便利的方法：主要原则是出于维护性的考虑，每个方法都应该尽其所能，而不应该过度耦合\n\n3 避免过长的参数列表：最多四个参数\n\n### 慎用重载\n\n这一节主要是讨论了重载的部分问题，主要是针对类型的判断，譬如list的remove方法，假如list的包含内容是int，remove的时候remove的是int的话，就会针对index和content起冲突，这是自动装箱和自动拆箱的判断\n\n重载需要考虑基本类型的使用方法，对于基本类型可以使用变形方法，变形方法不是重载，而是具有类似于writeBoolean, writeInt这种类型的方法\n\n\n### 慎用可变参数\n\n使用可变参数的时候，基本问题出现在单个可变参数的问题上面。\n\n```\nstatic int min(int... args){\n\t....\n}\n```\n类似上面这种，传入0个参数也是可以的，但是编译时却无法进行检查，这就会导致空指针异常出现，除非自己进行长度判断\n\n避免以上问题的2个方法，一个是指定类型的正常参数，即是自己进行判断，另一个是扩充参数表，增加一个varargs参数。\n\n在重视性能的前提下，需要明白，使用可变参数方法，每次调用都会导致一次数组分配和初始化，。因此当参数超过3个的时候，第四个及以后的都用可变参数来表示。\n\n### 返回零长度的数组或者集合，而不是null\n\n这节讲的内容主要是针对get方法，或者需要返回集合的方法，当集合不存在或者长度为0时，如果返回null的话会造成比较大的麻烦，这样依赖于下游对于该参数的单独处理\n\n### 为所有导出的api元素编写文档注释\n\n编写文档是门技巧，但不是现在关注的\n\n## 通用程序设计\n\n### 将局部变量的作用于最小化\n\n1. 要使局部变量的作用域最小化，最有利的方法就是在第一次使用它的地方声明\n\n2. 几乎每个局部变量的声明都应该包含一个初始化表达式（这个讲的很有道理，很多地方声明由于丢掉了初始化，基础类型还好，但是若是复杂结构，很大的问题会出现空的情况）\n\n另外如果一个参数的初始化需要使用到trycatch，而这个方法可能抛出异常，那么假如需要使用到这个参数，就将使用这个参数的地方和这个参数放在try内部，如果必须要在try外部使用，那么久必须在try之前被声明\n\n\n### foreach循环优先于传统的for循环\n\n### 了解和使用类库\n\n```\n不要重新发明轮子\n```\n\n### 如果需要精简的答案，避免使用float和double\n\n计算价格其实有更高的方法，就是精确到分即可。或者说以分为计数单位\n\n### 基本类型优先于装箱基本类型\n\n基本类型和装箱基本类型之剑有三个主要区别\n\n1 基本类型只有值，装箱基本类型则有与他们值不同的同一性\n\n2 基本类型只有功能完备的值，而每个装箱基本类型除了它对应基本类型的所有功能值以外，还有个非功能值，null\n\n3 基本类型比装箱基本类型更省时间和内存\n\n另外注意的一点是，装箱类型的比较需要使用到equal而不是==，这点在不同的机器上面展现不同，比如说在androidstudio里面 == 的含义和equal相同，但是在华为手机上面就不同。\n\n### 如果其他类型合适，尽量避免使用字符串\n\n字符串不适合代替其他的值类型\n\n字符串不适合代替枚举类型\n\n字符串不适合代替聚集类型\n\n字符串不适合代替能力表\n\n具体来讲就是该用的时候用，不该用，明显有些问题的场景，覆盖不全面的场景不要用\n\n### 当心字符串连接的性能\n\n字符串拼接的确有很多问题，+的性能开销很大，连接N个字符串，需要的时间是N的平方级。\n\n因此使用StringBuilder替代的话，开销仅仅是线性增加。或者我们可以使用字符数组，每次只处理一个字符串，这样也可以达到增加效率的目的（舍弃了工程效率）\n\n### 接口优先于反射机制\n\n反射的缺点：\n\n1 丧失了编译时检查的好处\n\n2 执行反射访问所需要的代码非常笨拙和冗长\n\n3 性能损失\n\n不过单纯的罗列缺点并不可行，尤其是很多情景下反射其实是不得已而为之，并且在android中，反射的效率并没有太过严重。我测试，大致1000次反射消耗1秒钟，并非不可接受\n\n### 谨慎的使用本地方法\n\n本地方法指的是native方法。\n\n使用本地方法来提高性能的做法不值得提倡：c或c++实现的代码，很容易出现内存毁坏错误的影响，尤其是我们做java开发的，在不熟悉相关语言的时候，\n\n### 谨慎的进行优化\n\n```\n在优化方面，我们应该遵守两条规则:\n\n1 不要优化\n2 在没有明确清晰的优化方案之前，不要进行优化\n```\n\n不要因为性能而牺牲合理的结构，应当编写好的程序而不是快的程序\n\n好的程序有两个规则：将设计决策集中在单个模块中\n\n```\n在每次优化之前和之后，要对性能进行测量\n```\n\n### 遵守普遍接受的命名惯例\n\n遵守驼峰原则\n\n## 异常\n\n### 只针对异常的情况才使用异常\n\n异常在jvm里面优化的比较少，写在try块里面的代码，每一步都会进行异常的检查，这样会造成严重的性能损耗，一般会增加一倍的运行时间。\n\n### 对可恢复的情况使用受检异常，对编程错误使用运行时异常\n\njava提供了三种可抛出的结构：受检的异常，运行时异常，错误。\n\n一般使用运行时异常来表示变成错误。明确的指出代码违例\n\n而受检异常，作为可抛出的结构，但是并不建议使用，因为会带来困惑。\n\n至于警告，说实话错误大部分是对于兼容性的处理，api过期等等，警告本上是很难避免的\n\n### 避免不必要的使用受检的异常\n\n主要是受检的异常会带来代码复杂度增加的问题，尤其是一些无法解决的情况，因此如果该受检其实是不必要的，完全没有必要增加代码复杂度\n\n### 优先使用标准的异常\n\njava提供了一些常用的异常：\n\nillegalArgumentException: 非null的参数值不正确\n\nillegalStateException: 对于方法调用而言，对象状态不合适\n\nnullPointException: 在禁止使用null的情况下参数值为null\n\nindexOutOfBoundsException: 下表参数值越界\n\nconcurrentModificationException: 在禁止并发修改的情况下，检测到对象的并发修改\n\nunsupportedOperationException: 对象不支持用户请求的方法\n\n### 抛出与抽象相对应的异常\n\n异常转译：更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行的解释。\n\n另外还有一种被称作异常链\n\n```\ntry{\n\t...\n}catch(LowerLevelException cause){\n\tthrow new HigherLevelException(cause);\n}\n```\n这样写，加上上层也写了捕捉higherlevelexception的动作，就可以将这个异常链传输到上层了。\n\n不过异常转译其实还是比异常链好一些，毕竟做了完整的处理。而如果凡事依赖异常链的话，那么很难说照顾到所有，如果捕捉了上层无法处理的，然后上层在弹出崩溃，那么一来追踪不是很方便，二来浪费效率\n\n### 每个方法抛出的异常都要有文档\n\n### 在细节消息中包含能捕获失败的信息\n\n这个在项目里有很多用途，主要是弹出给用户看\n\n### 努力使失败保持原子性\n\n失败的方法调用，应该使对象保持在被调用之前的状态。\n\n比较好的方法是进行参数检查，不符合直接抛出，这样就会在修改之前生效。\n\n还有一种方法是调整计算机处理过程的顺序，是的任何可能会失败的计算部分都在对象状态被修改之前发生\n\n另外还有一种是实现一段恢复代码，在出错的地方进行恢复\n\n虽然一般情况下都希望实现失败原子性，单并非总是可以做到，如果两个线程企图在没有适当的同步机制的情况下，并发的修改同一个对象，这个对象就有可能被留在不一致的状态中，因此在concurrentModificationException异常之后再假设对象仍然是可用的就是一个错误的论断。\n\n### 不要忽略异常\n\n简而言之catch区不要不做事情\n\n## 并发\n\n### 同步访问共享的可变数据\n\n使用synchronized来进行线程同步，并且阻止另一个线程观察到对象内部不一致的状态。\n\n### 避免过度同步\n\n过度同步会导致死锁\n\n### executor和task优先于线程\n\n创建一个工作队列\n```\nExecutorService executor = Executors.newSingleThreadExecutor();\n```\n\n执行提交一个runnable的方法\n\n```\nexecutor.execute(runnable)\n```\n\n终止executor\n```\nexecutor.shutdown()\n```\n\n","source":"_posts/effective-java学习笔记.md","raw":"---\ntitle: effective-java学习笔记\ndate: 2018-05-07 16:45:46\ntags: java\n---\n\n## 创建和销毁对象。\n\n### 使用静态工厂方法代替构造器\n\n优势：\n\n1 - 静态工厂方法与构造器不同的第一大优势：它们有名称。\n\n由于一个类只能有一个指定签名的构造器，及时我们使用替换顺序来构造不同的构造器，也会产生困扰，不知道该使用哪个。但是静态工厂方法则可以代替构造器，使用不同的名称以显示不同的区别。\n\n2 - 静态工厂方法与构造器不同的第二大优势：不必在每次调用它们的时候都创建一个新的对象。\n\n静态工厂方法可以使用预先构建好的实例，或者将实例缓存起来，进行重复利用。如果程序进场请求创建相同的对象，并且创建对象的代价很高的话，可以考虑使用该方法。\n\n3 - 静态工厂方法与构造器不同的第三大优势：它们可以返回原返回类型的任何子类型的对象。\n\napi可以返回对象，又不会使对象的类变成公有的，类的实现在客户端看来是不可见的。\n\n由于静态工厂方法返回的对象所属的类，在编写包含该静态方法的类时可以不必存在。因此衍生了“服务提供者框架”。\n\n服务提供者框架有三个重要的组件：服务接口，提供者注册api，服务访问api。第四个组件可选，是服务提供者接口。这些提供者负责创建其服务实现的实例，如果没有服务提供者接口，实现就按照类名称注册，并通过反射方式进行实例化。\n\n4 - 静态工厂方法的第四大优势：在创建参数化类型实例的时候，它们使代码变得更加简洁。\n\n例如\n```\nMap<String, List<String>> m = new HashMap<String, List<String>>();\n```\n\n可以通过\n```\npublic static <K, V> HashMap<K, V> newInstance(){\n\treturn new HashMap<K, V>();\n}\n```\n\n改成\n```\nMap<String, List<String>> m = HashMap.newInstance();\n```\n\n缺点：\n\n1 - 类如果不含公有的或者受保护的构造器，就不能子类化。\n\n针对这一条，“复合“好过”继承“\n\n2 - 它们与其他的静态方法实际上没有任何区别。\n\n由于不是构造器，因此没有办法像构造器一样明确标识出来。因此对于提供了静态工厂方法而不是构造器的类来讲，想要查明如何实例化一个类，比较困难。\n\n我们需要遵守一些惯用名称：\n\n- valueOf ---- 该方法返回的实例与他的参数具有相同的值，这样的静态工厂方法世纪上是类转换的方法。\n\n- of ---- valueOf的另一个更加简洁的方法\n\n- getInstance ---- 返回的实例是通过方法的参数来描述的，但是不能说与参数具有相同的值。对于singleton来说，该方法没有参数，并返回唯一的实例。\n\n- newInstance ---- newinstance能够确保返回的每个实例都与所有的其他实例不同\n\n- getType ---- 像getinstance一样，但是gettype表示返回的使用类型。\n\n- newType ---- 和gettype一样。\n\n### 遇到多个构造器参数时要考虑使用构建器\n\n静态工厂和构造器有个共同的局限性，它们都不能很好的扩展到大量的可选参数。\n\n构建器就是使用set方法来设置参数，不过是build模式的。可以利用单个builder构建多个对象，builder的参数可以在创建对象期间进行调整，也可以随着不同的对象而改变。builder可以自动填充某些域，例如每次创建对象时自动增加序列号。\n\n### 用私有构造器或者枚举类型强化singleton属性\n\n- 使用公有静态域\n\n```\npublic class Elvis{\n\tpublic static final Elvis INSTANCE = new Elvis();\n\tprivate Elvis(){\n\t\t...\n\t}\n}\n```\n\n该方法确保只有一个全局变量，但是该方法容易被反射。\n\n- 使用静态工厂方法来实现singleton\n\n```\npublic class Elvis{\n\tprivate static final Elvis INSTANCE = new Elvis();\n\tprivate Elvis{\n\t\t...\n\t}\n\tpublic static Elivs getInstance(){\n\t\treturn INSTANCE;\n\t}\n}\n```\n\ngetInstance()方法的所有调用都会返回同一个对象引用，所以永远不会创建别的对象。\n\n工厂方法的优势在于提供了灵活性，不改变api的前提下，可以改变该类是否是singleton的想法，可序列化但是维护singleton的话需要申明所有实例域是瞬时的，并且要提供一个readResolve方法\n\n```\nprivate Object readResolve(){\n\treturn Instance;\n}\n```\n\n- 编写一个包含单个元素的枚举类型\n\n```\npublic enum Elvis {\n\tINSTANCE;\n}\n```\n\n该方法在功能上与公有域相近，但是更加简洁，并且无偿的提供了序列化机制，绝对防止多次实例化，哪怕是反射的时候。\n\n### 通过私有化构造器强化不可实例化的能力\n\n对于类似于Collections这种，不需要也不希望实例化的类，避免自动构建其无参构造，可以使用以下方法。\n\n```\npublic class UtilityClass{\n\tprivate UtilityClass(){\n\t\tthrow new AssertionError();\n\t}\n}\n```\n\n该方法会导致子类没有构造器。\n\n### 避免创建不必要的对象\n\n对于同时提供静态方法和构造器的不可变类，通常可以使用静态工厂方法而不是构造器，以避免创建不必要的对象。例如Boolean.valueOf(String)几乎总是优先于构造器Boolean(String)。这是由于构造器每次构造的时候都会创建一个对象，而静态方法则不会。\n\n除了重用这种方法之外，还可以重用已知的不会修改的可变对象。\n\n```\npublic class Person{\n\t\n\tprivate final Date birthDate;\n\n\tpublic boolean isBabyBoomer(){\n\t\tCalendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n\t\tgmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);\n\t\tDate boomStart = gmtCal.getTime();\n\t\tgmtCal.set(1956, Calendar.JANUARY, 1, 0, 0, 0);\n\t\tDate boomEnd = gmtCal.getTime();\n\t\treturn birthDate.compare(boomStart) >= 0 && birthDate.compare(boomEnd) < 0;\n\t}\n\n}\n```\n\n如上方法，每次调用都会新建一个Calendar, 一个TimeZone, 和两个Date实例。\n\n```\nclass Person{\n\tprivate final Date birthDate;\n\n\tprivate static final Date BOOM_START;\n\tprivate static final Date BOOM_END;\n\n\tstatic{\n\t\tCalendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n\t\tgmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);\n\t\tBOOM_START = gmtCal.getTime();\n\t\tgmtCal.set(1956, Calendar.JANUARY, 1, 0, 0, 0);\n\t\tBOOM_END = gmtCal.getTime();\n\t}\n\n\tpublic boolean isBabyBoomer(){\n\t\treturn birthDate.compare(BOOM_START) >= 0 && birthDate.compare(BOOM_END) < 0;\n\t}\n\n}\n```\n\n改进后只会创建一个Calendar, 一个TimeZone和一个Date\n\n另外关于基本类型和装箱基本类型之前的变换，如今有自动拆箱和自动拆箱，不过在需要的时候，使用基本类型总是效率好过装箱类型，要小心无意识的自动装箱行为。\n\n### 消除过期的对象引用\n\n该题主要针对内存泄漏现象的分析，对过期引用的分析处理主要在清空引用方法。在android方面的分析处理看着的话用处不大。\n\n仍然是缓存和监听器回调泄漏这些方面。\n\n### 避免使用终结（finalizer）方法\n\n终结方法通常不可预测，一般不可使用。\n\njvm正确的执行对象的终结方法是顺利的回收。但是由于jvm不同，很有可能在不同的平台上不同的算法不同，导致产生的现象大相庭径。\n\n终结方法是以队列的形式进行回收，但是由于终结方法的优先级很低，不确定哪些线程会执行终结方法。因此会造成在终结方法中执行方法的速度小于进入终结方法的速度，会导致大量的回收对象堆积，以此产生oom。\n\n\n## 对于所有对象都通用的方法\n\n这一章是针对Object类\n\n### 覆盖equals是遵守通用约定\n\n#### 针对以下四点，不应该覆盖equals方法，同时不能让其他人调用使用\n\n1. 类的每个实例本质上都是唯一的：对于代表活动实体而不是值的类来说，object提供的equals是正确的。\n\n2. 不关心类是否提供了“逻辑相等”的测试功能：\n\n3. 超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的\n\n4. 类是私有的或是包级私有的，可以确定它的equals方法永远不会被调用：此时需要覆盖以防被意外调用。\n\n```\n@Override\npublic boolean equals(Object o ){\n\tthrow new AssertionError();\n}\n```\n\n#### 如果需要覆盖时，需要遵守以下的规范，来自JavaSE6\n\n1. 自反性：对于任何非null的引用值x，x.equals(x)必须返回true\n\n2. 对称性：对于任何非null的引用值x,y,z，如果x.equals(y) == true, 那么y.equals(x) == true也必须成立\n\n3. 传递性：对于任何非null的引用值x,y,z，如果x.equals(y) == true, y.equals(z) == true,那么x.equals(z) == true也必须成立\n\n4. 一致性：对于任何非null的引用值x，y，只要equals的比较操作在对象中所用的信息没有被修改，那么无论调用多少次equals，返回结果必须是一样的\n\n5. 非空性：对于任何非null的引用值x，x.equals(null)必须返回false\n\n#### 根据以上两个原则以及引申出来的原则，总结实现equals的窍门\n\n1. 使用 == 操作符检查“参数是否为这个对象的引用”\n\n2. 使用 instanceof 操作符检查“参数是否为正确的类型”\n\n3. 把参数转换成正确的类型\n\n4. 对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配（不能只针对某些关键条件来判断，而不是全部关键条件）\n\n5. 当编写完equals方法之后，应该检查对称性、传递性、一致性。\n\n### 覆盖equals时总要覆盖hashcode\n\n由于HashMap,HashSet和HashTable这些散列集合。\n\n散列集合的关键域，就有hashcode，若不覆盖的话，就会产生问题。例如由于hashcode不同，导致两个equals为true的对象，放到了不同的散列桶中，因此导致get出来的值是不同的，违反了上面的规则。\n\n#### 覆盖hashcode的方法\n\n1. 将某个非零的常数值，保存在名为result的int类型的变量中。\n\n2. 对于对象中每个关键域f，完成以下步骤：\n\n\ta. 为该域计算int类型的散列码c：\n\t\ti. f类型是boolean，则计算f?1:0\n\t\tii. 如果该域是byte，char，short或者int类型，则计算(int)f\n\t\tiii. 如果该域是long类型，则计算(int)(f^(f>>32))\n\t\tiv. 如果该域是float类型，则计算Float.floatToIntBits(f)\n\t\tv. 如果该域是double类型，则计算Double.doubleToLongBits(f),然后跳到iii\n\t\tvi. 如果是对象引用，可以设计一个范式，针对这个范式来计算hashcode\n\t\tvii. 如果该域是一个数组，需要针对每一个元素计算一下，然后依据b来计算\n\tb. 按照 result = result * 31 + c\n\n### 始终覆盖toString\n\n使用tostring来进行关键的提示\n\n### 谨慎的覆盖clone\n\n克隆部分主要是针对object的clone来进行浅克隆的缺点分析，和深克隆的优点介绍。\n\n提供了一种不断调用构造器来进行clone的深克隆方法。事实上目前深克隆有了更好的stream方法，所以略过不讲。\n\n之前说过的newinstance方法，其实就是浅克隆\n\n### 考虑实现comparable接口\n\n类实现了comparable接口，可以与许多泛型算法，以及依赖于该接口的集合实现进行协作。不过也同样要遵从自反性，对称性和传递性。\n\n由于类可能有很多个关键域，因此需要由最关键的域开始进行比较，直到所有的域都比较结束，才能算一个comparable接口实现结束\n\n## 类和接口\n\n### 使类和成员的可访问性最小化\n\n出于“封装”的特性，需要将类的方法进行访问性变更，仅仅暴露出一些需要暴露的方法进行模块间的沟通。\n\n有几个规定\n\n实例域不可公有，对于非final的实例域不可公有主要是针对线程安全。另外对于静态final域的对象来讲，需要确保其引用对象不是可变对象，否则也不可公有\n\n长度非0的数组，无论如何声明，也是可变的，因此对于数组的静态域返回，需要使用如下方法。\n\n```\nprivate final static Thing[] PRIVATE_VALUES = {...};\npublic static final Thing[] values(){\n\treturn PRIVATE_VALUES.clone();\n}\n```\n\n### 在公有域方法中使用访问方法，而不是公有域\n\n这就是使用get set等方法，而不是直接暴露出参数，来使用公有域。由于使用这种方法，可以确保通过自设的一些限制，确保返回的参数和自己需要的参数条件相当。\n\n### 使可变性最小化\n\n该例主要是针对不可变类的处理。不可变类是第一次构造时就赋予内部参数的类，类似String类。\n\n使类变成不可变类，需要遵循五条规则：\n\n1. 不要提供任何会修改对象状态的方法\n\n2. 保证类不会被扩展：防止子类化，一般可以将这个类做成final的\n\n3. 使所有的域都是final的：使用系统的强制方式，可以清楚的表明意图\n\n4. 使所有的域都成为私有的：防止客户端获得访问可变对象的权限，并防止客户端直接修改这些对象。\n\n5. 确保对于任何可变组件的互斥访问：如果类具有指向可变对象的域，必须确保该类的客户端无法获得指向这些对象的引用。因此如果需要修改对象，提供set方法。\n\n\n不可变对象比较简单，只有一种状态，即被创建时的状态，本质上是线程安全的，它们不要求同步。并发访问时不会破坏属性，因此可以被自由的共享，同时也不需要进行保护性拷贝。\n\n不仅可以共享不可变对象，甚至也可以共享它们的内部信息。\n\n不可变对象的唯一的缺点是，对于每个不同的值都要一个单独的对象。由于创建对象的代价可能很大，对于大型的对象，这样操作实在是损耗太大。\n\n```\npublic class Complex{\n\tprivate final double re;\n\tprivate final double im;\n\n\tprivate Complex(double re, double im){\n\t\tthis.re = re;\n\t\tthis.im = im;\n\t}\n\n\tpublic static Complex valueOf(double re, double im){\n\t\treturn new Complex(re, im);\n\t}\n}\n```\n\n### 复合优先于继承\n\n继承打破了封装性，当版本的升级导致父类的变化，会造成子类的破坏。因此需要进行复合。\n\n复合的意义是：不拓展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例，这种设计被称作复合。\n\n现有的类变成了新类的一个组件，新类的每个实例方法都可以调用被包含的现有实例中对应的方法，并返回他的结果，这种方式称为转发。新的类被称为包装类。\n\n缺点：包装类不适合用于回调框架\n\n### 要么为继承而设计，并提供文档说明，要么就禁止继承\n\n不是为了继承而设计，并且没有文档说明，会导致子类的继承出现破坏性的问题。\n\n文档必须要精确的描述覆盖每个方法所带来的影响。\n\n\n### 接口优于抽象类\n\n1. 现有的类可以很容易被更新，以实现新的接口\n\n2. 接口是定义mixin(混合类型)的理想选择\n\n3. 接口允许构造非层次接口的类型框架\n\n鉴于上上条“复合优先于继承”，如果使用接口的方式实现，包装类仍然完美使用\n\n### 接口只用于定义类型\n\n接口仅仅用于定义引用这个实例的类型，因此除此之外的接口都是不恰当的。\n\n### 类层次由于标签类\n\n标签类很少有适用的时候，当编写一个包含显式标签域的类时，应当考虑是否应该不使用标签类，而是将标签放到同一个层次的结构中去。\n\n### 用函数对象表示策略\n\njava虽然没有高阶语言的函数式编程，也没有c语言类似的函数指针，但是可以使用对象引用来实现同样的功能。\n\n如\n```\nclass StringLengthComparator{\n\tpublic int compare(String s1, String s2){\n\t\treturn s1.length() - s2.length();\n\t}\n}\n```\n改为\n\n```\nclass StringLengthComparator{\n\tprivate StringLengthComparator(){};\n\tpublic static final StringLengthComparator INSTANCE = new StringLengthComparator();\n\tpublic int compare(String s1, String s2){\n\t\treturn s1.length() - s2.length();\n\t}\n}\n```\n\n典型的具体策略类，是无状态的，没有域，所以所有的实例在功能上面都是等价的。\n\n### 优先考虑静态成员类\n\n嵌套类是指被定义在另一个类的内部的类。嵌套类存在的目的应该只是为他的外围类提供服务。\n\n嵌套类分为四种：静态成员类，非静态成员类，匿名类和局部类，除了第一种之外，其他三种都被称为内部类。\n\n非静态成员类的每个实例都隐含着与外围类的一个外围实例相关联，创建需要外围类的存在。没有外围实例，想创建非静态成员类是基本上不存在的。\n\n一般非静态成员类都是使用常见的adapter来实现，他允许外部类的实例被看做是另一个不相关的类的实例。\n\n因此，成员类不要求访问外部实例，希望外部实例以外的对象调用，就需要将static修饰符放在声明中。\n\n#### 私有静态成员类\n\n私有静态成员类的一中常见用法是用来代表外围类所代表的对象的组件。\n\n例如一个map实例，它把键和值对应起来，许多map实现的内部都有一个entry对象，对应于map中的每个键值对。虽然每个entry都与一个map关联，但是entry上的方法并不需要访问该map，因此，使用非静态成员来标识entry是很浪费的，如果不用static修饰，那么每个entry中将会包含一个指向该map的引用。\n\n#### 匿名类\n\n匿名类没有名字，他不是外围类的成员，他并不与其他的成员一起被申明，匿名类除了被申明的时候之外，是无法实例化的，无法进行instanceof测试，或者任何需要命名类的其他事情。\n\n```\nabstract class Father(){\n....\n}\npublic class Test{\n   Father f1 = new Father(){ .... }  //这里就是有个匿名内部类\n}\n```\n\n#### 局部类\n\n局部类用的很少，局部类只在本地范围内有效。\n\n```\npublic class Test {\n    {\n        class AA{}//块内局部类\n    }\n    public Test(){\n        class AA{}//构造器内局部类\n    }\n    public static void main(String[] args){\n    }\n    public void test(){\n        class AA{}//方法内局部类\n    }\n}\n```\n局部类最多只能有final修饰，但不同的是，块内局部类有enclose class属性，而构造器局部类有enclose constructor属性，方法局部类有enclose method属性，嘛，其实很好理解的吧，一看就知道。\n\n## 泛型\n\n### 请不要在新代码中使用原生态类型\n\n每种范型其实都是一组参数化的类型，他是一种原生态类型（rawtype），即不带任何实际类型参数的泛型名称。\n\n在不确定或者不在乎集合中元素类型的情况下，可以参考以下方式\n\n```\nstatic int numElementsInCommon(Set s1, Set s2){\n\tint result = 0;\n\tfor (Object o1 : s1){\n\t\tif(s2.contains(o1)){\n\t\t\tresult ++;\n\t\t}\n\t}\n\treturn result;\n}\n```\n\n使用原生类型是可以在不关心参数类型的情况下替代泛型，缺很危险，不过泛型也提供了一种安全的替代方式。\n\n```\nSet<E>   --->   Set<?> //可以持有任何集合\n```\n\n对于泛型使用instanceof的首选方法：\n```\nif (o instanceof Set){\n\tSet<?> m = (Set<?>)o;\n\t//一旦确定这个o是个set，就必须将它装换位通配符类型Set<?>而不是原生的Set，这是个受检的转换。\n}\n```\n\n### 消除非受检警告\n\n类似非受检警告如下：\n```\nSet<Lark> exaltation = new HashSet();\n\n[unchecked] unchecked conversion\n```\n\n需要改为如下：\n```\nSet<Lark> exaltation = new HashSet<Lark>();\n```\n\n 无法消除的时候，可以使用注解来压制这条警告。但是压制的时候代表仍然可能是有问题的，所以最好做一些备注或者catch\n\n\n### 列表优先于数组\n\n数组是covariant的，代表如果某个对象a是对象b的子类型，那么a[]也一定是b[]的子类型。\n\n而数组就是invariant的，对于任意两个不同的类型ab，并不能说a的list是b的list的子类，也不能说b的list是a的list的父类。\n\n事实上，本来就应该是如同list这样，数组这样反而是有缺陷的。\n\n数组会在运行时才知道并检查他们的类型，而泛型则是通过擦除来实现的。正因如此，泛型可以与没有使用泛型的代码随意进行互用。\n\n而泛型数组则是不建议创建的，每个不可具化的数组会得到一条警告，除了禁止并且避免在api中混合使用泛型和可变参数之外，别无他法。\n\n创建泛型数组，可以使用\n```\nelements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];\n```\n\n### 优先使用泛型\n\n使用泛型的步骤，可以先使用object，在不使用任何object内在方法以及实例方法的时候，可以完整实现一个类，即可替换使用泛型。\n\n### 优先考虑泛型方法\n\n核心步骤是使用泛型单例工厂方法，不单单可以通过泛型进行类型擦除，也适配了针对不同对象进行不同创建的问题\n\n```\npublic interface Comparable<T>{\n\tint compareTo(T o);\n}\n```\n\n\n```\npublic static <T extends Comparable<T>> T max(List<T> list){\n\t....\n}\n```\n\n类似上述这种，就解决了不同类型的对象比较的问题，所需要的对象仅仅需要在编译过程中实现了comparable，即可参与到比较中来。而回避了类似string和int之间的比较类型。\n\n### 利用有限的通配符来提升api的灵活性\n\n在部分情况下面，使用<? extends E>的方式来进行处理参数类型，有效的避免了部分不兼容接口的数据问题。和上一章讲的类似。\n```\npublic void pushAll(Iterable<? extends E> src){\n\tfor (E e: src){\n\t\tpush(e);\n\t}\n}\n```\n另外提到了一个<? super E>的方式，同上面的不同，这种方式是指?是E的超类\n对应的方法就是popAll\n```\npublic void popAll(Collection<? super E> dst){\n\twhile(!isEmpty()){\n\t\tdst.add(pop());\n\t}\n}\n```\n需要记得步骤PECS： producer-extends, consumer-super\n\n针对既可以消费，也可以生产的，可以使用下述方式\n```\n\tstatic <E> E reduce(List<? extends E> list, Function<E> f, E initVal);\n```\n这样基本上可以确保，list的值可以被f消费，同时list又可以作为一个消费者返回正确的结果。\n\nps:\n\n```\n   static <E> E reduce(List<E> list, Function<? super E> f, E initVal);\n```\n应该也是可以的，相同的意义\n\n### 优先考虑类型安全的异构容器\n\n一般来讲，泛型用于实现一些容器，这些容器大部分包含了单个参数或者类似map的2个参数。如果想要实现更多参数，就需要使用到这章的内容。\n\n实现一个简单的多参数泛型结构\n\n```\npublic class Favorites{\n\tpublic <T> void putFavourite(Class<T> type, T instance);\n\tpublic <T> getFavourite(Class<T> type);\n}\n```\n使用的方法如下：\n```\npublic static void main(String[] args){\n\tFavourite f = new Favourites();\n\tf.putFavourite(String.class, \"Java\");\n\tf.putFavourite(Integer.class, 0x000fffff);\n\tf.putFavourite(Class.class, Favourite.class);\n\tString favouritString = f.getFavourite(String.class);\n\tint favouriteInteger = f.getFavourite(Integer.class);\n\tClass<?> favouritClass = f.getFavourite(Class.class);\n\tSystem.out.printf(\"%s %x %s %n\", favouritString, favouriteInteger, favouritClass.getName());\n}\n```\n\n其中涉及到了Favourites的实现\n\n```\npublic class Favourites{\n\tprivate Map<Class<?>, Object> favourites = new HashMap<Class<?>, Object>();\n\n\tpublic <T> void putFavourite(Class<T> type, T instance){\n\t\tif(type == null){\n\t\t\tthrow new NullPointerException(\"Type is null\");\n\t\t}\n\t\tfavourites.put(type, instance);\n\t}\n\n\tpublic <T> T getFavourite(Class<T> type){\n\t\treturn type.cast(favourites.get(type));\n\t}\n}\n```\n\n这种模式是单key的，所以一个类，只可以对应一个值，实现一个数据库的单列是可以的\n\n其中注意到一点，type.cast()方法，是Class的方法，通过这个方法基本上可以活用泛型。这种type被称为类型，type token被称为类型令牌\n\n```\n@SuppressWarnings(\"unchecked\")\npublic T cast(Object obj) {\n    if (obj != null && !isInstance(obj))\n        throw new ClassCastException(cannotCastMsg(obj));\n    return (T) obj;\n}\n```\nps: Class类中自带了很多有用的方法，有空的时候可以看看\n\n## 枚举和注解\n\n枚举和注解都是jdk1.5发布的\n\n### 用enum代替int常量\n\n一般情况下使用int常量来做flag，会出现常量重复的现象，尤其是自己不注意的时候，可能两个命名不同的变量，却有相同的int值。在部分情况下会导致判断失误的现象\n\n而采用枚举类型则可以完全避免这些问题\n\n```\npublic enum Apple{ FUJI, PIPPIN, GRANNY_SMITH }\n\npublic enum Orange{ NAVEL, TEMPLE, BLOOD }\n```\n\n枚举的本质是通过公有的静态final域为每个枚举常量导出类型的类，由于没有可以访问的构造器，枚举类型是真正的final，并且是实例受控的，不可能进行拓展。他们是单例的泛型化，本质上是单元素的枚举\n\n枚举还提供了多个同名常量的在多个枚举类型中可以有自己的命名空间，可以和平相处。\n\n一个正常的有些复杂度的枚举类型：\n\n```\npublic enum Planet{\n\tMERCURY(3.302e+23, 2.439e6),\n\tVENUS(4.869e+24, 6.052e6),\n\tEARTH(5.975e+24, 6.378e6);\n\tprivate final double mass;\n\tprivate final double radius;\n\tprivate final double surfaceGravity;\n\tprivate static final double G = 6.67300e-11;\n\n\tPlanet(double mass, double radius){\n\t\tthis.mass = mass;\n\t\tthis.radius = radius;\n\t\tsurfaceGravity = G * mass / (radius * radius);\n\t}\n\n\tpublic double mass(){\n\t\treturn mass;\n\t}\n\n\tpublic double radius(){\n\t\treturn radius;\n\t}\n\n\tpublic double surfaceGravity(){\n\t\treturn surfaceGravity;\n\t}\n\n\tpublic double surfaceWeight(double mass){\n\t\treturn mass * surfaceGravity;\n\t}\n}\n```\n使用的方法如下：\n\n```\npublic class WeightTable{\n\tpublic static void main(String[] args){\n\t\tdouble earthWeight = Double.parseDouble(args[0]);\n\t\tdouble nass = earthWeight/ Planet.EARTH.surfaceGravity();\n\t\tfor  (Planet p : Planet.values()){\n\t\t\tSystem.out.printf(\"Weight on %s is %f%n\",p, p.surfaceWeight(mass));\n\t\t}\n\t}\n}\n```\n\n另外枚举类覆盖toString方法，亦可以直接在String中进行处理，这样在算术表达式中比较好处理\n\nps:尝试了一下，枚举类也可以有多态构造方法，内部类也是可以的，但是枚举实例只能放在头部。\n\n### 用实例域代替序数\n\n所有的枚举都有一个方法，叫做ordinal(),代表每个枚举常量在类型中的数字位置。\n\n但是实现的时候不能滥用这个方法，我们假如构造一个枚举类，千万不要无参，而通过这个方法来获取位置。而最起码应该带有一个数字参数\n\n### 用EnumSet代替位域\n\n用位域的好处是可以比较好的使用flag，类似经常用到的比如说intent的flag，textview的flag。\n\n位域有一系列的缺点，尤其是当打印出来的时候，这个我深受其害，在观察view的tree结构时，很多状态位看不懂，还需要翻代码对比才能看出来。\n\n使用enumset代替的确有规避这方面的好处，自己写代码的时候可以注意一下，但是framework的代码其实很难更改这个了。\n\n### 用EnumMap代替序数索引\n\n之前讲过用ordinal方法来进行索引，但是若是出现多个数组的情况，单ordinal就不满足了，需要进行状态的保存。\n\nenummap可以规避这个问题，但是看起来其实可用性不是很高。map的使用场景在android里面不如list。不过在构造容器的时候，使用enummap比较好\n\n### 用接口模拟可伸缩的枚举\n\n通过接口使得枚举拓展化，通过枚举来实现接口，这样使得枚举可以伸缩，虽然无法编写可拓展的枚举类型，但是这样却可以进行枚举的模拟\n\n### 注解优先于命名模式\n\n命名模式有几个缺点:\n1 文字拼写错误会导致失败，比如说测试用例需要test开头，这样就会导致写错test就失败\n\n2 无法确保他们只用于相应的元素上面\n\n3 没有提供参数值与程序元素关联起来的好方法\n\n通过注解可以完美的处理上述问题\n\n### 坚持使用override接口\n\n有助于编译器检查\n\n### 用标记接口定义类型\n\n标记接口类似于retrofit的标记方式，优点是可以精确的被锁定\n\n## 方法\n\n### 检查参数的有效性\n\n对于公开的方法，可以直接使用@throws标签进行标注，然后代码中判断\n\n非公开的方法，使用assert即可\n\n### 必要时进行保护性拷贝\n\n一个例子\n\n```\npublic Period(Data start, Data end){\n\tif(start.compareTo(end)){\n\t\tthrow new IllegalArgumentException(start + \"after\" + end);\n\t}\n\tthis.start = start;\n\tthis.end = end;\n}\n```\n\n由于传入的Data事实上是可变的，因此一旦在构造完之后，再次修改的话，会造成条件不成立。\n\n```\npublic Period(Data start, Data end){\n\tif(start.compareTo(end)){\n\t\tthrow new IllegalArgumentException(start + \"after\" + end);\n\t}\n\tthis.start = new Data(start.getTime());\n\tthis.end = new Data(end.getTime());\n}\n```\n使用这种方式就可以避免上述问题\n\n但是仍然有一种无法避免，就是暴露了相关参数，然后通过get接口获取之后直接更改。\n\n```\npublic Data getStart(){\n\treturn new Data(start.getTime());\n}\n```\n因此在get中也需要进行保护措施\n\n### 谨慎设计方法签名\n\n1 谨慎的选择方法的名称\n\n2 不要过分追求提供便利的方法：主要原则是出于维护性的考虑，每个方法都应该尽其所能，而不应该过度耦合\n\n3 避免过长的参数列表：最多四个参数\n\n### 慎用重载\n\n这一节主要是讨论了重载的部分问题，主要是针对类型的判断，譬如list的remove方法，假如list的包含内容是int，remove的时候remove的是int的话，就会针对index和content起冲突，这是自动装箱和自动拆箱的判断\n\n重载需要考虑基本类型的使用方法，对于基本类型可以使用变形方法，变形方法不是重载，而是具有类似于writeBoolean, writeInt这种类型的方法\n\n\n### 慎用可变参数\n\n使用可变参数的时候，基本问题出现在单个可变参数的问题上面。\n\n```\nstatic int min(int... args){\n\t....\n}\n```\n类似上面这种，传入0个参数也是可以的，但是编译时却无法进行检查，这就会导致空指针异常出现，除非自己进行长度判断\n\n避免以上问题的2个方法，一个是指定类型的正常参数，即是自己进行判断，另一个是扩充参数表，增加一个varargs参数。\n\n在重视性能的前提下，需要明白，使用可变参数方法，每次调用都会导致一次数组分配和初始化，。因此当参数超过3个的时候，第四个及以后的都用可变参数来表示。\n\n### 返回零长度的数组或者集合，而不是null\n\n这节讲的内容主要是针对get方法，或者需要返回集合的方法，当集合不存在或者长度为0时，如果返回null的话会造成比较大的麻烦，这样依赖于下游对于该参数的单独处理\n\n### 为所有导出的api元素编写文档注释\n\n编写文档是门技巧，但不是现在关注的\n\n## 通用程序设计\n\n### 将局部变量的作用于最小化\n\n1. 要使局部变量的作用域最小化，最有利的方法就是在第一次使用它的地方声明\n\n2. 几乎每个局部变量的声明都应该包含一个初始化表达式（这个讲的很有道理，很多地方声明由于丢掉了初始化，基础类型还好，但是若是复杂结构，很大的问题会出现空的情况）\n\n另外如果一个参数的初始化需要使用到trycatch，而这个方法可能抛出异常，那么假如需要使用到这个参数，就将使用这个参数的地方和这个参数放在try内部，如果必须要在try外部使用，那么久必须在try之前被声明\n\n\n### foreach循环优先于传统的for循环\n\n### 了解和使用类库\n\n```\n不要重新发明轮子\n```\n\n### 如果需要精简的答案，避免使用float和double\n\n计算价格其实有更高的方法，就是精确到分即可。或者说以分为计数单位\n\n### 基本类型优先于装箱基本类型\n\n基本类型和装箱基本类型之剑有三个主要区别\n\n1 基本类型只有值，装箱基本类型则有与他们值不同的同一性\n\n2 基本类型只有功能完备的值，而每个装箱基本类型除了它对应基本类型的所有功能值以外，还有个非功能值，null\n\n3 基本类型比装箱基本类型更省时间和内存\n\n另外注意的一点是，装箱类型的比较需要使用到equal而不是==，这点在不同的机器上面展现不同，比如说在androidstudio里面 == 的含义和equal相同，但是在华为手机上面就不同。\n\n### 如果其他类型合适，尽量避免使用字符串\n\n字符串不适合代替其他的值类型\n\n字符串不适合代替枚举类型\n\n字符串不适合代替聚集类型\n\n字符串不适合代替能力表\n\n具体来讲就是该用的时候用，不该用，明显有些问题的场景，覆盖不全面的场景不要用\n\n### 当心字符串连接的性能\n\n字符串拼接的确有很多问题，+的性能开销很大，连接N个字符串，需要的时间是N的平方级。\n\n因此使用StringBuilder替代的话，开销仅仅是线性增加。或者我们可以使用字符数组，每次只处理一个字符串，这样也可以达到增加效率的目的（舍弃了工程效率）\n\n### 接口优先于反射机制\n\n反射的缺点：\n\n1 丧失了编译时检查的好处\n\n2 执行反射访问所需要的代码非常笨拙和冗长\n\n3 性能损失\n\n不过单纯的罗列缺点并不可行，尤其是很多情景下反射其实是不得已而为之，并且在android中，反射的效率并没有太过严重。我测试，大致1000次反射消耗1秒钟，并非不可接受\n\n### 谨慎的使用本地方法\n\n本地方法指的是native方法。\n\n使用本地方法来提高性能的做法不值得提倡：c或c++实现的代码，很容易出现内存毁坏错误的影响，尤其是我们做java开发的，在不熟悉相关语言的时候，\n\n### 谨慎的进行优化\n\n```\n在优化方面，我们应该遵守两条规则:\n\n1 不要优化\n2 在没有明确清晰的优化方案之前，不要进行优化\n```\n\n不要因为性能而牺牲合理的结构，应当编写好的程序而不是快的程序\n\n好的程序有两个规则：将设计决策集中在单个模块中\n\n```\n在每次优化之前和之后，要对性能进行测量\n```\n\n### 遵守普遍接受的命名惯例\n\n遵守驼峰原则\n\n## 异常\n\n### 只针对异常的情况才使用异常\n\n异常在jvm里面优化的比较少，写在try块里面的代码，每一步都会进行异常的检查，这样会造成严重的性能损耗，一般会增加一倍的运行时间。\n\n### 对可恢复的情况使用受检异常，对编程错误使用运行时异常\n\njava提供了三种可抛出的结构：受检的异常，运行时异常，错误。\n\n一般使用运行时异常来表示变成错误。明确的指出代码违例\n\n而受检异常，作为可抛出的结构，但是并不建议使用，因为会带来困惑。\n\n至于警告，说实话错误大部分是对于兼容性的处理，api过期等等，警告本上是很难避免的\n\n### 避免不必要的使用受检的异常\n\n主要是受检的异常会带来代码复杂度增加的问题，尤其是一些无法解决的情况，因此如果该受检其实是不必要的，完全没有必要增加代码复杂度\n\n### 优先使用标准的异常\n\njava提供了一些常用的异常：\n\nillegalArgumentException: 非null的参数值不正确\n\nillegalStateException: 对于方法调用而言，对象状态不合适\n\nnullPointException: 在禁止使用null的情况下参数值为null\n\nindexOutOfBoundsException: 下表参数值越界\n\nconcurrentModificationException: 在禁止并发修改的情况下，检测到对象的并发修改\n\nunsupportedOperationException: 对象不支持用户请求的方法\n\n### 抛出与抽象相对应的异常\n\n异常转译：更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行的解释。\n\n另外还有一种被称作异常链\n\n```\ntry{\n\t...\n}catch(LowerLevelException cause){\n\tthrow new HigherLevelException(cause);\n}\n```\n这样写，加上上层也写了捕捉higherlevelexception的动作，就可以将这个异常链传输到上层了。\n\n不过异常转译其实还是比异常链好一些，毕竟做了完整的处理。而如果凡事依赖异常链的话，那么很难说照顾到所有，如果捕捉了上层无法处理的，然后上层在弹出崩溃，那么一来追踪不是很方便，二来浪费效率\n\n### 每个方法抛出的异常都要有文档\n\n### 在细节消息中包含能捕获失败的信息\n\n这个在项目里有很多用途，主要是弹出给用户看\n\n### 努力使失败保持原子性\n\n失败的方法调用，应该使对象保持在被调用之前的状态。\n\n比较好的方法是进行参数检查，不符合直接抛出，这样就会在修改之前生效。\n\n还有一种方法是调整计算机处理过程的顺序，是的任何可能会失败的计算部分都在对象状态被修改之前发生\n\n另外还有一种是实现一段恢复代码，在出错的地方进行恢复\n\n虽然一般情况下都希望实现失败原子性，单并非总是可以做到，如果两个线程企图在没有适当的同步机制的情况下，并发的修改同一个对象，这个对象就有可能被留在不一致的状态中，因此在concurrentModificationException异常之后再假设对象仍然是可用的就是一个错误的论断。\n\n### 不要忽略异常\n\n简而言之catch区不要不做事情\n\n## 并发\n\n### 同步访问共享的可变数据\n\n使用synchronized来进行线程同步，并且阻止另一个线程观察到对象内部不一致的状态。\n\n### 避免过度同步\n\n过度同步会导致死锁\n\n### executor和task优先于线程\n\n创建一个工作队列\n```\nExecutorService executor = Executors.newSingleThreadExecutor();\n```\n\n执行提交一个runnable的方法\n\n```\nexecutor.execute(runnable)\n```\n\n终止executor\n```\nexecutor.shutdown()\n```\n\n","slug":"effective-java学习笔记","published":1,"updated":"2019-03-12T09:26:33.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltu0k007i3a8k1mtewfg6","content":"<h2 id=\"创建和销毁对象。\"><a href=\"#创建和销毁对象。\" class=\"headerlink\" title=\"创建和销毁对象。\"></a>创建和销毁对象。</h2><h3 id=\"使用静态工厂方法代替构造器\"><a href=\"#使用静态工厂方法代替构造器\" class=\"headerlink\" title=\"使用静态工厂方法代替构造器\"></a>使用静态工厂方法代替构造器</h3><p>优势：</p>\n<p>1 - 静态工厂方法与构造器不同的第一大优势：它们有名称。</p>\n<p>由于一个类只能有一个指定签名的构造器，及时我们使用替换顺序来构造不同的构造器，也会产生困扰，不知道该使用哪个。但是静态工厂方法则可以代替构造器，使用不同的名称以显示不同的区别。</p>\n<p>2 - 静态工厂方法与构造器不同的第二大优势：不必在每次调用它们的时候都创建一个新的对象。</p>\n<p>静态工厂方法可以使用预先构建好的实例，或者将实例缓存起来，进行重复利用。如果程序进场请求创建相同的对象，并且创建对象的代价很高的话，可以考虑使用该方法。</p>\n<p>3 - 静态工厂方法与构造器不同的第三大优势：它们可以返回原返回类型的任何子类型的对象。</p>\n<p>api可以返回对象，又不会使对象的类变成公有的，类的实现在客户端看来是不可见的。</p>\n<p>由于静态工厂方法返回的对象所属的类，在编写包含该静态方法的类时可以不必存在。因此衍生了“服务提供者框架”。</p>\n<p>服务提供者框架有三个重要的组件：服务接口，提供者注册api，服务访问api。第四个组件可选，是服务提供者接口。这些提供者负责创建其服务实现的实例，如果没有服务提供者接口，实现就按照类名称注册，并通过反射方式进行实例化。</p>\n<p>4 - 静态工厂方法的第四大优势：在创建参数化类型实例的时候，它们使代码变得更加简洁。</p>\n<p>例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, List&lt;String&gt;&gt; m = new HashMap&lt;String, List&lt;String&gt;&gt;();</span><br></pre></td></tr></table></figure></p>\n<p>可以通过<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static &lt;K, V&gt; HashMap&lt;K, V&gt; newInstance()&#123;</span><br><span class=\"line\">\treturn new HashMap&lt;K, V&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>改成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, List&lt;String&gt;&gt; m = HashMap.newInstance();</span><br></pre></td></tr></table></figure></p>\n<p>缺点：</p>\n<p>1 - 类如果不含公有的或者受保护的构造器，就不能子类化。</p>\n<p>针对这一条，“复合“好过”继承“</p>\n<p>2 - 它们与其他的静态方法实际上没有任何区别。</p>\n<p>由于不是构造器，因此没有办法像构造器一样明确标识出来。因此对于提供了静态工厂方法而不是构造器的类来讲，想要查明如何实例化一个类，比较困难。</p>\n<p>我们需要遵守一些惯用名称：</p>\n<ul>\n<li><p>valueOf —- 该方法返回的实例与他的参数具有相同的值，这样的静态工厂方法世纪上是类转换的方法。</p>\n</li>\n<li><p>of —- valueOf的另一个更加简洁的方法</p>\n</li>\n<li><p>getInstance —- 返回的实例是通过方法的参数来描述的，但是不能说与参数具有相同的值。对于singleton来说，该方法没有参数，并返回唯一的实例。</p>\n</li>\n<li><p>newInstance —- newinstance能够确保返回的每个实例都与所有的其他实例不同</p>\n</li>\n<li><p>getType —- 像getinstance一样，但是gettype表示返回的使用类型。</p>\n</li>\n<li><p>newType —- 和gettype一样。</p>\n</li>\n</ul>\n<h3 id=\"遇到多个构造器参数时要考虑使用构建器\"><a href=\"#遇到多个构造器参数时要考虑使用构建器\" class=\"headerlink\" title=\"遇到多个构造器参数时要考虑使用构建器\"></a>遇到多个构造器参数时要考虑使用构建器</h3><p>静态工厂和构造器有个共同的局限性，它们都不能很好的扩展到大量的可选参数。</p>\n<p>构建器就是使用set方法来设置参数，不过是build模式的。可以利用单个builder构建多个对象，builder的参数可以在创建对象期间进行调整，也可以随着不同的对象而改变。builder可以自动填充某些域，例如每次创建对象时自动增加序列号。</p>\n<h3 id=\"用私有构造器或者枚举类型强化singleton属性\"><a href=\"#用私有构造器或者枚举类型强化singleton属性\" class=\"headerlink\" title=\"用私有构造器或者枚举类型强化singleton属性\"></a>用私有构造器或者枚举类型强化singleton属性</h3><ul>\n<li>使用公有静态域</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Elvis&#123;</span><br><span class=\"line\">\tpublic static final Elvis INSTANCE = new Elvis();</span><br><span class=\"line\">\tprivate Elvis()&#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法确保只有一个全局变量，但是该方法容易被反射。</p>\n<ul>\n<li>使用静态工厂方法来实现singleton</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Elvis&#123;</span><br><span class=\"line\">\tprivate static final Elvis INSTANCE = new Elvis();</span><br><span class=\"line\">\tprivate Elvis&#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic static Elivs getInstance()&#123;</span><br><span class=\"line\">\t\treturn INSTANCE;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>getInstance()方法的所有调用都会返回同一个对象引用，所以永远不会创建别的对象。</p>\n<p>工厂方法的优势在于提供了灵活性，不改变api的前提下，可以改变该类是否是singleton的想法，可序列化但是维护singleton的话需要申明所有实例域是瞬时的，并且要提供一个readResolve方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Object readResolve()&#123;</span><br><span class=\"line\">\treturn Instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>编写一个包含单个元素的枚举类型</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Elvis &#123;</span><br><span class=\"line\">\tINSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法在功能上与公有域相近，但是更加简洁，并且无偿的提供了序列化机制，绝对防止多次实例化，哪怕是反射的时候。</p>\n<h3 id=\"通过私有化构造器强化不可实例化的能力\"><a href=\"#通过私有化构造器强化不可实例化的能力\" class=\"headerlink\" title=\"通过私有化构造器强化不可实例化的能力\"></a>通过私有化构造器强化不可实例化的能力</h3><p>对于类似于Collections这种，不需要也不希望实例化的类，避免自动构建其无参构造，可以使用以下方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class UtilityClass&#123;</span><br><span class=\"line\">\tprivate UtilityClass()&#123;</span><br><span class=\"line\">\t\tthrow new AssertionError();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法会导致子类没有构造器。</p>\n<h3 id=\"避免创建不必要的对象\"><a href=\"#避免创建不必要的对象\" class=\"headerlink\" title=\"避免创建不必要的对象\"></a>避免创建不必要的对象</h3><p>对于同时提供静态方法和构造器的不可变类，通常可以使用静态工厂方法而不是构造器，以避免创建不必要的对象。例如Boolean.valueOf(String)几乎总是优先于构造器Boolean(String)。这是由于构造器每次构造的时候都会创建一个对象，而静态方法则不会。</p>\n<p>除了重用这种方法之外，还可以重用已知的不会修改的可变对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Person&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tprivate final Date birthDate;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic boolean isBabyBoomer()&#123;</span><br><span class=\"line\">\t\tCalendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span><br><span class=\"line\">\t\tgmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class=\"line\">\t\tDate boomStart = gmtCal.getTime();</span><br><span class=\"line\">\t\tgmtCal.set(1956, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class=\"line\">\t\tDate boomEnd = gmtCal.getTime();</span><br><span class=\"line\">\t\treturn birthDate.compare(boomStart) &gt;= 0 &amp;&amp; birthDate.compare(boomEnd) &lt; 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上方法，每次调用都会新建一个Calendar, 一个TimeZone, 和两个Date实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person&#123;</span><br><span class=\"line\">\tprivate final Date birthDate;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static final Date BOOM_START;</span><br><span class=\"line\">\tprivate static final Date BOOM_END;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstatic&#123;</span><br><span class=\"line\">\t\tCalendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span><br><span class=\"line\">\t\tgmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class=\"line\">\t\tBOOM_START = gmtCal.getTime();</span><br><span class=\"line\">\t\tgmtCal.set(1956, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class=\"line\">\t\tBOOM_END = gmtCal.getTime();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic boolean isBabyBoomer()&#123;</span><br><span class=\"line\">\t\treturn birthDate.compare(BOOM_START) &gt;= 0 &amp;&amp; birthDate.compare(BOOM_END) &lt; 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>改进后只会创建一个Calendar, 一个TimeZone和一个Date</p>\n<p>另外关于基本类型和装箱基本类型之前的变换，如今有自动拆箱和自动拆箱，不过在需要的时候，使用基本类型总是效率好过装箱类型，要小心无意识的自动装箱行为。</p>\n<h3 id=\"消除过期的对象引用\"><a href=\"#消除过期的对象引用\" class=\"headerlink\" title=\"消除过期的对象引用\"></a>消除过期的对象引用</h3><p>该题主要针对内存泄漏现象的分析，对过期引用的分析处理主要在清空引用方法。在android方面的分析处理看着的话用处不大。</p>\n<p>仍然是缓存和监听器回调泄漏这些方面。</p>\n<h3 id=\"避免使用终结（finalizer）方法\"><a href=\"#避免使用终结（finalizer）方法\" class=\"headerlink\" title=\"避免使用终结（finalizer）方法\"></a>避免使用终结（finalizer）方法</h3><p>终结方法通常不可预测，一般不可使用。</p>\n<p>jvm正确的执行对象的终结方法是顺利的回收。但是由于jvm不同，很有可能在不同的平台上不同的算法不同，导致产生的现象大相庭径。</p>\n<p>终结方法是以队列的形式进行回收，但是由于终结方法的优先级很低，不确定哪些线程会执行终结方法。因此会造成在终结方法中执行方法的速度小于进入终结方法的速度，会导致大量的回收对象堆积，以此产生oom。</p>\n<h2 id=\"对于所有对象都通用的方法\"><a href=\"#对于所有对象都通用的方法\" class=\"headerlink\" title=\"对于所有对象都通用的方法\"></a>对于所有对象都通用的方法</h2><p>这一章是针对Object类</p>\n<h3 id=\"覆盖equals是遵守通用约定\"><a href=\"#覆盖equals是遵守通用约定\" class=\"headerlink\" title=\"覆盖equals是遵守通用约定\"></a>覆盖equals是遵守通用约定</h3><h4 id=\"针对以下四点，不应该覆盖equals方法，同时不能让其他人调用使用\"><a href=\"#针对以下四点，不应该覆盖equals方法，同时不能让其他人调用使用\" class=\"headerlink\" title=\"针对以下四点，不应该覆盖equals方法，同时不能让其他人调用使用\"></a>针对以下四点，不应该覆盖equals方法，同时不能让其他人调用使用</h4><ol>\n<li><p>类的每个实例本质上都是唯一的：对于代表活动实体而不是值的类来说，object提供的equals是正确的。</p>\n</li>\n<li><p>不关心类是否提供了“逻辑相等”的测试功能：</p>\n</li>\n<li><p>超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的</p>\n</li>\n<li><p>类是私有的或是包级私有的，可以确定它的equals方法永远不会被调用：此时需要覆盖以防被意外调用。</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean equals(Object o )&#123;</span><br><span class=\"line\">\tthrow new AssertionError();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"如果需要覆盖时，需要遵守以下的规范，来自JavaSE6\"><a href=\"#如果需要覆盖时，需要遵守以下的规范，来自JavaSE6\" class=\"headerlink\" title=\"如果需要覆盖时，需要遵守以下的规范，来自JavaSE6\"></a>如果需要覆盖时，需要遵守以下的规范，来自JavaSE6</h4><ol>\n<li><p>自反性：对于任何非null的引用值x，x.equals(x)必须返回true</p>\n</li>\n<li><p>对称性：对于任何非null的引用值x,y,z，如果x.equals(y) == true, 那么y.equals(x) == true也必须成立</p>\n</li>\n<li><p>传递性：对于任何非null的引用值x,y,z，如果x.equals(y) == true, y.equals(z) == true,那么x.equals(z) == true也必须成立</p>\n</li>\n<li><p>一致性：对于任何非null的引用值x，y，只要equals的比较操作在对象中所用的信息没有被修改，那么无论调用多少次equals，返回结果必须是一样的</p>\n</li>\n<li><p>非空性：对于任何非null的引用值x，x.equals(null)必须返回false</p>\n</li>\n</ol>\n<h4 id=\"根据以上两个原则以及引申出来的原则，总结实现equals的窍门\"><a href=\"#根据以上两个原则以及引申出来的原则，总结实现equals的窍门\" class=\"headerlink\" title=\"根据以上两个原则以及引申出来的原则，总结实现equals的窍门\"></a>根据以上两个原则以及引申出来的原则，总结实现equals的窍门</h4><ol>\n<li><p>使用 == 操作符检查“参数是否为这个对象的引用”</p>\n</li>\n<li><p>使用 instanceof 操作符检查“参数是否为正确的类型”</p>\n</li>\n<li><p>把参数转换成正确的类型</p>\n</li>\n<li><p>对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配（不能只针对某些关键条件来判断，而不是全部关键条件）</p>\n</li>\n<li><p>当编写完equals方法之后，应该检查对称性、传递性、一致性。</p>\n</li>\n</ol>\n<h3 id=\"覆盖equals时总要覆盖hashcode\"><a href=\"#覆盖equals时总要覆盖hashcode\" class=\"headerlink\" title=\"覆盖equals时总要覆盖hashcode\"></a>覆盖equals时总要覆盖hashcode</h3><p>由于HashMap,HashSet和HashTable这些散列集合。</p>\n<p>散列集合的关键域，就有hashcode，若不覆盖的话，就会产生问题。例如由于hashcode不同，导致两个equals为true的对象，放到了不同的散列桶中，因此导致get出来的值是不同的，违反了上面的规则。</p>\n<h4 id=\"覆盖hashcode的方法\"><a href=\"#覆盖hashcode的方法\" class=\"headerlink\" title=\"覆盖hashcode的方法\"></a>覆盖hashcode的方法</h4><ol>\n<li><p>将某个非零的常数值，保存在名为result的int类型的变量中。</p>\n</li>\n<li><p>对于对象中每个关键域f，完成以下步骤：</p>\n<p> a. 为该域计算int类型的散列码c：</p>\n<pre><code>i. f类型是boolean，则计算f?1:0\nii. 如果该域是byte，char，short或者int类型，则计算(int)f\niii. 如果该域是long类型，则计算(int)(f^(f&gt;&gt;32))\niv. 如果该域是float类型，则计算Float.floatToIntBits(f)\nv. 如果该域是double类型，则计算Double.doubleToLongBits(f),然后跳到iii\nvi. 如果是对象引用，可以设计一个范式，针对这个范式来计算hashcode\nvii. 如果该域是一个数组，需要针对每一个元素计算一下，然后依据b来计算\n</code></pre><p> b. 按照 result = result * 31 + c</p>\n</li>\n</ol>\n<h3 id=\"始终覆盖toString\"><a href=\"#始终覆盖toString\" class=\"headerlink\" title=\"始终覆盖toString\"></a>始终覆盖toString</h3><p>使用tostring来进行关键的提示</p>\n<h3 id=\"谨慎的覆盖clone\"><a href=\"#谨慎的覆盖clone\" class=\"headerlink\" title=\"谨慎的覆盖clone\"></a>谨慎的覆盖clone</h3><p>克隆部分主要是针对object的clone来进行浅克隆的缺点分析，和深克隆的优点介绍。</p>\n<p>提供了一种不断调用构造器来进行clone的深克隆方法。事实上目前深克隆有了更好的stream方法，所以略过不讲。</p>\n<p>之前说过的newinstance方法，其实就是浅克隆</p>\n<h3 id=\"考虑实现comparable接口\"><a href=\"#考虑实现comparable接口\" class=\"headerlink\" title=\"考虑实现comparable接口\"></a>考虑实现comparable接口</h3><p>类实现了comparable接口，可以与许多泛型算法，以及依赖于该接口的集合实现进行协作。不过也同样要遵从自反性，对称性和传递性。</p>\n<p>由于类可能有很多个关键域，因此需要由最关键的域开始进行比较，直到所有的域都比较结束，才能算一个comparable接口实现结束</p>\n<h2 id=\"类和接口\"><a href=\"#类和接口\" class=\"headerlink\" title=\"类和接口\"></a>类和接口</h2><h3 id=\"使类和成员的可访问性最小化\"><a href=\"#使类和成员的可访问性最小化\" class=\"headerlink\" title=\"使类和成员的可访问性最小化\"></a>使类和成员的可访问性最小化</h3><p>出于“封装”的特性，需要将类的方法进行访问性变更，仅仅暴露出一些需要暴露的方法进行模块间的沟通。</p>\n<p>有几个规定</p>\n<p>实例域不可公有，对于非final的实例域不可公有主要是针对线程安全。另外对于静态final域的对象来讲，需要确保其引用对象不是可变对象，否则也不可公有</p>\n<p>长度非0的数组，无论如何声明，也是可变的，因此对于数组的静态域返回，需要使用如下方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final static Thing[] PRIVATE_VALUES = &#123;...&#125;;</span><br><span class=\"line\">public static final Thing[] values()&#123;</span><br><span class=\"line\">\treturn PRIVATE_VALUES.clone();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"在公有域方法中使用访问方法，而不是公有域\"><a href=\"#在公有域方法中使用访问方法，而不是公有域\" class=\"headerlink\" title=\"在公有域方法中使用访问方法，而不是公有域\"></a>在公有域方法中使用访问方法，而不是公有域</h3><p>这就是使用get set等方法，而不是直接暴露出参数，来使用公有域。由于使用这种方法，可以确保通过自设的一些限制，确保返回的参数和自己需要的参数条件相当。</p>\n<h3 id=\"使可变性最小化\"><a href=\"#使可变性最小化\" class=\"headerlink\" title=\"使可变性最小化\"></a>使可变性最小化</h3><p>该例主要是针对不可变类的处理。不可变类是第一次构造时就赋予内部参数的类，类似String类。</p>\n<p>使类变成不可变类，需要遵循五条规则：</p>\n<ol>\n<li><p>不要提供任何会修改对象状态的方法</p>\n</li>\n<li><p>保证类不会被扩展：防止子类化，一般可以将这个类做成final的</p>\n</li>\n<li><p>使所有的域都是final的：使用系统的强制方式，可以清楚的表明意图</p>\n</li>\n<li><p>使所有的域都成为私有的：防止客户端获得访问可变对象的权限，并防止客户端直接修改这些对象。</p>\n</li>\n<li><p>确保对于任何可变组件的互斥访问：如果类具有指向可变对象的域，必须确保该类的客户端无法获得指向这些对象的引用。因此如果需要修改对象，提供set方法。</p>\n</li>\n</ol>\n<p>不可变对象比较简单，只有一种状态，即被创建时的状态，本质上是线程安全的，它们不要求同步。并发访问时不会破坏属性，因此可以被自由的共享，同时也不需要进行保护性拷贝。</p>\n<p>不仅可以共享不可变对象，甚至也可以共享它们的内部信息。</p>\n<p>不可变对象的唯一的缺点是，对于每个不同的值都要一个单独的对象。由于创建对象的代价可能很大，对于大型的对象，这样操作实在是损耗太大。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Complex&#123;</span><br><span class=\"line\">\tprivate final double re;</span><br><span class=\"line\">\tprivate final double im;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate Complex(double re, double im)&#123;</span><br><span class=\"line\">\t\tthis.re = re;</span><br><span class=\"line\">\t\tthis.im = im;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static Complex valueOf(double re, double im)&#123;</span><br><span class=\"line\">\t\treturn new Complex(re, im);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"复合优先于继承\"><a href=\"#复合优先于继承\" class=\"headerlink\" title=\"复合优先于继承\"></a>复合优先于继承</h3><p>继承打破了封装性，当版本的升级导致父类的变化，会造成子类的破坏。因此需要进行复合。</p>\n<p>复合的意义是：不拓展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例，这种设计被称作复合。</p>\n<p>现有的类变成了新类的一个组件，新类的每个实例方法都可以调用被包含的现有实例中对应的方法，并返回他的结果，这种方式称为转发。新的类被称为包装类。</p>\n<p>缺点：包装类不适合用于回调框架</p>\n<h3 id=\"要么为继承而设计，并提供文档说明，要么就禁止继承\"><a href=\"#要么为继承而设计，并提供文档说明，要么就禁止继承\" class=\"headerlink\" title=\"要么为继承而设计，并提供文档说明，要么就禁止继承\"></a>要么为继承而设计，并提供文档说明，要么就禁止继承</h3><p>不是为了继承而设计，并且没有文档说明，会导致子类的继承出现破坏性的问题。</p>\n<p>文档必须要精确的描述覆盖每个方法所带来的影响。</p>\n<h3 id=\"接口优于抽象类\"><a href=\"#接口优于抽象类\" class=\"headerlink\" title=\"接口优于抽象类\"></a>接口优于抽象类</h3><ol>\n<li><p>现有的类可以很容易被更新，以实现新的接口</p>\n</li>\n<li><p>接口是定义mixin(混合类型)的理想选择</p>\n</li>\n<li><p>接口允许构造非层次接口的类型框架</p>\n</li>\n</ol>\n<p>鉴于上上条“复合优先于继承”，如果使用接口的方式实现，包装类仍然完美使用</p>\n<h3 id=\"接口只用于定义类型\"><a href=\"#接口只用于定义类型\" class=\"headerlink\" title=\"接口只用于定义类型\"></a>接口只用于定义类型</h3><p>接口仅仅用于定义引用这个实例的类型，因此除此之外的接口都是不恰当的。</p>\n<h3 id=\"类层次由于标签类\"><a href=\"#类层次由于标签类\" class=\"headerlink\" title=\"类层次由于标签类\"></a>类层次由于标签类</h3><p>标签类很少有适用的时候，当编写一个包含显式标签域的类时，应当考虑是否应该不使用标签类，而是将标签放到同一个层次的结构中去。</p>\n<h3 id=\"用函数对象表示策略\"><a href=\"#用函数对象表示策略\" class=\"headerlink\" title=\"用函数对象表示策略\"></a>用函数对象表示策略</h3><p>java虽然没有高阶语言的函数式编程，也没有c语言类似的函数指针，但是可以使用对象引用来实现同样的功能。</p>\n<p>如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class StringLengthComparator&#123;</span><br><span class=\"line\">\tpublic int compare(String s1, String s2)&#123;</span><br><span class=\"line\">\t\treturn s1.length() - s2.length();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class StringLengthComparator&#123;</span><br><span class=\"line\">\tprivate StringLengthComparator()&#123;&#125;;</span><br><span class=\"line\">\tpublic static final StringLengthComparator INSTANCE = new StringLengthComparator();</span><br><span class=\"line\">\tpublic int compare(String s1, String s2)&#123;</span><br><span class=\"line\">\t\treturn s1.length() - s2.length();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>典型的具体策略类，是无状态的，没有域，所以所有的实例在功能上面都是等价的。</p>\n<h3 id=\"优先考虑静态成员类\"><a href=\"#优先考虑静态成员类\" class=\"headerlink\" title=\"优先考虑静态成员类\"></a>优先考虑静态成员类</h3><p>嵌套类是指被定义在另一个类的内部的类。嵌套类存在的目的应该只是为他的外围类提供服务。</p>\n<p>嵌套类分为四种：静态成员类，非静态成员类，匿名类和局部类，除了第一种之外，其他三种都被称为内部类。</p>\n<p>非静态成员类的每个实例都隐含着与外围类的一个外围实例相关联，创建需要外围类的存在。没有外围实例，想创建非静态成员类是基本上不存在的。</p>\n<p>一般非静态成员类都是使用常见的adapter来实现，他允许外部类的实例被看做是另一个不相关的类的实例。</p>\n<p>因此，成员类不要求访问外部实例，希望外部实例以外的对象调用，就需要将static修饰符放在声明中。</p>\n<h4 id=\"私有静态成员类\"><a href=\"#私有静态成员类\" class=\"headerlink\" title=\"私有静态成员类\"></a>私有静态成员类</h4><p>私有静态成员类的一中常见用法是用来代表外围类所代表的对象的组件。</p>\n<p>例如一个map实例，它把键和值对应起来，许多map实现的内部都有一个entry对象，对应于map中的每个键值对。虽然每个entry都与一个map关联，但是entry上的方法并不需要访问该map，因此，使用非静态成员来标识entry是很浪费的，如果不用static修饰，那么每个entry中将会包含一个指向该map的引用。</p>\n<h4 id=\"匿名类\"><a href=\"#匿名类\" class=\"headerlink\" title=\"匿名类\"></a>匿名类</h4><p>匿名类没有名字，他不是外围类的成员，他并不与其他的成员一起被申明，匿名类除了被申明的时候之外，是无法实例化的，无法进行instanceof测试，或者任何需要命名类的其他事情。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abstract class Father()&#123;</span><br><span class=\"line\">....</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">   Father f1 = new Father()&#123; .... &#125;  //这里就是有个匿名内部类</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"局部类\"><a href=\"#局部类\" class=\"headerlink\" title=\"局部类\"></a>局部类</h4><p>局部类用的很少，局部类只在本地范围内有效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        class AA&#123;&#125;//块内局部类</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public Test()&#123;</span><br><span class=\"line\">        class AA&#123;&#125;//构造器内局部类</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args)&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void test()&#123;</span><br><span class=\"line\">        class AA&#123;&#125;//方法内局部类</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>局部类最多只能有final修饰，但不同的是，块内局部类有enclose class属性，而构造器局部类有enclose constructor属性，方法局部类有enclose method属性，嘛，其实很好理解的吧，一看就知道。</p>\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><h3 id=\"请不要在新代码中使用原生态类型\"><a href=\"#请不要在新代码中使用原生态类型\" class=\"headerlink\" title=\"请不要在新代码中使用原生态类型\"></a>请不要在新代码中使用原生态类型</h3><p>每种范型其实都是一组参数化的类型，他是一种原生态类型（rawtype），即不带任何实际类型参数的泛型名称。</p>\n<p>在不确定或者不在乎集合中元素类型的情况下，可以参考以下方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int numElementsInCommon(Set s1, Set s2)&#123;</span><br><span class=\"line\">\tint result = 0;</span><br><span class=\"line\">\tfor (Object o1 : s1)&#123;</span><br><span class=\"line\">\t\tif(s2.contains(o1))&#123;</span><br><span class=\"line\">\t\t\tresult ++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用原生类型是可以在不关心参数类型的情况下替代泛型，缺很危险，不过泛型也提供了一种安全的替代方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;E&gt;   ---&gt;   Set&lt;?&gt; //可以持有任何集合</span><br></pre></td></tr></table></figure>\n<p>对于泛型使用instanceof的首选方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (o instanceof Set)&#123;</span><br><span class=\"line\">\tSet&lt;?&gt; m = (Set&lt;?&gt;)o;</span><br><span class=\"line\">\t//一旦确定这个o是个set，就必须将它装换位通配符类型Set&lt;?&gt;而不是原生的Set，这是个受检的转换。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"消除非受检警告\"><a href=\"#消除非受检警告\" class=\"headerlink\" title=\"消除非受检警告\"></a>消除非受检警告</h3><p>类似非受检警告如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Lark&gt; exaltation = new HashSet();</span><br><span class=\"line\"></span><br><span class=\"line\">[unchecked] unchecked conversion</span><br></pre></td></tr></table></figure></p>\n<p>需要改为如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Lark&gt; exaltation = new HashSet&lt;Lark&gt;();</span><br></pre></td></tr></table></figure></p>\n<p> 无法消除的时候，可以使用注解来压制这条警告。但是压制的时候代表仍然可能是有问题的，所以最好做一些备注或者catch</p>\n<h3 id=\"列表优先于数组\"><a href=\"#列表优先于数组\" class=\"headerlink\" title=\"列表优先于数组\"></a>列表优先于数组</h3><p>数组是covariant的，代表如果某个对象a是对象b的子类型，那么a[]也一定是b[]的子类型。</p>\n<p>而数组就是invariant的，对于任意两个不同的类型ab，并不能说a的list是b的list的子类，也不能说b的list是a的list的父类。</p>\n<p>事实上，本来就应该是如同list这样，数组这样反而是有缺陷的。</p>\n<p>数组会在运行时才知道并检查他们的类型，而泛型则是通过擦除来实现的。正因如此，泛型可以与没有使用泛型的代码随意进行互用。</p>\n<p>而泛型数组则是不建议创建的，每个不可具化的数组会得到一条警告，除了禁止并且避免在api中混合使用泛型和可变参数之外，别无他法。</p>\n<p>创建泛型数组，可以使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"优先使用泛型\"><a href=\"#优先使用泛型\" class=\"headerlink\" title=\"优先使用泛型\"></a>优先使用泛型</h3><p>使用泛型的步骤，可以先使用object，在不使用任何object内在方法以及实例方法的时候，可以完整实现一个类，即可替换使用泛型。</p>\n<h3 id=\"优先考虑泛型方法\"><a href=\"#优先考虑泛型方法\" class=\"headerlink\" title=\"优先考虑泛型方法\"></a>优先考虑泛型方法</h3><p>核心步骤是使用泛型单例工厂方法，不单单可以通过泛型进行类型擦除，也适配了针对不同对象进行不同创建的问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Comparable&lt;T&gt;&#123;</span><br><span class=\"line\">\tint compareTo(T o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static &lt;T extends Comparable&lt;T&gt;&gt; T max(List&lt;T&gt; list)&#123;</span><br><span class=\"line\">\t....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类似上述这种，就解决了不同类型的对象比较的问题，所需要的对象仅仅需要在编译过程中实现了comparable，即可参与到比较中来。而回避了类似string和int之间的比较类型。</p>\n<h3 id=\"利用有限的通配符来提升api的灵活性\"><a href=\"#利用有限的通配符来提升api的灵活性\" class=\"headerlink\" title=\"利用有限的通配符来提升api的灵活性\"></a>利用有限的通配符来提升api的灵活性</h3><p>在部分情况下面，使用&lt;? extends E&gt;的方式来进行处理参数类型，有效的避免了部分不兼容接口的数据问题。和上一章讲的类似。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void pushAll(Iterable&lt;? extends E&gt; src)&#123;</span><br><span class=\"line\">\tfor (E e: src)&#123;</span><br><span class=\"line\">\t\tpush(e);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>另外提到了一个&lt;? super E&gt;的方式，同上面的不同，这种方式是指?是E的超类<br>对应的方法就是popAll<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void popAll(Collection&lt;? super E&gt; dst)&#123;</span><br><span class=\"line\">\twhile(!isEmpty())&#123;</span><br><span class=\"line\">\t\tdst.add(pop());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>需要记得步骤PECS： producer-extends, consumer-super</p>\n<p>针对既可以消费，也可以生产的，可以使用下述方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static &lt;E&gt; E reduce(List&lt;? extends E&gt; list, Function&lt;E&gt; f, E initVal);</span><br></pre></td></tr></table></figure></p>\n<p>这样基本上可以确保，list的值可以被f消费，同时list又可以作为一个消费者返回正确的结果。</p>\n<p>ps:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static &lt;E&gt; E reduce(List&lt;E&gt; list, Function&lt;? super E&gt; f, E initVal);</span><br></pre></td></tr></table></figure>\n<p>应该也是可以的，相同的意义</p>\n<h3 id=\"优先考虑类型安全的异构容器\"><a href=\"#优先考虑类型安全的异构容器\" class=\"headerlink\" title=\"优先考虑类型安全的异构容器\"></a>优先考虑类型安全的异构容器</h3><p>一般来讲，泛型用于实现一些容器，这些容器大部分包含了单个参数或者类似map的2个参数。如果想要实现更多参数，就需要使用到这章的内容。</p>\n<p>实现一个简单的多参数泛型结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Favorites&#123;</span><br><span class=\"line\">\tpublic &lt;T&gt; void putFavourite(Class&lt;T&gt; type, T instance);</span><br><span class=\"line\">\tpublic &lt;T&gt; getFavourite(Class&lt;T&gt; type);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用的方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args)&#123;</span><br><span class=\"line\">\tFavourite f = new Favourites();</span><br><span class=\"line\">\tf.putFavourite(String.class, &quot;Java&quot;);</span><br><span class=\"line\">\tf.putFavourite(Integer.class, 0x000fffff);</span><br><span class=\"line\">\tf.putFavourite(Class.class, Favourite.class);</span><br><span class=\"line\">\tString favouritString = f.getFavourite(String.class);</span><br><span class=\"line\">\tint favouriteInteger = f.getFavourite(Integer.class);</span><br><span class=\"line\">\tClass&lt;?&gt; favouritClass = f.getFavourite(Class.class);</span><br><span class=\"line\">\tSystem.out.printf(&quot;%s %x %s %n&quot;, favouritString, favouriteInteger, favouritClass.getName());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中涉及到了Favourites的实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Favourites&#123;</span><br><span class=\"line\">\tprivate Map&lt;Class&lt;?&gt;, Object&gt; favourites = new HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic &lt;T&gt; void putFavourite(Class&lt;T&gt; type, T instance)&#123;</span><br><span class=\"line\">\t\tif(type == null)&#123;</span><br><span class=\"line\">\t\t\tthrow new NullPointerException(&quot;Type is null&quot;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfavourites.put(type, instance);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic &lt;T&gt; T getFavourite(Class&lt;T&gt; type)&#123;</span><br><span class=\"line\">\t\treturn type.cast(favourites.get(type));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种模式是单key的，所以一个类，只可以对应一个值，实现一个数据库的单列是可以的</p>\n<p>其中注意到一点，type.cast()方法，是Class的方法，通过这个方法基本上可以活用泛型。这种type被称为类型，type token被称为类型令牌</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">public T cast(Object obj) &#123;</span><br><span class=\"line\">    if (obj != null &amp;&amp; !isInstance(obj))</span><br><span class=\"line\">        throw new ClassCastException(cannotCastMsg(obj));</span><br><span class=\"line\">    return (T) obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ps: Class类中自带了很多有用的方法，有空的时候可以看看</p>\n<h2 id=\"枚举和注解\"><a href=\"#枚举和注解\" class=\"headerlink\" title=\"枚举和注解\"></a>枚举和注解</h2><p>枚举和注解都是jdk1.5发布的</p>\n<h3 id=\"用enum代替int常量\"><a href=\"#用enum代替int常量\" class=\"headerlink\" title=\"用enum代替int常量\"></a>用enum代替int常量</h3><p>一般情况下使用int常量来做flag，会出现常量重复的现象，尤其是自己不注意的时候，可能两个命名不同的变量，却有相同的int值。在部分情况下会导致判断失误的现象</p>\n<p>而采用枚举类型则可以完全避免这些问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Apple&#123; FUJI, PIPPIN, GRANNY_SMITH &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public enum Orange&#123; NAVEL, TEMPLE, BLOOD &#125;</span><br></pre></td></tr></table></figure>\n<p>枚举的本质是通过公有的静态final域为每个枚举常量导出类型的类，由于没有可以访问的构造器，枚举类型是真正的final，并且是实例受控的，不可能进行拓展。他们是单例的泛型化，本质上是单元素的枚举</p>\n<p>枚举还提供了多个同名常量的在多个枚举类型中可以有自己的命名空间，可以和平相处。</p>\n<p>一个正常的有些复杂度的枚举类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Planet&#123;</span><br><span class=\"line\">\tMERCURY(3.302e+23, 2.439e6),</span><br><span class=\"line\">\tVENUS(4.869e+24, 6.052e6),</span><br><span class=\"line\">\tEARTH(5.975e+24, 6.378e6);</span><br><span class=\"line\">\tprivate final double mass;</span><br><span class=\"line\">\tprivate final double radius;</span><br><span class=\"line\">\tprivate final double surfaceGravity;</span><br><span class=\"line\">\tprivate static final double G = 6.67300e-11;</span><br><span class=\"line\"></span><br><span class=\"line\">\tPlanet(double mass, double radius)&#123;</span><br><span class=\"line\">\t\tthis.mass = mass;</span><br><span class=\"line\">\t\tthis.radius = radius;</span><br><span class=\"line\">\t\tsurfaceGravity = G * mass / (radius * radius);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic double mass()&#123;</span><br><span class=\"line\">\t\treturn mass;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic double radius()&#123;</span><br><span class=\"line\">\t\treturn radius;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic double surfaceGravity()&#123;</span><br><span class=\"line\">\t\treturn surfaceGravity;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic double surfaceWeight(double mass)&#123;</span><br><span class=\"line\">\t\treturn mass * surfaceGravity;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用的方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WeightTable&#123;</span><br><span class=\"line\">\tpublic static void main(String[] args)&#123;</span><br><span class=\"line\">\t\tdouble earthWeight = Double.parseDouble(args[0]);</span><br><span class=\"line\">\t\tdouble nass = earthWeight/ Planet.EARTH.surfaceGravity();</span><br><span class=\"line\">\t\tfor  (Planet p : Planet.values())&#123;</span><br><span class=\"line\">\t\t\tSystem.out.printf(&quot;Weight on %s is %f%n&quot;,p, p.surfaceWeight(mass));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外枚举类覆盖toString方法，亦可以直接在String中进行处理，这样在算术表达式中比较好处理</p>\n<p>ps:尝试了一下，枚举类也可以有多态构造方法，内部类也是可以的，但是枚举实例只能放在头部。</p>\n<h3 id=\"用实例域代替序数\"><a href=\"#用实例域代替序数\" class=\"headerlink\" title=\"用实例域代替序数\"></a>用实例域代替序数</h3><p>所有的枚举都有一个方法，叫做ordinal(),代表每个枚举常量在类型中的数字位置。</p>\n<p>但是实现的时候不能滥用这个方法，我们假如构造一个枚举类，千万不要无参，而通过这个方法来获取位置。而最起码应该带有一个数字参数</p>\n<h3 id=\"用EnumSet代替位域\"><a href=\"#用EnumSet代替位域\" class=\"headerlink\" title=\"用EnumSet代替位域\"></a>用EnumSet代替位域</h3><p>用位域的好处是可以比较好的使用flag，类似经常用到的比如说intent的flag，textview的flag。</p>\n<p>位域有一系列的缺点，尤其是当打印出来的时候，这个我深受其害，在观察view的tree结构时，很多状态位看不懂，还需要翻代码对比才能看出来。</p>\n<p>使用enumset代替的确有规避这方面的好处，自己写代码的时候可以注意一下，但是framework的代码其实很难更改这个了。</p>\n<h3 id=\"用EnumMap代替序数索引\"><a href=\"#用EnumMap代替序数索引\" class=\"headerlink\" title=\"用EnumMap代替序数索引\"></a>用EnumMap代替序数索引</h3><p>之前讲过用ordinal方法来进行索引，但是若是出现多个数组的情况，单ordinal就不满足了，需要进行状态的保存。</p>\n<p>enummap可以规避这个问题，但是看起来其实可用性不是很高。map的使用场景在android里面不如list。不过在构造容器的时候，使用enummap比较好</p>\n<h3 id=\"用接口模拟可伸缩的枚举\"><a href=\"#用接口模拟可伸缩的枚举\" class=\"headerlink\" title=\"用接口模拟可伸缩的枚举\"></a>用接口模拟可伸缩的枚举</h3><p>通过接口使得枚举拓展化，通过枚举来实现接口，这样使得枚举可以伸缩，虽然无法编写可拓展的枚举类型，但是这样却可以进行枚举的模拟</p>\n<h3 id=\"注解优先于命名模式\"><a href=\"#注解优先于命名模式\" class=\"headerlink\" title=\"注解优先于命名模式\"></a>注解优先于命名模式</h3><p>命名模式有几个缺点:<br>1 文字拼写错误会导致失败，比如说测试用例需要test开头，这样就会导致写错test就失败</p>\n<p>2 无法确保他们只用于相应的元素上面</p>\n<p>3 没有提供参数值与程序元素关联起来的好方法</p>\n<p>通过注解可以完美的处理上述问题</p>\n<h3 id=\"坚持使用override接口\"><a href=\"#坚持使用override接口\" class=\"headerlink\" title=\"坚持使用override接口\"></a>坚持使用override接口</h3><p>有助于编译器检查</p>\n<h3 id=\"用标记接口定义类型\"><a href=\"#用标记接口定义类型\" class=\"headerlink\" title=\"用标记接口定义类型\"></a>用标记接口定义类型</h3><p>标记接口类似于retrofit的标记方式，优点是可以精确的被锁定</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"检查参数的有效性\"><a href=\"#检查参数的有效性\" class=\"headerlink\" title=\"检查参数的有效性\"></a>检查参数的有效性</h3><p>对于公开的方法，可以直接使用@throws标签进行标注，然后代码中判断</p>\n<p>非公开的方法，使用assert即可</p>\n<h3 id=\"必要时进行保护性拷贝\"><a href=\"#必要时进行保护性拷贝\" class=\"headerlink\" title=\"必要时进行保护性拷贝\"></a>必要时进行保护性拷贝</h3><p>一个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Period(Data start, Data end)&#123;</span><br><span class=\"line\">\tif(start.compareTo(end))&#123;</span><br><span class=\"line\">\t\tthrow new IllegalArgumentException(start + &quot;after&quot; + end);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tthis.start = start;</span><br><span class=\"line\">\tthis.end = end;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于传入的Data事实上是可变的，因此一旦在构造完之后，再次修改的话，会造成条件不成立。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Period(Data start, Data end)&#123;</span><br><span class=\"line\">\tif(start.compareTo(end))&#123;</span><br><span class=\"line\">\t\tthrow new IllegalArgumentException(start + &quot;after&quot; + end);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tthis.start = new Data(start.getTime());</span><br><span class=\"line\">\tthis.end = new Data(end.getTime());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用这种方式就可以避免上述问题</p>\n<p>但是仍然有一种无法避免，就是暴露了相关参数，然后通过get接口获取之后直接更改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Data getStart()&#123;</span><br><span class=\"line\">\treturn new Data(start.getTime());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因此在get中也需要进行保护措施</p>\n<h3 id=\"谨慎设计方法签名\"><a href=\"#谨慎设计方法签名\" class=\"headerlink\" title=\"谨慎设计方法签名\"></a>谨慎设计方法签名</h3><p>1 谨慎的选择方法的名称</p>\n<p>2 不要过分追求提供便利的方法：主要原则是出于维护性的考虑，每个方法都应该尽其所能，而不应该过度耦合</p>\n<p>3 避免过长的参数列表：最多四个参数</p>\n<h3 id=\"慎用重载\"><a href=\"#慎用重载\" class=\"headerlink\" title=\"慎用重载\"></a>慎用重载</h3><p>这一节主要是讨论了重载的部分问题，主要是针对类型的判断，譬如list的remove方法，假如list的包含内容是int，remove的时候remove的是int的话，就会针对index和content起冲突，这是自动装箱和自动拆箱的判断</p>\n<p>重载需要考虑基本类型的使用方法，对于基本类型可以使用变形方法，变形方法不是重载，而是具有类似于writeBoolean, writeInt这种类型的方法</p>\n<h3 id=\"慎用可变参数\"><a href=\"#慎用可变参数\" class=\"headerlink\" title=\"慎用可变参数\"></a>慎用可变参数</h3><p>使用可变参数的时候，基本问题出现在单个可变参数的问题上面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int min(int... args)&#123;</span><br><span class=\"line\">\t....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类似上面这种，传入0个参数也是可以的，但是编译时却无法进行检查，这就会导致空指针异常出现，除非自己进行长度判断</p>\n<p>避免以上问题的2个方法，一个是指定类型的正常参数，即是自己进行判断，另一个是扩充参数表，增加一个varargs参数。</p>\n<p>在重视性能的前提下，需要明白，使用可变参数方法，每次调用都会导致一次数组分配和初始化，。因此当参数超过3个的时候，第四个及以后的都用可变参数来表示。</p>\n<h3 id=\"返回零长度的数组或者集合，而不是null\"><a href=\"#返回零长度的数组或者集合，而不是null\" class=\"headerlink\" title=\"返回零长度的数组或者集合，而不是null\"></a>返回零长度的数组或者集合，而不是null</h3><p>这节讲的内容主要是针对get方法，或者需要返回集合的方法，当集合不存在或者长度为0时，如果返回null的话会造成比较大的麻烦，这样依赖于下游对于该参数的单独处理</p>\n<h3 id=\"为所有导出的api元素编写文档注释\"><a href=\"#为所有导出的api元素编写文档注释\" class=\"headerlink\" title=\"为所有导出的api元素编写文档注释\"></a>为所有导出的api元素编写文档注释</h3><p>编写文档是门技巧，但不是现在关注的</p>\n<h2 id=\"通用程序设计\"><a href=\"#通用程序设计\" class=\"headerlink\" title=\"通用程序设计\"></a>通用程序设计</h2><h3 id=\"将局部变量的作用于最小化\"><a href=\"#将局部变量的作用于最小化\" class=\"headerlink\" title=\"将局部变量的作用于最小化\"></a>将局部变量的作用于最小化</h3><ol>\n<li><p>要使局部变量的作用域最小化，最有利的方法就是在第一次使用它的地方声明</p>\n</li>\n<li><p>几乎每个局部变量的声明都应该包含一个初始化表达式（这个讲的很有道理，很多地方声明由于丢掉了初始化，基础类型还好，但是若是复杂结构，很大的问题会出现空的情况）</p>\n</li>\n</ol>\n<p>另外如果一个参数的初始化需要使用到trycatch，而这个方法可能抛出异常，那么假如需要使用到这个参数，就将使用这个参数的地方和这个参数放在try内部，如果必须要在try外部使用，那么久必须在try之前被声明</p>\n<h3 id=\"foreach循环优先于传统的for循环\"><a href=\"#foreach循环优先于传统的for循环\" class=\"headerlink\" title=\"foreach循环优先于传统的for循环\"></a>foreach循环优先于传统的for循环</h3><h3 id=\"了解和使用类库\"><a href=\"#了解和使用类库\" class=\"headerlink\" title=\"了解和使用类库\"></a>了解和使用类库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">不要重新发明轮子</span><br></pre></td></tr></table></figure>\n<h3 id=\"如果需要精简的答案，避免使用float和double\"><a href=\"#如果需要精简的答案，避免使用float和double\" class=\"headerlink\" title=\"如果需要精简的答案，避免使用float和double\"></a>如果需要精简的答案，避免使用float和double</h3><p>计算价格其实有更高的方法，就是精确到分即可。或者说以分为计数单位</p>\n<h3 id=\"基本类型优先于装箱基本类型\"><a href=\"#基本类型优先于装箱基本类型\" class=\"headerlink\" title=\"基本类型优先于装箱基本类型\"></a>基本类型优先于装箱基本类型</h3><p>基本类型和装箱基本类型之剑有三个主要区别</p>\n<p>1 基本类型只有值，装箱基本类型则有与他们值不同的同一性</p>\n<p>2 基本类型只有功能完备的值，而每个装箱基本类型除了它对应基本类型的所有功能值以外，还有个非功能值，null</p>\n<p>3 基本类型比装箱基本类型更省时间和内存</p>\n<p>另外注意的一点是，装箱类型的比较需要使用到equal而不是==，这点在不同的机器上面展现不同，比如说在androidstudio里面 == 的含义和equal相同，但是在华为手机上面就不同。</p>\n<h3 id=\"如果其他类型合适，尽量避免使用字符串\"><a href=\"#如果其他类型合适，尽量避免使用字符串\" class=\"headerlink\" title=\"如果其他类型合适，尽量避免使用字符串\"></a>如果其他类型合适，尽量避免使用字符串</h3><p>字符串不适合代替其他的值类型</p>\n<p>字符串不适合代替枚举类型</p>\n<p>字符串不适合代替聚集类型</p>\n<p>字符串不适合代替能力表</p>\n<p>具体来讲就是该用的时候用，不该用，明显有些问题的场景，覆盖不全面的场景不要用</p>\n<h3 id=\"当心字符串连接的性能\"><a href=\"#当心字符串连接的性能\" class=\"headerlink\" title=\"当心字符串连接的性能\"></a>当心字符串连接的性能</h3><p>字符串拼接的确有很多问题，+的性能开销很大，连接N个字符串，需要的时间是N的平方级。</p>\n<p>因此使用StringBuilder替代的话，开销仅仅是线性增加。或者我们可以使用字符数组，每次只处理一个字符串，这样也可以达到增加效率的目的（舍弃了工程效率）</p>\n<h3 id=\"接口优先于反射机制\"><a href=\"#接口优先于反射机制\" class=\"headerlink\" title=\"接口优先于反射机制\"></a>接口优先于反射机制</h3><p>反射的缺点：</p>\n<p>1 丧失了编译时检查的好处</p>\n<p>2 执行反射访问所需要的代码非常笨拙和冗长</p>\n<p>3 性能损失</p>\n<p>不过单纯的罗列缺点并不可行，尤其是很多情景下反射其实是不得已而为之，并且在android中，反射的效率并没有太过严重。我测试，大致1000次反射消耗1秒钟，并非不可接受</p>\n<h3 id=\"谨慎的使用本地方法\"><a href=\"#谨慎的使用本地方法\" class=\"headerlink\" title=\"谨慎的使用本地方法\"></a>谨慎的使用本地方法</h3><p>本地方法指的是native方法。</p>\n<p>使用本地方法来提高性能的做法不值得提倡：c或c++实现的代码，很容易出现内存毁坏错误的影响，尤其是我们做java开发的，在不熟悉相关语言的时候，</p>\n<h3 id=\"谨慎的进行优化\"><a href=\"#谨慎的进行优化\" class=\"headerlink\" title=\"谨慎的进行优化\"></a>谨慎的进行优化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在优化方面，我们应该遵守两条规则:</span><br><span class=\"line\"></span><br><span class=\"line\">1 不要优化</span><br><span class=\"line\">2 在没有明确清晰的优化方案之前，不要进行优化</span><br></pre></td></tr></table></figure>\n<p>不要因为性能而牺牲合理的结构，应当编写好的程序而不是快的程序</p>\n<p>好的程序有两个规则：将设计决策集中在单个模块中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在每次优化之前和之后，要对性能进行测量</span><br></pre></td></tr></table></figure>\n<h3 id=\"遵守普遍接受的命名惯例\"><a href=\"#遵守普遍接受的命名惯例\" class=\"headerlink\" title=\"遵守普遍接受的命名惯例\"></a>遵守普遍接受的命名惯例</h3><p>遵守驼峰原则</p>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><h3 id=\"只针对异常的情况才使用异常\"><a href=\"#只针对异常的情况才使用异常\" class=\"headerlink\" title=\"只针对异常的情况才使用异常\"></a>只针对异常的情况才使用异常</h3><p>异常在jvm里面优化的比较少，写在try块里面的代码，每一步都会进行异常的检查，这样会造成严重的性能损耗，一般会增加一倍的运行时间。</p>\n<h3 id=\"对可恢复的情况使用受检异常，对编程错误使用运行时异常\"><a href=\"#对可恢复的情况使用受检异常，对编程错误使用运行时异常\" class=\"headerlink\" title=\"对可恢复的情况使用受检异常，对编程错误使用运行时异常\"></a>对可恢复的情况使用受检异常，对编程错误使用运行时异常</h3><p>java提供了三种可抛出的结构：受检的异常，运行时异常，错误。</p>\n<p>一般使用运行时异常来表示变成错误。明确的指出代码违例</p>\n<p>而受检异常，作为可抛出的结构，但是并不建议使用，因为会带来困惑。</p>\n<p>至于警告，说实话错误大部分是对于兼容性的处理，api过期等等，警告本上是很难避免的</p>\n<h3 id=\"避免不必要的使用受检的异常\"><a href=\"#避免不必要的使用受检的异常\" class=\"headerlink\" title=\"避免不必要的使用受检的异常\"></a>避免不必要的使用受检的异常</h3><p>主要是受检的异常会带来代码复杂度增加的问题，尤其是一些无法解决的情况，因此如果该受检其实是不必要的，完全没有必要增加代码复杂度</p>\n<h3 id=\"优先使用标准的异常\"><a href=\"#优先使用标准的异常\" class=\"headerlink\" title=\"优先使用标准的异常\"></a>优先使用标准的异常</h3><p>java提供了一些常用的异常：</p>\n<p>illegalArgumentException: 非null的参数值不正确</p>\n<p>illegalStateException: 对于方法调用而言，对象状态不合适</p>\n<p>nullPointException: 在禁止使用null的情况下参数值为null</p>\n<p>indexOutOfBoundsException: 下表参数值越界</p>\n<p>concurrentModificationException: 在禁止并发修改的情况下，检测到对象的并发修改</p>\n<p>unsupportedOperationException: 对象不支持用户请求的方法</p>\n<h3 id=\"抛出与抽象相对应的异常\"><a href=\"#抛出与抽象相对应的异常\" class=\"headerlink\" title=\"抛出与抽象相对应的异常\"></a>抛出与抽象相对应的异常</h3><p>异常转译：更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行的解释。</p>\n<p>另外还有一种被称作异常链</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;catch(LowerLevelException cause)&#123;</span><br><span class=\"line\">\tthrow new HigherLevelException(cause);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样写，加上上层也写了捕捉higherlevelexception的动作，就可以将这个异常链传输到上层了。</p>\n<p>不过异常转译其实还是比异常链好一些，毕竟做了完整的处理。而如果凡事依赖异常链的话，那么很难说照顾到所有，如果捕捉了上层无法处理的，然后上层在弹出崩溃，那么一来追踪不是很方便，二来浪费效率</p>\n<h3 id=\"每个方法抛出的异常都要有文档\"><a href=\"#每个方法抛出的异常都要有文档\" class=\"headerlink\" title=\"每个方法抛出的异常都要有文档\"></a>每个方法抛出的异常都要有文档</h3><h3 id=\"在细节消息中包含能捕获失败的信息\"><a href=\"#在细节消息中包含能捕获失败的信息\" class=\"headerlink\" title=\"在细节消息中包含能捕获失败的信息\"></a>在细节消息中包含能捕获失败的信息</h3><p>这个在项目里有很多用途，主要是弹出给用户看</p>\n<h3 id=\"努力使失败保持原子性\"><a href=\"#努力使失败保持原子性\" class=\"headerlink\" title=\"努力使失败保持原子性\"></a>努力使失败保持原子性</h3><p>失败的方法调用，应该使对象保持在被调用之前的状态。</p>\n<p>比较好的方法是进行参数检查，不符合直接抛出，这样就会在修改之前生效。</p>\n<p>还有一种方法是调整计算机处理过程的顺序，是的任何可能会失败的计算部分都在对象状态被修改之前发生</p>\n<p>另外还有一种是实现一段恢复代码，在出错的地方进行恢复</p>\n<p>虽然一般情况下都希望实现失败原子性，单并非总是可以做到，如果两个线程企图在没有适当的同步机制的情况下，并发的修改同一个对象，这个对象就有可能被留在不一致的状态中，因此在concurrentModificationException异常之后再假设对象仍然是可用的就是一个错误的论断。</p>\n<h3 id=\"不要忽略异常\"><a href=\"#不要忽略异常\" class=\"headerlink\" title=\"不要忽略异常\"></a>不要忽略异常</h3><p>简而言之catch区不要不做事情</p>\n<h2 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h2><h3 id=\"同步访问共享的可变数据\"><a href=\"#同步访问共享的可变数据\" class=\"headerlink\" title=\"同步访问共享的可变数据\"></a>同步访问共享的可变数据</h3><p>使用synchronized来进行线程同步，并且阻止另一个线程观察到对象内部不一致的状态。</p>\n<h3 id=\"避免过度同步\"><a href=\"#避免过度同步\" class=\"headerlink\" title=\"避免过度同步\"></a>避免过度同步</h3><p>过度同步会导致死锁</p>\n<h3 id=\"executor和task优先于线程\"><a href=\"#executor和task优先于线程\" class=\"headerlink\" title=\"executor和task优先于线程\"></a>executor和task优先于线程</h3><p>创建一个工作队列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService executor = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure></p>\n<p>执行提交一个runnable的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">executor.execute(runnable)</span><br></pre></td></tr></table></figure>\n<p>终止executor<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">executor.shutdown()</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"创建和销毁对象。\"><a href=\"#创建和销毁对象。\" class=\"headerlink\" title=\"创建和销毁对象。\"></a>创建和销毁对象。</h2><h3 id=\"使用静态工厂方法代替构造器\"><a href=\"#使用静态工厂方法代替构造器\" class=\"headerlink\" title=\"使用静态工厂方法代替构造器\"></a>使用静态工厂方法代替构造器</h3><p>优势：</p>\n<p>1 - 静态工厂方法与构造器不同的第一大优势：它们有名称。</p>\n<p>由于一个类只能有一个指定签名的构造器，及时我们使用替换顺序来构造不同的构造器，也会产生困扰，不知道该使用哪个。但是静态工厂方法则可以代替构造器，使用不同的名称以显示不同的区别。</p>\n<p>2 - 静态工厂方法与构造器不同的第二大优势：不必在每次调用它们的时候都创建一个新的对象。</p>\n<p>静态工厂方法可以使用预先构建好的实例，或者将实例缓存起来，进行重复利用。如果程序进场请求创建相同的对象，并且创建对象的代价很高的话，可以考虑使用该方法。</p>\n<p>3 - 静态工厂方法与构造器不同的第三大优势：它们可以返回原返回类型的任何子类型的对象。</p>\n<p>api可以返回对象，又不会使对象的类变成公有的，类的实现在客户端看来是不可见的。</p>\n<p>由于静态工厂方法返回的对象所属的类，在编写包含该静态方法的类时可以不必存在。因此衍生了“服务提供者框架”。</p>\n<p>服务提供者框架有三个重要的组件：服务接口，提供者注册api，服务访问api。第四个组件可选，是服务提供者接口。这些提供者负责创建其服务实现的实例，如果没有服务提供者接口，实现就按照类名称注册，并通过反射方式进行实例化。</p>\n<p>4 - 静态工厂方法的第四大优势：在创建参数化类型实例的时候，它们使代码变得更加简洁。</p>\n<p>例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, List&lt;String&gt;&gt; m = new HashMap&lt;String, List&lt;String&gt;&gt;();</span><br></pre></td></tr></table></figure></p>\n<p>可以通过<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static &lt;K, V&gt; HashMap&lt;K, V&gt; newInstance()&#123;</span><br><span class=\"line\">\treturn new HashMap&lt;K, V&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>改成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, List&lt;String&gt;&gt; m = HashMap.newInstance();</span><br></pre></td></tr></table></figure></p>\n<p>缺点：</p>\n<p>1 - 类如果不含公有的或者受保护的构造器，就不能子类化。</p>\n<p>针对这一条，“复合“好过”继承“</p>\n<p>2 - 它们与其他的静态方法实际上没有任何区别。</p>\n<p>由于不是构造器，因此没有办法像构造器一样明确标识出来。因此对于提供了静态工厂方法而不是构造器的类来讲，想要查明如何实例化一个类，比较困难。</p>\n<p>我们需要遵守一些惯用名称：</p>\n<ul>\n<li><p>valueOf —- 该方法返回的实例与他的参数具有相同的值，这样的静态工厂方法世纪上是类转换的方法。</p>\n</li>\n<li><p>of —- valueOf的另一个更加简洁的方法</p>\n</li>\n<li><p>getInstance —- 返回的实例是通过方法的参数来描述的，但是不能说与参数具有相同的值。对于singleton来说，该方法没有参数，并返回唯一的实例。</p>\n</li>\n<li><p>newInstance —- newinstance能够确保返回的每个实例都与所有的其他实例不同</p>\n</li>\n<li><p>getType —- 像getinstance一样，但是gettype表示返回的使用类型。</p>\n</li>\n<li><p>newType —- 和gettype一样。</p>\n</li>\n</ul>\n<h3 id=\"遇到多个构造器参数时要考虑使用构建器\"><a href=\"#遇到多个构造器参数时要考虑使用构建器\" class=\"headerlink\" title=\"遇到多个构造器参数时要考虑使用构建器\"></a>遇到多个构造器参数时要考虑使用构建器</h3><p>静态工厂和构造器有个共同的局限性，它们都不能很好的扩展到大量的可选参数。</p>\n<p>构建器就是使用set方法来设置参数，不过是build模式的。可以利用单个builder构建多个对象，builder的参数可以在创建对象期间进行调整，也可以随着不同的对象而改变。builder可以自动填充某些域，例如每次创建对象时自动增加序列号。</p>\n<h3 id=\"用私有构造器或者枚举类型强化singleton属性\"><a href=\"#用私有构造器或者枚举类型强化singleton属性\" class=\"headerlink\" title=\"用私有构造器或者枚举类型强化singleton属性\"></a>用私有构造器或者枚举类型强化singleton属性</h3><ul>\n<li>使用公有静态域</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Elvis&#123;</span><br><span class=\"line\">\tpublic static final Elvis INSTANCE = new Elvis();</span><br><span class=\"line\">\tprivate Elvis()&#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法确保只有一个全局变量，但是该方法容易被反射。</p>\n<ul>\n<li>使用静态工厂方法来实现singleton</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Elvis&#123;</span><br><span class=\"line\">\tprivate static final Elvis INSTANCE = new Elvis();</span><br><span class=\"line\">\tprivate Elvis&#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic static Elivs getInstance()&#123;</span><br><span class=\"line\">\t\treturn INSTANCE;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>getInstance()方法的所有调用都会返回同一个对象引用，所以永远不会创建别的对象。</p>\n<p>工厂方法的优势在于提供了灵活性，不改变api的前提下，可以改变该类是否是singleton的想法，可序列化但是维护singleton的话需要申明所有实例域是瞬时的，并且要提供一个readResolve方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Object readResolve()&#123;</span><br><span class=\"line\">\treturn Instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>编写一个包含单个元素的枚举类型</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Elvis &#123;</span><br><span class=\"line\">\tINSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法在功能上与公有域相近，但是更加简洁，并且无偿的提供了序列化机制，绝对防止多次实例化，哪怕是反射的时候。</p>\n<h3 id=\"通过私有化构造器强化不可实例化的能力\"><a href=\"#通过私有化构造器强化不可实例化的能力\" class=\"headerlink\" title=\"通过私有化构造器强化不可实例化的能力\"></a>通过私有化构造器强化不可实例化的能力</h3><p>对于类似于Collections这种，不需要也不希望实例化的类，避免自动构建其无参构造，可以使用以下方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class UtilityClass&#123;</span><br><span class=\"line\">\tprivate UtilityClass()&#123;</span><br><span class=\"line\">\t\tthrow new AssertionError();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法会导致子类没有构造器。</p>\n<h3 id=\"避免创建不必要的对象\"><a href=\"#避免创建不必要的对象\" class=\"headerlink\" title=\"避免创建不必要的对象\"></a>避免创建不必要的对象</h3><p>对于同时提供静态方法和构造器的不可变类，通常可以使用静态工厂方法而不是构造器，以避免创建不必要的对象。例如Boolean.valueOf(String)几乎总是优先于构造器Boolean(String)。这是由于构造器每次构造的时候都会创建一个对象，而静态方法则不会。</p>\n<p>除了重用这种方法之外，还可以重用已知的不会修改的可变对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Person&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tprivate final Date birthDate;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic boolean isBabyBoomer()&#123;</span><br><span class=\"line\">\t\tCalendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span><br><span class=\"line\">\t\tgmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class=\"line\">\t\tDate boomStart = gmtCal.getTime();</span><br><span class=\"line\">\t\tgmtCal.set(1956, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class=\"line\">\t\tDate boomEnd = gmtCal.getTime();</span><br><span class=\"line\">\t\treturn birthDate.compare(boomStart) &gt;= 0 &amp;&amp; birthDate.compare(boomEnd) &lt; 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上方法，每次调用都会新建一个Calendar, 一个TimeZone, 和两个Date实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person&#123;</span><br><span class=\"line\">\tprivate final Date birthDate;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static final Date BOOM_START;</span><br><span class=\"line\">\tprivate static final Date BOOM_END;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstatic&#123;</span><br><span class=\"line\">\t\tCalendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span><br><span class=\"line\">\t\tgmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class=\"line\">\t\tBOOM_START = gmtCal.getTime();</span><br><span class=\"line\">\t\tgmtCal.set(1956, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class=\"line\">\t\tBOOM_END = gmtCal.getTime();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic boolean isBabyBoomer()&#123;</span><br><span class=\"line\">\t\treturn birthDate.compare(BOOM_START) &gt;= 0 &amp;&amp; birthDate.compare(BOOM_END) &lt; 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>改进后只会创建一个Calendar, 一个TimeZone和一个Date</p>\n<p>另外关于基本类型和装箱基本类型之前的变换，如今有自动拆箱和自动拆箱，不过在需要的时候，使用基本类型总是效率好过装箱类型，要小心无意识的自动装箱行为。</p>\n<h3 id=\"消除过期的对象引用\"><a href=\"#消除过期的对象引用\" class=\"headerlink\" title=\"消除过期的对象引用\"></a>消除过期的对象引用</h3><p>该题主要针对内存泄漏现象的分析，对过期引用的分析处理主要在清空引用方法。在android方面的分析处理看着的话用处不大。</p>\n<p>仍然是缓存和监听器回调泄漏这些方面。</p>\n<h3 id=\"避免使用终结（finalizer）方法\"><a href=\"#避免使用终结（finalizer）方法\" class=\"headerlink\" title=\"避免使用终结（finalizer）方法\"></a>避免使用终结（finalizer）方法</h3><p>终结方法通常不可预测，一般不可使用。</p>\n<p>jvm正确的执行对象的终结方法是顺利的回收。但是由于jvm不同，很有可能在不同的平台上不同的算法不同，导致产生的现象大相庭径。</p>\n<p>终结方法是以队列的形式进行回收，但是由于终结方法的优先级很低，不确定哪些线程会执行终结方法。因此会造成在终结方法中执行方法的速度小于进入终结方法的速度，会导致大量的回收对象堆积，以此产生oom。</p>\n<h2 id=\"对于所有对象都通用的方法\"><a href=\"#对于所有对象都通用的方法\" class=\"headerlink\" title=\"对于所有对象都通用的方法\"></a>对于所有对象都通用的方法</h2><p>这一章是针对Object类</p>\n<h3 id=\"覆盖equals是遵守通用约定\"><a href=\"#覆盖equals是遵守通用约定\" class=\"headerlink\" title=\"覆盖equals是遵守通用约定\"></a>覆盖equals是遵守通用约定</h3><h4 id=\"针对以下四点，不应该覆盖equals方法，同时不能让其他人调用使用\"><a href=\"#针对以下四点，不应该覆盖equals方法，同时不能让其他人调用使用\" class=\"headerlink\" title=\"针对以下四点，不应该覆盖equals方法，同时不能让其他人调用使用\"></a>针对以下四点，不应该覆盖equals方法，同时不能让其他人调用使用</h4><ol>\n<li><p>类的每个实例本质上都是唯一的：对于代表活动实体而不是值的类来说，object提供的equals是正确的。</p>\n</li>\n<li><p>不关心类是否提供了“逻辑相等”的测试功能：</p>\n</li>\n<li><p>超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的</p>\n</li>\n<li><p>类是私有的或是包级私有的，可以确定它的equals方法永远不会被调用：此时需要覆盖以防被意外调用。</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean equals(Object o )&#123;</span><br><span class=\"line\">\tthrow new AssertionError();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"如果需要覆盖时，需要遵守以下的规范，来自JavaSE6\"><a href=\"#如果需要覆盖时，需要遵守以下的规范，来自JavaSE6\" class=\"headerlink\" title=\"如果需要覆盖时，需要遵守以下的规范，来自JavaSE6\"></a>如果需要覆盖时，需要遵守以下的规范，来自JavaSE6</h4><ol>\n<li><p>自反性：对于任何非null的引用值x，x.equals(x)必须返回true</p>\n</li>\n<li><p>对称性：对于任何非null的引用值x,y,z，如果x.equals(y) == true, 那么y.equals(x) == true也必须成立</p>\n</li>\n<li><p>传递性：对于任何非null的引用值x,y,z，如果x.equals(y) == true, y.equals(z) == true,那么x.equals(z) == true也必须成立</p>\n</li>\n<li><p>一致性：对于任何非null的引用值x，y，只要equals的比较操作在对象中所用的信息没有被修改，那么无论调用多少次equals，返回结果必须是一样的</p>\n</li>\n<li><p>非空性：对于任何非null的引用值x，x.equals(null)必须返回false</p>\n</li>\n</ol>\n<h4 id=\"根据以上两个原则以及引申出来的原则，总结实现equals的窍门\"><a href=\"#根据以上两个原则以及引申出来的原则，总结实现equals的窍门\" class=\"headerlink\" title=\"根据以上两个原则以及引申出来的原则，总结实现equals的窍门\"></a>根据以上两个原则以及引申出来的原则，总结实现equals的窍门</h4><ol>\n<li><p>使用 == 操作符检查“参数是否为这个对象的引用”</p>\n</li>\n<li><p>使用 instanceof 操作符检查“参数是否为正确的类型”</p>\n</li>\n<li><p>把参数转换成正确的类型</p>\n</li>\n<li><p>对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配（不能只针对某些关键条件来判断，而不是全部关键条件）</p>\n</li>\n<li><p>当编写完equals方法之后，应该检查对称性、传递性、一致性。</p>\n</li>\n</ol>\n<h3 id=\"覆盖equals时总要覆盖hashcode\"><a href=\"#覆盖equals时总要覆盖hashcode\" class=\"headerlink\" title=\"覆盖equals时总要覆盖hashcode\"></a>覆盖equals时总要覆盖hashcode</h3><p>由于HashMap,HashSet和HashTable这些散列集合。</p>\n<p>散列集合的关键域，就有hashcode，若不覆盖的话，就会产生问题。例如由于hashcode不同，导致两个equals为true的对象，放到了不同的散列桶中，因此导致get出来的值是不同的，违反了上面的规则。</p>\n<h4 id=\"覆盖hashcode的方法\"><a href=\"#覆盖hashcode的方法\" class=\"headerlink\" title=\"覆盖hashcode的方法\"></a>覆盖hashcode的方法</h4><ol>\n<li><p>将某个非零的常数值，保存在名为result的int类型的变量中。</p>\n</li>\n<li><p>对于对象中每个关键域f，完成以下步骤：</p>\n<p> a. 为该域计算int类型的散列码c：</p>\n<pre><code>i. f类型是boolean，则计算f?1:0\nii. 如果该域是byte，char，short或者int类型，则计算(int)f\niii. 如果该域是long类型，则计算(int)(f^(f&gt;&gt;32))\niv. 如果该域是float类型，则计算Float.floatToIntBits(f)\nv. 如果该域是double类型，则计算Double.doubleToLongBits(f),然后跳到iii\nvi. 如果是对象引用，可以设计一个范式，针对这个范式来计算hashcode\nvii. 如果该域是一个数组，需要针对每一个元素计算一下，然后依据b来计算\n</code></pre><p> b. 按照 result = result * 31 + c</p>\n</li>\n</ol>\n<h3 id=\"始终覆盖toString\"><a href=\"#始终覆盖toString\" class=\"headerlink\" title=\"始终覆盖toString\"></a>始终覆盖toString</h3><p>使用tostring来进行关键的提示</p>\n<h3 id=\"谨慎的覆盖clone\"><a href=\"#谨慎的覆盖clone\" class=\"headerlink\" title=\"谨慎的覆盖clone\"></a>谨慎的覆盖clone</h3><p>克隆部分主要是针对object的clone来进行浅克隆的缺点分析，和深克隆的优点介绍。</p>\n<p>提供了一种不断调用构造器来进行clone的深克隆方法。事实上目前深克隆有了更好的stream方法，所以略过不讲。</p>\n<p>之前说过的newinstance方法，其实就是浅克隆</p>\n<h3 id=\"考虑实现comparable接口\"><a href=\"#考虑实现comparable接口\" class=\"headerlink\" title=\"考虑实现comparable接口\"></a>考虑实现comparable接口</h3><p>类实现了comparable接口，可以与许多泛型算法，以及依赖于该接口的集合实现进行协作。不过也同样要遵从自反性，对称性和传递性。</p>\n<p>由于类可能有很多个关键域，因此需要由最关键的域开始进行比较，直到所有的域都比较结束，才能算一个comparable接口实现结束</p>\n<h2 id=\"类和接口\"><a href=\"#类和接口\" class=\"headerlink\" title=\"类和接口\"></a>类和接口</h2><h3 id=\"使类和成员的可访问性最小化\"><a href=\"#使类和成员的可访问性最小化\" class=\"headerlink\" title=\"使类和成员的可访问性最小化\"></a>使类和成员的可访问性最小化</h3><p>出于“封装”的特性，需要将类的方法进行访问性变更，仅仅暴露出一些需要暴露的方法进行模块间的沟通。</p>\n<p>有几个规定</p>\n<p>实例域不可公有，对于非final的实例域不可公有主要是针对线程安全。另外对于静态final域的对象来讲，需要确保其引用对象不是可变对象，否则也不可公有</p>\n<p>长度非0的数组，无论如何声明，也是可变的，因此对于数组的静态域返回，需要使用如下方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final static Thing[] PRIVATE_VALUES = &#123;...&#125;;</span><br><span class=\"line\">public static final Thing[] values()&#123;</span><br><span class=\"line\">\treturn PRIVATE_VALUES.clone();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"在公有域方法中使用访问方法，而不是公有域\"><a href=\"#在公有域方法中使用访问方法，而不是公有域\" class=\"headerlink\" title=\"在公有域方法中使用访问方法，而不是公有域\"></a>在公有域方法中使用访问方法，而不是公有域</h3><p>这就是使用get set等方法，而不是直接暴露出参数，来使用公有域。由于使用这种方法，可以确保通过自设的一些限制，确保返回的参数和自己需要的参数条件相当。</p>\n<h3 id=\"使可变性最小化\"><a href=\"#使可变性最小化\" class=\"headerlink\" title=\"使可变性最小化\"></a>使可变性最小化</h3><p>该例主要是针对不可变类的处理。不可变类是第一次构造时就赋予内部参数的类，类似String类。</p>\n<p>使类变成不可变类，需要遵循五条规则：</p>\n<ol>\n<li><p>不要提供任何会修改对象状态的方法</p>\n</li>\n<li><p>保证类不会被扩展：防止子类化，一般可以将这个类做成final的</p>\n</li>\n<li><p>使所有的域都是final的：使用系统的强制方式，可以清楚的表明意图</p>\n</li>\n<li><p>使所有的域都成为私有的：防止客户端获得访问可变对象的权限，并防止客户端直接修改这些对象。</p>\n</li>\n<li><p>确保对于任何可变组件的互斥访问：如果类具有指向可变对象的域，必须确保该类的客户端无法获得指向这些对象的引用。因此如果需要修改对象，提供set方法。</p>\n</li>\n</ol>\n<p>不可变对象比较简单，只有一种状态，即被创建时的状态，本质上是线程安全的，它们不要求同步。并发访问时不会破坏属性，因此可以被自由的共享，同时也不需要进行保护性拷贝。</p>\n<p>不仅可以共享不可变对象，甚至也可以共享它们的内部信息。</p>\n<p>不可变对象的唯一的缺点是，对于每个不同的值都要一个单独的对象。由于创建对象的代价可能很大，对于大型的对象，这样操作实在是损耗太大。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Complex&#123;</span><br><span class=\"line\">\tprivate final double re;</span><br><span class=\"line\">\tprivate final double im;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate Complex(double re, double im)&#123;</span><br><span class=\"line\">\t\tthis.re = re;</span><br><span class=\"line\">\t\tthis.im = im;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static Complex valueOf(double re, double im)&#123;</span><br><span class=\"line\">\t\treturn new Complex(re, im);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"复合优先于继承\"><a href=\"#复合优先于继承\" class=\"headerlink\" title=\"复合优先于继承\"></a>复合优先于继承</h3><p>继承打破了封装性，当版本的升级导致父类的变化，会造成子类的破坏。因此需要进行复合。</p>\n<p>复合的意义是：不拓展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例，这种设计被称作复合。</p>\n<p>现有的类变成了新类的一个组件，新类的每个实例方法都可以调用被包含的现有实例中对应的方法，并返回他的结果，这种方式称为转发。新的类被称为包装类。</p>\n<p>缺点：包装类不适合用于回调框架</p>\n<h3 id=\"要么为继承而设计，并提供文档说明，要么就禁止继承\"><a href=\"#要么为继承而设计，并提供文档说明，要么就禁止继承\" class=\"headerlink\" title=\"要么为继承而设计，并提供文档说明，要么就禁止继承\"></a>要么为继承而设计，并提供文档说明，要么就禁止继承</h3><p>不是为了继承而设计，并且没有文档说明，会导致子类的继承出现破坏性的问题。</p>\n<p>文档必须要精确的描述覆盖每个方法所带来的影响。</p>\n<h3 id=\"接口优于抽象类\"><a href=\"#接口优于抽象类\" class=\"headerlink\" title=\"接口优于抽象类\"></a>接口优于抽象类</h3><ol>\n<li><p>现有的类可以很容易被更新，以实现新的接口</p>\n</li>\n<li><p>接口是定义mixin(混合类型)的理想选择</p>\n</li>\n<li><p>接口允许构造非层次接口的类型框架</p>\n</li>\n</ol>\n<p>鉴于上上条“复合优先于继承”，如果使用接口的方式实现，包装类仍然完美使用</p>\n<h3 id=\"接口只用于定义类型\"><a href=\"#接口只用于定义类型\" class=\"headerlink\" title=\"接口只用于定义类型\"></a>接口只用于定义类型</h3><p>接口仅仅用于定义引用这个实例的类型，因此除此之外的接口都是不恰当的。</p>\n<h3 id=\"类层次由于标签类\"><a href=\"#类层次由于标签类\" class=\"headerlink\" title=\"类层次由于标签类\"></a>类层次由于标签类</h3><p>标签类很少有适用的时候，当编写一个包含显式标签域的类时，应当考虑是否应该不使用标签类，而是将标签放到同一个层次的结构中去。</p>\n<h3 id=\"用函数对象表示策略\"><a href=\"#用函数对象表示策略\" class=\"headerlink\" title=\"用函数对象表示策略\"></a>用函数对象表示策略</h3><p>java虽然没有高阶语言的函数式编程，也没有c语言类似的函数指针，但是可以使用对象引用来实现同样的功能。</p>\n<p>如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class StringLengthComparator&#123;</span><br><span class=\"line\">\tpublic int compare(String s1, String s2)&#123;</span><br><span class=\"line\">\t\treturn s1.length() - s2.length();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class StringLengthComparator&#123;</span><br><span class=\"line\">\tprivate StringLengthComparator()&#123;&#125;;</span><br><span class=\"line\">\tpublic static final StringLengthComparator INSTANCE = new StringLengthComparator();</span><br><span class=\"line\">\tpublic int compare(String s1, String s2)&#123;</span><br><span class=\"line\">\t\treturn s1.length() - s2.length();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>典型的具体策略类，是无状态的，没有域，所以所有的实例在功能上面都是等价的。</p>\n<h3 id=\"优先考虑静态成员类\"><a href=\"#优先考虑静态成员类\" class=\"headerlink\" title=\"优先考虑静态成员类\"></a>优先考虑静态成员类</h3><p>嵌套类是指被定义在另一个类的内部的类。嵌套类存在的目的应该只是为他的外围类提供服务。</p>\n<p>嵌套类分为四种：静态成员类，非静态成员类，匿名类和局部类，除了第一种之外，其他三种都被称为内部类。</p>\n<p>非静态成员类的每个实例都隐含着与外围类的一个外围实例相关联，创建需要外围类的存在。没有外围实例，想创建非静态成员类是基本上不存在的。</p>\n<p>一般非静态成员类都是使用常见的adapter来实现，他允许外部类的实例被看做是另一个不相关的类的实例。</p>\n<p>因此，成员类不要求访问外部实例，希望外部实例以外的对象调用，就需要将static修饰符放在声明中。</p>\n<h4 id=\"私有静态成员类\"><a href=\"#私有静态成员类\" class=\"headerlink\" title=\"私有静态成员类\"></a>私有静态成员类</h4><p>私有静态成员类的一中常见用法是用来代表外围类所代表的对象的组件。</p>\n<p>例如一个map实例，它把键和值对应起来，许多map实现的内部都有一个entry对象，对应于map中的每个键值对。虽然每个entry都与一个map关联，但是entry上的方法并不需要访问该map，因此，使用非静态成员来标识entry是很浪费的，如果不用static修饰，那么每个entry中将会包含一个指向该map的引用。</p>\n<h4 id=\"匿名类\"><a href=\"#匿名类\" class=\"headerlink\" title=\"匿名类\"></a>匿名类</h4><p>匿名类没有名字，他不是外围类的成员，他并不与其他的成员一起被申明，匿名类除了被申明的时候之外，是无法实例化的，无法进行instanceof测试，或者任何需要命名类的其他事情。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abstract class Father()&#123;</span><br><span class=\"line\">....</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">   Father f1 = new Father()&#123; .... &#125;  //这里就是有个匿名内部类</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"局部类\"><a href=\"#局部类\" class=\"headerlink\" title=\"局部类\"></a>局部类</h4><p>局部类用的很少，局部类只在本地范围内有效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        class AA&#123;&#125;//块内局部类</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public Test()&#123;</span><br><span class=\"line\">        class AA&#123;&#125;//构造器内局部类</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args)&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void test()&#123;</span><br><span class=\"line\">        class AA&#123;&#125;//方法内局部类</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>局部类最多只能有final修饰，但不同的是，块内局部类有enclose class属性，而构造器局部类有enclose constructor属性，方法局部类有enclose method属性，嘛，其实很好理解的吧，一看就知道。</p>\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><h3 id=\"请不要在新代码中使用原生态类型\"><a href=\"#请不要在新代码中使用原生态类型\" class=\"headerlink\" title=\"请不要在新代码中使用原生态类型\"></a>请不要在新代码中使用原生态类型</h3><p>每种范型其实都是一组参数化的类型，他是一种原生态类型（rawtype），即不带任何实际类型参数的泛型名称。</p>\n<p>在不确定或者不在乎集合中元素类型的情况下，可以参考以下方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int numElementsInCommon(Set s1, Set s2)&#123;</span><br><span class=\"line\">\tint result = 0;</span><br><span class=\"line\">\tfor (Object o1 : s1)&#123;</span><br><span class=\"line\">\t\tif(s2.contains(o1))&#123;</span><br><span class=\"line\">\t\t\tresult ++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用原生类型是可以在不关心参数类型的情况下替代泛型，缺很危险，不过泛型也提供了一种安全的替代方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;E&gt;   ---&gt;   Set&lt;?&gt; //可以持有任何集合</span><br></pre></td></tr></table></figure>\n<p>对于泛型使用instanceof的首选方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (o instanceof Set)&#123;</span><br><span class=\"line\">\tSet&lt;?&gt; m = (Set&lt;?&gt;)o;</span><br><span class=\"line\">\t//一旦确定这个o是个set，就必须将它装换位通配符类型Set&lt;?&gt;而不是原生的Set，这是个受检的转换。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"消除非受检警告\"><a href=\"#消除非受检警告\" class=\"headerlink\" title=\"消除非受检警告\"></a>消除非受检警告</h3><p>类似非受检警告如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Lark&gt; exaltation = new HashSet();</span><br><span class=\"line\"></span><br><span class=\"line\">[unchecked] unchecked conversion</span><br></pre></td></tr></table></figure></p>\n<p>需要改为如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Lark&gt; exaltation = new HashSet&lt;Lark&gt;();</span><br></pre></td></tr></table></figure></p>\n<p> 无法消除的时候，可以使用注解来压制这条警告。但是压制的时候代表仍然可能是有问题的，所以最好做一些备注或者catch</p>\n<h3 id=\"列表优先于数组\"><a href=\"#列表优先于数组\" class=\"headerlink\" title=\"列表优先于数组\"></a>列表优先于数组</h3><p>数组是covariant的，代表如果某个对象a是对象b的子类型，那么a[]也一定是b[]的子类型。</p>\n<p>而数组就是invariant的，对于任意两个不同的类型ab，并不能说a的list是b的list的子类，也不能说b的list是a的list的父类。</p>\n<p>事实上，本来就应该是如同list这样，数组这样反而是有缺陷的。</p>\n<p>数组会在运行时才知道并检查他们的类型，而泛型则是通过擦除来实现的。正因如此，泛型可以与没有使用泛型的代码随意进行互用。</p>\n<p>而泛型数组则是不建议创建的，每个不可具化的数组会得到一条警告，除了禁止并且避免在api中混合使用泛型和可变参数之外，别无他法。</p>\n<p>创建泛型数组，可以使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"优先使用泛型\"><a href=\"#优先使用泛型\" class=\"headerlink\" title=\"优先使用泛型\"></a>优先使用泛型</h3><p>使用泛型的步骤，可以先使用object，在不使用任何object内在方法以及实例方法的时候，可以完整实现一个类，即可替换使用泛型。</p>\n<h3 id=\"优先考虑泛型方法\"><a href=\"#优先考虑泛型方法\" class=\"headerlink\" title=\"优先考虑泛型方法\"></a>优先考虑泛型方法</h3><p>核心步骤是使用泛型单例工厂方法，不单单可以通过泛型进行类型擦除，也适配了针对不同对象进行不同创建的问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Comparable&lt;T&gt;&#123;</span><br><span class=\"line\">\tint compareTo(T o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static &lt;T extends Comparable&lt;T&gt;&gt; T max(List&lt;T&gt; list)&#123;</span><br><span class=\"line\">\t....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类似上述这种，就解决了不同类型的对象比较的问题，所需要的对象仅仅需要在编译过程中实现了comparable，即可参与到比较中来。而回避了类似string和int之间的比较类型。</p>\n<h3 id=\"利用有限的通配符来提升api的灵活性\"><a href=\"#利用有限的通配符来提升api的灵活性\" class=\"headerlink\" title=\"利用有限的通配符来提升api的灵活性\"></a>利用有限的通配符来提升api的灵活性</h3><p>在部分情况下面，使用&lt;? extends E&gt;的方式来进行处理参数类型，有效的避免了部分不兼容接口的数据问题。和上一章讲的类似。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void pushAll(Iterable&lt;? extends E&gt; src)&#123;</span><br><span class=\"line\">\tfor (E e: src)&#123;</span><br><span class=\"line\">\t\tpush(e);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>另外提到了一个&lt;? super E&gt;的方式，同上面的不同，这种方式是指?是E的超类<br>对应的方法就是popAll<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void popAll(Collection&lt;? super E&gt; dst)&#123;</span><br><span class=\"line\">\twhile(!isEmpty())&#123;</span><br><span class=\"line\">\t\tdst.add(pop());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>需要记得步骤PECS： producer-extends, consumer-super</p>\n<p>针对既可以消费，也可以生产的，可以使用下述方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static &lt;E&gt; E reduce(List&lt;? extends E&gt; list, Function&lt;E&gt; f, E initVal);</span><br></pre></td></tr></table></figure></p>\n<p>这样基本上可以确保，list的值可以被f消费，同时list又可以作为一个消费者返回正确的结果。</p>\n<p>ps:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static &lt;E&gt; E reduce(List&lt;E&gt; list, Function&lt;? super E&gt; f, E initVal);</span><br></pre></td></tr></table></figure>\n<p>应该也是可以的，相同的意义</p>\n<h3 id=\"优先考虑类型安全的异构容器\"><a href=\"#优先考虑类型安全的异构容器\" class=\"headerlink\" title=\"优先考虑类型安全的异构容器\"></a>优先考虑类型安全的异构容器</h3><p>一般来讲，泛型用于实现一些容器，这些容器大部分包含了单个参数或者类似map的2个参数。如果想要实现更多参数，就需要使用到这章的内容。</p>\n<p>实现一个简单的多参数泛型结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Favorites&#123;</span><br><span class=\"line\">\tpublic &lt;T&gt; void putFavourite(Class&lt;T&gt; type, T instance);</span><br><span class=\"line\">\tpublic &lt;T&gt; getFavourite(Class&lt;T&gt; type);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用的方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args)&#123;</span><br><span class=\"line\">\tFavourite f = new Favourites();</span><br><span class=\"line\">\tf.putFavourite(String.class, &quot;Java&quot;);</span><br><span class=\"line\">\tf.putFavourite(Integer.class, 0x000fffff);</span><br><span class=\"line\">\tf.putFavourite(Class.class, Favourite.class);</span><br><span class=\"line\">\tString favouritString = f.getFavourite(String.class);</span><br><span class=\"line\">\tint favouriteInteger = f.getFavourite(Integer.class);</span><br><span class=\"line\">\tClass&lt;?&gt; favouritClass = f.getFavourite(Class.class);</span><br><span class=\"line\">\tSystem.out.printf(&quot;%s %x %s %n&quot;, favouritString, favouriteInteger, favouritClass.getName());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中涉及到了Favourites的实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Favourites&#123;</span><br><span class=\"line\">\tprivate Map&lt;Class&lt;?&gt;, Object&gt; favourites = new HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic &lt;T&gt; void putFavourite(Class&lt;T&gt; type, T instance)&#123;</span><br><span class=\"line\">\t\tif(type == null)&#123;</span><br><span class=\"line\">\t\t\tthrow new NullPointerException(&quot;Type is null&quot;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfavourites.put(type, instance);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic &lt;T&gt; T getFavourite(Class&lt;T&gt; type)&#123;</span><br><span class=\"line\">\t\treturn type.cast(favourites.get(type));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种模式是单key的，所以一个类，只可以对应一个值，实现一个数据库的单列是可以的</p>\n<p>其中注意到一点，type.cast()方法，是Class的方法，通过这个方法基本上可以活用泛型。这种type被称为类型，type token被称为类型令牌</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">public T cast(Object obj) &#123;</span><br><span class=\"line\">    if (obj != null &amp;&amp; !isInstance(obj))</span><br><span class=\"line\">        throw new ClassCastException(cannotCastMsg(obj));</span><br><span class=\"line\">    return (T) obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ps: Class类中自带了很多有用的方法，有空的时候可以看看</p>\n<h2 id=\"枚举和注解\"><a href=\"#枚举和注解\" class=\"headerlink\" title=\"枚举和注解\"></a>枚举和注解</h2><p>枚举和注解都是jdk1.5发布的</p>\n<h3 id=\"用enum代替int常量\"><a href=\"#用enum代替int常量\" class=\"headerlink\" title=\"用enum代替int常量\"></a>用enum代替int常量</h3><p>一般情况下使用int常量来做flag，会出现常量重复的现象，尤其是自己不注意的时候，可能两个命名不同的变量，却有相同的int值。在部分情况下会导致判断失误的现象</p>\n<p>而采用枚举类型则可以完全避免这些问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Apple&#123; FUJI, PIPPIN, GRANNY_SMITH &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public enum Orange&#123; NAVEL, TEMPLE, BLOOD &#125;</span><br></pre></td></tr></table></figure>\n<p>枚举的本质是通过公有的静态final域为每个枚举常量导出类型的类，由于没有可以访问的构造器，枚举类型是真正的final，并且是实例受控的，不可能进行拓展。他们是单例的泛型化，本质上是单元素的枚举</p>\n<p>枚举还提供了多个同名常量的在多个枚举类型中可以有自己的命名空间，可以和平相处。</p>\n<p>一个正常的有些复杂度的枚举类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Planet&#123;</span><br><span class=\"line\">\tMERCURY(3.302e+23, 2.439e6),</span><br><span class=\"line\">\tVENUS(4.869e+24, 6.052e6),</span><br><span class=\"line\">\tEARTH(5.975e+24, 6.378e6);</span><br><span class=\"line\">\tprivate final double mass;</span><br><span class=\"line\">\tprivate final double radius;</span><br><span class=\"line\">\tprivate final double surfaceGravity;</span><br><span class=\"line\">\tprivate static final double G = 6.67300e-11;</span><br><span class=\"line\"></span><br><span class=\"line\">\tPlanet(double mass, double radius)&#123;</span><br><span class=\"line\">\t\tthis.mass = mass;</span><br><span class=\"line\">\t\tthis.radius = radius;</span><br><span class=\"line\">\t\tsurfaceGravity = G * mass / (radius * radius);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic double mass()&#123;</span><br><span class=\"line\">\t\treturn mass;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic double radius()&#123;</span><br><span class=\"line\">\t\treturn radius;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic double surfaceGravity()&#123;</span><br><span class=\"line\">\t\treturn surfaceGravity;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic double surfaceWeight(double mass)&#123;</span><br><span class=\"line\">\t\treturn mass * surfaceGravity;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用的方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WeightTable&#123;</span><br><span class=\"line\">\tpublic static void main(String[] args)&#123;</span><br><span class=\"line\">\t\tdouble earthWeight = Double.parseDouble(args[0]);</span><br><span class=\"line\">\t\tdouble nass = earthWeight/ Planet.EARTH.surfaceGravity();</span><br><span class=\"line\">\t\tfor  (Planet p : Planet.values())&#123;</span><br><span class=\"line\">\t\t\tSystem.out.printf(&quot;Weight on %s is %f%n&quot;,p, p.surfaceWeight(mass));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外枚举类覆盖toString方法，亦可以直接在String中进行处理，这样在算术表达式中比较好处理</p>\n<p>ps:尝试了一下，枚举类也可以有多态构造方法，内部类也是可以的，但是枚举实例只能放在头部。</p>\n<h3 id=\"用实例域代替序数\"><a href=\"#用实例域代替序数\" class=\"headerlink\" title=\"用实例域代替序数\"></a>用实例域代替序数</h3><p>所有的枚举都有一个方法，叫做ordinal(),代表每个枚举常量在类型中的数字位置。</p>\n<p>但是实现的时候不能滥用这个方法，我们假如构造一个枚举类，千万不要无参，而通过这个方法来获取位置。而最起码应该带有一个数字参数</p>\n<h3 id=\"用EnumSet代替位域\"><a href=\"#用EnumSet代替位域\" class=\"headerlink\" title=\"用EnumSet代替位域\"></a>用EnumSet代替位域</h3><p>用位域的好处是可以比较好的使用flag，类似经常用到的比如说intent的flag，textview的flag。</p>\n<p>位域有一系列的缺点，尤其是当打印出来的时候，这个我深受其害，在观察view的tree结构时，很多状态位看不懂，还需要翻代码对比才能看出来。</p>\n<p>使用enumset代替的确有规避这方面的好处，自己写代码的时候可以注意一下，但是framework的代码其实很难更改这个了。</p>\n<h3 id=\"用EnumMap代替序数索引\"><a href=\"#用EnumMap代替序数索引\" class=\"headerlink\" title=\"用EnumMap代替序数索引\"></a>用EnumMap代替序数索引</h3><p>之前讲过用ordinal方法来进行索引，但是若是出现多个数组的情况，单ordinal就不满足了，需要进行状态的保存。</p>\n<p>enummap可以规避这个问题，但是看起来其实可用性不是很高。map的使用场景在android里面不如list。不过在构造容器的时候，使用enummap比较好</p>\n<h3 id=\"用接口模拟可伸缩的枚举\"><a href=\"#用接口模拟可伸缩的枚举\" class=\"headerlink\" title=\"用接口模拟可伸缩的枚举\"></a>用接口模拟可伸缩的枚举</h3><p>通过接口使得枚举拓展化，通过枚举来实现接口，这样使得枚举可以伸缩，虽然无法编写可拓展的枚举类型，但是这样却可以进行枚举的模拟</p>\n<h3 id=\"注解优先于命名模式\"><a href=\"#注解优先于命名模式\" class=\"headerlink\" title=\"注解优先于命名模式\"></a>注解优先于命名模式</h3><p>命名模式有几个缺点:<br>1 文字拼写错误会导致失败，比如说测试用例需要test开头，这样就会导致写错test就失败</p>\n<p>2 无法确保他们只用于相应的元素上面</p>\n<p>3 没有提供参数值与程序元素关联起来的好方法</p>\n<p>通过注解可以完美的处理上述问题</p>\n<h3 id=\"坚持使用override接口\"><a href=\"#坚持使用override接口\" class=\"headerlink\" title=\"坚持使用override接口\"></a>坚持使用override接口</h3><p>有助于编译器检查</p>\n<h3 id=\"用标记接口定义类型\"><a href=\"#用标记接口定义类型\" class=\"headerlink\" title=\"用标记接口定义类型\"></a>用标记接口定义类型</h3><p>标记接口类似于retrofit的标记方式，优点是可以精确的被锁定</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"检查参数的有效性\"><a href=\"#检查参数的有效性\" class=\"headerlink\" title=\"检查参数的有效性\"></a>检查参数的有效性</h3><p>对于公开的方法，可以直接使用@throws标签进行标注，然后代码中判断</p>\n<p>非公开的方法，使用assert即可</p>\n<h3 id=\"必要时进行保护性拷贝\"><a href=\"#必要时进行保护性拷贝\" class=\"headerlink\" title=\"必要时进行保护性拷贝\"></a>必要时进行保护性拷贝</h3><p>一个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Period(Data start, Data end)&#123;</span><br><span class=\"line\">\tif(start.compareTo(end))&#123;</span><br><span class=\"line\">\t\tthrow new IllegalArgumentException(start + &quot;after&quot; + end);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tthis.start = start;</span><br><span class=\"line\">\tthis.end = end;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于传入的Data事实上是可变的，因此一旦在构造完之后，再次修改的话，会造成条件不成立。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Period(Data start, Data end)&#123;</span><br><span class=\"line\">\tif(start.compareTo(end))&#123;</span><br><span class=\"line\">\t\tthrow new IllegalArgumentException(start + &quot;after&quot; + end);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tthis.start = new Data(start.getTime());</span><br><span class=\"line\">\tthis.end = new Data(end.getTime());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用这种方式就可以避免上述问题</p>\n<p>但是仍然有一种无法避免，就是暴露了相关参数，然后通过get接口获取之后直接更改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Data getStart()&#123;</span><br><span class=\"line\">\treturn new Data(start.getTime());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因此在get中也需要进行保护措施</p>\n<h3 id=\"谨慎设计方法签名\"><a href=\"#谨慎设计方法签名\" class=\"headerlink\" title=\"谨慎设计方法签名\"></a>谨慎设计方法签名</h3><p>1 谨慎的选择方法的名称</p>\n<p>2 不要过分追求提供便利的方法：主要原则是出于维护性的考虑，每个方法都应该尽其所能，而不应该过度耦合</p>\n<p>3 避免过长的参数列表：最多四个参数</p>\n<h3 id=\"慎用重载\"><a href=\"#慎用重载\" class=\"headerlink\" title=\"慎用重载\"></a>慎用重载</h3><p>这一节主要是讨论了重载的部分问题，主要是针对类型的判断，譬如list的remove方法，假如list的包含内容是int，remove的时候remove的是int的话，就会针对index和content起冲突，这是自动装箱和自动拆箱的判断</p>\n<p>重载需要考虑基本类型的使用方法，对于基本类型可以使用变形方法，变形方法不是重载，而是具有类似于writeBoolean, writeInt这种类型的方法</p>\n<h3 id=\"慎用可变参数\"><a href=\"#慎用可变参数\" class=\"headerlink\" title=\"慎用可变参数\"></a>慎用可变参数</h3><p>使用可变参数的时候，基本问题出现在单个可变参数的问题上面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int min(int... args)&#123;</span><br><span class=\"line\">\t....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类似上面这种，传入0个参数也是可以的，但是编译时却无法进行检查，这就会导致空指针异常出现，除非自己进行长度判断</p>\n<p>避免以上问题的2个方法，一个是指定类型的正常参数，即是自己进行判断，另一个是扩充参数表，增加一个varargs参数。</p>\n<p>在重视性能的前提下，需要明白，使用可变参数方法，每次调用都会导致一次数组分配和初始化，。因此当参数超过3个的时候，第四个及以后的都用可变参数来表示。</p>\n<h3 id=\"返回零长度的数组或者集合，而不是null\"><a href=\"#返回零长度的数组或者集合，而不是null\" class=\"headerlink\" title=\"返回零长度的数组或者集合，而不是null\"></a>返回零长度的数组或者集合，而不是null</h3><p>这节讲的内容主要是针对get方法，或者需要返回集合的方法，当集合不存在或者长度为0时，如果返回null的话会造成比较大的麻烦，这样依赖于下游对于该参数的单独处理</p>\n<h3 id=\"为所有导出的api元素编写文档注释\"><a href=\"#为所有导出的api元素编写文档注释\" class=\"headerlink\" title=\"为所有导出的api元素编写文档注释\"></a>为所有导出的api元素编写文档注释</h3><p>编写文档是门技巧，但不是现在关注的</p>\n<h2 id=\"通用程序设计\"><a href=\"#通用程序设计\" class=\"headerlink\" title=\"通用程序设计\"></a>通用程序设计</h2><h3 id=\"将局部变量的作用于最小化\"><a href=\"#将局部变量的作用于最小化\" class=\"headerlink\" title=\"将局部变量的作用于最小化\"></a>将局部变量的作用于最小化</h3><ol>\n<li><p>要使局部变量的作用域最小化，最有利的方法就是在第一次使用它的地方声明</p>\n</li>\n<li><p>几乎每个局部变量的声明都应该包含一个初始化表达式（这个讲的很有道理，很多地方声明由于丢掉了初始化，基础类型还好，但是若是复杂结构，很大的问题会出现空的情况）</p>\n</li>\n</ol>\n<p>另外如果一个参数的初始化需要使用到trycatch，而这个方法可能抛出异常，那么假如需要使用到这个参数，就将使用这个参数的地方和这个参数放在try内部，如果必须要在try外部使用，那么久必须在try之前被声明</p>\n<h3 id=\"foreach循环优先于传统的for循环\"><a href=\"#foreach循环优先于传统的for循环\" class=\"headerlink\" title=\"foreach循环优先于传统的for循环\"></a>foreach循环优先于传统的for循环</h3><h3 id=\"了解和使用类库\"><a href=\"#了解和使用类库\" class=\"headerlink\" title=\"了解和使用类库\"></a>了解和使用类库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">不要重新发明轮子</span><br></pre></td></tr></table></figure>\n<h3 id=\"如果需要精简的答案，避免使用float和double\"><a href=\"#如果需要精简的答案，避免使用float和double\" class=\"headerlink\" title=\"如果需要精简的答案，避免使用float和double\"></a>如果需要精简的答案，避免使用float和double</h3><p>计算价格其实有更高的方法，就是精确到分即可。或者说以分为计数单位</p>\n<h3 id=\"基本类型优先于装箱基本类型\"><a href=\"#基本类型优先于装箱基本类型\" class=\"headerlink\" title=\"基本类型优先于装箱基本类型\"></a>基本类型优先于装箱基本类型</h3><p>基本类型和装箱基本类型之剑有三个主要区别</p>\n<p>1 基本类型只有值，装箱基本类型则有与他们值不同的同一性</p>\n<p>2 基本类型只有功能完备的值，而每个装箱基本类型除了它对应基本类型的所有功能值以外，还有个非功能值，null</p>\n<p>3 基本类型比装箱基本类型更省时间和内存</p>\n<p>另外注意的一点是，装箱类型的比较需要使用到equal而不是==，这点在不同的机器上面展现不同，比如说在androidstudio里面 == 的含义和equal相同，但是在华为手机上面就不同。</p>\n<h3 id=\"如果其他类型合适，尽量避免使用字符串\"><a href=\"#如果其他类型合适，尽量避免使用字符串\" class=\"headerlink\" title=\"如果其他类型合适，尽量避免使用字符串\"></a>如果其他类型合适，尽量避免使用字符串</h3><p>字符串不适合代替其他的值类型</p>\n<p>字符串不适合代替枚举类型</p>\n<p>字符串不适合代替聚集类型</p>\n<p>字符串不适合代替能力表</p>\n<p>具体来讲就是该用的时候用，不该用，明显有些问题的场景，覆盖不全面的场景不要用</p>\n<h3 id=\"当心字符串连接的性能\"><a href=\"#当心字符串连接的性能\" class=\"headerlink\" title=\"当心字符串连接的性能\"></a>当心字符串连接的性能</h3><p>字符串拼接的确有很多问题，+的性能开销很大，连接N个字符串，需要的时间是N的平方级。</p>\n<p>因此使用StringBuilder替代的话，开销仅仅是线性增加。或者我们可以使用字符数组，每次只处理一个字符串，这样也可以达到增加效率的目的（舍弃了工程效率）</p>\n<h3 id=\"接口优先于反射机制\"><a href=\"#接口优先于反射机制\" class=\"headerlink\" title=\"接口优先于反射机制\"></a>接口优先于反射机制</h3><p>反射的缺点：</p>\n<p>1 丧失了编译时检查的好处</p>\n<p>2 执行反射访问所需要的代码非常笨拙和冗长</p>\n<p>3 性能损失</p>\n<p>不过单纯的罗列缺点并不可行，尤其是很多情景下反射其实是不得已而为之，并且在android中，反射的效率并没有太过严重。我测试，大致1000次反射消耗1秒钟，并非不可接受</p>\n<h3 id=\"谨慎的使用本地方法\"><a href=\"#谨慎的使用本地方法\" class=\"headerlink\" title=\"谨慎的使用本地方法\"></a>谨慎的使用本地方法</h3><p>本地方法指的是native方法。</p>\n<p>使用本地方法来提高性能的做法不值得提倡：c或c++实现的代码，很容易出现内存毁坏错误的影响，尤其是我们做java开发的，在不熟悉相关语言的时候，</p>\n<h3 id=\"谨慎的进行优化\"><a href=\"#谨慎的进行优化\" class=\"headerlink\" title=\"谨慎的进行优化\"></a>谨慎的进行优化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在优化方面，我们应该遵守两条规则:</span><br><span class=\"line\"></span><br><span class=\"line\">1 不要优化</span><br><span class=\"line\">2 在没有明确清晰的优化方案之前，不要进行优化</span><br></pre></td></tr></table></figure>\n<p>不要因为性能而牺牲合理的结构，应当编写好的程序而不是快的程序</p>\n<p>好的程序有两个规则：将设计决策集中在单个模块中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在每次优化之前和之后，要对性能进行测量</span><br></pre></td></tr></table></figure>\n<h3 id=\"遵守普遍接受的命名惯例\"><a href=\"#遵守普遍接受的命名惯例\" class=\"headerlink\" title=\"遵守普遍接受的命名惯例\"></a>遵守普遍接受的命名惯例</h3><p>遵守驼峰原则</p>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><h3 id=\"只针对异常的情况才使用异常\"><a href=\"#只针对异常的情况才使用异常\" class=\"headerlink\" title=\"只针对异常的情况才使用异常\"></a>只针对异常的情况才使用异常</h3><p>异常在jvm里面优化的比较少，写在try块里面的代码，每一步都会进行异常的检查，这样会造成严重的性能损耗，一般会增加一倍的运行时间。</p>\n<h3 id=\"对可恢复的情况使用受检异常，对编程错误使用运行时异常\"><a href=\"#对可恢复的情况使用受检异常，对编程错误使用运行时异常\" class=\"headerlink\" title=\"对可恢复的情况使用受检异常，对编程错误使用运行时异常\"></a>对可恢复的情况使用受检异常，对编程错误使用运行时异常</h3><p>java提供了三种可抛出的结构：受检的异常，运行时异常，错误。</p>\n<p>一般使用运行时异常来表示变成错误。明确的指出代码违例</p>\n<p>而受检异常，作为可抛出的结构，但是并不建议使用，因为会带来困惑。</p>\n<p>至于警告，说实话错误大部分是对于兼容性的处理，api过期等等，警告本上是很难避免的</p>\n<h3 id=\"避免不必要的使用受检的异常\"><a href=\"#避免不必要的使用受检的异常\" class=\"headerlink\" title=\"避免不必要的使用受检的异常\"></a>避免不必要的使用受检的异常</h3><p>主要是受检的异常会带来代码复杂度增加的问题，尤其是一些无法解决的情况，因此如果该受检其实是不必要的，完全没有必要增加代码复杂度</p>\n<h3 id=\"优先使用标准的异常\"><a href=\"#优先使用标准的异常\" class=\"headerlink\" title=\"优先使用标准的异常\"></a>优先使用标准的异常</h3><p>java提供了一些常用的异常：</p>\n<p>illegalArgumentException: 非null的参数值不正确</p>\n<p>illegalStateException: 对于方法调用而言，对象状态不合适</p>\n<p>nullPointException: 在禁止使用null的情况下参数值为null</p>\n<p>indexOutOfBoundsException: 下表参数值越界</p>\n<p>concurrentModificationException: 在禁止并发修改的情况下，检测到对象的并发修改</p>\n<p>unsupportedOperationException: 对象不支持用户请求的方法</p>\n<h3 id=\"抛出与抽象相对应的异常\"><a href=\"#抛出与抽象相对应的异常\" class=\"headerlink\" title=\"抛出与抽象相对应的异常\"></a>抛出与抽象相对应的异常</h3><p>异常转译：更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行的解释。</p>\n<p>另外还有一种被称作异常链</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;catch(LowerLevelException cause)&#123;</span><br><span class=\"line\">\tthrow new HigherLevelException(cause);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样写，加上上层也写了捕捉higherlevelexception的动作，就可以将这个异常链传输到上层了。</p>\n<p>不过异常转译其实还是比异常链好一些，毕竟做了完整的处理。而如果凡事依赖异常链的话，那么很难说照顾到所有，如果捕捉了上层无法处理的，然后上层在弹出崩溃，那么一来追踪不是很方便，二来浪费效率</p>\n<h3 id=\"每个方法抛出的异常都要有文档\"><a href=\"#每个方法抛出的异常都要有文档\" class=\"headerlink\" title=\"每个方法抛出的异常都要有文档\"></a>每个方法抛出的异常都要有文档</h3><h3 id=\"在细节消息中包含能捕获失败的信息\"><a href=\"#在细节消息中包含能捕获失败的信息\" class=\"headerlink\" title=\"在细节消息中包含能捕获失败的信息\"></a>在细节消息中包含能捕获失败的信息</h3><p>这个在项目里有很多用途，主要是弹出给用户看</p>\n<h3 id=\"努力使失败保持原子性\"><a href=\"#努力使失败保持原子性\" class=\"headerlink\" title=\"努力使失败保持原子性\"></a>努力使失败保持原子性</h3><p>失败的方法调用，应该使对象保持在被调用之前的状态。</p>\n<p>比较好的方法是进行参数检查，不符合直接抛出，这样就会在修改之前生效。</p>\n<p>还有一种方法是调整计算机处理过程的顺序，是的任何可能会失败的计算部分都在对象状态被修改之前发生</p>\n<p>另外还有一种是实现一段恢复代码，在出错的地方进行恢复</p>\n<p>虽然一般情况下都希望实现失败原子性，单并非总是可以做到，如果两个线程企图在没有适当的同步机制的情况下，并发的修改同一个对象，这个对象就有可能被留在不一致的状态中，因此在concurrentModificationException异常之后再假设对象仍然是可用的就是一个错误的论断。</p>\n<h3 id=\"不要忽略异常\"><a href=\"#不要忽略异常\" class=\"headerlink\" title=\"不要忽略异常\"></a>不要忽略异常</h3><p>简而言之catch区不要不做事情</p>\n<h2 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h2><h3 id=\"同步访问共享的可变数据\"><a href=\"#同步访问共享的可变数据\" class=\"headerlink\" title=\"同步访问共享的可变数据\"></a>同步访问共享的可变数据</h3><p>使用synchronized来进行线程同步，并且阻止另一个线程观察到对象内部不一致的状态。</p>\n<h3 id=\"避免过度同步\"><a href=\"#避免过度同步\" class=\"headerlink\" title=\"避免过度同步\"></a>避免过度同步</h3><p>过度同步会导致死锁</p>\n<h3 id=\"executor和task优先于线程\"><a href=\"#executor和task优先于线程\" class=\"headerlink\" title=\"executor和task优先于线程\"></a>executor和task优先于线程</h3><p>创建一个工作队列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService executor = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure></p>\n<p>执行提交一个runnable的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">executor.execute(runnable)</span><br></pre></td></tr></table></figure>\n<p>终止executor<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">executor.shutdown()</span><br></pre></td></tr></table></figure></p>\n"},{"title":"recyclerview源码学习","date":"2019-01-27T09:50:30.000Z","_content":"\n# 绘制过程\n\n绘制过程需要理解的是如何一个itemview一个itemview的绘制\n\n## onMeasure\n\n```\nprotected void onMeasure(int widthSpec, int heightSpec) {\n        if (mLayout == null) {\n            //layoutManager没有设置的话，直接走default的方法，所以会为空白\n            defaultOnMeasure(widthSpec, heightSpec);\n            return;\n        }\n        if (mLayout.mAutoMeasure) {\n            final boolean skipMeasure = widthMode == MeasureSpec.EXACTLY\n                    && heightMode == MeasureSpec.EXACTLY;\n            //如果测量是绝对值，则跳过measure过程直接走layout\n            if (skipMeasure || mAdapter == null) {\n                return;\n            }\n            if (mState.mLayoutStep == State.STEP_START) {\n                //mLayoutStep默认值是 State.STEP_START\n                dispatchLayoutStep1();\n                //执行完dispatchLayoutStep1()后是State.STEP_LAYOUT\n            }\n             ..........\n            //真正执行LayoutManager绘制的地方\n            dispatchLayoutStep2();\n            //执行完后是State.STEP_ANIMATIONS\n             ..........\n            //宽高都不确定的时候，会绘制两次\n            // if RecyclerView has non-exact width and height and if there is at least one child\n            // which also has non-exact width & height, we have to re-measure.\n            if (mLayout.shouldMeasureTwice()) {\n             ..........\n                dispatchLayoutStep2();\n             ..........            }\n        } else {\n            if (mHasFixedSize) {\n                mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);\n                return;\n            }\n             ..........\n            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);\n             ..........\n            mState.mInPreLayout = false; // clear\n        }\n    }\n--------------------- \n别人概括的measure过程\n```\n\n从这里大概分为三步，毕竟三个else\n\n### layout == null\n\n```\nvoid defaultOnMeasure(int widthSpec, int heightSpec) {\n        // calling LayoutManager here is not pretty but that API is already public and it is better\n        // than creating another method since this is internal.\n        final int width = LayoutManager.chooseSize(widthSpec,\n                getPaddingLeft() + getPaddingRight(),\n                ViewCompat.getMinimumWidth(this));\n        final int height = LayoutManager.chooseSize(heightSpec,\n                getPaddingTop() + getPaddingBottom(),\n                ViewCompat.getMinimumHeight(this));\n        setMeasuredDimension(width, height);\n    }\n```\n\n```\npublic static int chooseSize(int spec, int desired, int min) {\n            int mode = MeasureSpec.getMode(spec);\n            int size = MeasureSpec.getSize(spec);\n            switch(mode) {\n            case -2147483648:\n                return Math.min(size, Math.max(desired, min));\n            case 0:\n            default:\n                return Math.max(desired, min);\n            case 1073741824:\n                return size;\n            }\n        }\n```\n\n默认情况下面其实是处理了一下高度的问题，如果有padding的话，会将padding归入计算\n\n### mlayout != null &&  mLayout.isAutoMeasureEnabled()\n\n```\npublic boolean isAutoMeasureEnabled() {\n            return mAutoMeasure;\n        }\n```\n\n```\n/**\n         * Defines whether the measuring pass of layout should use the AutoMeasure mechanism of\n         * {@link RecyclerView} or if it should be done by the LayoutManager's implementation of\n         * {@link LayoutManager#onMeasure(Recycler, State, int, int)}.\n         *\n         * @param enabled <code>True</code> if layout measurement should be done by the\n         *                RecyclerView, <code>false</code> if it should be done by this\n         *                LayoutManager.\n         *\n         * @see #isAutoMeasureEnabled()\n         *\n         * @deprecated Implementors of LayoutManager should define whether or not it uses\n         *             AutoMeasure by overriding {@link #isAutoMeasureEnabled()}.\n         */\n        @Deprecated\n        public void setAutoMeasureEnabled(boolean enabled) {\n            mAutoMeasure = enabled;\n        }\n```\n\n这个api是deprecate的，其功能主要是设置自动测量\n\n```\nif (mLayout.mAutoMeasure) {\n            final int widthMode = MeasureSpec.getMode(widthSpec);\n            final int heightMode = MeasureSpec.getMode(heightSpec);\n            final boolean skipMeasure = widthMode == MeasureSpec.EXACTLY\n                    && heightMode == MeasureSpec.EXACTLY;\n            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);\n            if (skipMeasure || mAdapter == null) {\n                return;\n            }\n            if (mState.mLayoutStep == State.STEP_START) {\n                dispatchLayoutStep1();\n            }\n            // set dimensions in 2nd step. Pre-layout should happen with old dimensions for\n            // consistency\n            mLayout.setMeasureSpecs(widthSpec, heightSpec);\n            mState.mIsMeasuring = true;\n            dispatchLayoutStep2();\n\n            // now we can get the width and height from the children.\n            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);\n\n            // if RecyclerView has non-exact width and height and if there is at least one child\n            // which also has non-exact width & height, we have to re-measure.\n            if (mLayout.shouldMeasureTwice()) {\n                mLayout.setMeasureSpecs(\n                        MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),\n                        MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));\n                mState.mIsMeasuring = true;\n                dispatchLayoutStep2();\n                // now we can get the width and height from the children.\n                mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);\n            }\n        }\n```\n\n1. 如果测量是绝对值，则不再进行measure而直接layout，毕竟EXACTLY是写死了面积了，recyclerview的父类会直接获取面积来摆放\n\n2. STATE变量为start时\n\n```\n        static final int STEP_START = 1;\n        static final int STEP_LAYOUT = 1 << 1;\n        static final int STEP_ANIMATIONS = 1 << 2;\n```\n\n```\n/**\n     * The first step of a layout where we;\n     * - process adapter updates\n     * - decide which animation should run\n     * - save information about current views\n     * - If necessary, run predictive layout and save its information\n     */\n    private void dispatchLayoutStep1() {\n        mState.assertLayoutStep(State.STEP_START);\n        fillRemainingScrollValues(mState);\n        mState.mIsMeasuring = false;\n        startInterceptRequestLayout();\n        mViewInfoStore.clear();\n        onEnterLayoutOrScroll();\n        processAdapterUpdatesAndSetAnimationFlags();\n        saveFocusInfo();\n        mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations && mItemsChanged;\n        mItemsAddedOrRemoved = mItemsChanged = false;\n        mState.mInPreLayout = mState.mRunPredictiveAnimations;\n        mState.mItemCount = mAdapter.getItemCount();\n        findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);\n\n        if (mState.mRunSimpleAnimations) {\n            // Step 0: Find out where all non-removed items are, pre-layout\n            int count = mChildHelper.getChildCount();\n            for (int i = 0; i < count; ++i) {\n                final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));\n                if (holder.shouldIgnore() || (holder.isInvalid() && !mAdapter.hasStableIds())) {\n                    continue;\n                }\n                final ItemHolderInfo animationInfo = mItemAnimator\n                        .recordPreLayoutInformation(mState, holder,\n                                ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),\n                                holder.getUnmodifiedPayloads());\n                mViewInfoStore.addToPreLayout(holder, animationInfo);\n                if (mState.mTrackOldChangeHolders && holder.isUpdated() && !holder.isRemoved()\n                        && !holder.shouldIgnore() && !holder.isInvalid()) {\n                    long key = getChangedHolderKey(holder);\n                    // This is NOT the only place where a ViewHolder is added to old change holders\n                    // list. There is another case where:\n                    //    * A VH is currently hidden but not deleted\n                    //    * The hidden item is changed in the adapter\n                    //    * Layout manager decides to layout the item in the pre-Layout pass (step1)\n                    // When this case is detected, RV will un-hide that view and add to the old\n                    // change holders list.\n                    mViewInfoStore.addToOldChangeHolders(key, holder);\n                }\n            }\n        }\n        if (mState.mRunPredictiveAnimations) {\n            // Step 1: run prelayout: This will use the old positions of items. The layout manager\n            // is expected to layout everything, even removed items (though not to add removed\n            // items back to the container). This gives the pre-layout position of APPEARING views\n            // which come into existence as part of the real layout.\n\n            // Save old positions so that LayoutManager can run its mapping logic.\n            saveOldPositions();\n            final boolean didStructureChange = mState.mStructureChanged;\n            mState.mStructureChanged = false;\n            // temporarily disable flag because we are asking for previous layout\n            mLayout.onLayoutChildren(mRecycler, mState);\n            mState.mStructureChanged = didStructureChange;\n\n            for (int i = 0; i < mChildHelper.getChildCount(); ++i) {\n                final View child = mChildHelper.getChildAt(i);\n                final ViewHolder viewHolder = getChildViewHolderInt(child);\n                if (viewHolder.shouldIgnore()) {\n                    continue;\n                }\n                if (!mViewInfoStore.isInPreLayout(viewHolder)) {\n                    int flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder);\n                    boolean wasHidden = viewHolder\n                            .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);\n                    if (!wasHidden) {\n                        flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;\n                    }\n                    final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(\n                            mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads());\n                    if (wasHidden) {\n                        recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo);\n                    } else {\n                        mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo);\n                    }\n                }\n            }\n            // we don't process disappearing list because they may re-appear in post layout pass.\n            clearOldPositions();\n        } else {\n            clearOldPositions();\n        }\n        onExitLayoutOrScroll();\n        stopInterceptRequestLayout(false);\n        mState.mLayoutStep = State.STEP_LAYOUT;\n    }\n```\n\n从备注的内容中可以知道，这个步骤有四个功能\n\n- 处理adapter的更新\n- 决定哪些动画需要执行\n- 保存当前view的信息\n- 如果必要的情况下，执行上一个layout的操作并且保存他的信息\n\n该步骤只是做了准备工作\n\n3. state不为start时\n\n```\n /**\n     * The second layout step where we do the actual layout of the views for the final state.\n     * This step might be run multiple times if necessary (e.g. measure).\n     */\n    private void dispatchLayoutStep2() {\n        startInterceptRequestLayout();\n        onEnterLayoutOrScroll();\n        mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);\n        mAdapterHelper.consumeUpdatesInOnePass();\n        mState.mItemCount = mAdapter.getItemCount();\n        mState.mDeletedInvisibleItemCountSincePreviousLayout = 0;\n\n        // Step 2: Run layout\n        mState.mInPreLayout = false;\n        mLayout.onLayoutChildren(mRecycler, mState);\n\n        mState.mStructureChanged = false;\n        mPendingSavedState = null;\n\n        // onLayoutChildren may have caused client code to disable item animations; re-check\n        mState.mRunSimpleAnimations = mState.mRunSimpleAnimations && mItemAnimator != null;\n        mState.mLayoutStep = State.STEP_ANIMATIONS;\n        onExitLayoutOrScroll();\n        stopInterceptRequestLayout(false);\n    }\n```\n\n这里的分析需要细致一些，着重点在mLayout.onLayoutChildren()内，绘制的工作交给了layoutmanager\n\n```\npublic void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {\n        // layout algorithm:\n        //找寻锚点\n        // 1) by checking children and other variables, find an anchor coordinate and an anchor\n        // item position.\n        //两个方向填充，从锚点往上，从锚点往下\n        // 2) fill towards start, stacking from bottom\n        // 3) fill towards end, stacking from top\n        // 4) scroll to fulfill requirements like stack from bottom.\n        // create layout state\n        ....\n        // resolve layout direction\n        //判断绘制方向,给mShouldReverseLayout赋值,默认是正向绘制，则mShouldReverseLayout是false\n        resolveShouldLayoutReverse();\n        final View focused = getFocusedChild();\n        //mValid的默认值是false，一次测量之后设为true，onLayout完成后会回调执行reset方法，又变为false\n        if (!mAnchorInfo.mValid || mPendingScrollPosition != NO_POSITION\n                || mPendingSavedState != null) {\n        ....\n            //mStackFromEnd默认是false，除非手动调用setStackFromEnd()方法，两个都会false，异或则为false\n            mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;\n            // calculate anchor position and coordinate\n            //计算锚点的位置和偏移量\n            updateAnchorInfoForLayout(recycler, state, mAnchorInfo);\n        ....\n        } else if (focused != null && (mOrientationHelper.getDecoratedStart(focused)\n                >= mOrientationHelper.getEndAfterPadding()\n                || mOrientationHelper.getDecoratedEnd(focused)\n                <= mOrientationHelper.getStartAfterPadding())) {\n         ....\n        }\n         ....\n        //mLayoutFromEnd为false\n        if (mAnchorInfo.mLayoutFromEnd) {\n            //倒着绘制的话，先往上绘制，再往下绘制\n            // fill towards start\n            // 从锚点到往上\n            updateLayoutStateToFillStart(mAnchorInfo);\n            ....\n            fill(recycler, mLayoutState, state, false);\n            ....\n            // 从锚点到往下\n            // fill towards end\n            updateLayoutStateToFillEnd(mAnchorInfo);\n            ....\n            //调两遍fill方法\n            fill(recycler, mLayoutState, state, false);\n            ....\n            if (mLayoutState.mAvailable > 0) {\n                // end could not consume all. add more items towards start\n            ....\n                updateLayoutStateToFillStart(firstElement, startOffset);\n                mLayoutState.mExtra = extraForStart;\n                fill(recycler, mLayoutState, state, false);\n             ....\n            }\n        } else {\n            //正常绘制流程的话，先往下绘制，再往上绘制\n            // fill towards end\n            updateLayoutStateToFillEnd(mAnchorInfo);\n            ....\n            fill(recycler, mLayoutState, state, false);\n             ....\n            // fill towards start\n            updateLayoutStateToFillStart(mAnchorInfo);\n            ....\n            fill(recycler, mLayoutState, state, false);\n             ....\n            if (mLayoutState.mAvailable > 0) {\n                ....\n                // start could not consume all it should. add more items towards end\n                updateLayoutStateToFillEnd(lastElement, endOffset);\n                 ....\n                fill(recycler, mLayoutState, state, false);\n                ....\n            }\n        }\n        ....\n        layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);\n        //完成后重置参数\n        if (!state.isPreLayout()) {\n            mOrientationHelper.onLayoutComplete();\n        } else {\n            mAnchorInfo.reset();\n        }\n        mLastStackFromEnd = mStackFromEnd;\n    }\n```\n摘抄了别人分析的内容，很明显，这是linearlayoutmanager一个完整的layout的过程，说实话真的很复杂。\n\n```\n先寻找页面当前的锚点 \n以这个锚点未基准，向上和向下分别填充 \n填充完后，如果还有剩余的可填充大小，再填充一次\n```\n\n从这个角度来讲，可以大致理解为绘制的顺序，是首先绘制可见区域及以下的内容，而后绘制可见区域以上的内容，这个上下会依据重心来变化\n\n以前listview的绘制，大概也是差不多的，不过listview有个细节，是不设定数量的情况下，只绘制可见区域及上下加起来7个大小。分析recyclerview的源码发现，其绘制的区域仅仅是可见区域，如果需要预先绘制的话，需要自己制定预先加载的数量，其中的差别体现的还是比较明显的，因为layoutmanager需要考虑绘制的时候的动画。\n\n### 最后一步\n\n```\n            if (mHasFixedSize) {\n                mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);\n                return;\n            }\n            // custom onMeasure\n            if (mAdapterUpdateDuringMeasure) {\n                startInterceptRequestLayout();\n                onEnterLayoutOrScroll();\n                processAdapterUpdatesAndSetAnimationFlags();\n                onExitLayoutOrScroll();\n\n                if (mState.mRunPredictiveAnimations) {\n                    mState.mInPreLayout = true;\n                } else {\n                    // consume remaining updates to provide a consistent state with the layout pass.\n                    mAdapterHelper.consumeUpdatesInOnePass();\n                    mState.mInPreLayout = false;\n                }\n                mAdapterUpdateDuringMeasure = false;\n                stopInterceptRequestLayout(false);\n            } else if (mState.mRunPredictiveAnimations) {\n                // If mAdapterUpdateDuringMeasure is false and mRunPredictiveAnimations is true:\n                // this means there is already an onMeasure() call performed to handle the pending\n                // adapter change, two onMeasure() calls can happen if RV is a child of LinearLayout\n                // with layout_width=MATCH_PARENT. RV cannot call LM.onMeasure() second time\n                // because getViewForPosition() will crash when LM uses a child to measure.\n                setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight());\n                return;\n            }\n\n            if (mAdapter != null) {\n                mState.mItemCount = mAdapter.getItemCount();\n            } else {\n                mState.mItemCount = 0;\n            }\n            startInterceptRequestLayout();\n            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);\n            stopInterceptRequestLayout(false);\n            mState.mInPreLayout = false; // clear\n        }\n```\n这一步是当recyclerview没有设置**mLayout.isAutoMeasureEnabled()**的时候出现的，默认情况下走的就是这一步。\n\n这一步的含义是将绘制权直接交于layoutmanager来绘制，有个细节，就是如果期望绘制的过程由recyclerview内部来进行的话，就不要再重写layoutmanager的onmeasure了。不过对于我们这种大多数时候直接调用linearlayoutmanager的，平时不会太注意这个。\n\n回到这一步上来，大概做了这样几件事\n\n1. 当设置了hasfixedsize时\n\n```\n/**\n     * RecyclerView can perform several optimizations if it can know in advance that RecyclerView's\n     * size is not affected by the adapter contents. RecyclerView can still change its size based\n     * on other factors (e.g. its parent's size) but this size calculation cannot depend on the\n     * size of its children or contents of its adapter (except the number of items in the adapter).\n     * <p>\n     * If your use of RecyclerView falls into this category, set this to {@code true}. It will allow\n     * RecyclerView to avoid invalidating the whole layout when its adapter contents change.\n     *\n     * @param hasFixedSize true if adapter changes cannot affect the size of the RecyclerView.\n     */\n```\n\n也就是当item的大小是固定的，不会出现根据adapter的内容变化的布局，这样recyclerview就会依据某些参数固定下来他的尺寸，并不会在参考其内部数据变化而计算出来的尺寸。算是**优化**的一个注意点\n\n设置了这个参数之后，就会直接甩手给layoutmanager进行onmeasure操作\n\n2. 未设置hasfixedsize时 && adapter在onmeasure过程中正在更新\n\n此时只会做一些状态的更改，lock的重入这样。其lock的标记位实在是太多了，不过的确没有做什么事情，不过此过程如果进行，会跳转到第四步继续下去\n\n3. 未设置hasfixedsize时 && adapter 不在更新 && 目前的状态处在更新之前的动画时\n\n此时会在更新完前一个item动画之后在更新自己，所以此时只做了一个动作，就是提前将宽高的measurespec设置完毕\n\n4. 以上都没有的情况下\n\n首先会调用layoutmanager的onmeasure，之后会清除状态位。\n\n#### 最后一步的一个总结\n\n为什么hasfixedsize起作用呢？\n\n因为当未设置这个的时候，会等待adapter更新结束才会绘制，而adapter的更新会有一系列的等待，等待数据处理结束之后，才会再次做一个更新的操作。\n而设置了hasfixedsize之后，就不会等待更新了，而是会直接进行绘制。\n\n另外拷一份关于这个的别人的总结\n\n```\n总结：当我们确定Item的改变不会影响RecyclerView的宽高的时候可以设置setHasFixedSize(true)，并通过Adapter的增删改插方法去刷新RecyclerView，而不是通过notifyDataSetChanged()。（其实可以直接设置为true，当需要改变宽高的时候就用notifyDataSetChanged()去整体刷新一下）\n--------------------- \n作者：wsdaijianjun \n来源：CSDN \n原文：https://blog.csdn.net/wsdaijianjun/article/details/74735039 \n版权声明：本文为博主原创文章，转载请附上博文链接！\n```\n\n## onLayout\n\n```\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n        ...\n        dispatchLayout();\n        ...\n    }\n```\n```\n/**\n     * Wrapper around layoutChildren() that handles animating changes caused by layout.\n     * Animations work on the assumption that there are five different kinds of items\n     * in play:\n     * PERSISTENT: items are visible before and after layout\n     * REMOVED: items were visible before layout and were removed by the app\n     * ADDED: items did not exist before layout and were added by the app\n     * DISAPPEARING: items exist in the data set before/after, but changed from\n     * visible to non-visible in the process of layout (they were moved off\n     * screen as a side-effect of other changes)\n     * APPEARING: items exist in the data set before/after, but changed from\n     * non-visible to visible in the process of layout (they were moved on\n     * screen as a side-effect of other changes)\n     * The overall approach figures out what items exist before/after layout and\n     * infers one of the five above states for each of the items. Then the animations\n     * are set up accordingly:\n     * PERSISTENT views are animated via\n     * {@link ItemAnimator#animatePersistence(ViewHolder, ItemHolderInfo, ItemHolderInfo)}\n     * DISAPPEARING views are animated via\n     * {@link ItemAnimator#animateDisappearance(ViewHolder, ItemHolderInfo, ItemHolderInfo)}\n     * APPEARING views are animated via\n     * {@link ItemAnimator#animateAppearance(ViewHolder, ItemHolderInfo, ItemHolderInfo)}\n     * and changed views are animated via\n     * {@link ItemAnimator#animateChange(ViewHolder, ViewHolder, ItemHolderInfo, ItemHolderInfo)}.\n     */\n    void dispatchLayout() {\n        if (mAdapter == null) {\n            Log.e(TAG, \"No adapter attached; skipping layout\");\n            // leave the state in START\n            return;\n        }\n        if (mLayout == null) {\n            Log.e(TAG, \"No layout manager attached; skipping layout\");\n            // leave the state in START\n            return;\n        }\n        mState.mIsMeasuring = false;\n        if (mState.mLayoutStep == State.STEP_START) {\n            dispatchLayoutStep1();\n            mLayout.setExactMeasureSpecsFrom(this);\n            dispatchLayoutStep2();\n        } else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()\n                || mLayout.getHeight() != getHeight()) {\n            // First 2 steps are done in onMeasure but looks like we have to run again due to\n            // changed size.\n            mLayout.setExactMeasureSpecsFrom(this);\n            dispatchLayoutStep2();\n        } else {\n            // always make sure we sync them (to ensure mode is exact)\n            mLayout.setExactMeasureSpecsFrom(this);\n        }\n        dispatchLayoutStep3();\n    }\n```\n\nonlayout的过程相对比较简单，即是直接通过state的状态，来设置目前需要走到哪一步。其中dispatchlayoutstep1和dispatchlayoutstep2都是onmeasure过程中使用到的。\n\n唯一不知道的是dispatchlayoutstep3\n\n```\n /**\n     * The final step of the layout where we save the information about views for animations,\n     * trigger animations and do any necessary cleanup.\n     */\n    private void dispatchLayoutStep3() {\n        mState.assertLayoutStep(State.STEP_ANIMATIONS);\n        eatRequestLayout();\n        onEnterLayoutOrScroll();\n        mState.mLayoutStep = State.STEP_START;\n        if (mState.mRunSimpleAnimations) {\n            // Step 3: Find out where things are now, and process change animations.\n            // traverse list in reverse because we may call animateChange in the loop which may\n            // remove the target view holder.\n            for (int i = mChildHelper.getChildCount() - 1; i >= 0; i--) {\n                ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));\n                if (holder.shouldIgnore()) {\n                    continue;\n                }\n                long key = getChangedHolderKey(holder);\n                final ItemHolderInfo animationInfo = mItemAnimator\n                        .recordPostLayoutInformation(mState, holder);\n                ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key);\n                if (oldChangeViewHolder != null && !oldChangeViewHolder.shouldIgnore()) {\n                    // run a change animation\n\n                    // If an Item is CHANGED but the updated version is disappearing, it creates\n                    // a conflicting case.\n                    // Since a view that is marked as disappearing is likely to be going out of\n                    // bounds, we run a change animation. Both views will be cleaned automatically\n                    // once their animations finish.\n                    // On the other hand, if it is the same view holder instance, we run a\n                    // disappearing animation instead because we are not going to rebind the updated\n                    // VH unless it is enforced by the layout manager.\n                    final boolean oldDisappearing = mViewInfoStore.isDisappearing(\n                            oldChangeViewHolder);\n                    final boolean newDisappearing = mViewInfoStore.isDisappearing(holder);\n                    if (oldDisappearing && oldChangeViewHolder == holder) {\n                        // run disappear animation instead of change\n                        mViewInfoStore.addToPostLayout(holder, animationInfo);\n                    } else {\n                        final ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout(\n                                oldChangeViewHolder);\n                        // we add and remove so that any post info is merged.\n                        mViewInfoStore.addToPostLayout(holder, animationInfo);\n                        ItemHolderInfo postInfo = mViewInfoStore.popFromPostLayout(holder);\n                        if (preInfo == null) {\n                            handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder);\n                        } else {\n                            animateChange(oldChangeViewHolder, holder, preInfo, postInfo,\n                                    oldDisappearing, newDisappearing);\n                        }\n                    }\n                } else {\n                    mViewInfoStore.addToPostLayout(holder, animationInfo);\n                }\n            }\n\n            // Step 4: Process view info lists and trigger animations\n            mViewInfoStore.process(mViewInfoProcessCallback);\n        }\n\n        mLayout.removeAndRecycleScrapInt(mRecycler);\n        mState.mPreviousLayoutItemCount = mState.mItemCount;\n        mDataSetHasChangedAfterLayout = false;\n        mState.mRunSimpleAnimations = false;\n\n        mState.mRunPredictiveAnimations = false;\n        mLayout.mRequestedSimpleAnimations = false;\n        if (mRecycler.mChangedScrap != null) {\n            mRecycler.mChangedScrap.clear();\n        }\n        if (mLayout.mPrefetchMaxObservedInInitialPrefetch) {\n            // Initial prefetch has expanded cache, so reset until next prefetch.\n            // This prevents initial prefetches from expanding the cache permanently.\n            mLayout.mPrefetchMaxCountObserved = 0;\n            mLayout.mPrefetchMaxObservedInInitialPrefetch = false;\n            mRecycler.updateViewCacheSize();\n        }\n\n        mLayout.onLayoutCompleted(mState);\n        onExitLayoutOrScroll();\n        resumeRequestLayout(false);\n        mViewInfoStore.clear();\n        if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) {\n            dispatchOnScrolled(0, 0);\n        }\n        recoverFocusFromState();\n        resetFocusInfo();\n    }\n```\n\n这里看上去，能了解几个信息点，首先是处理了动画，在然后是reset了一些状态。这一步和布局没有什么必然的关系。\n\n## 全布局总结\n\n这里我就直接抄了，我的言语也最多总结成这样。\n\n\n第一步：\n处理Adapter的更新\n决定哪些动画播放\n保存当前View的信息\n如果有必要的话再进行上一布局操作，并保存它的信息\n```\nprivate void dispatchLayoutStep1() {\n    …… // 省略代码，该部分判断状态和更改状态以及保存一些信息\n    // 下面这个方法很重要，那么我们先略过，看下下面的内容。哎~我就这么调皮!哈哈，\n    // 其实是，在没有讲动画流程之前，根本讲不清。这个是动画流程的中间过程。所以\n    // ，在这里只要先知道，这里是处理Adapter更新，并计算动画类型的即可。\n    processAdapterUpdatesAndSetAnimationFlags();\n    …… // 设置一些状态，保存一些信息。\n\n    // 下面的内容是需要运行动画的情况下进行的，主要做的事情就是找出那些要需要进\n    // 行上一布局操作的ViewHolder，并且保存它们的边界信息。如果有更新操作(这个更新\n    // 指的是内容的更新，不是插入删除的这种更新)，然后保存这些更新的ViewHolder\n    if (mState.mRunSimpleAnimations) {\n        …… // 看上面的解释，这里代码都是和动画相关的，暂时懒得放，太占地方\n    }\n    // 下面的内容是需要在布局结束之后运行动画的情况下执行的。主要做的事情就是\n    // 执行上一布局操作，上一布局操作其实就是先以上一次的状态执行一边LayoutManager\n    // 的onLayoutChildren方法，其实RecyclerView的布局策略就是在\n    // LayoutManager的onLayoutChildren方法中。执行一次它就获得了所有\n    // ViewHolder的边界信息。只不过，这次获得的是之前状态下的ViewHolder的\n    // 边界信息。不过这个应该是要在LayoutManager中，根据state的isPreLayout\n    // 的返回值，选择使用新的还是旧的position。但我在系统给的几个LayoutManager中\n    // 都没有看到。\n    if (mState.mRunPredictiveAnimations) {\n        …… \n        mLayout.onLayoutChildren(mRecycler, mState);\n        ……\n    }\n    …… //恢复状态\n}\n```\n\n\n第二步：真正的布局\n\n```\nprivate void dispatchLayoutStep2() {\n    …… // 设置状态\n    mState.mInPreLayout = false; // 更改此状态，确保不是会执行上一布局操作\n    // 真正布局就是这一句话，布局的具体策略交给了LayoutManager，哈哈!这篇的主角讲完了!\n    mLayout.onLayoutChildren(mRecycler, mState);\n    …… // 设置和恢复状态\n}\n```\n\n第三步：\n\n保存信息，触发动画，清除垃圾\n```\nprivate void dispatchLayoutStep3() {\n    …… // 设置状态\n    if (mState.mRunSimpleAnimations) {\n        …… // 需要动画的情况。找出ViewHolder现在的位置，并且处理改变动画。最后触发动画。\n    }\n\n    …… // 清除状态和清除无用的信息\n    mLayout.onLayoutCompleted(mState); // 给LayoutManager的布局完成的回调\n    …… // 清除状体和清楚无用的信息，最后在恢复一些信息信息，比如焦点。\n}\n```\n\n# 缓存机制\n\nrecyclerview的缓存主要在view的复用\n\n其依赖于\n```\nfinal View view = recycler.getViewForPosition(mCurrentPosition);\n```\n\n该方法获取了viewholder的itemview\n\n```\n/**\n         * Obtain a view initialized for the given position.\n         *\n         * This method should be used by {@link LayoutManager} implementations to obtain\n         * views to represent data from an {@link Adapter}.\n         * <p>\n         * The Recycler may reuse a scrap or detached view from a shared pool if one is\n         * available for the correct view type. If the adapter has not indicated that the\n         * data at the given position has changed, the Recycler will attempt to hand back\n         * a scrap view that was previously initialized for that data without rebinding.\n         *\n         * @param position Position to obtain a view for\n         * @return A view representing the data at <code>position</code> from <code>adapter</code>\n         */\n        public View getViewForPosition(int position) {\n            return getViewForPosition(position, false);\n        }\n\n        View getViewForPosition(int position, boolean dryRun) {\n            return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;\n        }\n\n        /**\n         * Attempts to get the ViewHolder for the given position, either from the Recycler scrap,\n         * cache, the RecycledViewPool, or creating it directly.\n         * <p>\n         * If a deadlineNs other than {@link #FOREVER_NS} is passed, this method early return\n         * rather than constructing or binding a ViewHolder if it doesn't think it has time.\n         * If a ViewHolder must be constructed and not enough time remains, null is returned. If a\n         * ViewHolder is aquired and must be bound but not enough time remains, an unbound holder is\n         * returned. Use {@link ViewHolder#isBound()} on the returned object to check for this.\n         *\n         * @param position Position of ViewHolder to be returned.\n         * @param dryRun True if the ViewHolder should not be removed from scrap/cache/\n         * @param deadlineNs Time, relative to getNanoTime(), by which bind/create work should\n         *                   complete. If FOREVER_NS is passed, this method will not fail to\n         *                   create/bind the holder if needed.\n         *\n         * @return ViewHolder for requested position\n         */\n        @Nullable\n        ViewHolder tryGetViewHolderForPositionByDeadline(int position,\n                boolean dryRun, long deadlineNs) {\n            if (position < 0 || position >= mState.getItemCount()) {\n                throw new IndexOutOfBoundsException(\"Invalid item position \" + position\n                        + \"(\" + position + \"). Item count:\" + mState.getItemCount()\n                        + exceptionLabel());\n            }\n            boolean fromScrapOrHiddenOrCache = false;\n            ViewHolder holder = null;\n            // 0) If there is a changed scrap, try to find from there\n            if (mState.isPreLayout()) {\n                holder = getChangedScrapViewForPosition(position);\n                fromScrapOrHiddenOrCache = holder != null;\n            }\n            // 1) Find by position from scrap/hidden list/cache\n            if (holder == null) {\n                holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);\n                if (holder != null) {\n                    if (!validateViewHolderForOffsetPosition(holder)) {\n                        // recycle holder (and unscrap if relevant) since it can't be used\n                        if (!dryRun) {\n                            // we would like to recycle this but need to make sure it is not used by\n                            // animation logic etc.\n                            holder.addFlags(ViewHolder.FLAG_INVALID);\n                            if (holder.isScrap()) {\n                                removeDetachedView(holder.itemView, false);\n                                holder.unScrap();\n                            } else if (holder.wasReturnedFromScrap()) {\n                                holder.clearReturnedFromScrapFlag();\n                            }\n                            recycleViewHolderInternal(holder);\n                        }\n                        holder = null;\n                    } else {\n                        fromScrapOrHiddenOrCache = true;\n                    }\n                }\n            }\n            if (holder == null) {\n                final int offsetPosition = mAdapterHelper.findPositionOffset(position);\n                if (offsetPosition < 0 || offsetPosition >= mAdapter.getItemCount()) {\n                    throw new IndexOutOfBoundsException(\"Inconsistency detected. Invalid item \"\n                            + \"position \" + position + \"(offset:\" + offsetPosition + \").\"\n                            + \"state:\" + mState.getItemCount() + exceptionLabel());\n                }\n\n                final int type = mAdapter.getItemViewType(offsetPosition);\n                // 2) Find from scrap/cache via stable ids, if exists\n                if (mAdapter.hasStableIds()) {\n                    holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),\n                            type, dryRun);\n                    if (holder != null) {\n                        // update position\n                        holder.mPosition = offsetPosition;\n                        fromScrapOrHiddenOrCache = true;\n                    }\n                }\n                if (holder == null && mViewCacheExtension != null) {\n                    // We are NOT sending the offsetPosition because LayoutManager does not\n                    // know it.\n                    final View view = mViewCacheExtension\n                            .getViewForPositionAndType(this, position, type);\n                    if (view != null) {\n                        holder = getChildViewHolder(view);\n                        if (holder == null) {\n                            throw new IllegalArgumentException(\"getViewForPositionAndType returned\"\n                                    + \" a view which does not have a ViewHolder\"\n                                    + exceptionLabel());\n                        } else if (holder.shouldIgnore()) {\n                            throw new IllegalArgumentException(\"getViewForPositionAndType returned\"\n                                    + \" a view that is ignored. You must call stopIgnoring before\"\n                                    + \" returning this view.\" + exceptionLabel());\n                        }\n                    }\n                }\n                if (holder == null) { // fallback to pool\n                    if (DEBUG) {\n                        Log.d(TAG, \"tryGetViewHolderForPositionByDeadline(\"\n                                + position + \") fetching from shared pool\");\n                    }\n                    holder = getRecycledViewPool().getRecycledView(type);\n                    if (holder != null) {\n                        holder.resetInternal();\n                        if (FORCE_INVALIDATE_DISPLAY_LIST) {\n                            invalidateDisplayListInt(holder);\n                        }\n                    }\n                }\n                if (holder == null) {\n                    long start = getNanoTime();\n                    if (deadlineNs != FOREVER_NS\n                            && !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) {\n                        // abort - we have a deadline we can't meet\n                        return null;\n                    }\n                    holder = mAdapter.createViewHolder(RecyclerView.this, type);\n                    if (ALLOW_THREAD_GAP_WORK) {\n                        // only bother finding nested RV if prefetching\n                        RecyclerView innerView = findNestedRecyclerView(holder.itemView);\n                        if (innerView != null) {\n                            holder.mNestedRecyclerView = new WeakReference<>(innerView);\n                        }\n                    }\n\n                    long end = getNanoTime();\n                    mRecyclerPool.factorInCreateTime(type, end - start);\n                    if (DEBUG) {\n                        Log.d(TAG, \"tryGetViewHolderForPositionByDeadline created new ViewHolder\");\n                    }\n                }\n            }\n```\n\n这段代码写的还是比较容易懂得，其实就是按照顺序去缓存里面寻找viewholder。\n\n缓存的顺序是\n\n1. 状态为预加载时：\n\n    getChangedScrapViewForPosition() -> 从mChangedScrap中找\n\n2. 没找着或者压根没走预加载：\n\n    getScrapOrHiddenOrCachedHolderForPosition() -> \n        从mAttachedScrap中找layoutposition等于该position的\n        ->还没找着->从mCachedViews中寻找\n\n3. 还没找着：\n\n    adapter里面有stable id：\n        getScrapOrCachedViewForId() -> 从mAttachedScrap中找itemid等于id的\n    没找着或adapter里面没有stable id:\n        mViewCacheExtension.getViewForPositionAndType() -> 在viewCacheExtension存在的前提下，从对用户扩展的viewCacheExtension中找\n    还没找着：\n        getRecycledViewPool().getRecycledView() -> 从循环view池里面获取被循环的viewholder，这个循环view池默认也就存5个\n    再没找着：\n        mAdapter.createViewHolder() ->创建一个viewholder\n\n//吐槽一下：明明是一个问题，为什么if还不嵌套...\n\n![缓存的顺序图，copy自bugly](/images/android/recyclerview缓存模型.jpg)\n\n## 总结一下：三层缓存\n\nView的detach和remove: \n\n**detach**: 在ViewGroup中的实现很简单，只是将ChildView**从ParentView的ChildView数组中移除，ChildView的mParent设置为null, 可以理解为轻量级的临时remove, 因为View此时和View树还是藕断丝连, 这个函数被经常用来改变ChildView在ChildView数组中的次序。**View被detach一般是临时的，在后面会被重新attach。\n\n**remove**: 真正的移除，不光被从ChildView数组中除名，其他和View树各项联系也会被彻底斩断(不考虑Animation/LayoutTransition这种特殊情况)， 比如焦点被清除，从TouchTarget中被移除等。\n\n\n>> Scrap View指的是在RecyclerView中，处于根据数据刷新界面等行为, ChildView被detach(注意这个detach指的是1中介绍的detach行为，而不是RecyclerView一部分注释中的”detach”，RecyclerView一部分注释中的”detach”其实指得是上面的remove)，并且被存储到了Recycler中，这部分ChildView就是Scrap View。\n\n\n1. 第一级缓存\n\nScrap View: mAttachedScrap和mChangedScrap\nRemoveed View: mCachedViews\n\n2. 第二级缓存\n\nViewCacheExtension(可选可配置)： 供使用者自行扩展，让使用者可以控制缓存\n\n3. 第三级缓存\n\nRecycledViewPool(可配置): RecyclerView之间共享ViewHolder的缓存池\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/recyclerview源码学习.md","raw":"---\ntitle: recyclerview源码学习\ndate: 2019-01-27 17:50:30\ntags: android\n---\n\n# 绘制过程\n\n绘制过程需要理解的是如何一个itemview一个itemview的绘制\n\n## onMeasure\n\n```\nprotected void onMeasure(int widthSpec, int heightSpec) {\n        if (mLayout == null) {\n            //layoutManager没有设置的话，直接走default的方法，所以会为空白\n            defaultOnMeasure(widthSpec, heightSpec);\n            return;\n        }\n        if (mLayout.mAutoMeasure) {\n            final boolean skipMeasure = widthMode == MeasureSpec.EXACTLY\n                    && heightMode == MeasureSpec.EXACTLY;\n            //如果测量是绝对值，则跳过measure过程直接走layout\n            if (skipMeasure || mAdapter == null) {\n                return;\n            }\n            if (mState.mLayoutStep == State.STEP_START) {\n                //mLayoutStep默认值是 State.STEP_START\n                dispatchLayoutStep1();\n                //执行完dispatchLayoutStep1()后是State.STEP_LAYOUT\n            }\n             ..........\n            //真正执行LayoutManager绘制的地方\n            dispatchLayoutStep2();\n            //执行完后是State.STEP_ANIMATIONS\n             ..........\n            //宽高都不确定的时候，会绘制两次\n            // if RecyclerView has non-exact width and height and if there is at least one child\n            // which also has non-exact width & height, we have to re-measure.\n            if (mLayout.shouldMeasureTwice()) {\n             ..........\n                dispatchLayoutStep2();\n             ..........            }\n        } else {\n            if (mHasFixedSize) {\n                mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);\n                return;\n            }\n             ..........\n            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);\n             ..........\n            mState.mInPreLayout = false; // clear\n        }\n    }\n--------------------- \n别人概括的measure过程\n```\n\n从这里大概分为三步，毕竟三个else\n\n### layout == null\n\n```\nvoid defaultOnMeasure(int widthSpec, int heightSpec) {\n        // calling LayoutManager here is not pretty but that API is already public and it is better\n        // than creating another method since this is internal.\n        final int width = LayoutManager.chooseSize(widthSpec,\n                getPaddingLeft() + getPaddingRight(),\n                ViewCompat.getMinimumWidth(this));\n        final int height = LayoutManager.chooseSize(heightSpec,\n                getPaddingTop() + getPaddingBottom(),\n                ViewCompat.getMinimumHeight(this));\n        setMeasuredDimension(width, height);\n    }\n```\n\n```\npublic static int chooseSize(int spec, int desired, int min) {\n            int mode = MeasureSpec.getMode(spec);\n            int size = MeasureSpec.getSize(spec);\n            switch(mode) {\n            case -2147483648:\n                return Math.min(size, Math.max(desired, min));\n            case 0:\n            default:\n                return Math.max(desired, min);\n            case 1073741824:\n                return size;\n            }\n        }\n```\n\n默认情况下面其实是处理了一下高度的问题，如果有padding的话，会将padding归入计算\n\n### mlayout != null &&  mLayout.isAutoMeasureEnabled()\n\n```\npublic boolean isAutoMeasureEnabled() {\n            return mAutoMeasure;\n        }\n```\n\n```\n/**\n         * Defines whether the measuring pass of layout should use the AutoMeasure mechanism of\n         * {@link RecyclerView} or if it should be done by the LayoutManager's implementation of\n         * {@link LayoutManager#onMeasure(Recycler, State, int, int)}.\n         *\n         * @param enabled <code>True</code> if layout measurement should be done by the\n         *                RecyclerView, <code>false</code> if it should be done by this\n         *                LayoutManager.\n         *\n         * @see #isAutoMeasureEnabled()\n         *\n         * @deprecated Implementors of LayoutManager should define whether or not it uses\n         *             AutoMeasure by overriding {@link #isAutoMeasureEnabled()}.\n         */\n        @Deprecated\n        public void setAutoMeasureEnabled(boolean enabled) {\n            mAutoMeasure = enabled;\n        }\n```\n\n这个api是deprecate的，其功能主要是设置自动测量\n\n```\nif (mLayout.mAutoMeasure) {\n            final int widthMode = MeasureSpec.getMode(widthSpec);\n            final int heightMode = MeasureSpec.getMode(heightSpec);\n            final boolean skipMeasure = widthMode == MeasureSpec.EXACTLY\n                    && heightMode == MeasureSpec.EXACTLY;\n            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);\n            if (skipMeasure || mAdapter == null) {\n                return;\n            }\n            if (mState.mLayoutStep == State.STEP_START) {\n                dispatchLayoutStep1();\n            }\n            // set dimensions in 2nd step. Pre-layout should happen with old dimensions for\n            // consistency\n            mLayout.setMeasureSpecs(widthSpec, heightSpec);\n            mState.mIsMeasuring = true;\n            dispatchLayoutStep2();\n\n            // now we can get the width and height from the children.\n            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);\n\n            // if RecyclerView has non-exact width and height and if there is at least one child\n            // which also has non-exact width & height, we have to re-measure.\n            if (mLayout.shouldMeasureTwice()) {\n                mLayout.setMeasureSpecs(\n                        MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),\n                        MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));\n                mState.mIsMeasuring = true;\n                dispatchLayoutStep2();\n                // now we can get the width and height from the children.\n                mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);\n            }\n        }\n```\n\n1. 如果测量是绝对值，则不再进行measure而直接layout，毕竟EXACTLY是写死了面积了，recyclerview的父类会直接获取面积来摆放\n\n2. STATE变量为start时\n\n```\n        static final int STEP_START = 1;\n        static final int STEP_LAYOUT = 1 << 1;\n        static final int STEP_ANIMATIONS = 1 << 2;\n```\n\n```\n/**\n     * The first step of a layout where we;\n     * - process adapter updates\n     * - decide which animation should run\n     * - save information about current views\n     * - If necessary, run predictive layout and save its information\n     */\n    private void dispatchLayoutStep1() {\n        mState.assertLayoutStep(State.STEP_START);\n        fillRemainingScrollValues(mState);\n        mState.mIsMeasuring = false;\n        startInterceptRequestLayout();\n        mViewInfoStore.clear();\n        onEnterLayoutOrScroll();\n        processAdapterUpdatesAndSetAnimationFlags();\n        saveFocusInfo();\n        mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations && mItemsChanged;\n        mItemsAddedOrRemoved = mItemsChanged = false;\n        mState.mInPreLayout = mState.mRunPredictiveAnimations;\n        mState.mItemCount = mAdapter.getItemCount();\n        findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);\n\n        if (mState.mRunSimpleAnimations) {\n            // Step 0: Find out where all non-removed items are, pre-layout\n            int count = mChildHelper.getChildCount();\n            for (int i = 0; i < count; ++i) {\n                final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));\n                if (holder.shouldIgnore() || (holder.isInvalid() && !mAdapter.hasStableIds())) {\n                    continue;\n                }\n                final ItemHolderInfo animationInfo = mItemAnimator\n                        .recordPreLayoutInformation(mState, holder,\n                                ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),\n                                holder.getUnmodifiedPayloads());\n                mViewInfoStore.addToPreLayout(holder, animationInfo);\n                if (mState.mTrackOldChangeHolders && holder.isUpdated() && !holder.isRemoved()\n                        && !holder.shouldIgnore() && !holder.isInvalid()) {\n                    long key = getChangedHolderKey(holder);\n                    // This is NOT the only place where a ViewHolder is added to old change holders\n                    // list. There is another case where:\n                    //    * A VH is currently hidden but not deleted\n                    //    * The hidden item is changed in the adapter\n                    //    * Layout manager decides to layout the item in the pre-Layout pass (step1)\n                    // When this case is detected, RV will un-hide that view and add to the old\n                    // change holders list.\n                    mViewInfoStore.addToOldChangeHolders(key, holder);\n                }\n            }\n        }\n        if (mState.mRunPredictiveAnimations) {\n            // Step 1: run prelayout: This will use the old positions of items. The layout manager\n            // is expected to layout everything, even removed items (though not to add removed\n            // items back to the container). This gives the pre-layout position of APPEARING views\n            // which come into existence as part of the real layout.\n\n            // Save old positions so that LayoutManager can run its mapping logic.\n            saveOldPositions();\n            final boolean didStructureChange = mState.mStructureChanged;\n            mState.mStructureChanged = false;\n            // temporarily disable flag because we are asking for previous layout\n            mLayout.onLayoutChildren(mRecycler, mState);\n            mState.mStructureChanged = didStructureChange;\n\n            for (int i = 0; i < mChildHelper.getChildCount(); ++i) {\n                final View child = mChildHelper.getChildAt(i);\n                final ViewHolder viewHolder = getChildViewHolderInt(child);\n                if (viewHolder.shouldIgnore()) {\n                    continue;\n                }\n                if (!mViewInfoStore.isInPreLayout(viewHolder)) {\n                    int flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder);\n                    boolean wasHidden = viewHolder\n                            .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);\n                    if (!wasHidden) {\n                        flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;\n                    }\n                    final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(\n                            mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads());\n                    if (wasHidden) {\n                        recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo);\n                    } else {\n                        mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo);\n                    }\n                }\n            }\n            // we don't process disappearing list because they may re-appear in post layout pass.\n            clearOldPositions();\n        } else {\n            clearOldPositions();\n        }\n        onExitLayoutOrScroll();\n        stopInterceptRequestLayout(false);\n        mState.mLayoutStep = State.STEP_LAYOUT;\n    }\n```\n\n从备注的内容中可以知道，这个步骤有四个功能\n\n- 处理adapter的更新\n- 决定哪些动画需要执行\n- 保存当前view的信息\n- 如果必要的情况下，执行上一个layout的操作并且保存他的信息\n\n该步骤只是做了准备工作\n\n3. state不为start时\n\n```\n /**\n     * The second layout step where we do the actual layout of the views for the final state.\n     * This step might be run multiple times if necessary (e.g. measure).\n     */\n    private void dispatchLayoutStep2() {\n        startInterceptRequestLayout();\n        onEnterLayoutOrScroll();\n        mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);\n        mAdapterHelper.consumeUpdatesInOnePass();\n        mState.mItemCount = mAdapter.getItemCount();\n        mState.mDeletedInvisibleItemCountSincePreviousLayout = 0;\n\n        // Step 2: Run layout\n        mState.mInPreLayout = false;\n        mLayout.onLayoutChildren(mRecycler, mState);\n\n        mState.mStructureChanged = false;\n        mPendingSavedState = null;\n\n        // onLayoutChildren may have caused client code to disable item animations; re-check\n        mState.mRunSimpleAnimations = mState.mRunSimpleAnimations && mItemAnimator != null;\n        mState.mLayoutStep = State.STEP_ANIMATIONS;\n        onExitLayoutOrScroll();\n        stopInterceptRequestLayout(false);\n    }\n```\n\n这里的分析需要细致一些，着重点在mLayout.onLayoutChildren()内，绘制的工作交给了layoutmanager\n\n```\npublic void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {\n        // layout algorithm:\n        //找寻锚点\n        // 1) by checking children and other variables, find an anchor coordinate and an anchor\n        // item position.\n        //两个方向填充，从锚点往上，从锚点往下\n        // 2) fill towards start, stacking from bottom\n        // 3) fill towards end, stacking from top\n        // 4) scroll to fulfill requirements like stack from bottom.\n        // create layout state\n        ....\n        // resolve layout direction\n        //判断绘制方向,给mShouldReverseLayout赋值,默认是正向绘制，则mShouldReverseLayout是false\n        resolveShouldLayoutReverse();\n        final View focused = getFocusedChild();\n        //mValid的默认值是false，一次测量之后设为true，onLayout完成后会回调执行reset方法，又变为false\n        if (!mAnchorInfo.mValid || mPendingScrollPosition != NO_POSITION\n                || mPendingSavedState != null) {\n        ....\n            //mStackFromEnd默认是false，除非手动调用setStackFromEnd()方法，两个都会false，异或则为false\n            mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;\n            // calculate anchor position and coordinate\n            //计算锚点的位置和偏移量\n            updateAnchorInfoForLayout(recycler, state, mAnchorInfo);\n        ....\n        } else if (focused != null && (mOrientationHelper.getDecoratedStart(focused)\n                >= mOrientationHelper.getEndAfterPadding()\n                || mOrientationHelper.getDecoratedEnd(focused)\n                <= mOrientationHelper.getStartAfterPadding())) {\n         ....\n        }\n         ....\n        //mLayoutFromEnd为false\n        if (mAnchorInfo.mLayoutFromEnd) {\n            //倒着绘制的话，先往上绘制，再往下绘制\n            // fill towards start\n            // 从锚点到往上\n            updateLayoutStateToFillStart(mAnchorInfo);\n            ....\n            fill(recycler, mLayoutState, state, false);\n            ....\n            // 从锚点到往下\n            // fill towards end\n            updateLayoutStateToFillEnd(mAnchorInfo);\n            ....\n            //调两遍fill方法\n            fill(recycler, mLayoutState, state, false);\n            ....\n            if (mLayoutState.mAvailable > 0) {\n                // end could not consume all. add more items towards start\n            ....\n                updateLayoutStateToFillStart(firstElement, startOffset);\n                mLayoutState.mExtra = extraForStart;\n                fill(recycler, mLayoutState, state, false);\n             ....\n            }\n        } else {\n            //正常绘制流程的话，先往下绘制，再往上绘制\n            // fill towards end\n            updateLayoutStateToFillEnd(mAnchorInfo);\n            ....\n            fill(recycler, mLayoutState, state, false);\n             ....\n            // fill towards start\n            updateLayoutStateToFillStart(mAnchorInfo);\n            ....\n            fill(recycler, mLayoutState, state, false);\n             ....\n            if (mLayoutState.mAvailable > 0) {\n                ....\n                // start could not consume all it should. add more items towards end\n                updateLayoutStateToFillEnd(lastElement, endOffset);\n                 ....\n                fill(recycler, mLayoutState, state, false);\n                ....\n            }\n        }\n        ....\n        layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);\n        //完成后重置参数\n        if (!state.isPreLayout()) {\n            mOrientationHelper.onLayoutComplete();\n        } else {\n            mAnchorInfo.reset();\n        }\n        mLastStackFromEnd = mStackFromEnd;\n    }\n```\n摘抄了别人分析的内容，很明显，这是linearlayoutmanager一个完整的layout的过程，说实话真的很复杂。\n\n```\n先寻找页面当前的锚点 \n以这个锚点未基准，向上和向下分别填充 \n填充完后，如果还有剩余的可填充大小，再填充一次\n```\n\n从这个角度来讲，可以大致理解为绘制的顺序，是首先绘制可见区域及以下的内容，而后绘制可见区域以上的内容，这个上下会依据重心来变化\n\n以前listview的绘制，大概也是差不多的，不过listview有个细节，是不设定数量的情况下，只绘制可见区域及上下加起来7个大小。分析recyclerview的源码发现，其绘制的区域仅仅是可见区域，如果需要预先绘制的话，需要自己制定预先加载的数量，其中的差别体现的还是比较明显的，因为layoutmanager需要考虑绘制的时候的动画。\n\n### 最后一步\n\n```\n            if (mHasFixedSize) {\n                mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);\n                return;\n            }\n            // custom onMeasure\n            if (mAdapterUpdateDuringMeasure) {\n                startInterceptRequestLayout();\n                onEnterLayoutOrScroll();\n                processAdapterUpdatesAndSetAnimationFlags();\n                onExitLayoutOrScroll();\n\n                if (mState.mRunPredictiveAnimations) {\n                    mState.mInPreLayout = true;\n                } else {\n                    // consume remaining updates to provide a consistent state with the layout pass.\n                    mAdapterHelper.consumeUpdatesInOnePass();\n                    mState.mInPreLayout = false;\n                }\n                mAdapterUpdateDuringMeasure = false;\n                stopInterceptRequestLayout(false);\n            } else if (mState.mRunPredictiveAnimations) {\n                // If mAdapterUpdateDuringMeasure is false and mRunPredictiveAnimations is true:\n                // this means there is already an onMeasure() call performed to handle the pending\n                // adapter change, two onMeasure() calls can happen if RV is a child of LinearLayout\n                // with layout_width=MATCH_PARENT. RV cannot call LM.onMeasure() second time\n                // because getViewForPosition() will crash when LM uses a child to measure.\n                setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight());\n                return;\n            }\n\n            if (mAdapter != null) {\n                mState.mItemCount = mAdapter.getItemCount();\n            } else {\n                mState.mItemCount = 0;\n            }\n            startInterceptRequestLayout();\n            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);\n            stopInterceptRequestLayout(false);\n            mState.mInPreLayout = false; // clear\n        }\n```\n这一步是当recyclerview没有设置**mLayout.isAutoMeasureEnabled()**的时候出现的，默认情况下走的就是这一步。\n\n这一步的含义是将绘制权直接交于layoutmanager来绘制，有个细节，就是如果期望绘制的过程由recyclerview内部来进行的话，就不要再重写layoutmanager的onmeasure了。不过对于我们这种大多数时候直接调用linearlayoutmanager的，平时不会太注意这个。\n\n回到这一步上来，大概做了这样几件事\n\n1. 当设置了hasfixedsize时\n\n```\n/**\n     * RecyclerView can perform several optimizations if it can know in advance that RecyclerView's\n     * size is not affected by the adapter contents. RecyclerView can still change its size based\n     * on other factors (e.g. its parent's size) but this size calculation cannot depend on the\n     * size of its children or contents of its adapter (except the number of items in the adapter).\n     * <p>\n     * If your use of RecyclerView falls into this category, set this to {@code true}. It will allow\n     * RecyclerView to avoid invalidating the whole layout when its adapter contents change.\n     *\n     * @param hasFixedSize true if adapter changes cannot affect the size of the RecyclerView.\n     */\n```\n\n也就是当item的大小是固定的，不会出现根据adapter的内容变化的布局，这样recyclerview就会依据某些参数固定下来他的尺寸，并不会在参考其内部数据变化而计算出来的尺寸。算是**优化**的一个注意点\n\n设置了这个参数之后，就会直接甩手给layoutmanager进行onmeasure操作\n\n2. 未设置hasfixedsize时 && adapter在onmeasure过程中正在更新\n\n此时只会做一些状态的更改，lock的重入这样。其lock的标记位实在是太多了，不过的确没有做什么事情，不过此过程如果进行，会跳转到第四步继续下去\n\n3. 未设置hasfixedsize时 && adapter 不在更新 && 目前的状态处在更新之前的动画时\n\n此时会在更新完前一个item动画之后在更新自己，所以此时只做了一个动作，就是提前将宽高的measurespec设置完毕\n\n4. 以上都没有的情况下\n\n首先会调用layoutmanager的onmeasure，之后会清除状态位。\n\n#### 最后一步的一个总结\n\n为什么hasfixedsize起作用呢？\n\n因为当未设置这个的时候，会等待adapter更新结束才会绘制，而adapter的更新会有一系列的等待，等待数据处理结束之后，才会再次做一个更新的操作。\n而设置了hasfixedsize之后，就不会等待更新了，而是会直接进行绘制。\n\n另外拷一份关于这个的别人的总结\n\n```\n总结：当我们确定Item的改变不会影响RecyclerView的宽高的时候可以设置setHasFixedSize(true)，并通过Adapter的增删改插方法去刷新RecyclerView，而不是通过notifyDataSetChanged()。（其实可以直接设置为true，当需要改变宽高的时候就用notifyDataSetChanged()去整体刷新一下）\n--------------------- \n作者：wsdaijianjun \n来源：CSDN \n原文：https://blog.csdn.net/wsdaijianjun/article/details/74735039 \n版权声明：本文为博主原创文章，转载请附上博文链接！\n```\n\n## onLayout\n\n```\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n        ...\n        dispatchLayout();\n        ...\n    }\n```\n```\n/**\n     * Wrapper around layoutChildren() that handles animating changes caused by layout.\n     * Animations work on the assumption that there are five different kinds of items\n     * in play:\n     * PERSISTENT: items are visible before and after layout\n     * REMOVED: items were visible before layout and were removed by the app\n     * ADDED: items did not exist before layout and were added by the app\n     * DISAPPEARING: items exist in the data set before/after, but changed from\n     * visible to non-visible in the process of layout (they were moved off\n     * screen as a side-effect of other changes)\n     * APPEARING: items exist in the data set before/after, but changed from\n     * non-visible to visible in the process of layout (they were moved on\n     * screen as a side-effect of other changes)\n     * The overall approach figures out what items exist before/after layout and\n     * infers one of the five above states for each of the items. Then the animations\n     * are set up accordingly:\n     * PERSISTENT views are animated via\n     * {@link ItemAnimator#animatePersistence(ViewHolder, ItemHolderInfo, ItemHolderInfo)}\n     * DISAPPEARING views are animated via\n     * {@link ItemAnimator#animateDisappearance(ViewHolder, ItemHolderInfo, ItemHolderInfo)}\n     * APPEARING views are animated via\n     * {@link ItemAnimator#animateAppearance(ViewHolder, ItemHolderInfo, ItemHolderInfo)}\n     * and changed views are animated via\n     * {@link ItemAnimator#animateChange(ViewHolder, ViewHolder, ItemHolderInfo, ItemHolderInfo)}.\n     */\n    void dispatchLayout() {\n        if (mAdapter == null) {\n            Log.e(TAG, \"No adapter attached; skipping layout\");\n            // leave the state in START\n            return;\n        }\n        if (mLayout == null) {\n            Log.e(TAG, \"No layout manager attached; skipping layout\");\n            // leave the state in START\n            return;\n        }\n        mState.mIsMeasuring = false;\n        if (mState.mLayoutStep == State.STEP_START) {\n            dispatchLayoutStep1();\n            mLayout.setExactMeasureSpecsFrom(this);\n            dispatchLayoutStep2();\n        } else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()\n                || mLayout.getHeight() != getHeight()) {\n            // First 2 steps are done in onMeasure but looks like we have to run again due to\n            // changed size.\n            mLayout.setExactMeasureSpecsFrom(this);\n            dispatchLayoutStep2();\n        } else {\n            // always make sure we sync them (to ensure mode is exact)\n            mLayout.setExactMeasureSpecsFrom(this);\n        }\n        dispatchLayoutStep3();\n    }\n```\n\nonlayout的过程相对比较简单，即是直接通过state的状态，来设置目前需要走到哪一步。其中dispatchlayoutstep1和dispatchlayoutstep2都是onmeasure过程中使用到的。\n\n唯一不知道的是dispatchlayoutstep3\n\n```\n /**\n     * The final step of the layout where we save the information about views for animations,\n     * trigger animations and do any necessary cleanup.\n     */\n    private void dispatchLayoutStep3() {\n        mState.assertLayoutStep(State.STEP_ANIMATIONS);\n        eatRequestLayout();\n        onEnterLayoutOrScroll();\n        mState.mLayoutStep = State.STEP_START;\n        if (mState.mRunSimpleAnimations) {\n            // Step 3: Find out where things are now, and process change animations.\n            // traverse list in reverse because we may call animateChange in the loop which may\n            // remove the target view holder.\n            for (int i = mChildHelper.getChildCount() - 1; i >= 0; i--) {\n                ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));\n                if (holder.shouldIgnore()) {\n                    continue;\n                }\n                long key = getChangedHolderKey(holder);\n                final ItemHolderInfo animationInfo = mItemAnimator\n                        .recordPostLayoutInformation(mState, holder);\n                ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key);\n                if (oldChangeViewHolder != null && !oldChangeViewHolder.shouldIgnore()) {\n                    // run a change animation\n\n                    // If an Item is CHANGED but the updated version is disappearing, it creates\n                    // a conflicting case.\n                    // Since a view that is marked as disappearing is likely to be going out of\n                    // bounds, we run a change animation. Both views will be cleaned automatically\n                    // once their animations finish.\n                    // On the other hand, if it is the same view holder instance, we run a\n                    // disappearing animation instead because we are not going to rebind the updated\n                    // VH unless it is enforced by the layout manager.\n                    final boolean oldDisappearing = mViewInfoStore.isDisappearing(\n                            oldChangeViewHolder);\n                    final boolean newDisappearing = mViewInfoStore.isDisappearing(holder);\n                    if (oldDisappearing && oldChangeViewHolder == holder) {\n                        // run disappear animation instead of change\n                        mViewInfoStore.addToPostLayout(holder, animationInfo);\n                    } else {\n                        final ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout(\n                                oldChangeViewHolder);\n                        // we add and remove so that any post info is merged.\n                        mViewInfoStore.addToPostLayout(holder, animationInfo);\n                        ItemHolderInfo postInfo = mViewInfoStore.popFromPostLayout(holder);\n                        if (preInfo == null) {\n                            handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder);\n                        } else {\n                            animateChange(oldChangeViewHolder, holder, preInfo, postInfo,\n                                    oldDisappearing, newDisappearing);\n                        }\n                    }\n                } else {\n                    mViewInfoStore.addToPostLayout(holder, animationInfo);\n                }\n            }\n\n            // Step 4: Process view info lists and trigger animations\n            mViewInfoStore.process(mViewInfoProcessCallback);\n        }\n\n        mLayout.removeAndRecycleScrapInt(mRecycler);\n        mState.mPreviousLayoutItemCount = mState.mItemCount;\n        mDataSetHasChangedAfterLayout = false;\n        mState.mRunSimpleAnimations = false;\n\n        mState.mRunPredictiveAnimations = false;\n        mLayout.mRequestedSimpleAnimations = false;\n        if (mRecycler.mChangedScrap != null) {\n            mRecycler.mChangedScrap.clear();\n        }\n        if (mLayout.mPrefetchMaxObservedInInitialPrefetch) {\n            // Initial prefetch has expanded cache, so reset until next prefetch.\n            // This prevents initial prefetches from expanding the cache permanently.\n            mLayout.mPrefetchMaxCountObserved = 0;\n            mLayout.mPrefetchMaxObservedInInitialPrefetch = false;\n            mRecycler.updateViewCacheSize();\n        }\n\n        mLayout.onLayoutCompleted(mState);\n        onExitLayoutOrScroll();\n        resumeRequestLayout(false);\n        mViewInfoStore.clear();\n        if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) {\n            dispatchOnScrolled(0, 0);\n        }\n        recoverFocusFromState();\n        resetFocusInfo();\n    }\n```\n\n这里看上去，能了解几个信息点，首先是处理了动画，在然后是reset了一些状态。这一步和布局没有什么必然的关系。\n\n## 全布局总结\n\n这里我就直接抄了，我的言语也最多总结成这样。\n\n\n第一步：\n处理Adapter的更新\n决定哪些动画播放\n保存当前View的信息\n如果有必要的话再进行上一布局操作，并保存它的信息\n```\nprivate void dispatchLayoutStep1() {\n    …… // 省略代码，该部分判断状态和更改状态以及保存一些信息\n    // 下面这个方法很重要，那么我们先略过，看下下面的内容。哎~我就这么调皮!哈哈，\n    // 其实是，在没有讲动画流程之前，根本讲不清。这个是动画流程的中间过程。所以\n    // ，在这里只要先知道，这里是处理Adapter更新，并计算动画类型的即可。\n    processAdapterUpdatesAndSetAnimationFlags();\n    …… // 设置一些状态，保存一些信息。\n\n    // 下面的内容是需要运行动画的情况下进行的，主要做的事情就是找出那些要需要进\n    // 行上一布局操作的ViewHolder，并且保存它们的边界信息。如果有更新操作(这个更新\n    // 指的是内容的更新，不是插入删除的这种更新)，然后保存这些更新的ViewHolder\n    if (mState.mRunSimpleAnimations) {\n        …… // 看上面的解释，这里代码都是和动画相关的，暂时懒得放，太占地方\n    }\n    // 下面的内容是需要在布局结束之后运行动画的情况下执行的。主要做的事情就是\n    // 执行上一布局操作，上一布局操作其实就是先以上一次的状态执行一边LayoutManager\n    // 的onLayoutChildren方法，其实RecyclerView的布局策略就是在\n    // LayoutManager的onLayoutChildren方法中。执行一次它就获得了所有\n    // ViewHolder的边界信息。只不过，这次获得的是之前状态下的ViewHolder的\n    // 边界信息。不过这个应该是要在LayoutManager中，根据state的isPreLayout\n    // 的返回值，选择使用新的还是旧的position。但我在系统给的几个LayoutManager中\n    // 都没有看到。\n    if (mState.mRunPredictiveAnimations) {\n        …… \n        mLayout.onLayoutChildren(mRecycler, mState);\n        ……\n    }\n    …… //恢复状态\n}\n```\n\n\n第二步：真正的布局\n\n```\nprivate void dispatchLayoutStep2() {\n    …… // 设置状态\n    mState.mInPreLayout = false; // 更改此状态，确保不是会执行上一布局操作\n    // 真正布局就是这一句话，布局的具体策略交给了LayoutManager，哈哈!这篇的主角讲完了!\n    mLayout.onLayoutChildren(mRecycler, mState);\n    …… // 设置和恢复状态\n}\n```\n\n第三步：\n\n保存信息，触发动画，清除垃圾\n```\nprivate void dispatchLayoutStep3() {\n    …… // 设置状态\n    if (mState.mRunSimpleAnimations) {\n        …… // 需要动画的情况。找出ViewHolder现在的位置，并且处理改变动画。最后触发动画。\n    }\n\n    …… // 清除状态和清除无用的信息\n    mLayout.onLayoutCompleted(mState); // 给LayoutManager的布局完成的回调\n    …… // 清除状体和清楚无用的信息，最后在恢复一些信息信息，比如焦点。\n}\n```\n\n# 缓存机制\n\nrecyclerview的缓存主要在view的复用\n\n其依赖于\n```\nfinal View view = recycler.getViewForPosition(mCurrentPosition);\n```\n\n该方法获取了viewholder的itemview\n\n```\n/**\n         * Obtain a view initialized for the given position.\n         *\n         * This method should be used by {@link LayoutManager} implementations to obtain\n         * views to represent data from an {@link Adapter}.\n         * <p>\n         * The Recycler may reuse a scrap or detached view from a shared pool if one is\n         * available for the correct view type. If the adapter has not indicated that the\n         * data at the given position has changed, the Recycler will attempt to hand back\n         * a scrap view that was previously initialized for that data without rebinding.\n         *\n         * @param position Position to obtain a view for\n         * @return A view representing the data at <code>position</code> from <code>adapter</code>\n         */\n        public View getViewForPosition(int position) {\n            return getViewForPosition(position, false);\n        }\n\n        View getViewForPosition(int position, boolean dryRun) {\n            return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;\n        }\n\n        /**\n         * Attempts to get the ViewHolder for the given position, either from the Recycler scrap,\n         * cache, the RecycledViewPool, or creating it directly.\n         * <p>\n         * If a deadlineNs other than {@link #FOREVER_NS} is passed, this method early return\n         * rather than constructing or binding a ViewHolder if it doesn't think it has time.\n         * If a ViewHolder must be constructed and not enough time remains, null is returned. If a\n         * ViewHolder is aquired and must be bound but not enough time remains, an unbound holder is\n         * returned. Use {@link ViewHolder#isBound()} on the returned object to check for this.\n         *\n         * @param position Position of ViewHolder to be returned.\n         * @param dryRun True if the ViewHolder should not be removed from scrap/cache/\n         * @param deadlineNs Time, relative to getNanoTime(), by which bind/create work should\n         *                   complete. If FOREVER_NS is passed, this method will not fail to\n         *                   create/bind the holder if needed.\n         *\n         * @return ViewHolder for requested position\n         */\n        @Nullable\n        ViewHolder tryGetViewHolderForPositionByDeadline(int position,\n                boolean dryRun, long deadlineNs) {\n            if (position < 0 || position >= mState.getItemCount()) {\n                throw new IndexOutOfBoundsException(\"Invalid item position \" + position\n                        + \"(\" + position + \"). Item count:\" + mState.getItemCount()\n                        + exceptionLabel());\n            }\n            boolean fromScrapOrHiddenOrCache = false;\n            ViewHolder holder = null;\n            // 0) If there is a changed scrap, try to find from there\n            if (mState.isPreLayout()) {\n                holder = getChangedScrapViewForPosition(position);\n                fromScrapOrHiddenOrCache = holder != null;\n            }\n            // 1) Find by position from scrap/hidden list/cache\n            if (holder == null) {\n                holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);\n                if (holder != null) {\n                    if (!validateViewHolderForOffsetPosition(holder)) {\n                        // recycle holder (and unscrap if relevant) since it can't be used\n                        if (!dryRun) {\n                            // we would like to recycle this but need to make sure it is not used by\n                            // animation logic etc.\n                            holder.addFlags(ViewHolder.FLAG_INVALID);\n                            if (holder.isScrap()) {\n                                removeDetachedView(holder.itemView, false);\n                                holder.unScrap();\n                            } else if (holder.wasReturnedFromScrap()) {\n                                holder.clearReturnedFromScrapFlag();\n                            }\n                            recycleViewHolderInternal(holder);\n                        }\n                        holder = null;\n                    } else {\n                        fromScrapOrHiddenOrCache = true;\n                    }\n                }\n            }\n            if (holder == null) {\n                final int offsetPosition = mAdapterHelper.findPositionOffset(position);\n                if (offsetPosition < 0 || offsetPosition >= mAdapter.getItemCount()) {\n                    throw new IndexOutOfBoundsException(\"Inconsistency detected. Invalid item \"\n                            + \"position \" + position + \"(offset:\" + offsetPosition + \").\"\n                            + \"state:\" + mState.getItemCount() + exceptionLabel());\n                }\n\n                final int type = mAdapter.getItemViewType(offsetPosition);\n                // 2) Find from scrap/cache via stable ids, if exists\n                if (mAdapter.hasStableIds()) {\n                    holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),\n                            type, dryRun);\n                    if (holder != null) {\n                        // update position\n                        holder.mPosition = offsetPosition;\n                        fromScrapOrHiddenOrCache = true;\n                    }\n                }\n                if (holder == null && mViewCacheExtension != null) {\n                    // We are NOT sending the offsetPosition because LayoutManager does not\n                    // know it.\n                    final View view = mViewCacheExtension\n                            .getViewForPositionAndType(this, position, type);\n                    if (view != null) {\n                        holder = getChildViewHolder(view);\n                        if (holder == null) {\n                            throw new IllegalArgumentException(\"getViewForPositionAndType returned\"\n                                    + \" a view which does not have a ViewHolder\"\n                                    + exceptionLabel());\n                        } else if (holder.shouldIgnore()) {\n                            throw new IllegalArgumentException(\"getViewForPositionAndType returned\"\n                                    + \" a view that is ignored. You must call stopIgnoring before\"\n                                    + \" returning this view.\" + exceptionLabel());\n                        }\n                    }\n                }\n                if (holder == null) { // fallback to pool\n                    if (DEBUG) {\n                        Log.d(TAG, \"tryGetViewHolderForPositionByDeadline(\"\n                                + position + \") fetching from shared pool\");\n                    }\n                    holder = getRecycledViewPool().getRecycledView(type);\n                    if (holder != null) {\n                        holder.resetInternal();\n                        if (FORCE_INVALIDATE_DISPLAY_LIST) {\n                            invalidateDisplayListInt(holder);\n                        }\n                    }\n                }\n                if (holder == null) {\n                    long start = getNanoTime();\n                    if (deadlineNs != FOREVER_NS\n                            && !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) {\n                        // abort - we have a deadline we can't meet\n                        return null;\n                    }\n                    holder = mAdapter.createViewHolder(RecyclerView.this, type);\n                    if (ALLOW_THREAD_GAP_WORK) {\n                        // only bother finding nested RV if prefetching\n                        RecyclerView innerView = findNestedRecyclerView(holder.itemView);\n                        if (innerView != null) {\n                            holder.mNestedRecyclerView = new WeakReference<>(innerView);\n                        }\n                    }\n\n                    long end = getNanoTime();\n                    mRecyclerPool.factorInCreateTime(type, end - start);\n                    if (DEBUG) {\n                        Log.d(TAG, \"tryGetViewHolderForPositionByDeadline created new ViewHolder\");\n                    }\n                }\n            }\n```\n\n这段代码写的还是比较容易懂得，其实就是按照顺序去缓存里面寻找viewholder。\n\n缓存的顺序是\n\n1. 状态为预加载时：\n\n    getChangedScrapViewForPosition() -> 从mChangedScrap中找\n\n2. 没找着或者压根没走预加载：\n\n    getScrapOrHiddenOrCachedHolderForPosition() -> \n        从mAttachedScrap中找layoutposition等于该position的\n        ->还没找着->从mCachedViews中寻找\n\n3. 还没找着：\n\n    adapter里面有stable id：\n        getScrapOrCachedViewForId() -> 从mAttachedScrap中找itemid等于id的\n    没找着或adapter里面没有stable id:\n        mViewCacheExtension.getViewForPositionAndType() -> 在viewCacheExtension存在的前提下，从对用户扩展的viewCacheExtension中找\n    还没找着：\n        getRecycledViewPool().getRecycledView() -> 从循环view池里面获取被循环的viewholder，这个循环view池默认也就存5个\n    再没找着：\n        mAdapter.createViewHolder() ->创建一个viewholder\n\n//吐槽一下：明明是一个问题，为什么if还不嵌套...\n\n![缓存的顺序图，copy自bugly](/images/android/recyclerview缓存模型.jpg)\n\n## 总结一下：三层缓存\n\nView的detach和remove: \n\n**detach**: 在ViewGroup中的实现很简单，只是将ChildView**从ParentView的ChildView数组中移除，ChildView的mParent设置为null, 可以理解为轻量级的临时remove, 因为View此时和View树还是藕断丝连, 这个函数被经常用来改变ChildView在ChildView数组中的次序。**View被detach一般是临时的，在后面会被重新attach。\n\n**remove**: 真正的移除，不光被从ChildView数组中除名，其他和View树各项联系也会被彻底斩断(不考虑Animation/LayoutTransition这种特殊情况)， 比如焦点被清除，从TouchTarget中被移除等。\n\n\n>> Scrap View指的是在RecyclerView中，处于根据数据刷新界面等行为, ChildView被detach(注意这个detach指的是1中介绍的detach行为，而不是RecyclerView一部分注释中的”detach”，RecyclerView一部分注释中的”detach”其实指得是上面的remove)，并且被存储到了Recycler中，这部分ChildView就是Scrap View。\n\n\n1. 第一级缓存\n\nScrap View: mAttachedScrap和mChangedScrap\nRemoveed View: mCachedViews\n\n2. 第二级缓存\n\nViewCacheExtension(可选可配置)： 供使用者自行扩展，让使用者可以控制缓存\n\n3. 第三级缓存\n\nRecycledViewPool(可配置): RecyclerView之间共享ViewHolder的缓存池\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"recyclerview源码学习","published":1,"updated":"2019-03-12T09:26:33.161Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5ltu0n007k3a8kgo1vcqq8","content":"<h1 id=\"绘制过程\"><a href=\"#绘制过程\" class=\"headerlink\" title=\"绘制过程\"></a>绘制过程</h1><p>绘制过程需要理解的是如何一个itemview一个itemview的绘制</p>\n<h2 id=\"onMeasure\"><a href=\"#onMeasure\" class=\"headerlink\" title=\"onMeasure\"></a>onMeasure</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void onMeasure(int widthSpec, int heightSpec) &#123;</span><br><span class=\"line\">        if (mLayout == null) &#123;</span><br><span class=\"line\">            //layoutManager没有设置的话，直接走default的方法，所以会为空白</span><br><span class=\"line\">            defaultOnMeasure(widthSpec, heightSpec);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (mLayout.mAutoMeasure) &#123;</span><br><span class=\"line\">            final boolean skipMeasure = widthMode == MeasureSpec.EXACTLY</span><br><span class=\"line\">                    &amp;&amp; heightMode == MeasureSpec.EXACTLY;</span><br><span class=\"line\">            //如果测量是绝对值，则跳过measure过程直接走layout</span><br><span class=\"line\">            if (skipMeasure || mAdapter == null) &#123;</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class=\"line\">                //mLayoutStep默认值是 State.STEP_START</span><br><span class=\"line\">                dispatchLayoutStep1();</span><br><span class=\"line\">                //执行完dispatchLayoutStep1()后是State.STEP_LAYOUT</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">             ..........</span><br><span class=\"line\">            //真正执行LayoutManager绘制的地方</span><br><span class=\"line\">            dispatchLayoutStep2();</span><br><span class=\"line\">            //执行完后是State.STEP_ANIMATIONS</span><br><span class=\"line\">             ..........</span><br><span class=\"line\">            //宽高都不确定的时候，会绘制两次</span><br><span class=\"line\">            // if RecyclerView has non-exact width and height and if there is at least one child</span><br><span class=\"line\">            // which also has non-exact width &amp; height, we have to re-measure.</span><br><span class=\"line\">            if (mLayout.shouldMeasureTwice()) &#123;</span><br><span class=\"line\">             ..........</span><br><span class=\"line\">                dispatchLayoutStep2();</span><br><span class=\"line\">             ..........            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (mHasFixedSize) &#123;</span><br><span class=\"line\">                mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">             ..........</span><br><span class=\"line\">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class=\"line\">             ..........</span><br><span class=\"line\">            mState.mInPreLayout = false; // clear</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">--------------------- </span><br><span class=\"line\">别人概括的measure过程</span><br></pre></td></tr></table></figure>\n<p>从这里大概分为三步，毕竟三个else</p>\n<h3 id=\"layout-null\"><a href=\"#layout-null\" class=\"headerlink\" title=\"layout == null\"></a>layout == null</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void defaultOnMeasure(int widthSpec, int heightSpec) &#123;</span><br><span class=\"line\">        // calling LayoutManager here is not pretty but that API is already public and it is better</span><br><span class=\"line\">        // than creating another method since this is internal.</span><br><span class=\"line\">        final int width = LayoutManager.chooseSize(widthSpec,</span><br><span class=\"line\">                getPaddingLeft() + getPaddingRight(),</span><br><span class=\"line\">                ViewCompat.getMinimumWidth(this));</span><br><span class=\"line\">        final int height = LayoutManager.chooseSize(heightSpec,</span><br><span class=\"line\">                getPaddingTop() + getPaddingBottom(),</span><br><span class=\"line\">                ViewCompat.getMinimumHeight(this));</span><br><span class=\"line\">        setMeasuredDimension(width, height);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int chooseSize(int spec, int desired, int min) &#123;</span><br><span class=\"line\">            int mode = MeasureSpec.getMode(spec);</span><br><span class=\"line\">            int size = MeasureSpec.getSize(spec);</span><br><span class=\"line\">            switch(mode) &#123;</span><br><span class=\"line\">            case -2147483648:</span><br><span class=\"line\">                return Math.min(size, Math.max(desired, min));</span><br><span class=\"line\">            case 0:</span><br><span class=\"line\">            default:</span><br><span class=\"line\">                return Math.max(desired, min);</span><br><span class=\"line\">            case 1073741824:</span><br><span class=\"line\">                return size;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>默认情况下面其实是处理了一下高度的问题，如果有padding的话，会将padding归入计算</p>\n<h3 id=\"mlayout-null-amp-amp-mLayout-isAutoMeasureEnabled\"><a href=\"#mlayout-null-amp-amp-mLayout-isAutoMeasureEnabled\" class=\"headerlink\" title=\"mlayout != null &amp;&amp;  mLayout.isAutoMeasureEnabled()\"></a>mlayout != null &amp;&amp;  mLayout.isAutoMeasureEnabled()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean isAutoMeasureEnabled() &#123;</span><br><span class=\"line\">            return mAutoMeasure;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">         * Defines whether the measuring pass of layout should use the AutoMeasure mechanism of</span><br><span class=\"line\">         * &#123;@link RecyclerView&#125; or if it should be done by the LayoutManager&apos;s implementation of</span><br><span class=\"line\">         * &#123;@link LayoutManager#onMeasure(Recycler, State, int, int)&#125;.</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * @param enabled &lt;code&gt;True&lt;/code&gt; if layout measurement should be done by the</span><br><span class=\"line\">         *                RecyclerView, &lt;code&gt;false&lt;/code&gt; if it should be done by this</span><br><span class=\"line\">         *                LayoutManager.</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * @see #isAutoMeasureEnabled()</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * @deprecated Implementors of LayoutManager should define whether or not it uses</span><br><span class=\"line\">         *             AutoMeasure by overriding &#123;@link #isAutoMeasureEnabled()&#125;.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        @Deprecated</span><br><span class=\"line\">        public void setAutoMeasureEnabled(boolean enabled) &#123;</span><br><span class=\"line\">            mAutoMeasure = enabled;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>这个api是deprecate的，其功能主要是设置自动测量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (mLayout.mAutoMeasure) &#123;</span><br><span class=\"line\">            final int widthMode = MeasureSpec.getMode(widthSpec);</span><br><span class=\"line\">            final int heightMode = MeasureSpec.getMode(heightSpec);</span><br><span class=\"line\">            final boolean skipMeasure = widthMode == MeasureSpec.EXACTLY</span><br><span class=\"line\">                    &amp;&amp; heightMode == MeasureSpec.EXACTLY;</span><br><span class=\"line\">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class=\"line\">            if (skipMeasure || mAdapter == null) &#123;</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class=\"line\">                dispatchLayoutStep1();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // set dimensions in 2nd step. Pre-layout should happen with old dimensions for</span><br><span class=\"line\">            // consistency</span><br><span class=\"line\">            mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class=\"line\">            mState.mIsMeasuring = true;</span><br><span class=\"line\">            dispatchLayoutStep2();</span><br><span class=\"line\"></span><br><span class=\"line\">            // now we can get the width and height from the children.</span><br><span class=\"line\">            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">            // if RecyclerView has non-exact width and height and if there is at least one child</span><br><span class=\"line\">            // which also has non-exact width &amp; height, we have to re-measure.</span><br><span class=\"line\">            if (mLayout.shouldMeasureTwice()) &#123;</span><br><span class=\"line\">                mLayout.setMeasureSpecs(</span><br><span class=\"line\">                        MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),</span><br><span class=\"line\">                        MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));</span><br><span class=\"line\">                mState.mIsMeasuring = true;</span><br><span class=\"line\">                dispatchLayoutStep2();</span><br><span class=\"line\">                // now we can get the width and height from the children.</span><br><span class=\"line\">                mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>如果测量是绝对值，则不再进行measure而直接layout，毕竟EXACTLY是写死了面积了，recyclerview的父类会直接获取面积来摆放</p>\n</li>\n<li><p>STATE变量为start时</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final int STEP_START = 1;</span><br><span class=\"line\">static final int STEP_LAYOUT = 1 &lt;&lt; 1;</span><br><span class=\"line\">static final int STEP_ANIMATIONS = 1 &lt;&lt; 2;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * The first step of a layout where we;</span><br><span class=\"line\">     * - process adapter updates</span><br><span class=\"line\">     * - decide which animation should run</span><br><span class=\"line\">     * - save information about current views</span><br><span class=\"line\">     * - If necessary, run predictive layout and save its information</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void dispatchLayoutStep1() &#123;</span><br><span class=\"line\">        mState.assertLayoutStep(State.STEP_START);</span><br><span class=\"line\">        fillRemainingScrollValues(mState);</span><br><span class=\"line\">        mState.mIsMeasuring = false;</span><br><span class=\"line\">        startInterceptRequestLayout();</span><br><span class=\"line\">        mViewInfoStore.clear();</span><br><span class=\"line\">        onEnterLayoutOrScroll();</span><br><span class=\"line\">        processAdapterUpdatesAndSetAnimationFlags();</span><br><span class=\"line\">        saveFocusInfo();</span><br><span class=\"line\">        mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations &amp;&amp; mItemsChanged;</span><br><span class=\"line\">        mItemsAddedOrRemoved = mItemsChanged = false;</span><br><span class=\"line\">        mState.mInPreLayout = mState.mRunPredictiveAnimations;</span><br><span class=\"line\">        mState.mItemCount = mAdapter.getItemCount();</span><br><span class=\"line\">        findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (mState.mRunSimpleAnimations) &#123;</span><br><span class=\"line\">            // Step 0: Find out where all non-removed items are, pre-layout</span><br><span class=\"line\">            int count = mChildHelper.getChildCount();</span><br><span class=\"line\">            for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class=\"line\">                final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class=\"line\">                if (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) &#123;</span><br><span class=\"line\">                    continue;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                final ItemHolderInfo animationInfo = mItemAnimator</span><br><span class=\"line\">                        .recordPreLayoutInformation(mState, holder,</span><br><span class=\"line\">                                ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),</span><br><span class=\"line\">                                holder.getUnmodifiedPayloads());</span><br><span class=\"line\">                mViewInfoStore.addToPreLayout(holder, animationInfo);</span><br><span class=\"line\">                if (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved()</span><br><span class=\"line\">                        &amp;&amp; !holder.shouldIgnore() &amp;&amp; !holder.isInvalid()) &#123;</span><br><span class=\"line\">                    long key = getChangedHolderKey(holder);</span><br><span class=\"line\">                    // This is NOT the only place where a ViewHolder is added to old change holders</span><br><span class=\"line\">                    // list. There is another case where:</span><br><span class=\"line\">                    //    * A VH is currently hidden but not deleted</span><br><span class=\"line\">                    //    * The hidden item is changed in the adapter</span><br><span class=\"line\">                    //    * Layout manager decides to layout the item in the pre-Layout pass (step1)</span><br><span class=\"line\">                    // When this case is detected, RV will un-hide that view and add to the old</span><br><span class=\"line\">                    // change holders list.</span><br><span class=\"line\">                    mViewInfoStore.addToOldChangeHolders(key, holder);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (mState.mRunPredictiveAnimations) &#123;</span><br><span class=\"line\">            // Step 1: run prelayout: This will use the old positions of items. The layout manager</span><br><span class=\"line\">            // is expected to layout everything, even removed items (though not to add removed</span><br><span class=\"line\">            // items back to the container). This gives the pre-layout position of APPEARING views</span><br><span class=\"line\">            // which come into existence as part of the real layout.</span><br><span class=\"line\"></span><br><span class=\"line\">            // Save old positions so that LayoutManager can run its mapping logic.</span><br><span class=\"line\">            saveOldPositions();</span><br><span class=\"line\">            final boolean didStructureChange = mState.mStructureChanged;</span><br><span class=\"line\">            mState.mStructureChanged = false;</span><br><span class=\"line\">            // temporarily disable flag because we are asking for previous layout</span><br><span class=\"line\">            mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class=\"line\">            mState.mStructureChanged = didStructureChange;</span><br><span class=\"line\"></span><br><span class=\"line\">            for (int i = 0; i &lt; mChildHelper.getChildCount(); ++i) &#123;</span><br><span class=\"line\">                final View child = mChildHelper.getChildAt(i);</span><br><span class=\"line\">                final ViewHolder viewHolder = getChildViewHolderInt(child);</span><br><span class=\"line\">                if (viewHolder.shouldIgnore()) &#123;</span><br><span class=\"line\">                    continue;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (!mViewInfoStore.isInPreLayout(viewHolder)) &#123;</span><br><span class=\"line\">                    int flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder);</span><br><span class=\"line\">                    boolean wasHidden = viewHolder</span><br><span class=\"line\">                            .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</span><br><span class=\"line\">                    if (!wasHidden) &#123;</span><br><span class=\"line\">                        flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(</span><br><span class=\"line\">                            mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads());</span><br><span class=\"line\">                    if (wasHidden) &#123;</span><br><span class=\"line\">                        recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo);</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // we don&apos;t process disappearing list because they may re-appear in post layout pass.</span><br><span class=\"line\">            clearOldPositions();</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            clearOldPositions();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        onExitLayoutOrScroll();</span><br><span class=\"line\">        stopInterceptRequestLayout(false);</span><br><span class=\"line\">        mState.mLayoutStep = State.STEP_LAYOUT;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>从备注的内容中可以知道，这个步骤有四个功能</p>\n<ul>\n<li>处理adapter的更新</li>\n<li>决定哪些动画需要执行</li>\n<li>保存当前view的信息</li>\n<li>如果必要的情况下，执行上一个layout的操作并且保存他的信息</li>\n</ul>\n<p>该步骤只是做了准备工作</p>\n<ol start=\"3\">\n<li>state不为start时</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">    * The second layout step where we do the actual layout of the views for the final state.</span><br><span class=\"line\">    * This step might be run multiple times if necessary (e.g. measure).</span><br><span class=\"line\">    */</span><br><span class=\"line\">   private void dispatchLayoutStep2() &#123;</span><br><span class=\"line\">       startInterceptRequestLayout();</span><br><span class=\"line\">       onEnterLayoutOrScroll();</span><br><span class=\"line\">       mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);</span><br><span class=\"line\">       mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class=\"line\">       mState.mItemCount = mAdapter.getItemCount();</span><br><span class=\"line\">       mState.mDeletedInvisibleItemCountSincePreviousLayout = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">       // Step 2: Run layout</span><br><span class=\"line\">       mState.mInPreLayout = false;</span><br><span class=\"line\">       mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class=\"line\"></span><br><span class=\"line\">       mState.mStructureChanged = false;</span><br><span class=\"line\">       mPendingSavedState = null;</span><br><span class=\"line\"></span><br><span class=\"line\">       // onLayoutChildren may have caused client code to disable item animations; re-check</span><br><span class=\"line\">       mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != null;</span><br><span class=\"line\">       mState.mLayoutStep = State.STEP_ANIMATIONS;</span><br><span class=\"line\">       onExitLayoutOrScroll();</span><br><span class=\"line\">       stopInterceptRequestLayout(false);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>这里的分析需要细致一些，着重点在mLayout.onLayoutChildren()内，绘制的工作交给了layoutmanager</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</span><br><span class=\"line\">        // layout algorithm:</span><br><span class=\"line\">        //找寻锚点</span><br><span class=\"line\">        // 1) by checking children and other variables, find an anchor coordinate and an anchor</span><br><span class=\"line\">        // item position.</span><br><span class=\"line\">        //两个方向填充，从锚点往上，从锚点往下</span><br><span class=\"line\">        // 2) fill towards start, stacking from bottom</span><br><span class=\"line\">        // 3) fill towards end, stacking from top</span><br><span class=\"line\">        // 4) scroll to fulfill requirements like stack from bottom.</span><br><span class=\"line\">        // create layout state</span><br><span class=\"line\">        ....</span><br><span class=\"line\">        // resolve layout direction</span><br><span class=\"line\">        //判断绘制方向,给mShouldReverseLayout赋值,默认是正向绘制，则mShouldReverseLayout是false</span><br><span class=\"line\">        resolveShouldLayoutReverse();</span><br><span class=\"line\">        final View focused = getFocusedChild();</span><br><span class=\"line\">        //mValid的默认值是false，一次测量之后设为true，onLayout完成后会回调执行reset方法，又变为false</span><br><span class=\"line\">        if (!mAnchorInfo.mValid || mPendingScrollPosition != NO_POSITION</span><br><span class=\"line\">                || mPendingSavedState != null) &#123;</span><br><span class=\"line\">        ....</span><br><span class=\"line\">            //mStackFromEnd默认是false，除非手动调用setStackFromEnd()方法，两个都会false，异或则为false</span><br><span class=\"line\">            mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;</span><br><span class=\"line\">            // calculate anchor position and coordinate</span><br><span class=\"line\">            //计算锚点的位置和偏移量</span><br><span class=\"line\">            updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</span><br><span class=\"line\">        ....</span><br><span class=\"line\">        &#125; else if (focused != null &amp;&amp; (mOrientationHelper.getDecoratedStart(focused)</span><br><span class=\"line\">                &gt;= mOrientationHelper.getEndAfterPadding()</span><br><span class=\"line\">                || mOrientationHelper.getDecoratedEnd(focused)</span><br><span class=\"line\">                &lt;= mOrientationHelper.getStartAfterPadding())) &#123;</span><br><span class=\"line\">         ....</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         ....</span><br><span class=\"line\">        //mLayoutFromEnd为false</span><br><span class=\"line\">        if (mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class=\"line\">            //倒着绘制的话，先往上绘制，再往下绘制</span><br><span class=\"line\">            // fill towards start</span><br><span class=\"line\">            // 从锚点到往上</span><br><span class=\"line\">            updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class=\"line\">            ....</span><br><span class=\"line\">            fill(recycler, mLayoutState, state, false);</span><br><span class=\"line\">            ....</span><br><span class=\"line\">            // 从锚点到往下</span><br><span class=\"line\">            // fill towards end</span><br><span class=\"line\">            updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class=\"line\">            ....</span><br><span class=\"line\">            //调两遍fill方法</span><br><span class=\"line\">            fill(recycler, mLayoutState, state, false);</span><br><span class=\"line\">            ....</span><br><span class=\"line\">            if (mLayoutState.mAvailable &gt; 0) &#123;</span><br><span class=\"line\">                // end could not consume all. add more items towards start</span><br><span class=\"line\">            ....</span><br><span class=\"line\">                updateLayoutStateToFillStart(firstElement, startOffset);</span><br><span class=\"line\">                mLayoutState.mExtra = extraForStart;</span><br><span class=\"line\">                fill(recycler, mLayoutState, state, false);</span><br><span class=\"line\">             ....</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            //正常绘制流程的话，先往下绘制，再往上绘制</span><br><span class=\"line\">            // fill towards end</span><br><span class=\"line\">            updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class=\"line\">            ....</span><br><span class=\"line\">            fill(recycler, mLayoutState, state, false);</span><br><span class=\"line\">             ....</span><br><span class=\"line\">            // fill towards start</span><br><span class=\"line\">            updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class=\"line\">            ....</span><br><span class=\"line\">            fill(recycler, mLayoutState, state, false);</span><br><span class=\"line\">             ....</span><br><span class=\"line\">            if (mLayoutState.mAvailable &gt; 0) &#123;</span><br><span class=\"line\">                ....</span><br><span class=\"line\">                // start could not consume all it should. add more items towards end</span><br><span class=\"line\">                updateLayoutStateToFillEnd(lastElement, endOffset);</span><br><span class=\"line\">                 ....</span><br><span class=\"line\">                fill(recycler, mLayoutState, state, false);</span><br><span class=\"line\">                ....</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ....</span><br><span class=\"line\">        layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);</span><br><span class=\"line\">        //完成后重置参数</span><br><span class=\"line\">        if (!state.isPreLayout()) &#123;</span><br><span class=\"line\">            mOrientationHelper.onLayoutComplete();</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            mAnchorInfo.reset();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mLastStackFromEnd = mStackFromEnd;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>摘抄了别人分析的内容，很明显，这是linearlayoutmanager一个完整的layout的过程，说实话真的很复杂。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">先寻找页面当前的锚点 </span><br><span class=\"line\">以这个锚点未基准，向上和向下分别填充 </span><br><span class=\"line\">填充完后，如果还有剩余的可填充大小，再填充一次</span><br></pre></td></tr></table></figure>\n<p>从这个角度来讲，可以大致理解为绘制的顺序，是首先绘制可见区域及以下的内容，而后绘制可见区域以上的内容，这个上下会依据重心来变化</p>\n<p>以前listview的绘制，大概也是差不多的，不过listview有个细节，是不设定数量的情况下，只绘制可见区域及上下加起来7个大小。分析recyclerview的源码发现，其绘制的区域仅仅是可见区域，如果需要预先绘制的话，需要自己制定预先加载的数量，其中的差别体现的还是比较明显的，因为layoutmanager需要考虑绘制的时候的动画。</p>\n<h3 id=\"最后一步\"><a href=\"#最后一步\" class=\"headerlink\" title=\"最后一步\"></a>最后一步</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    if (mHasFixedSize) &#123;</span><br><span class=\"line\">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // custom onMeasure</span><br><span class=\"line\">    if (mAdapterUpdateDuringMeasure) &#123;</span><br><span class=\"line\">        startInterceptRequestLayout();</span><br><span class=\"line\">        onEnterLayoutOrScroll();</span><br><span class=\"line\">        processAdapterUpdatesAndSetAnimationFlags();</span><br><span class=\"line\">        onExitLayoutOrScroll();</span><br><span class=\"line\"></span><br><span class=\"line\">        if (mState.mRunPredictiveAnimations) &#123;</span><br><span class=\"line\">            mState.mInPreLayout = true;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // consume remaining updates to provide a consistent state with the layout pass.</span><br><span class=\"line\">            mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class=\"line\">            mState.mInPreLayout = false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mAdapterUpdateDuringMeasure = false;</span><br><span class=\"line\">        stopInterceptRequestLayout(false);</span><br><span class=\"line\">    &#125; else if (mState.mRunPredictiveAnimations) &#123;</span><br><span class=\"line\">        // If mAdapterUpdateDuringMeasure is false and mRunPredictiveAnimations is true:</span><br><span class=\"line\">        // this means there is already an onMeasure() call performed to handle the pending</span><br><span class=\"line\">        // adapter change, two onMeasure() calls can happen if RV is a child of LinearLayout</span><br><span class=\"line\">        // with layout_width=MATCH_PARENT. RV cannot call LM.onMeasure() second time</span><br><span class=\"line\">        // because getViewForPosition() will crash when LM uses a child to measure.</span><br><span class=\"line\">        setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight());</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (mAdapter != null) &#123;</span><br><span class=\"line\">        mState.mItemCount = mAdapter.getItemCount();</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        mState.mItemCount = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    startInterceptRequestLayout();</span><br><span class=\"line\">    mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class=\"line\">    stopInterceptRequestLayout(false);</span><br><span class=\"line\">    mState.mInPreLayout = false; // clear</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这一步是当recyclerview没有设置<strong>mLayout.isAutoMeasureEnabled()</strong>的时候出现的，默认情况下走的就是这一步。</p>\n<p>这一步的含义是将绘制权直接交于layoutmanager来绘制，有个细节，就是如果期望绘制的过程由recyclerview内部来进行的话，就不要再重写layoutmanager的onmeasure了。不过对于我们这种大多数时候直接调用linearlayoutmanager的，平时不会太注意这个。</p>\n<p>回到这一步上来，大概做了这样几件事</p>\n<ol>\n<li>当设置了hasfixedsize时</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * RecyclerView can perform several optimizations if it can know in advance that RecyclerView&apos;s</span><br><span class=\"line\">     * size is not affected by the adapter contents. RecyclerView can still change its size based</span><br><span class=\"line\">     * on other factors (e.g. its parent&apos;s size) but this size calculation cannot depend on the</span><br><span class=\"line\">     * size of its children or contents of its adapter (except the number of items in the adapter).</span><br><span class=\"line\">     * &lt;p&gt;</span><br><span class=\"line\">     * If your use of RecyclerView falls into this category, set this to &#123;@code true&#125;. It will allow</span><br><span class=\"line\">     * RecyclerView to avoid invalidating the whole layout when its adapter contents change.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param hasFixedSize true if adapter changes cannot affect the size of the RecyclerView.</span><br><span class=\"line\">     */</span><br></pre></td></tr></table></figure>\n<p>也就是当item的大小是固定的，不会出现根据adapter的内容变化的布局，这样recyclerview就会依据某些参数固定下来他的尺寸，并不会在参考其内部数据变化而计算出来的尺寸。算是<strong>优化</strong>的一个注意点</p>\n<p>设置了这个参数之后，就会直接甩手给layoutmanager进行onmeasure操作</p>\n<ol start=\"2\">\n<li>未设置hasfixedsize时 &amp;&amp; adapter在onmeasure过程中正在更新</li>\n</ol>\n<p>此时只会做一些状态的更改，lock的重入这样。其lock的标记位实在是太多了，不过的确没有做什么事情，不过此过程如果进行，会跳转到第四步继续下去</p>\n<ol start=\"3\">\n<li>未设置hasfixedsize时 &amp;&amp; adapter 不在更新 &amp;&amp; 目前的状态处在更新之前的动画时</li>\n</ol>\n<p>此时会在更新完前一个item动画之后在更新自己，所以此时只做了一个动作，就是提前将宽高的measurespec设置完毕</p>\n<ol start=\"4\">\n<li>以上都没有的情况下</li>\n</ol>\n<p>首先会调用layoutmanager的onmeasure，之后会清除状态位。</p>\n<h4 id=\"最后一步的一个总结\"><a href=\"#最后一步的一个总结\" class=\"headerlink\" title=\"最后一步的一个总结\"></a>最后一步的一个总结</h4><p>为什么hasfixedsize起作用呢？</p>\n<p>因为当未设置这个的时候，会等待adapter更新结束才会绘制，而adapter的更新会有一系列的等待，等待数据处理结束之后，才会再次做一个更新的操作。<br>而设置了hasfixedsize之后，就不会等待更新了，而是会直接进行绘制。</p>\n<p>另外拷一份关于这个的别人的总结</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">总结：当我们确定Item的改变不会影响RecyclerView的宽高的时候可以设置setHasFixedSize(true)，并通过Adapter的增删改插方法去刷新RecyclerView，而不是通过notifyDataSetChanged()。（其实可以直接设置为true，当需要改变宽高的时候就用notifyDataSetChanged()去整体刷新一下）</span><br><span class=\"line\">--------------------- </span><br><span class=\"line\">作者：wsdaijianjun </span><br><span class=\"line\">来源：CSDN </span><br><span class=\"line\">原文：https://blog.csdn.net/wsdaijianjun/article/details/74735039 </span><br><span class=\"line\">版权声明：本文为博主原创文章，转载请附上博文链接！</span><br></pre></td></tr></table></figure>\n<h2 id=\"onLayout\"><a href=\"#onLayout\" class=\"headerlink\" title=\"onLayout\"></a>onLayout</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    dispatchLayout();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * Wrapper around layoutChildren() that handles animating changes caused by layout.</span><br><span class=\"line\">     * Animations work on the assumption that there are five different kinds of items</span><br><span class=\"line\">     * in play:</span><br><span class=\"line\">     * PERSISTENT: items are visible before and after layout</span><br><span class=\"line\">     * REMOVED: items were visible before layout and were removed by the app</span><br><span class=\"line\">     * ADDED: items did not exist before layout and were added by the app</span><br><span class=\"line\">     * DISAPPEARING: items exist in the data set before/after, but changed from</span><br><span class=\"line\">     * visible to non-visible in the process of layout (they were moved off</span><br><span class=\"line\">     * screen as a side-effect of other changes)</span><br><span class=\"line\">     * APPEARING: items exist in the data set before/after, but changed from</span><br><span class=\"line\">     * non-visible to visible in the process of layout (they were moved on</span><br><span class=\"line\">     * screen as a side-effect of other changes)</span><br><span class=\"line\">     * The overall approach figures out what items exist before/after layout and</span><br><span class=\"line\">     * infers one of the five above states for each of the items. Then the animations</span><br><span class=\"line\">     * are set up accordingly:</span><br><span class=\"line\">     * PERSISTENT views are animated via</span><br><span class=\"line\">     * &#123;@link ItemAnimator#animatePersistence(ViewHolder, ItemHolderInfo, ItemHolderInfo)&#125;</span><br><span class=\"line\">     * DISAPPEARING views are animated via</span><br><span class=\"line\">     * &#123;@link ItemAnimator#animateDisappearance(ViewHolder, ItemHolderInfo, ItemHolderInfo)&#125;</span><br><span class=\"line\">     * APPEARING views are animated via</span><br><span class=\"line\">     * &#123;@link ItemAnimator#animateAppearance(ViewHolder, ItemHolderInfo, ItemHolderInfo)&#125;</span><br><span class=\"line\">     * and changed views are animated via</span><br><span class=\"line\">     * &#123;@link ItemAnimator#animateChange(ViewHolder, ViewHolder, ItemHolderInfo, ItemHolderInfo)&#125;.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void dispatchLayout() &#123;</span><br><span class=\"line\">        if (mAdapter == null) &#123;</span><br><span class=\"line\">            Log.e(TAG, &quot;No adapter attached; skipping layout&quot;);</span><br><span class=\"line\">            // leave the state in START</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (mLayout == null) &#123;</span><br><span class=\"line\">            Log.e(TAG, &quot;No layout manager attached; skipping layout&quot;);</span><br><span class=\"line\">            // leave the state in START</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mState.mIsMeasuring = false;</span><br><span class=\"line\">        if (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class=\"line\">            dispatchLayoutStep1();</span><br><span class=\"line\">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class=\"line\">            dispatchLayoutStep2();</span><br><span class=\"line\">        &#125; else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()</span><br><span class=\"line\">                || mLayout.getHeight() != getHeight()) &#123;</span><br><span class=\"line\">            // First 2 steps are done in onMeasure but looks like we have to run again due to</span><br><span class=\"line\">            // changed size.</span><br><span class=\"line\">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class=\"line\">            dispatchLayoutStep2();</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // always make sure we sync them (to ensure mode is exact)</span><br><span class=\"line\">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dispatchLayoutStep3();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>onlayout的过程相对比较简单，即是直接通过state的状态，来设置目前需要走到哪一步。其中dispatchlayoutstep1和dispatchlayoutstep2都是onmeasure过程中使用到的。</p>\n<p>唯一不知道的是dispatchlayoutstep3</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">    * The final step of the layout where we save the information about views for animations,</span><br><span class=\"line\">    * trigger animations and do any necessary cleanup.</span><br><span class=\"line\">    */</span><br><span class=\"line\">   private void dispatchLayoutStep3() &#123;</span><br><span class=\"line\">       mState.assertLayoutStep(State.STEP_ANIMATIONS);</span><br><span class=\"line\">       eatRequestLayout();</span><br><span class=\"line\">       onEnterLayoutOrScroll();</span><br><span class=\"line\">       mState.mLayoutStep = State.STEP_START;</span><br><span class=\"line\">       if (mState.mRunSimpleAnimations) &#123;</span><br><span class=\"line\">           // Step 3: Find out where things are now, and process change animations.</span><br><span class=\"line\">           // traverse list in reverse because we may call animateChange in the loop which may</span><br><span class=\"line\">           // remove the target view holder.</span><br><span class=\"line\">           for (int i = mChildHelper.getChildCount() - 1; i &gt;= 0; i--) &#123;</span><br><span class=\"line\">               ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class=\"line\">               if (holder.shouldIgnore()) &#123;</span><br><span class=\"line\">                   continue;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               long key = getChangedHolderKey(holder);</span><br><span class=\"line\">               final ItemHolderInfo animationInfo = mItemAnimator</span><br><span class=\"line\">                       .recordPostLayoutInformation(mState, holder);</span><br><span class=\"line\">               ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key);</span><br><span class=\"line\">               if (oldChangeViewHolder != null &amp;&amp; !oldChangeViewHolder.shouldIgnore()) &#123;</span><br><span class=\"line\">                   // run a change animation</span><br><span class=\"line\"></span><br><span class=\"line\">                   // If an Item is CHANGED but the updated version is disappearing, it creates</span><br><span class=\"line\">                   // a conflicting case.</span><br><span class=\"line\">                   // Since a view that is marked as disappearing is likely to be going out of</span><br><span class=\"line\">                   // bounds, we run a change animation. Both views will be cleaned automatically</span><br><span class=\"line\">                   // once their animations finish.</span><br><span class=\"line\">                   // On the other hand, if it is the same view holder instance, we run a</span><br><span class=\"line\">                   // disappearing animation instead because we are not going to rebind the updated</span><br><span class=\"line\">                   // VH unless it is enforced by the layout manager.</span><br><span class=\"line\">                   final boolean oldDisappearing = mViewInfoStore.isDisappearing(</span><br><span class=\"line\">                           oldChangeViewHolder);</span><br><span class=\"line\">                   final boolean newDisappearing = mViewInfoStore.isDisappearing(holder);</span><br><span class=\"line\">                   if (oldDisappearing &amp;&amp; oldChangeViewHolder == holder) &#123;</span><br><span class=\"line\">                       // run disappear animation instead of change</span><br><span class=\"line\">                       mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class=\"line\">                   &#125; else &#123;</span><br><span class=\"line\">                       final ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout(</span><br><span class=\"line\">                               oldChangeViewHolder);</span><br><span class=\"line\">                       // we add and remove so that any post info is merged.</span><br><span class=\"line\">                       mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class=\"line\">                       ItemHolderInfo postInfo = mViewInfoStore.popFromPostLayout(holder);</span><br><span class=\"line\">                       if (preInfo == null) &#123;</span><br><span class=\"line\">                           handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder);</span><br><span class=\"line\">                       &#125; else &#123;</span><br><span class=\"line\">                           animateChange(oldChangeViewHolder, holder, preInfo, postInfo,</span><br><span class=\"line\">                                   oldDisappearing, newDisappearing);</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125; else &#123;</span><br><span class=\"line\">                   mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           // Step 4: Process view info lists and trigger animations</span><br><span class=\"line\">           mViewInfoStore.process(mViewInfoProcessCallback);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       mLayout.removeAndRecycleScrapInt(mRecycler);</span><br><span class=\"line\">       mState.mPreviousLayoutItemCount = mState.mItemCount;</span><br><span class=\"line\">       mDataSetHasChangedAfterLayout = false;</span><br><span class=\"line\">       mState.mRunSimpleAnimations = false;</span><br><span class=\"line\"></span><br><span class=\"line\">       mState.mRunPredictiveAnimations = false;</span><br><span class=\"line\">       mLayout.mRequestedSimpleAnimations = false;</span><br><span class=\"line\">       if (mRecycler.mChangedScrap != null) &#123;</span><br><span class=\"line\">           mRecycler.mChangedScrap.clear();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       if (mLayout.mPrefetchMaxObservedInInitialPrefetch) &#123;</span><br><span class=\"line\">           // Initial prefetch has expanded cache, so reset until next prefetch.</span><br><span class=\"line\">           // This prevents initial prefetches from expanding the cache permanently.</span><br><span class=\"line\">           mLayout.mPrefetchMaxCountObserved = 0;</span><br><span class=\"line\">           mLayout.mPrefetchMaxObservedInInitialPrefetch = false;</span><br><span class=\"line\">           mRecycler.updateViewCacheSize();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       mLayout.onLayoutCompleted(mState);</span><br><span class=\"line\">       onExitLayoutOrScroll();</span><br><span class=\"line\">       resumeRequestLayout(false);</span><br><span class=\"line\">       mViewInfoStore.clear();</span><br><span class=\"line\">       if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) &#123;</span><br><span class=\"line\">           dispatchOnScrolled(0, 0);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       recoverFocusFromState();</span><br><span class=\"line\">       resetFocusInfo();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>这里看上去，能了解几个信息点，首先是处理了动画，在然后是reset了一些状态。这一步和布局没有什么必然的关系。</p>\n<h2 id=\"全布局总结\"><a href=\"#全布局总结\" class=\"headerlink\" title=\"全布局总结\"></a>全布局总结</h2><p>这里我就直接抄了，我的言语也最多总结成这样。</p>\n<p>第一步：<br>处理Adapter的更新<br>决定哪些动画播放<br>保存当前View的信息<br>如果有必要的话再进行上一布局操作，并保存它的信息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void dispatchLayoutStep1() &#123;</span><br><span class=\"line\">    …… // 省略代码，该部分判断状态和更改状态以及保存一些信息</span><br><span class=\"line\">    // 下面这个方法很重要，那么我们先略过，看下下面的内容。哎~我就这么调皮!哈哈，</span><br><span class=\"line\">    // 其实是，在没有讲动画流程之前，根本讲不清。这个是动画流程的中间过程。所以</span><br><span class=\"line\">    // ，在这里只要先知道，这里是处理Adapter更新，并计算动画类型的即可。</span><br><span class=\"line\">    processAdapterUpdatesAndSetAnimationFlags();</span><br><span class=\"line\">    …… // 设置一些状态，保存一些信息。</span><br><span class=\"line\"></span><br><span class=\"line\">    // 下面的内容是需要运行动画的情况下进行的，主要做的事情就是找出那些要需要进</span><br><span class=\"line\">    // 行上一布局操作的ViewHolder，并且保存它们的边界信息。如果有更新操作(这个更新</span><br><span class=\"line\">    // 指的是内容的更新，不是插入删除的这种更新)，然后保存这些更新的ViewHolder</span><br><span class=\"line\">    if (mState.mRunSimpleAnimations) &#123;</span><br><span class=\"line\">        …… // 看上面的解释，这里代码都是和动画相关的，暂时懒得放，太占地方</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 下面的内容是需要在布局结束之后运行动画的情况下执行的。主要做的事情就是</span><br><span class=\"line\">    // 执行上一布局操作，上一布局操作其实就是先以上一次的状态执行一边LayoutManager</span><br><span class=\"line\">    // 的onLayoutChildren方法，其实RecyclerView的布局策略就是在</span><br><span class=\"line\">    // LayoutManager的onLayoutChildren方法中。执行一次它就获得了所有</span><br><span class=\"line\">    // ViewHolder的边界信息。只不过，这次获得的是之前状态下的ViewHolder的</span><br><span class=\"line\">    // 边界信息。不过这个应该是要在LayoutManager中，根据state的isPreLayout</span><br><span class=\"line\">    // 的返回值，选择使用新的还是旧的position。但我在系统给的几个LayoutManager中</span><br><span class=\"line\">    // 都没有看到。</span><br><span class=\"line\">    if (mState.mRunPredictiveAnimations) &#123;</span><br><span class=\"line\">        …… </span><br><span class=\"line\">        mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class=\"line\">        ……</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    …… //恢复状态</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第二步：真正的布局</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void dispatchLayoutStep2() &#123;</span><br><span class=\"line\">    …… // 设置状态</span><br><span class=\"line\">    mState.mInPreLayout = false; // 更改此状态，确保不是会执行上一布局操作</span><br><span class=\"line\">    // 真正布局就是这一句话，布局的具体策略交给了LayoutManager，哈哈!这篇的主角讲完了!</span><br><span class=\"line\">    mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class=\"line\">    …… // 设置和恢复状态</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第三步：</p>\n<p>保存信息，触发动画，清除垃圾<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void dispatchLayoutStep3() &#123;</span><br><span class=\"line\">    …… // 设置状态</span><br><span class=\"line\">    if (mState.mRunSimpleAnimations) &#123;</span><br><span class=\"line\">        …… // 需要动画的情况。找出ViewHolder现在的位置，并且处理改变动画。最后触发动画。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    …… // 清除状态和清除无用的信息</span><br><span class=\"line\">    mLayout.onLayoutCompleted(mState); // 给LayoutManager的布局完成的回调</span><br><span class=\"line\">    …… // 清除状体和清楚无用的信息，最后在恢复一些信息信息，比如焦点。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"缓存机制\"><a href=\"#缓存机制\" class=\"headerlink\" title=\"缓存机制\"></a>缓存机制</h1><p>recyclerview的缓存主要在view的复用</p>\n<p>其依赖于<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final View view = recycler.getViewForPosition(mCurrentPosition);</span><br></pre></td></tr></table></figure></p>\n<p>该方法获取了viewholder的itemview</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">         * Obtain a view initialized for the given position.</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * This method should be used by &#123;@link LayoutManager&#125; implementations to obtain</span><br><span class=\"line\">         * views to represent data from an &#123;@link Adapter&#125;.</span><br><span class=\"line\">         * &lt;p&gt;</span><br><span class=\"line\">         * The Recycler may reuse a scrap or detached view from a shared pool if one is</span><br><span class=\"line\">         * available for the correct view type. If the adapter has not indicated that the</span><br><span class=\"line\">         * data at the given position has changed, the Recycler will attempt to hand back</span><br><span class=\"line\">         * a scrap view that was previously initialized for that data without rebinding.</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * @param position Position to obtain a view for</span><br><span class=\"line\">         * @return A view representing the data at &lt;code&gt;position&lt;/code&gt; from &lt;code&gt;adapter&lt;/code&gt;</span><br><span class=\"line\">         */</span><br><span class=\"line\">        public View getViewForPosition(int position) &#123;</span><br><span class=\"line\">            return getViewForPosition(position, false);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        View getViewForPosition(int position, boolean dryRun) &#123;</span><br><span class=\"line\">            return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * Attempts to get the ViewHolder for the given position, either from the Recycler scrap,</span><br><span class=\"line\">         * cache, the RecycledViewPool, or creating it directly.</span><br><span class=\"line\">         * &lt;p&gt;</span><br><span class=\"line\">         * If a deadlineNs other than &#123;@link #FOREVER_NS&#125; is passed, this method early return</span><br><span class=\"line\">         * rather than constructing or binding a ViewHolder if it doesn&apos;t think it has time.</span><br><span class=\"line\">         * If a ViewHolder must be constructed and not enough time remains, null is returned. If a</span><br><span class=\"line\">         * ViewHolder is aquired and must be bound but not enough time remains, an unbound holder is</span><br><span class=\"line\">         * returned. Use &#123;@link ViewHolder#isBound()&#125; on the returned object to check for this.</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * @param position Position of ViewHolder to be returned.</span><br><span class=\"line\">         * @param dryRun True if the ViewHolder should not be removed from scrap/cache/</span><br><span class=\"line\">         * @param deadlineNs Time, relative to getNanoTime(), by which bind/create work should</span><br><span class=\"line\">         *                   complete. If FOREVER_NS is passed, this method will not fail to</span><br><span class=\"line\">         *                   create/bind the holder if needed.</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * @return ViewHolder for requested position</span><br><span class=\"line\">         */</span><br><span class=\"line\">        @Nullable</span><br><span class=\"line\">        ViewHolder tryGetViewHolderForPositionByDeadline(int position,</span><br><span class=\"line\">                boolean dryRun, long deadlineNs) &#123;</span><br><span class=\"line\">            if (position &lt; 0 || position &gt;= mState.getItemCount()) &#123;</span><br><span class=\"line\">                throw new IndexOutOfBoundsException(&quot;Invalid item position &quot; + position</span><br><span class=\"line\">                        + &quot;(&quot; + position + &quot;). Item count:&quot; + mState.getItemCount()</span><br><span class=\"line\">                        + exceptionLabel());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            boolean fromScrapOrHiddenOrCache = false;</span><br><span class=\"line\">            ViewHolder holder = null;</span><br><span class=\"line\">            // 0) If there is a changed scrap, try to find from there</span><br><span class=\"line\">            if (mState.isPreLayout()) &#123;</span><br><span class=\"line\">                holder = getChangedScrapViewForPosition(position);</span><br><span class=\"line\">                fromScrapOrHiddenOrCache = holder != null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 1) Find by position from scrap/hidden list/cache</span><br><span class=\"line\">            if (holder == null) &#123;</span><br><span class=\"line\">                holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</span><br><span class=\"line\">                if (holder != null) &#123;</span><br><span class=\"line\">                    if (!validateViewHolderForOffsetPosition(holder)) &#123;</span><br><span class=\"line\">                        // recycle holder (and unscrap if relevant) since it can&apos;t be used</span><br><span class=\"line\">                        if (!dryRun) &#123;</span><br><span class=\"line\">                            // we would like to recycle this but need to make sure it is not used by</span><br><span class=\"line\">                            // animation logic etc.</span><br><span class=\"line\">                            holder.addFlags(ViewHolder.FLAG_INVALID);</span><br><span class=\"line\">                            if (holder.isScrap()) &#123;</span><br><span class=\"line\">                                removeDetachedView(holder.itemView, false);</span><br><span class=\"line\">                                holder.unScrap();</span><br><span class=\"line\">                            &#125; else if (holder.wasReturnedFromScrap()) &#123;</span><br><span class=\"line\">                                holder.clearReturnedFromScrapFlag();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            recycleViewHolderInternal(holder);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        holder = null;</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        fromScrapOrHiddenOrCache = true;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (holder == null) &#123;</span><br><span class=\"line\">                final int offsetPosition = mAdapterHelper.findPositionOffset(position);</span><br><span class=\"line\">                if (offsetPosition &lt; 0 || offsetPosition &gt;= mAdapter.getItemCount()) &#123;</span><br><span class=\"line\">                    throw new IndexOutOfBoundsException(&quot;Inconsistency detected. Invalid item &quot;</span><br><span class=\"line\">                            + &quot;position &quot; + position + &quot;(offset:&quot; + offsetPosition + &quot;).&quot;</span><br><span class=\"line\">                            + &quot;state:&quot; + mState.getItemCount() + exceptionLabel());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                final int type = mAdapter.getItemViewType(offsetPosition);</span><br><span class=\"line\">                // 2) Find from scrap/cache via stable ids, if exists</span><br><span class=\"line\">                if (mAdapter.hasStableIds()) &#123;</span><br><span class=\"line\">                    holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</span><br><span class=\"line\">                            type, dryRun);</span><br><span class=\"line\">                    if (holder != null) &#123;</span><br><span class=\"line\">                        // update position</span><br><span class=\"line\">                        holder.mPosition = offsetPosition;</span><br><span class=\"line\">                        fromScrapOrHiddenOrCache = true;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (holder == null &amp;&amp; mViewCacheExtension != null) &#123;</span><br><span class=\"line\">                    // We are NOT sending the offsetPosition because LayoutManager does not</span><br><span class=\"line\">                    // know it.</span><br><span class=\"line\">                    final View view = mViewCacheExtension</span><br><span class=\"line\">                            .getViewForPositionAndType(this, position, type);</span><br><span class=\"line\">                    if (view != null) &#123;</span><br><span class=\"line\">                        holder = getChildViewHolder(view);</span><br><span class=\"line\">                        if (holder == null) &#123;</span><br><span class=\"line\">                            throw new IllegalArgumentException(&quot;getViewForPositionAndType returned&quot;</span><br><span class=\"line\">                                    + &quot; a view which does not have a ViewHolder&quot;</span><br><span class=\"line\">                                    + exceptionLabel());</span><br><span class=\"line\">                        &#125; else if (holder.shouldIgnore()) &#123;</span><br><span class=\"line\">                            throw new IllegalArgumentException(&quot;getViewForPositionAndType returned&quot;</span><br><span class=\"line\">                                    + &quot; a view that is ignored. You must call stopIgnoring before&quot;</span><br><span class=\"line\">                                    + &quot; returning this view.&quot; + exceptionLabel());</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (holder == null) &#123; // fallback to pool</span><br><span class=\"line\">                    if (DEBUG) &#123;</span><br><span class=\"line\">                        Log.d(TAG, &quot;tryGetViewHolderForPositionByDeadline(&quot;</span><br><span class=\"line\">                                + position + &quot;) fetching from shared pool&quot;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    holder = getRecycledViewPool().getRecycledView(type);</span><br><span class=\"line\">                    if (holder != null) &#123;</span><br><span class=\"line\">                        holder.resetInternal();</span><br><span class=\"line\">                        if (FORCE_INVALIDATE_DISPLAY_LIST) &#123;</span><br><span class=\"line\">                            invalidateDisplayListInt(holder);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (holder == null) &#123;</span><br><span class=\"line\">                    long start = getNanoTime();</span><br><span class=\"line\">                    if (deadlineNs != FOREVER_NS</span><br><span class=\"line\">                            &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123;</span><br><span class=\"line\">                        // abort - we have a deadline we can&apos;t meet</span><br><span class=\"line\">                        return null;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    holder = mAdapter.createViewHolder(RecyclerView.this, type);</span><br><span class=\"line\">                    if (ALLOW_THREAD_GAP_WORK) &#123;</span><br><span class=\"line\">                        // only bother finding nested RV if prefetching</span><br><span class=\"line\">                        RecyclerView innerView = findNestedRecyclerView(holder.itemView);</span><br><span class=\"line\">                        if (innerView != null) &#123;</span><br><span class=\"line\">                            holder.mNestedRecyclerView = new WeakReference&lt;&gt;(innerView);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    long end = getNanoTime();</span><br><span class=\"line\">                    mRecyclerPool.factorInCreateTime(type, end - start);</span><br><span class=\"line\">                    if (DEBUG) &#123;</span><br><span class=\"line\">                        Log.d(TAG, &quot;tryGetViewHolderForPositionByDeadline created new ViewHolder&quot;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码写的还是比较容易懂得，其实就是按照顺序去缓存里面寻找viewholder。</p>\n<p>缓存的顺序是</p>\n<ol>\n<li><p>状态为预加载时：</p>\n<p> getChangedScrapViewForPosition() -&gt; 从mChangedScrap中找</p>\n</li>\n<li><p>没找着或者压根没走预加载：</p>\n<p> getScrapOrHiddenOrCachedHolderForPosition() -&gt; </p>\n<pre><code>从mAttachedScrap中找layoutposition等于该position的\n-&gt;还没找着-&gt;从mCachedViews中寻找\n</code></pre></li>\n<li><p>还没找着：</p>\n<p> adapter里面有stable id：</p>\n<pre><code>getScrapOrCachedViewForId() -&gt; 从mAttachedScrap中找itemid等于id的\n</code></pre><p> 没找着或adapter里面没有stable id:</p>\n<pre><code>mViewCacheExtension.getViewForPositionAndType() -&gt; 在viewCacheExtension存在的前提下，从对用户扩展的viewCacheExtension中找\n</code></pre><p> 还没找着：</p>\n<pre><code>getRecycledViewPool().getRecycledView() -&gt; 从循环view池里面获取被循环的viewholder，这个循环view池默认也就存5个\n</code></pre><p> 再没找着：</p>\n<pre><code>mAdapter.createViewHolder() -&gt;创建一个viewholder\n</code></pre></li>\n</ol>\n<p>//吐槽一下：明明是一个问题，为什么if还不嵌套…</p>\n<p><img src=\"/images/android/recyclerview缓存模型.jpg\" alt=\"缓存的顺序图，copy自bugly\"></p>\n<h2 id=\"总结一下：三层缓存\"><a href=\"#总结一下：三层缓存\" class=\"headerlink\" title=\"总结一下：三层缓存\"></a>总结一下：三层缓存</h2><p>View的detach和remove: </p>\n<p><strong>detach</strong>: 在ViewGroup中的实现很简单，只是将ChildView<strong>从ParentView的ChildView数组中移除，ChildView的mParent设置为null, 可以理解为轻量级的临时remove, 因为View此时和View树还是藕断丝连, 这个函数被经常用来改变ChildView在ChildView数组中的次序。</strong>View被detach一般是临时的，在后面会被重新attach。</p>\n<p><strong>remove</strong>: 真正的移除，不光被从ChildView数组中除名，其他和View树各项联系也会被彻底斩断(不考虑Animation/LayoutTransition这种特殊情况)， 比如焦点被清除，从TouchTarget中被移除等。</p>\n<blockquote>\n<blockquote>\n<p>Scrap View指的是在RecyclerView中，处于根据数据刷新界面等行为, ChildView被detach(注意这个detach指的是1中介绍的detach行为，而不是RecyclerView一部分注释中的”detach”，RecyclerView一部分注释中的”detach”其实指得是上面的remove)，并且被存储到了Recycler中，这部分ChildView就是Scrap View。</p>\n</blockquote>\n</blockquote>\n<ol>\n<li>第一级缓存</li>\n</ol>\n<p>Scrap View: mAttachedScrap和mChangedScrap<br>Removeed View: mCachedViews</p>\n<ol start=\"2\">\n<li>第二级缓存</li>\n</ol>\n<p>ViewCacheExtension(可选可配置)： 供使用者自行扩展，让使用者可以控制缓存</p>\n<ol start=\"3\">\n<li>第三级缓存</li>\n</ol>\n<p>RecycledViewPool(可配置): RecyclerView之间共享ViewHolder的缓存池</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"绘制过程\"><a href=\"#绘制过程\" class=\"headerlink\" title=\"绘制过程\"></a>绘制过程</h1><p>绘制过程需要理解的是如何一个itemview一个itemview的绘制</p>\n<h2 id=\"onMeasure\"><a href=\"#onMeasure\" class=\"headerlink\" title=\"onMeasure\"></a>onMeasure</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void onMeasure(int widthSpec, int heightSpec) &#123;</span><br><span class=\"line\">        if (mLayout == null) &#123;</span><br><span class=\"line\">            //layoutManager没有设置的话，直接走default的方法，所以会为空白</span><br><span class=\"line\">            defaultOnMeasure(widthSpec, heightSpec);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (mLayout.mAutoMeasure) &#123;</span><br><span class=\"line\">            final boolean skipMeasure = widthMode == MeasureSpec.EXACTLY</span><br><span class=\"line\">                    &amp;&amp; heightMode == MeasureSpec.EXACTLY;</span><br><span class=\"line\">            //如果测量是绝对值，则跳过measure过程直接走layout</span><br><span class=\"line\">            if (skipMeasure || mAdapter == null) &#123;</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class=\"line\">                //mLayoutStep默认值是 State.STEP_START</span><br><span class=\"line\">                dispatchLayoutStep1();</span><br><span class=\"line\">                //执行完dispatchLayoutStep1()后是State.STEP_LAYOUT</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">             ..........</span><br><span class=\"line\">            //真正执行LayoutManager绘制的地方</span><br><span class=\"line\">            dispatchLayoutStep2();</span><br><span class=\"line\">            //执行完后是State.STEP_ANIMATIONS</span><br><span class=\"line\">             ..........</span><br><span class=\"line\">            //宽高都不确定的时候，会绘制两次</span><br><span class=\"line\">            // if RecyclerView has non-exact width and height and if there is at least one child</span><br><span class=\"line\">            // which also has non-exact width &amp; height, we have to re-measure.</span><br><span class=\"line\">            if (mLayout.shouldMeasureTwice()) &#123;</span><br><span class=\"line\">             ..........</span><br><span class=\"line\">                dispatchLayoutStep2();</span><br><span class=\"line\">             ..........            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (mHasFixedSize) &#123;</span><br><span class=\"line\">                mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">             ..........</span><br><span class=\"line\">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class=\"line\">             ..........</span><br><span class=\"line\">            mState.mInPreLayout = false; // clear</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">--------------------- </span><br><span class=\"line\">别人概括的measure过程</span><br></pre></td></tr></table></figure>\n<p>从这里大概分为三步，毕竟三个else</p>\n<h3 id=\"layout-null\"><a href=\"#layout-null\" class=\"headerlink\" title=\"layout == null\"></a>layout == null</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void defaultOnMeasure(int widthSpec, int heightSpec) &#123;</span><br><span class=\"line\">        // calling LayoutManager here is not pretty but that API is already public and it is better</span><br><span class=\"line\">        // than creating another method since this is internal.</span><br><span class=\"line\">        final int width = LayoutManager.chooseSize(widthSpec,</span><br><span class=\"line\">                getPaddingLeft() + getPaddingRight(),</span><br><span class=\"line\">                ViewCompat.getMinimumWidth(this));</span><br><span class=\"line\">        final int height = LayoutManager.chooseSize(heightSpec,</span><br><span class=\"line\">                getPaddingTop() + getPaddingBottom(),</span><br><span class=\"line\">                ViewCompat.getMinimumHeight(this));</span><br><span class=\"line\">        setMeasuredDimension(width, height);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int chooseSize(int spec, int desired, int min) &#123;</span><br><span class=\"line\">            int mode = MeasureSpec.getMode(spec);</span><br><span class=\"line\">            int size = MeasureSpec.getSize(spec);</span><br><span class=\"line\">            switch(mode) &#123;</span><br><span class=\"line\">            case -2147483648:</span><br><span class=\"line\">                return Math.min(size, Math.max(desired, min));</span><br><span class=\"line\">            case 0:</span><br><span class=\"line\">            default:</span><br><span class=\"line\">                return Math.max(desired, min);</span><br><span class=\"line\">            case 1073741824:</span><br><span class=\"line\">                return size;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>默认情况下面其实是处理了一下高度的问题，如果有padding的话，会将padding归入计算</p>\n<h3 id=\"mlayout-null-amp-amp-mLayout-isAutoMeasureEnabled\"><a href=\"#mlayout-null-amp-amp-mLayout-isAutoMeasureEnabled\" class=\"headerlink\" title=\"mlayout != null &amp;&amp;  mLayout.isAutoMeasureEnabled()\"></a>mlayout != null &amp;&amp;  mLayout.isAutoMeasureEnabled()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean isAutoMeasureEnabled() &#123;</span><br><span class=\"line\">            return mAutoMeasure;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">         * Defines whether the measuring pass of layout should use the AutoMeasure mechanism of</span><br><span class=\"line\">         * &#123;@link RecyclerView&#125; or if it should be done by the LayoutManager&apos;s implementation of</span><br><span class=\"line\">         * &#123;@link LayoutManager#onMeasure(Recycler, State, int, int)&#125;.</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * @param enabled &lt;code&gt;True&lt;/code&gt; if layout measurement should be done by the</span><br><span class=\"line\">         *                RecyclerView, &lt;code&gt;false&lt;/code&gt; if it should be done by this</span><br><span class=\"line\">         *                LayoutManager.</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * @see #isAutoMeasureEnabled()</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * @deprecated Implementors of LayoutManager should define whether or not it uses</span><br><span class=\"line\">         *             AutoMeasure by overriding &#123;@link #isAutoMeasureEnabled()&#125;.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        @Deprecated</span><br><span class=\"line\">        public void setAutoMeasureEnabled(boolean enabled) &#123;</span><br><span class=\"line\">            mAutoMeasure = enabled;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>这个api是deprecate的，其功能主要是设置自动测量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (mLayout.mAutoMeasure) &#123;</span><br><span class=\"line\">            final int widthMode = MeasureSpec.getMode(widthSpec);</span><br><span class=\"line\">            final int heightMode = MeasureSpec.getMode(heightSpec);</span><br><span class=\"line\">            final boolean skipMeasure = widthMode == MeasureSpec.EXACTLY</span><br><span class=\"line\">                    &amp;&amp; heightMode == MeasureSpec.EXACTLY;</span><br><span class=\"line\">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class=\"line\">            if (skipMeasure || mAdapter == null) &#123;</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class=\"line\">                dispatchLayoutStep1();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // set dimensions in 2nd step. Pre-layout should happen with old dimensions for</span><br><span class=\"line\">            // consistency</span><br><span class=\"line\">            mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class=\"line\">            mState.mIsMeasuring = true;</span><br><span class=\"line\">            dispatchLayoutStep2();</span><br><span class=\"line\"></span><br><span class=\"line\">            // now we can get the width and height from the children.</span><br><span class=\"line\">            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">            // if RecyclerView has non-exact width and height and if there is at least one child</span><br><span class=\"line\">            // which also has non-exact width &amp; height, we have to re-measure.</span><br><span class=\"line\">            if (mLayout.shouldMeasureTwice()) &#123;</span><br><span class=\"line\">                mLayout.setMeasureSpecs(</span><br><span class=\"line\">                        MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),</span><br><span class=\"line\">                        MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));</span><br><span class=\"line\">                mState.mIsMeasuring = true;</span><br><span class=\"line\">                dispatchLayoutStep2();</span><br><span class=\"line\">                // now we can get the width and height from the children.</span><br><span class=\"line\">                mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>如果测量是绝对值，则不再进行measure而直接layout，毕竟EXACTLY是写死了面积了，recyclerview的父类会直接获取面积来摆放</p>\n</li>\n<li><p>STATE变量为start时</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final int STEP_START = 1;</span><br><span class=\"line\">static final int STEP_LAYOUT = 1 &lt;&lt; 1;</span><br><span class=\"line\">static final int STEP_ANIMATIONS = 1 &lt;&lt; 2;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * The first step of a layout where we;</span><br><span class=\"line\">     * - process adapter updates</span><br><span class=\"line\">     * - decide which animation should run</span><br><span class=\"line\">     * - save information about current views</span><br><span class=\"line\">     * - If necessary, run predictive layout and save its information</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void dispatchLayoutStep1() &#123;</span><br><span class=\"line\">        mState.assertLayoutStep(State.STEP_START);</span><br><span class=\"line\">        fillRemainingScrollValues(mState);</span><br><span class=\"line\">        mState.mIsMeasuring = false;</span><br><span class=\"line\">        startInterceptRequestLayout();</span><br><span class=\"line\">        mViewInfoStore.clear();</span><br><span class=\"line\">        onEnterLayoutOrScroll();</span><br><span class=\"line\">        processAdapterUpdatesAndSetAnimationFlags();</span><br><span class=\"line\">        saveFocusInfo();</span><br><span class=\"line\">        mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations &amp;&amp; mItemsChanged;</span><br><span class=\"line\">        mItemsAddedOrRemoved = mItemsChanged = false;</span><br><span class=\"line\">        mState.mInPreLayout = mState.mRunPredictiveAnimations;</span><br><span class=\"line\">        mState.mItemCount = mAdapter.getItemCount();</span><br><span class=\"line\">        findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (mState.mRunSimpleAnimations) &#123;</span><br><span class=\"line\">            // Step 0: Find out where all non-removed items are, pre-layout</span><br><span class=\"line\">            int count = mChildHelper.getChildCount();</span><br><span class=\"line\">            for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class=\"line\">                final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class=\"line\">                if (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) &#123;</span><br><span class=\"line\">                    continue;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                final ItemHolderInfo animationInfo = mItemAnimator</span><br><span class=\"line\">                        .recordPreLayoutInformation(mState, holder,</span><br><span class=\"line\">                                ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),</span><br><span class=\"line\">                                holder.getUnmodifiedPayloads());</span><br><span class=\"line\">                mViewInfoStore.addToPreLayout(holder, animationInfo);</span><br><span class=\"line\">                if (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved()</span><br><span class=\"line\">                        &amp;&amp; !holder.shouldIgnore() &amp;&amp; !holder.isInvalid()) &#123;</span><br><span class=\"line\">                    long key = getChangedHolderKey(holder);</span><br><span class=\"line\">                    // This is NOT the only place where a ViewHolder is added to old change holders</span><br><span class=\"line\">                    // list. There is another case where:</span><br><span class=\"line\">                    //    * A VH is currently hidden but not deleted</span><br><span class=\"line\">                    //    * The hidden item is changed in the adapter</span><br><span class=\"line\">                    //    * Layout manager decides to layout the item in the pre-Layout pass (step1)</span><br><span class=\"line\">                    // When this case is detected, RV will un-hide that view and add to the old</span><br><span class=\"line\">                    // change holders list.</span><br><span class=\"line\">                    mViewInfoStore.addToOldChangeHolders(key, holder);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (mState.mRunPredictiveAnimations) &#123;</span><br><span class=\"line\">            // Step 1: run prelayout: This will use the old positions of items. The layout manager</span><br><span class=\"line\">            // is expected to layout everything, even removed items (though not to add removed</span><br><span class=\"line\">            // items back to the container). This gives the pre-layout position of APPEARING views</span><br><span class=\"line\">            // which come into existence as part of the real layout.</span><br><span class=\"line\"></span><br><span class=\"line\">            // Save old positions so that LayoutManager can run its mapping logic.</span><br><span class=\"line\">            saveOldPositions();</span><br><span class=\"line\">            final boolean didStructureChange = mState.mStructureChanged;</span><br><span class=\"line\">            mState.mStructureChanged = false;</span><br><span class=\"line\">            // temporarily disable flag because we are asking for previous layout</span><br><span class=\"line\">            mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class=\"line\">            mState.mStructureChanged = didStructureChange;</span><br><span class=\"line\"></span><br><span class=\"line\">            for (int i = 0; i &lt; mChildHelper.getChildCount(); ++i) &#123;</span><br><span class=\"line\">                final View child = mChildHelper.getChildAt(i);</span><br><span class=\"line\">                final ViewHolder viewHolder = getChildViewHolderInt(child);</span><br><span class=\"line\">                if (viewHolder.shouldIgnore()) &#123;</span><br><span class=\"line\">                    continue;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (!mViewInfoStore.isInPreLayout(viewHolder)) &#123;</span><br><span class=\"line\">                    int flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder);</span><br><span class=\"line\">                    boolean wasHidden = viewHolder</span><br><span class=\"line\">                            .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</span><br><span class=\"line\">                    if (!wasHidden) &#123;</span><br><span class=\"line\">                        flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(</span><br><span class=\"line\">                            mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads());</span><br><span class=\"line\">                    if (wasHidden) &#123;</span><br><span class=\"line\">                        recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo);</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // we don&apos;t process disappearing list because they may re-appear in post layout pass.</span><br><span class=\"line\">            clearOldPositions();</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            clearOldPositions();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        onExitLayoutOrScroll();</span><br><span class=\"line\">        stopInterceptRequestLayout(false);</span><br><span class=\"line\">        mState.mLayoutStep = State.STEP_LAYOUT;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>从备注的内容中可以知道，这个步骤有四个功能</p>\n<ul>\n<li>处理adapter的更新</li>\n<li>决定哪些动画需要执行</li>\n<li>保存当前view的信息</li>\n<li>如果必要的情况下，执行上一个layout的操作并且保存他的信息</li>\n</ul>\n<p>该步骤只是做了准备工作</p>\n<ol start=\"3\">\n<li>state不为start时</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">    * The second layout step where we do the actual layout of the views for the final state.</span><br><span class=\"line\">    * This step might be run multiple times if necessary (e.g. measure).</span><br><span class=\"line\">    */</span><br><span class=\"line\">   private void dispatchLayoutStep2() &#123;</span><br><span class=\"line\">       startInterceptRequestLayout();</span><br><span class=\"line\">       onEnterLayoutOrScroll();</span><br><span class=\"line\">       mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);</span><br><span class=\"line\">       mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class=\"line\">       mState.mItemCount = mAdapter.getItemCount();</span><br><span class=\"line\">       mState.mDeletedInvisibleItemCountSincePreviousLayout = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">       // Step 2: Run layout</span><br><span class=\"line\">       mState.mInPreLayout = false;</span><br><span class=\"line\">       mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class=\"line\"></span><br><span class=\"line\">       mState.mStructureChanged = false;</span><br><span class=\"line\">       mPendingSavedState = null;</span><br><span class=\"line\"></span><br><span class=\"line\">       // onLayoutChildren may have caused client code to disable item animations; re-check</span><br><span class=\"line\">       mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != null;</span><br><span class=\"line\">       mState.mLayoutStep = State.STEP_ANIMATIONS;</span><br><span class=\"line\">       onExitLayoutOrScroll();</span><br><span class=\"line\">       stopInterceptRequestLayout(false);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>这里的分析需要细致一些，着重点在mLayout.onLayoutChildren()内，绘制的工作交给了layoutmanager</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</span><br><span class=\"line\">        // layout algorithm:</span><br><span class=\"line\">        //找寻锚点</span><br><span class=\"line\">        // 1) by checking children and other variables, find an anchor coordinate and an anchor</span><br><span class=\"line\">        // item position.</span><br><span class=\"line\">        //两个方向填充，从锚点往上，从锚点往下</span><br><span class=\"line\">        // 2) fill towards start, stacking from bottom</span><br><span class=\"line\">        // 3) fill towards end, stacking from top</span><br><span class=\"line\">        // 4) scroll to fulfill requirements like stack from bottom.</span><br><span class=\"line\">        // create layout state</span><br><span class=\"line\">        ....</span><br><span class=\"line\">        // resolve layout direction</span><br><span class=\"line\">        //判断绘制方向,给mShouldReverseLayout赋值,默认是正向绘制，则mShouldReverseLayout是false</span><br><span class=\"line\">        resolveShouldLayoutReverse();</span><br><span class=\"line\">        final View focused = getFocusedChild();</span><br><span class=\"line\">        //mValid的默认值是false，一次测量之后设为true，onLayout完成后会回调执行reset方法，又变为false</span><br><span class=\"line\">        if (!mAnchorInfo.mValid || mPendingScrollPosition != NO_POSITION</span><br><span class=\"line\">                || mPendingSavedState != null) &#123;</span><br><span class=\"line\">        ....</span><br><span class=\"line\">            //mStackFromEnd默认是false，除非手动调用setStackFromEnd()方法，两个都会false，异或则为false</span><br><span class=\"line\">            mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;</span><br><span class=\"line\">            // calculate anchor position and coordinate</span><br><span class=\"line\">            //计算锚点的位置和偏移量</span><br><span class=\"line\">            updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</span><br><span class=\"line\">        ....</span><br><span class=\"line\">        &#125; else if (focused != null &amp;&amp; (mOrientationHelper.getDecoratedStart(focused)</span><br><span class=\"line\">                &gt;= mOrientationHelper.getEndAfterPadding()</span><br><span class=\"line\">                || mOrientationHelper.getDecoratedEnd(focused)</span><br><span class=\"line\">                &lt;= mOrientationHelper.getStartAfterPadding())) &#123;</span><br><span class=\"line\">         ....</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         ....</span><br><span class=\"line\">        //mLayoutFromEnd为false</span><br><span class=\"line\">        if (mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class=\"line\">            //倒着绘制的话，先往上绘制，再往下绘制</span><br><span class=\"line\">            // fill towards start</span><br><span class=\"line\">            // 从锚点到往上</span><br><span class=\"line\">            updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class=\"line\">            ....</span><br><span class=\"line\">            fill(recycler, mLayoutState, state, false);</span><br><span class=\"line\">            ....</span><br><span class=\"line\">            // 从锚点到往下</span><br><span class=\"line\">            // fill towards end</span><br><span class=\"line\">            updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class=\"line\">            ....</span><br><span class=\"line\">            //调两遍fill方法</span><br><span class=\"line\">            fill(recycler, mLayoutState, state, false);</span><br><span class=\"line\">            ....</span><br><span class=\"line\">            if (mLayoutState.mAvailable &gt; 0) &#123;</span><br><span class=\"line\">                // end could not consume all. add more items towards start</span><br><span class=\"line\">            ....</span><br><span class=\"line\">                updateLayoutStateToFillStart(firstElement, startOffset);</span><br><span class=\"line\">                mLayoutState.mExtra = extraForStart;</span><br><span class=\"line\">                fill(recycler, mLayoutState, state, false);</span><br><span class=\"line\">             ....</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            //正常绘制流程的话，先往下绘制，再往上绘制</span><br><span class=\"line\">            // fill towards end</span><br><span class=\"line\">            updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class=\"line\">            ....</span><br><span class=\"line\">            fill(recycler, mLayoutState, state, false);</span><br><span class=\"line\">             ....</span><br><span class=\"line\">            // fill towards start</span><br><span class=\"line\">            updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class=\"line\">            ....</span><br><span class=\"line\">            fill(recycler, mLayoutState, state, false);</span><br><span class=\"line\">             ....</span><br><span class=\"line\">            if (mLayoutState.mAvailable &gt; 0) &#123;</span><br><span class=\"line\">                ....</span><br><span class=\"line\">                // start could not consume all it should. add more items towards end</span><br><span class=\"line\">                updateLayoutStateToFillEnd(lastElement, endOffset);</span><br><span class=\"line\">                 ....</span><br><span class=\"line\">                fill(recycler, mLayoutState, state, false);</span><br><span class=\"line\">                ....</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ....</span><br><span class=\"line\">        layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);</span><br><span class=\"line\">        //完成后重置参数</span><br><span class=\"line\">        if (!state.isPreLayout()) &#123;</span><br><span class=\"line\">            mOrientationHelper.onLayoutComplete();</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            mAnchorInfo.reset();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mLastStackFromEnd = mStackFromEnd;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>摘抄了别人分析的内容，很明显，这是linearlayoutmanager一个完整的layout的过程，说实话真的很复杂。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">先寻找页面当前的锚点 </span><br><span class=\"line\">以这个锚点未基准，向上和向下分别填充 </span><br><span class=\"line\">填充完后，如果还有剩余的可填充大小，再填充一次</span><br></pre></td></tr></table></figure>\n<p>从这个角度来讲，可以大致理解为绘制的顺序，是首先绘制可见区域及以下的内容，而后绘制可见区域以上的内容，这个上下会依据重心来变化</p>\n<p>以前listview的绘制，大概也是差不多的，不过listview有个细节，是不设定数量的情况下，只绘制可见区域及上下加起来7个大小。分析recyclerview的源码发现，其绘制的区域仅仅是可见区域，如果需要预先绘制的话，需要自己制定预先加载的数量，其中的差别体现的还是比较明显的，因为layoutmanager需要考虑绘制的时候的动画。</p>\n<h3 id=\"最后一步\"><a href=\"#最后一步\" class=\"headerlink\" title=\"最后一步\"></a>最后一步</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    if (mHasFixedSize) &#123;</span><br><span class=\"line\">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // custom onMeasure</span><br><span class=\"line\">    if (mAdapterUpdateDuringMeasure) &#123;</span><br><span class=\"line\">        startInterceptRequestLayout();</span><br><span class=\"line\">        onEnterLayoutOrScroll();</span><br><span class=\"line\">        processAdapterUpdatesAndSetAnimationFlags();</span><br><span class=\"line\">        onExitLayoutOrScroll();</span><br><span class=\"line\"></span><br><span class=\"line\">        if (mState.mRunPredictiveAnimations) &#123;</span><br><span class=\"line\">            mState.mInPreLayout = true;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // consume remaining updates to provide a consistent state with the layout pass.</span><br><span class=\"line\">            mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class=\"line\">            mState.mInPreLayout = false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mAdapterUpdateDuringMeasure = false;</span><br><span class=\"line\">        stopInterceptRequestLayout(false);</span><br><span class=\"line\">    &#125; else if (mState.mRunPredictiveAnimations) &#123;</span><br><span class=\"line\">        // If mAdapterUpdateDuringMeasure is false and mRunPredictiveAnimations is true:</span><br><span class=\"line\">        // this means there is already an onMeasure() call performed to handle the pending</span><br><span class=\"line\">        // adapter change, two onMeasure() calls can happen if RV is a child of LinearLayout</span><br><span class=\"line\">        // with layout_width=MATCH_PARENT. RV cannot call LM.onMeasure() second time</span><br><span class=\"line\">        // because getViewForPosition() will crash when LM uses a child to measure.</span><br><span class=\"line\">        setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight());</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (mAdapter != null) &#123;</span><br><span class=\"line\">        mState.mItemCount = mAdapter.getItemCount();</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        mState.mItemCount = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    startInterceptRequestLayout();</span><br><span class=\"line\">    mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class=\"line\">    stopInterceptRequestLayout(false);</span><br><span class=\"line\">    mState.mInPreLayout = false; // clear</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这一步是当recyclerview没有设置<strong>mLayout.isAutoMeasureEnabled()</strong>的时候出现的，默认情况下走的就是这一步。</p>\n<p>这一步的含义是将绘制权直接交于layoutmanager来绘制，有个细节，就是如果期望绘制的过程由recyclerview内部来进行的话，就不要再重写layoutmanager的onmeasure了。不过对于我们这种大多数时候直接调用linearlayoutmanager的，平时不会太注意这个。</p>\n<p>回到这一步上来，大概做了这样几件事</p>\n<ol>\n<li>当设置了hasfixedsize时</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * RecyclerView can perform several optimizations if it can know in advance that RecyclerView&apos;s</span><br><span class=\"line\">     * size is not affected by the adapter contents. RecyclerView can still change its size based</span><br><span class=\"line\">     * on other factors (e.g. its parent&apos;s size) but this size calculation cannot depend on the</span><br><span class=\"line\">     * size of its children or contents of its adapter (except the number of items in the adapter).</span><br><span class=\"line\">     * &lt;p&gt;</span><br><span class=\"line\">     * If your use of RecyclerView falls into this category, set this to &#123;@code true&#125;. It will allow</span><br><span class=\"line\">     * RecyclerView to avoid invalidating the whole layout when its adapter contents change.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param hasFixedSize true if adapter changes cannot affect the size of the RecyclerView.</span><br><span class=\"line\">     */</span><br></pre></td></tr></table></figure>\n<p>也就是当item的大小是固定的，不会出现根据adapter的内容变化的布局，这样recyclerview就会依据某些参数固定下来他的尺寸，并不会在参考其内部数据变化而计算出来的尺寸。算是<strong>优化</strong>的一个注意点</p>\n<p>设置了这个参数之后，就会直接甩手给layoutmanager进行onmeasure操作</p>\n<ol start=\"2\">\n<li>未设置hasfixedsize时 &amp;&amp; adapter在onmeasure过程中正在更新</li>\n</ol>\n<p>此时只会做一些状态的更改，lock的重入这样。其lock的标记位实在是太多了，不过的确没有做什么事情，不过此过程如果进行，会跳转到第四步继续下去</p>\n<ol start=\"3\">\n<li>未设置hasfixedsize时 &amp;&amp; adapter 不在更新 &amp;&amp; 目前的状态处在更新之前的动画时</li>\n</ol>\n<p>此时会在更新完前一个item动画之后在更新自己，所以此时只做了一个动作，就是提前将宽高的measurespec设置完毕</p>\n<ol start=\"4\">\n<li>以上都没有的情况下</li>\n</ol>\n<p>首先会调用layoutmanager的onmeasure，之后会清除状态位。</p>\n<h4 id=\"最后一步的一个总结\"><a href=\"#最后一步的一个总结\" class=\"headerlink\" title=\"最后一步的一个总结\"></a>最后一步的一个总结</h4><p>为什么hasfixedsize起作用呢？</p>\n<p>因为当未设置这个的时候，会等待adapter更新结束才会绘制，而adapter的更新会有一系列的等待，等待数据处理结束之后，才会再次做一个更新的操作。<br>而设置了hasfixedsize之后，就不会等待更新了，而是会直接进行绘制。</p>\n<p>另外拷一份关于这个的别人的总结</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">总结：当我们确定Item的改变不会影响RecyclerView的宽高的时候可以设置setHasFixedSize(true)，并通过Adapter的增删改插方法去刷新RecyclerView，而不是通过notifyDataSetChanged()。（其实可以直接设置为true，当需要改变宽高的时候就用notifyDataSetChanged()去整体刷新一下）</span><br><span class=\"line\">--------------------- </span><br><span class=\"line\">作者：wsdaijianjun </span><br><span class=\"line\">来源：CSDN </span><br><span class=\"line\">原文：https://blog.csdn.net/wsdaijianjun/article/details/74735039 </span><br><span class=\"line\">版权声明：本文为博主原创文章，转载请附上博文链接！</span><br></pre></td></tr></table></figure>\n<h2 id=\"onLayout\"><a href=\"#onLayout\" class=\"headerlink\" title=\"onLayout\"></a>onLayout</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    dispatchLayout();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * Wrapper around layoutChildren() that handles animating changes caused by layout.</span><br><span class=\"line\">     * Animations work on the assumption that there are five different kinds of items</span><br><span class=\"line\">     * in play:</span><br><span class=\"line\">     * PERSISTENT: items are visible before and after layout</span><br><span class=\"line\">     * REMOVED: items were visible before layout and were removed by the app</span><br><span class=\"line\">     * ADDED: items did not exist before layout and were added by the app</span><br><span class=\"line\">     * DISAPPEARING: items exist in the data set before/after, but changed from</span><br><span class=\"line\">     * visible to non-visible in the process of layout (they were moved off</span><br><span class=\"line\">     * screen as a side-effect of other changes)</span><br><span class=\"line\">     * APPEARING: items exist in the data set before/after, but changed from</span><br><span class=\"line\">     * non-visible to visible in the process of layout (they were moved on</span><br><span class=\"line\">     * screen as a side-effect of other changes)</span><br><span class=\"line\">     * The overall approach figures out what items exist before/after layout and</span><br><span class=\"line\">     * infers one of the five above states for each of the items. Then the animations</span><br><span class=\"line\">     * are set up accordingly:</span><br><span class=\"line\">     * PERSISTENT views are animated via</span><br><span class=\"line\">     * &#123;@link ItemAnimator#animatePersistence(ViewHolder, ItemHolderInfo, ItemHolderInfo)&#125;</span><br><span class=\"line\">     * DISAPPEARING views are animated via</span><br><span class=\"line\">     * &#123;@link ItemAnimator#animateDisappearance(ViewHolder, ItemHolderInfo, ItemHolderInfo)&#125;</span><br><span class=\"line\">     * APPEARING views are animated via</span><br><span class=\"line\">     * &#123;@link ItemAnimator#animateAppearance(ViewHolder, ItemHolderInfo, ItemHolderInfo)&#125;</span><br><span class=\"line\">     * and changed views are animated via</span><br><span class=\"line\">     * &#123;@link ItemAnimator#animateChange(ViewHolder, ViewHolder, ItemHolderInfo, ItemHolderInfo)&#125;.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void dispatchLayout() &#123;</span><br><span class=\"line\">        if (mAdapter == null) &#123;</span><br><span class=\"line\">            Log.e(TAG, &quot;No adapter attached; skipping layout&quot;);</span><br><span class=\"line\">            // leave the state in START</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (mLayout == null) &#123;</span><br><span class=\"line\">            Log.e(TAG, &quot;No layout manager attached; skipping layout&quot;);</span><br><span class=\"line\">            // leave the state in START</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mState.mIsMeasuring = false;</span><br><span class=\"line\">        if (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class=\"line\">            dispatchLayoutStep1();</span><br><span class=\"line\">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class=\"line\">            dispatchLayoutStep2();</span><br><span class=\"line\">        &#125; else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()</span><br><span class=\"line\">                || mLayout.getHeight() != getHeight()) &#123;</span><br><span class=\"line\">            // First 2 steps are done in onMeasure but looks like we have to run again due to</span><br><span class=\"line\">            // changed size.</span><br><span class=\"line\">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class=\"line\">            dispatchLayoutStep2();</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // always make sure we sync them (to ensure mode is exact)</span><br><span class=\"line\">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dispatchLayoutStep3();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>onlayout的过程相对比较简单，即是直接通过state的状态，来设置目前需要走到哪一步。其中dispatchlayoutstep1和dispatchlayoutstep2都是onmeasure过程中使用到的。</p>\n<p>唯一不知道的是dispatchlayoutstep3</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">    * The final step of the layout where we save the information about views for animations,</span><br><span class=\"line\">    * trigger animations and do any necessary cleanup.</span><br><span class=\"line\">    */</span><br><span class=\"line\">   private void dispatchLayoutStep3() &#123;</span><br><span class=\"line\">       mState.assertLayoutStep(State.STEP_ANIMATIONS);</span><br><span class=\"line\">       eatRequestLayout();</span><br><span class=\"line\">       onEnterLayoutOrScroll();</span><br><span class=\"line\">       mState.mLayoutStep = State.STEP_START;</span><br><span class=\"line\">       if (mState.mRunSimpleAnimations) &#123;</span><br><span class=\"line\">           // Step 3: Find out where things are now, and process change animations.</span><br><span class=\"line\">           // traverse list in reverse because we may call animateChange in the loop which may</span><br><span class=\"line\">           // remove the target view holder.</span><br><span class=\"line\">           for (int i = mChildHelper.getChildCount() - 1; i &gt;= 0; i--) &#123;</span><br><span class=\"line\">               ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class=\"line\">               if (holder.shouldIgnore()) &#123;</span><br><span class=\"line\">                   continue;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               long key = getChangedHolderKey(holder);</span><br><span class=\"line\">               final ItemHolderInfo animationInfo = mItemAnimator</span><br><span class=\"line\">                       .recordPostLayoutInformation(mState, holder);</span><br><span class=\"line\">               ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key);</span><br><span class=\"line\">               if (oldChangeViewHolder != null &amp;&amp; !oldChangeViewHolder.shouldIgnore()) &#123;</span><br><span class=\"line\">                   // run a change animation</span><br><span class=\"line\"></span><br><span class=\"line\">                   // If an Item is CHANGED but the updated version is disappearing, it creates</span><br><span class=\"line\">                   // a conflicting case.</span><br><span class=\"line\">                   // Since a view that is marked as disappearing is likely to be going out of</span><br><span class=\"line\">                   // bounds, we run a change animation. Both views will be cleaned automatically</span><br><span class=\"line\">                   // once their animations finish.</span><br><span class=\"line\">                   // On the other hand, if it is the same view holder instance, we run a</span><br><span class=\"line\">                   // disappearing animation instead because we are not going to rebind the updated</span><br><span class=\"line\">                   // VH unless it is enforced by the layout manager.</span><br><span class=\"line\">                   final boolean oldDisappearing = mViewInfoStore.isDisappearing(</span><br><span class=\"line\">                           oldChangeViewHolder);</span><br><span class=\"line\">                   final boolean newDisappearing = mViewInfoStore.isDisappearing(holder);</span><br><span class=\"line\">                   if (oldDisappearing &amp;&amp; oldChangeViewHolder == holder) &#123;</span><br><span class=\"line\">                       // run disappear animation instead of change</span><br><span class=\"line\">                       mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class=\"line\">                   &#125; else &#123;</span><br><span class=\"line\">                       final ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout(</span><br><span class=\"line\">                               oldChangeViewHolder);</span><br><span class=\"line\">                       // we add and remove so that any post info is merged.</span><br><span class=\"line\">                       mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class=\"line\">                       ItemHolderInfo postInfo = mViewInfoStore.popFromPostLayout(holder);</span><br><span class=\"line\">                       if (preInfo == null) &#123;</span><br><span class=\"line\">                           handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder);</span><br><span class=\"line\">                       &#125; else &#123;</span><br><span class=\"line\">                           animateChange(oldChangeViewHolder, holder, preInfo, postInfo,</span><br><span class=\"line\">                                   oldDisappearing, newDisappearing);</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125; else &#123;</span><br><span class=\"line\">                   mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           // Step 4: Process view info lists and trigger animations</span><br><span class=\"line\">           mViewInfoStore.process(mViewInfoProcessCallback);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       mLayout.removeAndRecycleScrapInt(mRecycler);</span><br><span class=\"line\">       mState.mPreviousLayoutItemCount = mState.mItemCount;</span><br><span class=\"line\">       mDataSetHasChangedAfterLayout = false;</span><br><span class=\"line\">       mState.mRunSimpleAnimations = false;</span><br><span class=\"line\"></span><br><span class=\"line\">       mState.mRunPredictiveAnimations = false;</span><br><span class=\"line\">       mLayout.mRequestedSimpleAnimations = false;</span><br><span class=\"line\">       if (mRecycler.mChangedScrap != null) &#123;</span><br><span class=\"line\">           mRecycler.mChangedScrap.clear();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       if (mLayout.mPrefetchMaxObservedInInitialPrefetch) &#123;</span><br><span class=\"line\">           // Initial prefetch has expanded cache, so reset until next prefetch.</span><br><span class=\"line\">           // This prevents initial prefetches from expanding the cache permanently.</span><br><span class=\"line\">           mLayout.mPrefetchMaxCountObserved = 0;</span><br><span class=\"line\">           mLayout.mPrefetchMaxObservedInInitialPrefetch = false;</span><br><span class=\"line\">           mRecycler.updateViewCacheSize();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       mLayout.onLayoutCompleted(mState);</span><br><span class=\"line\">       onExitLayoutOrScroll();</span><br><span class=\"line\">       resumeRequestLayout(false);</span><br><span class=\"line\">       mViewInfoStore.clear();</span><br><span class=\"line\">       if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) &#123;</span><br><span class=\"line\">           dispatchOnScrolled(0, 0);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       recoverFocusFromState();</span><br><span class=\"line\">       resetFocusInfo();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>这里看上去，能了解几个信息点，首先是处理了动画，在然后是reset了一些状态。这一步和布局没有什么必然的关系。</p>\n<h2 id=\"全布局总结\"><a href=\"#全布局总结\" class=\"headerlink\" title=\"全布局总结\"></a>全布局总结</h2><p>这里我就直接抄了，我的言语也最多总结成这样。</p>\n<p>第一步：<br>处理Adapter的更新<br>决定哪些动画播放<br>保存当前View的信息<br>如果有必要的话再进行上一布局操作，并保存它的信息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void dispatchLayoutStep1() &#123;</span><br><span class=\"line\">    …… // 省略代码，该部分判断状态和更改状态以及保存一些信息</span><br><span class=\"line\">    // 下面这个方法很重要，那么我们先略过，看下下面的内容。哎~我就这么调皮!哈哈，</span><br><span class=\"line\">    // 其实是，在没有讲动画流程之前，根本讲不清。这个是动画流程的中间过程。所以</span><br><span class=\"line\">    // ，在这里只要先知道，这里是处理Adapter更新，并计算动画类型的即可。</span><br><span class=\"line\">    processAdapterUpdatesAndSetAnimationFlags();</span><br><span class=\"line\">    …… // 设置一些状态，保存一些信息。</span><br><span class=\"line\"></span><br><span class=\"line\">    // 下面的内容是需要运行动画的情况下进行的，主要做的事情就是找出那些要需要进</span><br><span class=\"line\">    // 行上一布局操作的ViewHolder，并且保存它们的边界信息。如果有更新操作(这个更新</span><br><span class=\"line\">    // 指的是内容的更新，不是插入删除的这种更新)，然后保存这些更新的ViewHolder</span><br><span class=\"line\">    if (mState.mRunSimpleAnimations) &#123;</span><br><span class=\"line\">        …… // 看上面的解释，这里代码都是和动画相关的，暂时懒得放，太占地方</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 下面的内容是需要在布局结束之后运行动画的情况下执行的。主要做的事情就是</span><br><span class=\"line\">    // 执行上一布局操作，上一布局操作其实就是先以上一次的状态执行一边LayoutManager</span><br><span class=\"line\">    // 的onLayoutChildren方法，其实RecyclerView的布局策略就是在</span><br><span class=\"line\">    // LayoutManager的onLayoutChildren方法中。执行一次它就获得了所有</span><br><span class=\"line\">    // ViewHolder的边界信息。只不过，这次获得的是之前状态下的ViewHolder的</span><br><span class=\"line\">    // 边界信息。不过这个应该是要在LayoutManager中，根据state的isPreLayout</span><br><span class=\"line\">    // 的返回值，选择使用新的还是旧的position。但我在系统给的几个LayoutManager中</span><br><span class=\"line\">    // 都没有看到。</span><br><span class=\"line\">    if (mState.mRunPredictiveAnimations) &#123;</span><br><span class=\"line\">        …… </span><br><span class=\"line\">        mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class=\"line\">        ……</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    …… //恢复状态</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第二步：真正的布局</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void dispatchLayoutStep2() &#123;</span><br><span class=\"line\">    …… // 设置状态</span><br><span class=\"line\">    mState.mInPreLayout = false; // 更改此状态，确保不是会执行上一布局操作</span><br><span class=\"line\">    // 真正布局就是这一句话，布局的具体策略交给了LayoutManager，哈哈!这篇的主角讲完了!</span><br><span class=\"line\">    mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class=\"line\">    …… // 设置和恢复状态</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第三步：</p>\n<p>保存信息，触发动画，清除垃圾<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void dispatchLayoutStep3() &#123;</span><br><span class=\"line\">    …… // 设置状态</span><br><span class=\"line\">    if (mState.mRunSimpleAnimations) &#123;</span><br><span class=\"line\">        …… // 需要动画的情况。找出ViewHolder现在的位置，并且处理改变动画。最后触发动画。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    …… // 清除状态和清除无用的信息</span><br><span class=\"line\">    mLayout.onLayoutCompleted(mState); // 给LayoutManager的布局完成的回调</span><br><span class=\"line\">    …… // 清除状体和清楚无用的信息，最后在恢复一些信息信息，比如焦点。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"缓存机制\"><a href=\"#缓存机制\" class=\"headerlink\" title=\"缓存机制\"></a>缓存机制</h1><p>recyclerview的缓存主要在view的复用</p>\n<p>其依赖于<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final View view = recycler.getViewForPosition(mCurrentPosition);</span><br></pre></td></tr></table></figure></p>\n<p>该方法获取了viewholder的itemview</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">         * Obtain a view initialized for the given position.</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * This method should be used by &#123;@link LayoutManager&#125; implementations to obtain</span><br><span class=\"line\">         * views to represent data from an &#123;@link Adapter&#125;.</span><br><span class=\"line\">         * &lt;p&gt;</span><br><span class=\"line\">         * The Recycler may reuse a scrap or detached view from a shared pool if one is</span><br><span class=\"line\">         * available for the correct view type. If the adapter has not indicated that the</span><br><span class=\"line\">         * data at the given position has changed, the Recycler will attempt to hand back</span><br><span class=\"line\">         * a scrap view that was previously initialized for that data without rebinding.</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * @param position Position to obtain a view for</span><br><span class=\"line\">         * @return A view representing the data at &lt;code&gt;position&lt;/code&gt; from &lt;code&gt;adapter&lt;/code&gt;</span><br><span class=\"line\">         */</span><br><span class=\"line\">        public View getViewForPosition(int position) &#123;</span><br><span class=\"line\">            return getViewForPosition(position, false);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        View getViewForPosition(int position, boolean dryRun) &#123;</span><br><span class=\"line\">            return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * Attempts to get the ViewHolder for the given position, either from the Recycler scrap,</span><br><span class=\"line\">         * cache, the RecycledViewPool, or creating it directly.</span><br><span class=\"line\">         * &lt;p&gt;</span><br><span class=\"line\">         * If a deadlineNs other than &#123;@link #FOREVER_NS&#125; is passed, this method early return</span><br><span class=\"line\">         * rather than constructing or binding a ViewHolder if it doesn&apos;t think it has time.</span><br><span class=\"line\">         * If a ViewHolder must be constructed and not enough time remains, null is returned. If a</span><br><span class=\"line\">         * ViewHolder is aquired and must be bound but not enough time remains, an unbound holder is</span><br><span class=\"line\">         * returned. Use &#123;@link ViewHolder#isBound()&#125; on the returned object to check for this.</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * @param position Position of ViewHolder to be returned.</span><br><span class=\"line\">         * @param dryRun True if the ViewHolder should not be removed from scrap/cache/</span><br><span class=\"line\">         * @param deadlineNs Time, relative to getNanoTime(), by which bind/create work should</span><br><span class=\"line\">         *                   complete. If FOREVER_NS is passed, this method will not fail to</span><br><span class=\"line\">         *                   create/bind the holder if needed.</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * @return ViewHolder for requested position</span><br><span class=\"line\">         */</span><br><span class=\"line\">        @Nullable</span><br><span class=\"line\">        ViewHolder tryGetViewHolderForPositionByDeadline(int position,</span><br><span class=\"line\">                boolean dryRun, long deadlineNs) &#123;</span><br><span class=\"line\">            if (position &lt; 0 || position &gt;= mState.getItemCount()) &#123;</span><br><span class=\"line\">                throw new IndexOutOfBoundsException(&quot;Invalid item position &quot; + position</span><br><span class=\"line\">                        + &quot;(&quot; + position + &quot;). Item count:&quot; + mState.getItemCount()</span><br><span class=\"line\">                        + exceptionLabel());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            boolean fromScrapOrHiddenOrCache = false;</span><br><span class=\"line\">            ViewHolder holder = null;</span><br><span class=\"line\">            // 0) If there is a changed scrap, try to find from there</span><br><span class=\"line\">            if (mState.isPreLayout()) &#123;</span><br><span class=\"line\">                holder = getChangedScrapViewForPosition(position);</span><br><span class=\"line\">                fromScrapOrHiddenOrCache = holder != null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 1) Find by position from scrap/hidden list/cache</span><br><span class=\"line\">            if (holder == null) &#123;</span><br><span class=\"line\">                holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</span><br><span class=\"line\">                if (holder != null) &#123;</span><br><span class=\"line\">                    if (!validateViewHolderForOffsetPosition(holder)) &#123;</span><br><span class=\"line\">                        // recycle holder (and unscrap if relevant) since it can&apos;t be used</span><br><span class=\"line\">                        if (!dryRun) &#123;</span><br><span class=\"line\">                            // we would like to recycle this but need to make sure it is not used by</span><br><span class=\"line\">                            // animation logic etc.</span><br><span class=\"line\">                            holder.addFlags(ViewHolder.FLAG_INVALID);</span><br><span class=\"line\">                            if (holder.isScrap()) &#123;</span><br><span class=\"line\">                                removeDetachedView(holder.itemView, false);</span><br><span class=\"line\">                                holder.unScrap();</span><br><span class=\"line\">                            &#125; else if (holder.wasReturnedFromScrap()) &#123;</span><br><span class=\"line\">                                holder.clearReturnedFromScrapFlag();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            recycleViewHolderInternal(holder);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        holder = null;</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        fromScrapOrHiddenOrCache = true;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (holder == null) &#123;</span><br><span class=\"line\">                final int offsetPosition = mAdapterHelper.findPositionOffset(position);</span><br><span class=\"line\">                if (offsetPosition &lt; 0 || offsetPosition &gt;= mAdapter.getItemCount()) &#123;</span><br><span class=\"line\">                    throw new IndexOutOfBoundsException(&quot;Inconsistency detected. Invalid item &quot;</span><br><span class=\"line\">                            + &quot;position &quot; + position + &quot;(offset:&quot; + offsetPosition + &quot;).&quot;</span><br><span class=\"line\">                            + &quot;state:&quot; + mState.getItemCount() + exceptionLabel());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                final int type = mAdapter.getItemViewType(offsetPosition);</span><br><span class=\"line\">                // 2) Find from scrap/cache via stable ids, if exists</span><br><span class=\"line\">                if (mAdapter.hasStableIds()) &#123;</span><br><span class=\"line\">                    holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</span><br><span class=\"line\">                            type, dryRun);</span><br><span class=\"line\">                    if (holder != null) &#123;</span><br><span class=\"line\">                        // update position</span><br><span class=\"line\">                        holder.mPosition = offsetPosition;</span><br><span class=\"line\">                        fromScrapOrHiddenOrCache = true;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (holder == null &amp;&amp; mViewCacheExtension != null) &#123;</span><br><span class=\"line\">                    // We are NOT sending the offsetPosition because LayoutManager does not</span><br><span class=\"line\">                    // know it.</span><br><span class=\"line\">                    final View view = mViewCacheExtension</span><br><span class=\"line\">                            .getViewForPositionAndType(this, position, type);</span><br><span class=\"line\">                    if (view != null) &#123;</span><br><span class=\"line\">                        holder = getChildViewHolder(view);</span><br><span class=\"line\">                        if (holder == null) &#123;</span><br><span class=\"line\">                            throw new IllegalArgumentException(&quot;getViewForPositionAndType returned&quot;</span><br><span class=\"line\">                                    + &quot; a view which does not have a ViewHolder&quot;</span><br><span class=\"line\">                                    + exceptionLabel());</span><br><span class=\"line\">                        &#125; else if (holder.shouldIgnore()) &#123;</span><br><span class=\"line\">                            throw new IllegalArgumentException(&quot;getViewForPositionAndType returned&quot;</span><br><span class=\"line\">                                    + &quot; a view that is ignored. You must call stopIgnoring before&quot;</span><br><span class=\"line\">                                    + &quot; returning this view.&quot; + exceptionLabel());</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (holder == null) &#123; // fallback to pool</span><br><span class=\"line\">                    if (DEBUG) &#123;</span><br><span class=\"line\">                        Log.d(TAG, &quot;tryGetViewHolderForPositionByDeadline(&quot;</span><br><span class=\"line\">                                + position + &quot;) fetching from shared pool&quot;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    holder = getRecycledViewPool().getRecycledView(type);</span><br><span class=\"line\">                    if (holder != null) &#123;</span><br><span class=\"line\">                        holder.resetInternal();</span><br><span class=\"line\">                        if (FORCE_INVALIDATE_DISPLAY_LIST) &#123;</span><br><span class=\"line\">                            invalidateDisplayListInt(holder);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (holder == null) &#123;</span><br><span class=\"line\">                    long start = getNanoTime();</span><br><span class=\"line\">                    if (deadlineNs != FOREVER_NS</span><br><span class=\"line\">                            &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123;</span><br><span class=\"line\">                        // abort - we have a deadline we can&apos;t meet</span><br><span class=\"line\">                        return null;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    holder = mAdapter.createViewHolder(RecyclerView.this, type);</span><br><span class=\"line\">                    if (ALLOW_THREAD_GAP_WORK) &#123;</span><br><span class=\"line\">                        // only bother finding nested RV if prefetching</span><br><span class=\"line\">                        RecyclerView innerView = findNestedRecyclerView(holder.itemView);</span><br><span class=\"line\">                        if (innerView != null) &#123;</span><br><span class=\"line\">                            holder.mNestedRecyclerView = new WeakReference&lt;&gt;(innerView);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    long end = getNanoTime();</span><br><span class=\"line\">                    mRecyclerPool.factorInCreateTime(type, end - start);</span><br><span class=\"line\">                    if (DEBUG) &#123;</span><br><span class=\"line\">                        Log.d(TAG, &quot;tryGetViewHolderForPositionByDeadline created new ViewHolder&quot;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码写的还是比较容易懂得，其实就是按照顺序去缓存里面寻找viewholder。</p>\n<p>缓存的顺序是</p>\n<ol>\n<li><p>状态为预加载时：</p>\n<p> getChangedScrapViewForPosition() -&gt; 从mChangedScrap中找</p>\n</li>\n<li><p>没找着或者压根没走预加载：</p>\n<p> getScrapOrHiddenOrCachedHolderForPosition() -&gt; </p>\n<pre><code>从mAttachedScrap中找layoutposition等于该position的\n-&gt;还没找着-&gt;从mCachedViews中寻找\n</code></pre></li>\n<li><p>还没找着：</p>\n<p> adapter里面有stable id：</p>\n<pre><code>getScrapOrCachedViewForId() -&gt; 从mAttachedScrap中找itemid等于id的\n</code></pre><p> 没找着或adapter里面没有stable id:</p>\n<pre><code>mViewCacheExtension.getViewForPositionAndType() -&gt; 在viewCacheExtension存在的前提下，从对用户扩展的viewCacheExtension中找\n</code></pre><p> 还没找着：</p>\n<pre><code>getRecycledViewPool().getRecycledView() -&gt; 从循环view池里面获取被循环的viewholder，这个循环view池默认也就存5个\n</code></pre><p> 再没找着：</p>\n<pre><code>mAdapter.createViewHolder() -&gt;创建一个viewholder\n</code></pre></li>\n</ol>\n<p>//吐槽一下：明明是一个问题，为什么if还不嵌套…</p>\n<p><img src=\"/images/android/recyclerview缓存模型.jpg\" alt=\"缓存的顺序图，copy自bugly\"></p>\n<h2 id=\"总结一下：三层缓存\"><a href=\"#总结一下：三层缓存\" class=\"headerlink\" title=\"总结一下：三层缓存\"></a>总结一下：三层缓存</h2><p>View的detach和remove: </p>\n<p><strong>detach</strong>: 在ViewGroup中的实现很简单，只是将ChildView<strong>从ParentView的ChildView数组中移除，ChildView的mParent设置为null, 可以理解为轻量级的临时remove, 因为View此时和View树还是藕断丝连, 这个函数被经常用来改变ChildView在ChildView数组中的次序。</strong>View被detach一般是临时的，在后面会被重新attach。</p>\n<p><strong>remove</strong>: 真正的移除，不光被从ChildView数组中除名，其他和View树各项联系也会被彻底斩断(不考虑Animation/LayoutTransition这种特殊情况)， 比如焦点被清除，从TouchTarget中被移除等。</p>\n<blockquote>\n<blockquote>\n<p>Scrap View指的是在RecyclerView中，处于根据数据刷新界面等行为, ChildView被detach(注意这个detach指的是1中介绍的detach行为，而不是RecyclerView一部分注释中的”detach”，RecyclerView一部分注释中的”detach”其实指得是上面的remove)，并且被存储到了Recycler中，这部分ChildView就是Scrap View。</p>\n</blockquote>\n</blockquote>\n<ol>\n<li>第一级缓存</li>\n</ol>\n<p>Scrap View: mAttachedScrap和mChangedScrap<br>Removeed View: mCachedViews</p>\n<ol start=\"2\">\n<li>第二级缓存</li>\n</ol>\n<p>ViewCacheExtension(可选可配置)： 供使用者自行扩展，让使用者可以控制缓存</p>\n<ol start=\"3\">\n<li>第三级缓存</li>\n</ol>\n<p>RecycledViewPool(可配置): RecyclerView之间共享ViewHolder的缓存池</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjt5lttwk00053a8kdpdryq0n","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttwn00083a8kx47jm4e4"},{"post_id":"cjt5lttwc00013a8ktue6u1ta","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttwo000a3a8kn8ntf7i8"},{"post_id":"cjt5lttwl00063a8ksss0i4cu","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttwq000d3a8k95s6balc"},{"post_id":"cjt5lttwn00093a8kat5f8ywe","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttwr000f3a8ku43489bv"},{"post_id":"cjt5lttwg00023a8kee0yl1e9","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttwt000h3a8k8j0xnva4"},{"post_id":"cjt5lttwo000b3a8kd50sdsww","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttwv000j3a8kk9g3yk6p"},{"post_id":"cjt5lttwq000e3a8k9krefnrp","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttww000l3a8kxrw6hxz2"},{"post_id":"cjt5lttwj00043a8kz2oxy5lr","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttwx000o3a8kjk7kehl8"},{"post_id":"cjt5lttwr000g3a8ka9rhxovg","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttwy000q3a8kdvkg0hgi"},{"post_id":"cjt5lttwt000i3a8k970ec0ck","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttwz000s3a8kpqxej2bi"},{"post_id":"cjt5lttww000m3a8kjc2n8yjf","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttx1000u3a8k4eg7cvk4"},{"post_id":"cjt5lttwx000p3a8kh84u9pyf","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttx2000w3a8k0k0ma7jd"},{"post_id":"cjt5lttwy000r3a8kxnjffj9k","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttx3000y3a8knz4zleww"},{"post_id":"cjt5lttwv000k3a8koau588cc","tag_id":"cjt5lttwx000n3a8ke820pdsw","_id":"cjt5lttx300103a8k4cnris22"},{"post_id":"cjt5lttx0000t3a8kwmnz325x","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttx400123a8kj2emic3h"},{"post_id":"cjt5lttx1000v3a8kar0v86co","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttx500143a8kedn8vm3t"},{"post_id":"cjt5lttx2000x3a8k9ol4exnc","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttx600163a8ko9afqiuj"},{"post_id":"cjt5lttx3000z3a8k2th4kmmc","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttx700183a8k4huq44e9"},{"post_id":"cjt5lttx300113a8kygdusa6e","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttx8001a3a8knoyn180c"},{"post_id":"cjt5lttx400133a8ktan7353x","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttx9001c3a8kzymdzknh"},{"post_id":"cjt5lttx500153a8kpcfvr0jv","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttxa001e3a8ko04eqgtq"},{"post_id":"cjt5lttx600173a8k1136oqli","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttxb001g3a8k68zoffhf"},{"post_id":"cjt5lttx700193a8khzhowzcx","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttxc001i3a8k2veeh8uh"},{"post_id":"cjt5lttx8001b3a8k8iqjwcwd","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttxd001k3a8kttrysbq7"},{"post_id":"cjt5lttx9001d3a8kdjnh32gf","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttxd001m3a8ktzxi91t3"},{"post_id":"cjt5lttxa001f3a8k5h4g4xql","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttxe001o3a8k7c1zkllj"},{"post_id":"cjt5lttxb001h3a8kwhb0snf0","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttxf001q3a8kvcxlg9va"},{"post_id":"cjt5lttxc001j3a8krjums0re","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttxg001s3a8kmz2b4s1h"},{"post_id":"cjt5lttxd001l3a8kduqqnfoe","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttxi001u3a8ktpgpq8d7"},{"post_id":"cjt5lttxd001n3a8kyo80wc5g","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttxi001x3a8kc6az96gk"},{"post_id":"cjt5lttxe001p3a8kbzwi7wkm","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttxj001z3a8kycfvh54j"},{"post_id":"cjt5lttxf001r3a8kcv7a8ozd","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttxk00213a8k17tnuf68"},{"post_id":"cjt5lttxj00203a8knnhz0at5","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttxl00243a8k95fxoinn"},{"post_id":"cjt5lttxg001t3a8kh8kfqb2h","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttxm00263a8kipvmmha9"},{"post_id":"cjt5lttxk00223a8k5pch0m8y","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttxn00293a8knys86ixr"},{"post_id":"cjt5lttxi001v3a8khac99wor","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttxo002b3a8k8apfh19p"},{"post_id":"cjt5lttxm00273a8kjx4xxc8n","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttxp002e3a8kqjvwxe3y"},{"post_id":"cjt5lttxn002a3a8kwktkh6dp","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttxq002g3a8kz0hlerkg"},{"post_id":"cjt5lttxi001y3a8kxt9av0hk","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttxr002i3a8kzx19fbu9"},{"post_id":"cjt5lttxo002c3a8k33u8sgcj","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttxs002k3a8k2pk6fh2o"},{"post_id":"cjt5lttxp002f3a8kkdbr5gv2","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttxs002m3a8k8m1rw7kj"},{"post_id":"cjt5lttxl00253a8k17rgvlnu","tag_id":"cjt5lttxo002d3a8k63jrzsqi","_id":"cjt5lttxt002o3a8kwczmbdxd"},{"post_id":"cjt5lttxq002h3a8kacaipbgd","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttxu002q3a8ki9brmtxm"},{"post_id":"cjt5lttxr002j3a8kdsqcq820","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttxv002s3a8krgtus6pd"},{"post_id":"cjt5lttxs002l3a8ku39kottj","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttxw002u3a8kyjrj5hjh"},{"post_id":"cjt5lttxt002n3a8ke0bmv6wa","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttxx002x3a8k3ixg76q6"},{"post_id":"cjt5lttxu002r3a8k8j9lnnyq","tag_id":"cjt5lttxo002d3a8k63jrzsqi","_id":"cjt5lttxy002z3a8kvvooim49"},{"post_id":"cjt5lttxv002t3a8ka334cm4y","tag_id":"cjt5lttxx002w3a8kzbbfikyy","_id":"cjt5ltty100333a8kfj61dihg"},{"post_id":"cjt5lttxw002v3a8kebasigmj","tag_id":"cjt5ltty000323a8kqi768jlb","_id":"cjt5ltty500383a8kwft7os0g"},{"post_id":"cjt5lttxx002y3a8kdwjfzv8l","tag_id":"cjt5ltty300363a8khesfczb1","_id":"cjt5ltty7003c3a8ky41wlbot"},{"post_id":"cjt5ltty6003b3a8kz9wdzooh","tag_id":"cjt5ltty6003a3a8k330jzqoy","_id":"cjt5ltty8003e3a8kc4xub2un"},{"post_id":"cjt5lttxz00303a8ki4qndu47","tag_id":"cjt5ltty6003a3a8k330jzqoy","_id":"cjt5ltty9003h3a8kklezk2x3"},{"post_id":"cjt5ltty7003d3a8ko34mz2q6","tag_id":"cjt5ltty6003a3a8k330jzqoy","_id":"cjt5lttyb003j3a8khp6j6adg"},{"post_id":"cjt5lttxz00313a8kzqh4fqxn","tag_id":"cjt5ltty8003f3a8k4ph4oyux","_id":"cjt5lttyd003m3a8kwauax89m"},{"post_id":"cjt5lttyb003k3a8kcdcotb3r","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttyh003o3a8kv6bz7qiq"},{"post_id":"cjt5lttyd003n3a8k6r20sq65","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttyi003r3a8kd6f7butc"},{"post_id":"cjt5ltty100343a8kum2psazj","tag_id":"cjt5ltty6003a3a8k330jzqoy","_id":"cjt5lttyi003t3a8kjfpdjssj"},{"post_id":"cjt5lttyh003p3a8kgql8wkat","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttyj003w3a8kd0yy9ywd"},{"post_id":"cjt5lttyi003s3a8k0cfitxo1","tag_id":"cjt5lttxo002d3a8k63jrzsqi","_id":"cjt5lttyk003y3a8kw0pe74x8"},{"post_id":"cjt5ltty200353a8kh94x118m","tag_id":"cjt5ltty6003a3a8k330jzqoy","_id":"cjt5lttyl00413a8ka6kaj6ib"},{"post_id":"cjt5lttyk003x3a8k5ynigoae","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttym00433a8kkj15zk50"},{"post_id":"cjt5ltty300373a8kcbpeqr8f","tag_id":"cjt5ltty6003a3a8k330jzqoy","_id":"cjt5lttym00463a8klicp4jgg"},{"post_id":"cjt5lttyl00423a8kac4b8xra","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttyo00483a8kouiazq2k"},{"post_id":"cjt5ltty500393a8kkvx047sx","tag_id":"cjt5ltty6003a3a8k330jzqoy","_id":"cjt5lttyp004b3a8kgkb9b7ab"},{"post_id":"cjt5lttym00443a8kooguyrgm","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttyq004d3a8ke2w9cr5q"},{"post_id":"cjt5lttyn00473a8kxhib95f0","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttyr004g3a8kda0qozaf"},{"post_id":"cjt5ltty8003g3a8kerc0vzm4","tag_id":"cjt5lttym00453a8k6z03noor","_id":"cjt5lttyt004i3a8kl3r8i7zj"},{"post_id":"cjt5lttyj003u3a8k5sxmq4vk","tag_id":"cjt5lttyp004a3a8k6wbl0irb","_id":"cjt5lttyu004k3a8kon7ql1a0"},{"post_id":"cjt5lttyr004h3a8kic7xn9n0","tag_id":"cjt5lttyr004f3a8kt3fnzdsy","_id":"cjt5lttyv004m3a8km7yu3bze"},{"post_id":"cjt5lttyk003z3a8kd3gxdvev","tag_id":"cjt5lttyr004f3a8kt3fnzdsy","_id":"cjt5lttyv004o3a8kdl4qu1tm"},{"post_id":"cjt5lttyt004j3a8kqvrt3i55","tag_id":"cjt5lttyp004a3a8k6wbl0irb","_id":"cjt5lttyy004q3a8kzzv8d67y"},{"post_id":"cjt5lttyu004l3a8k76d0k3gr","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttz0004s3a8k140pijh5"},{"post_id":"cjt5lttyv004n3a8kbhpd985y","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttz1004u3a8kroc8d823"},{"post_id":"cjt5lttyw004p3a8khau06tjk","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttz3004w3a8ky8ikf4kx"},{"post_id":"cjt5lttz0004t3a8keo32ofoe","tag_id":"cjt5ltty8003f3a8k4ph4oyux","_id":"cjt5lttz3004y3a8kuhxq7ks8"},{"post_id":"cjt5lttz1004v3a8kxao7zi99","tag_id":"cjt5ltty8003f3a8k4ph4oyux","_id":"cjt5lttz400503a8kgk2b4eba"},{"post_id":"cjt5lttz3004x3a8k1gxow6z1","tag_id":"cjt5ltty8003f3a8k4ph4oyux","_id":"cjt5lttz600523a8kbod1t087"},{"post_id":"cjt5lttz600533a8koumvm7ty","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttz700563a8kwljuoerc"},{"post_id":"cjt5lttz700573a8kkjlqwowd","tag_id":"cjt5lttyp004a3a8k6wbl0irb","_id":"cjt5lttz8005a3a8ko71gm8g9"},{"post_id":"cjt5lttz500513a8ki14e2pq4","tag_id":"cjt5lttz600543a8kp5z19s94","_id":"cjt5lttz9005c3a8kw0jdrn7i"},{"post_id":"cjt5lttz700583a8k6jrwklyl","tag_id":"cjt5ltty8003f3a8k4ph4oyux","_id":"cjt5lttza005e3a8kf27nowf2"},{"post_id":"cjt5lttz8005b3a8k03xvmut3","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttza005g3a8knluqknn4"},{"post_id":"cjt5lttz600553a8kqfepnl8g","tag_id":"cjt5lttz800593a8kozcqmdv0","_id":"cjt5lttzc005i3a8k0p27jpf6"},{"post_id":"cjt5lttz9005d3a8kv7ej0jhj","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttzd005k3a8k22d6rhxn"},{"post_id":"cjt5lttza005f3a8k5wze9e8y","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttze005m3a8kuop3tph2"},{"post_id":"cjt5lttza005h3a8kluzyf53t","tag_id":"cjt5ltty8003f3a8k4ph4oyux","_id":"cjt5lttzf005p3a8kf2gnj0cq"},{"post_id":"cjt5lttzc005j3a8kn8ye5b76","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttzg005r3a8kd5ibe11h"},{"post_id":"cjt5lttze005n3a8k74wqmfbh","tag_id":"cjt5lttz600543a8kp5z19s94","_id":"cjt5lttzh005t3a8kjlvfti8z"},{"post_id":"cjt5lttzf005q3a8k8f7jmr0c","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttzh005u3a8kwiu1t68b"},{"post_id":"cjt5lttzd005l3a8ki178684k","tag_id":"cjt5lttzf005o3a8k50e6etk3","_id":"cjt5lttzi005v3a8kf9kfmzay"},{"post_id":"cjt5lttzo005w3a8kmhwvv7dg","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttzr005y3a8k1klllvd4"},{"post_id":"cjt5lttzp005x3a8kcklxi5wb","tag_id":"cjt5lttwh00033a8ktrdc2soq","_id":"cjt5lttzs00603a8kkcxfe4mi"},{"post_id":"cjt5lttzs00613a8k5pbfqyc8","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttzv00643a8kknaw32gb"},{"post_id":"cjt5lttzt00633a8k1hlkcvdq","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttzx00663a8k7rfyqzda"},{"post_id":"cjt5lttzv00653a8ksefniyxk","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5lttzz00683a8kt958bkgb"},{"post_id":"cjt5lttzr005z3a8k9t7jg6yi","tag_id":"cjt5lttzt00623a8kisidxste","_id":"cjt5ltu00006a3a8k0khvebzi"},{"post_id":"cjt5lttzy00673a8knmtnq0a9","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5ltu01006d3a8kxejytxgv"},{"post_id":"cjt5ltu00006b3a8kvsa71kn6","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5ltu01006f3a8kkentfmt1"},{"post_id":"cjt5ltu01006e3a8kmrbduaxs","tag_id":"cjt5ltty6003a3a8k330jzqoy","_id":"cjt5ltu02006h3a8kqs2jbf02"},{"post_id":"cjt5lttzz00693a8k8o6g41hz","tag_id":"cjt5ltu01006c3a8k9ktbhoi7","_id":"cjt5ltu03006k3a8kszupxe6x"},{"post_id":"cjt5ltu02006i3a8k4zimvtt7","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5ltu04006m3a8kfk0yat4c"},{"post_id":"cjt5ltu03006l3a8kxzwtpa2c","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5ltu04006o3a8k3ghd1u3v"},{"post_id":"cjt5ltu04006n3a8kg913fj6t","tag_id":"cjt5ltty6003a3a8k330jzqoy","_id":"cjt5ltu05006q3a8k4wuqebzg"},{"post_id":"cjt5ltu02006g3a8kp87ivt63","tag_id":"cjt5ltu03006j3a8k2tz9ij1f","_id":"cjt5ltu06006s3a8k6p10ma7k"},{"post_id":"cjt5ltu04006p3a8kqfj6crxg","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5ltu06006u3a8kb2hf7zgv"},{"post_id":"cjt5ltu05006r3a8kxv1bnx1v","tag_id":"cjt5ltu01006c3a8k9ktbhoi7","_id":"cjt5ltu07006x3a8ka0cggfco"},{"post_id":"cjt5ltu06006v3a8kkgbsdb0w","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5ltu08006z3a8kz4b1yqdu"},{"post_id":"cjt5ltu07006y3a8kbkzedqh9","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5ltu0900713a8k0bm3xkcf"},{"post_id":"cjt5ltu0800703a8k7hf171lv","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5ltu0900733a8kpxammhce"},{"post_id":"cjt5ltu06006t3a8kdzch8hb9","tag_id":"cjt5ltu07006w3a8kgvf7gluu","_id":"cjt5ltu0a00753a8kmdis0tqe"},{"post_id":"cjt5ltu0900723a8kybkgi8yg","tag_id":"cjt5ltu0a00743a8ktl43v98w","_id":"cjt5ltu0a00763a8keex050aw"},{"post_id":"cjt5ltu0c00773a8kiwb87al4","tag_id":"cjt5ltty6003a3a8k330jzqoy","_id":"cjt5ltu0e00793a8ka9mligqt"},{"post_id":"cjt5ltu0e00783a8kxz909yrt","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5ltu0f007b3a8k78qco7qd"},{"post_id":"cjt5ltu0e007a3a8k6505lj7q","tag_id":"cjt5ltty6003a3a8k330jzqoy","_id":"cjt5ltu0g007d3a8kzzkpyyja"},{"post_id":"cjt5ltu0f007c3a8kw9nage12","tag_id":"cjt5ltu0g007e3a8kj8bn31kw","_id":"cjt5ltu0g007f3a8k7t9czyao"},{"post_id":"cjt5ltu0i007g3a8k6xovy918","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5ltu0i007h3a8kwb2zpgwj"},{"post_id":"cjt5ltu0k007i3a8k1mtewfg6","tag_id":"cjt5ltty6003a3a8k330jzqoy","_id":"cjt5ltu0l007j3a8k2znh9e9l"},{"post_id":"cjt5ltu0n007k3a8kgo1vcqq8","tag_id":"cjt5lttxi001w3a8kmu0jhxyw","_id":"cjt5ltu0n007l3a8kcvy32fkc"}],"Tag":[{"name":"工作小结","_id":"cjt5lttwh00033a8ktrdc2soq"},{"name":"工作复盘","_id":"cjt5lttwx000n3a8ke820pdsw"},{"name":"android","_id":"cjt5lttxi001w3a8kmu0jhxyw"},{"name":"架构","_id":"cjt5lttxo002d3a8k63jrzsqi"},{"name":"日常bug","_id":"cjt5lttxx002w3a8kzbbfikyy"},{"name":"http","_id":"cjt5ltty000323a8kqi768jlb"},{"name":"ios","_id":"cjt5ltty300363a8khesfczb1"},{"name":"java","_id":"cjt5ltty6003a3a8k330jzqoy"},{"name":"算法","_id":"cjt5ltty8003f3a8k4ph4oyux"},{"name":"javascript","_id":"cjt5lttym00453a8k6z03noor"},{"name":"python","_id":"cjt5lttyp004a3a8k6wbl0irb"},{"name":"hexo","_id":"cjt5lttyr004f3a8kt3fnzdsy"},{"name":"生活","_id":"cjt5lttz600543a8kp5z19s94"},{"name":"自我提升","_id":"cjt5lttz800593a8kozcqmdv0"},{"name":"设计模式","_id":"cjt5lttzf005o3a8k50e6etk3"},{"name":"计划","_id":"cjt5lttzt00623a8kisidxste"},{"name":"数据结构","_id":"cjt5ltu01006c3a8k9ktbhoi7"},{"name":"sql","_id":"cjt5ltu03006j3a8k2tz9ij1f"},{"name":"多线程","_id":"cjt5ltu07006w3a8kgvf7gluu"},{"name":"andrid","_id":"cjt5ltu0a00743a8ktl43v98w"},{"name":"网络协议","_id":"cjt5ltu0g007e3a8kj8bn31kw"}]}}