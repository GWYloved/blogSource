<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="记录者">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="记录者">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="记录者">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>记录者</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">记录者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/07/effective-java学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/07/effective-java学习笔记/" itemprop="url">effective-java学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-07T16:45:46+08:00">
                2018-05-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="创建和销毁对象。"><a href="#创建和销毁对象。" class="headerlink" title="创建和销毁对象。"></a>创建和销毁对象。</h2><h3 id="使用静态工厂方法代替构造器"><a href="#使用静态工厂方法代替构造器" class="headerlink" title="使用静态工厂方法代替构造器"></a>使用静态工厂方法代替构造器</h3><p>优势：</p>
<p>1 - 静态工厂方法与构造器不同的第一大优势：它们有名称。</p>
<p>由于一个类只能有一个指定签名的构造器，及时我们使用替换顺序来构造不同的构造器，也会产生困扰，不知道该使用哪个。但是静态工厂方法则可以代替构造器，使用不同的名称以显示不同的区别。</p>
<p>2 - 静态工厂方法与构造器不同的第二大优势：不必在每次调用它们的时候都创建一个新的对象。</p>
<p>静态工厂方法可以使用预先构建好的实例，或者将实例缓存起来，进行重复利用。如果程序进场请求创建相同的对象，并且创建对象的代价很高的话，可以考虑使用该方法。</p>
<p>3 - 静态工厂方法与构造器不同的第三大优势：它们可以返回原返回类型的任何子类型的对象。</p>
<p>api可以返回对象，又不会使对象的类变成公有的，类的实现在客户端看来是不可见的。</p>
<p>由于静态工厂方法返回的对象所属的类，在编写包含该静态方法的类时可以不必存在。因此衍生了“服务提供者框架”。</p>
<p>服务提供者框架有三个重要的组件：服务接口，提供者注册api，服务访问api。第四个组件可选，是服务提供者接口。这些提供者负责创建其服务实现的实例，如果没有服务提供者接口，实现就按照类名称注册，并通过反射方式进行实例化。</p>
<p>4 - 静态工厂方法的第四大优势：在创建参数化类型实例的时候，它们使代码变得更加简洁。</p>
<p>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; m = new HashMap&lt;String, List&lt;String&gt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>可以通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;K, V&gt; HashMap&lt;K, V&gt; newInstance()&#123;</span><br><span class="line">	return new HashMap&lt;K, V&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; m = HashMap.newInstance();</span><br></pre></td></tr></table></figure></p>
<p>缺点：</p>
<p>1 - 类如果不含公有的或者受保护的构造器，就不能子类化。</p>
<p>针对这一条，“复合“好过”继承“</p>
<p>2 - 它们与其他的静态方法实际上没有任何区别。</p>
<p>由于不是构造器，因此没有办法像构造器一样明确标识出来。因此对于提供了静态工厂方法而不是构造器的类来讲，想要查明如何实例化一个类，比较困难。</p>
<p>我们需要遵守一些惯用名称：</p>
<ul>
<li><p>valueOf —- 该方法返回的实例与他的参数具有相同的值，这样的静态工厂方法世纪上是类转换的方法。</p>
</li>
<li><p>of —- valueOf的另一个更加简洁的方法</p>
</li>
<li><p>getInstance —- 返回的实例是通过方法的参数来描述的，但是不能说与参数具有相同的值。对于singleton来说，该方法没有参数，并返回唯一的实例。</p>
</li>
<li><p>newInstance —- newinstance能够确保返回的每个实例都与所有的其他实例不同</p>
</li>
<li><p>getType —- 像getinstance一样，但是gettype表示返回的使用类型。</p>
</li>
<li><p>newType —- 和gettype一样。</p>
</li>
</ul>
<h3 id="遇到多个构造器参数时要考虑使用构建器"><a href="#遇到多个构造器参数时要考虑使用构建器" class="headerlink" title="遇到多个构造器参数时要考虑使用构建器"></a>遇到多个构造器参数时要考虑使用构建器</h3><p>静态工厂和构造器有个共同的局限性，它们都不能很好的扩展到大量的可选参数。</p>
<p>构建器就是使用set方法来设置参数，不过是build模式的。可以利用单个builder构建多个对象，builder的参数可以在创建对象期间进行调整，也可以随着不同的对象而改变。builder可以自动填充某些域，例如每次创建对象时自动增加序列号。</p>
<h3 id="用私有构造器或者枚举类型强化singleton属性"><a href="#用私有构造器或者枚举类型强化singleton属性" class="headerlink" title="用私有构造器或者枚举类型强化singleton属性"></a>用私有构造器或者枚举类型强化singleton属性</h3><ul>
<li>使用公有静态域</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Elvis&#123;</span><br><span class="line">	public static final Elvis INSTANCE = new Elvis();</span><br><span class="line">	private Elvis()&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法确保只有一个全局变量，但是该方法容易被反射。</p>
<ul>
<li>使用静态工厂方法来实现singleton</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Elvis&#123;</span><br><span class="line">	private static final Elvis INSTANCE = new Elvis();</span><br><span class="line">	private Elvis&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	public static Elivs getInstance()&#123;</span><br><span class="line">		return INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getInstance()方法的所有调用都会返回同一个对象引用，所以永远不会创建别的对象。</p>
<p>工厂方法的优势在于提供了灵活性，不改变api的前提下，可以改变该类是否是singleton的想法，可序列化但是维护singleton的话需要申明所有实例域是瞬时的，并且要提供一个readResolve方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private Object readResolve()&#123;</span><br><span class="line">	return Instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写一个包含单个元素的枚举类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Elvis &#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法在功能上与公有域相近，但是更加简洁，并且无偿的提供了序列化机制，绝对防止多次实例化，哪怕是反射的时候。</p>
<h3 id="通过私有化构造器强化不可实例化的能力"><a href="#通过私有化构造器强化不可实例化的能力" class="headerlink" title="通过私有化构造器强化不可实例化的能力"></a>通过私有化构造器强化不可实例化的能力</h3><p>对于类似于Collections这种，不需要也不希望实例化的类，避免自动构建其无参构造，可以使用以下方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class UtilityClass&#123;</span><br><span class="line">	private UtilityClass()&#123;</span><br><span class="line">		throw new AssertionError();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法会导致子类没有构造器。</p>
<h3 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h3><p>对于同时提供静态方法和构造器的不可变类，通常可以使用静态工厂方法而不是构造器，以避免创建不必要的对象。例如Boolean.valueOf(String)几乎总是优先于构造器Boolean(String)。这是由于构造器每次构造的时候都会创建一个对象，而静态方法则不会。</p>
<p>除了重用这种方法之外，还可以重用已知的不会修改的可变对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">	</span><br><span class="line">	private final Date birthDate;</span><br><span class="line"></span><br><span class="line">	public boolean isBabyBoomer()&#123;</span><br><span class="line">		Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span><br><span class="line">		gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class="line">		Date boomStart = gmtCal.getTime();</span><br><span class="line">		gmtCal.set(1956, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class="line">		Date boomEnd = gmtCal.getTime();</span><br><span class="line">		return birthDate.compare(boomStart) &gt;= 0 &amp;&amp; birthDate.compare(boomEnd) &lt; 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上方法，每次调用都会新建一个Calendar, 一个TimeZone, 和两个Date实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">	private final Date birthDate;</span><br><span class="line"></span><br><span class="line">	private static final Date BOOM_START;</span><br><span class="line">	private static final Date BOOM_END;</span><br><span class="line"></span><br><span class="line">	static&#123;</span><br><span class="line">		Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span><br><span class="line">		gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class="line">		BOOM_START = gmtCal.getTime();</span><br><span class="line">		gmtCal.set(1956, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class="line">		BOOM_END = gmtCal.getTime();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public boolean isBabyBoomer()&#123;</span><br><span class="line">		return birthDate.compare(BOOM_START) &gt;= 0 &amp;&amp; birthDate.compare(BOOM_END) &lt; 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进后只会创建一个Calendar, 一个TimeZone和一个Date</p>
<p>另外关于基本类型和装箱基本类型之前的变换，如今有自动拆箱和自动拆箱，不过在需要的时候，使用基本类型总是效率好过装箱类型，要小心无意识的自动装箱行为。</p>
<h3 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h3><p>该题主要针对内存泄漏现象的分析，对过期引用的分析处理主要在清空引用方法。在android方面的分析处理看着的话用处不大。</p>
<p>仍然是缓存和监听器回调泄漏这些方面。</p>
<h3 id="避免使用终结（finalizer）方法"><a href="#避免使用终结（finalizer）方法" class="headerlink" title="避免使用终结（finalizer）方法"></a>避免使用终结（finalizer）方法</h3><p>终结方法通常不可预测，一般不可使用。</p>
<p>jvm正确的执行对象的终结方法是顺利的回收。但是由于jvm不同，很有可能在不同的平台上不同的算法不同，导致产生的现象大相庭径。</p>
<p>终结方法是以队列的形式进行回收，但是由于终结方法的优先级很低，不确定哪些线程会执行终结方法。因此会造成在终结方法中执行方法的速度小于进入终结方法的速度，会导致大量的回收对象堆积，以此产生oom。</p>
<h2 id="对于所有对象都通用的方法"><a href="#对于所有对象都通用的方法" class="headerlink" title="对于所有对象都通用的方法"></a>对于所有对象都通用的方法</h2><p>这一章是针对Object类</p>
<h3 id="覆盖equals是遵守通用约定"><a href="#覆盖equals是遵守通用约定" class="headerlink" title="覆盖equals是遵守通用约定"></a>覆盖equals是遵守通用约定</h3><h4 id="针对以下四点，不应该覆盖equals方法，同时不能让其他人调用使用"><a href="#针对以下四点，不应该覆盖equals方法，同时不能让其他人调用使用" class="headerlink" title="针对以下四点，不应该覆盖equals方法，同时不能让其他人调用使用"></a>针对以下四点，不应该覆盖equals方法，同时不能让其他人调用使用</h4><ol>
<li><p>类的每个实例本质上都是唯一的：对于代表活动实体而不是值的类来说，object提供的equals是正确的。</p>
</li>
<li><p>不关心类是否提供了“逻辑相等”的测试功能：</p>
</li>
<li><p>超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的</p>
</li>
<li><p>类是私有的或是包级私有的，可以确定它的equals方法永远不会被调用：此时需要覆盖以防被意外调用。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object o )&#123;</span><br><span class="line">	throw new AssertionError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如果需要覆盖时，需要遵守以下的规范，来自JavaSE6"><a href="#如果需要覆盖时，需要遵守以下的规范，来自JavaSE6" class="headerlink" title="如果需要覆盖时，需要遵守以下的规范，来自JavaSE6"></a>如果需要覆盖时，需要遵守以下的规范，来自JavaSE6</h4><ol>
<li><p>自反性：对于任何非null的引用值x，x.equals(x)必须返回true</p>
</li>
<li><p>对称性：对于任何非null的引用值x,y,z，如果x.equals(y) == true, 那么y.equals(x) == true也必须成立</p>
</li>
<li><p>传递性：对于任何非null的引用值x,y,z，如果x.equals(y) == true, y.equals(z) == true,那么x.equals(z) == true也必须成立</p>
</li>
<li><p>一致性：对于任何非null的引用值x，y，只要equals的比较操作在对象中所用的信息没有被修改，那么无论调用多少次equals，返回结果必须是一样的</p>
</li>
<li><p>非空性：对于任何非null的引用值x，x.equals(null)必须返回false</p>
</li>
</ol>
<h4 id="根据以上两个原则以及引申出来的原则，总结实现equals的窍门"><a href="#根据以上两个原则以及引申出来的原则，总结实现equals的窍门" class="headerlink" title="根据以上两个原则以及引申出来的原则，总结实现equals的窍门"></a>根据以上两个原则以及引申出来的原则，总结实现equals的窍门</h4><ol>
<li><p>使用 == 操作符检查“参数是否为这个对象的引用”</p>
</li>
<li><p>使用 instanceof 操作符检查“参数是否为正确的类型”</p>
</li>
<li><p>把参数转换成正确的类型</p>
</li>
<li><p>对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配（不能只针对某些关键条件来判断，而不是全部关键条件）</p>
</li>
<li><p>当编写完equals方法之后，应该检查对称性、传递性、一致性。</p>
</li>
</ol>
<h3 id="覆盖equals时总要覆盖hashcode"><a href="#覆盖equals时总要覆盖hashcode" class="headerlink" title="覆盖equals时总要覆盖hashcode"></a>覆盖equals时总要覆盖hashcode</h3><p>由于HashMap,HashSet和HashTable这些散列集合。</p>
<p>散列集合的关键域，就有hashcode，若不覆盖的话，就会产生问题。例如由于hashcode不同，导致两个equals为true的对象，放到了不同的散列桶中，因此导致get出来的值是不同的，违反了上面的规则。</p>
<h4 id="覆盖hashcode的方法"><a href="#覆盖hashcode的方法" class="headerlink" title="覆盖hashcode的方法"></a>覆盖hashcode的方法</h4><ol>
<li><p>将某个非零的常数值，保存在名为result的int类型的变量中。</p>
</li>
<li><p>对于对象中每个关键域f，完成以下步骤：</p>
<p> a. 为该域计算int类型的散列码c：</p>
<pre><code>i. f类型是boolean，则计算f?1:0
ii. 如果该域是byte，char，short或者int类型，则计算(int)f
iii. 如果该域是long类型，则计算(int)(f^(f&gt;&gt;32))
iv. 如果该域是float类型，则计算Float.floatToIntBits(f)
v. 如果该域是double类型，则计算Double.doubleToLongBits(f),然后跳到iii
vi. 如果是对象引用，可以设计一个范式，针对这个范式来计算hashcode
vii. 如果该域是一个数组，需要针对每一个元素计算一下，然后依据b来计算
</code></pre><p> b. 按照 result = result * 31 + c</p>
</li>
</ol>
<h3 id="始终覆盖toString"><a href="#始终覆盖toString" class="headerlink" title="始终覆盖toString"></a>始终覆盖toString</h3><p>使用tostring来进行关键的提示</p>
<h3 id="谨慎的覆盖clone"><a href="#谨慎的覆盖clone" class="headerlink" title="谨慎的覆盖clone"></a>谨慎的覆盖clone</h3><p>克隆部分主要是针对object的clone来进行浅克隆的缺点分析，和深克隆的优点介绍。</p>
<p>提供了一种不断调用构造器来进行clone的深克隆方法。事实上目前深克隆有了更好的stream方法，所以略过不讲。</p>
<p>之前说过的newinstance方法，其实就是浅克隆</p>
<h3 id="考虑实现comparable接口"><a href="#考虑实现comparable接口" class="headerlink" title="考虑实现comparable接口"></a>考虑实现comparable接口</h3><p>类实现了comparable接口，可以与许多泛型算法，以及依赖于该接口的集合实现进行协作。不过也同样要遵从自反性，对称性和传递性。</p>
<p>由于类可能有很多个关键域，因此需要由最关键的域开始进行比较，直到所有的域都比较结束，才能算一个comparable接口实现结束</p>
<h2 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h2><h3 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h3><p>出于“封装”的特性，需要将类的方法进行访问性变更，仅仅暴露出一些需要暴露的方法进行模块间的沟通。</p>
<p>有几个规定</p>
<p>实例域不可公有，对于非final的实例域不可公有主要是针对线程安全。另外对于静态final域的对象来讲，需要确保其引用对象不是可变对象，否则也不可公有</p>
<p>长度非0的数组，无论如何声明，也是可变的，因此对于数组的静态域返回，需要使用如下方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final static Thing[] PRIVATE_VALUES = &#123;...&#125;;</span><br><span class="line">public static final Thing[] values()&#123;</span><br><span class="line">	return PRIVATE_VALUES.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在公有域方法中使用访问方法，而不是公有域"><a href="#在公有域方法中使用访问方法，而不是公有域" class="headerlink" title="在公有域方法中使用访问方法，而不是公有域"></a>在公有域方法中使用访问方法，而不是公有域</h3><p>这就是使用get set等方法，而不是直接暴露出参数，来使用公有域。由于使用这种方法，可以确保通过自设的一些限制，确保返回的参数和自己需要的参数条件相当。</p>
<h3 id="使可变性最小化"><a href="#使可变性最小化" class="headerlink" title="使可变性最小化"></a>使可变性最小化</h3><p>该例主要是针对不可变类的处理。不可变类是第一次构造时就赋予内部参数的类，类似String类。</p>
<p>使类变成不可变类，需要遵循五条规则：</p>
<ol>
<li><p>不要提供任何会修改对象状态的方法</p>
</li>
<li><p>保证类不会被扩展：防止子类化，一般可以将这个类做成final的</p>
</li>
<li><p>使所有的域都是final的：使用系统的强制方式，可以清楚的表明意图</p>
</li>
<li><p>使所有的域都成为私有的：防止客户端获得访问可变对象的权限，并防止客户端直接修改这些对象。</p>
</li>
<li><p>确保对于任何可变组件的互斥访问：如果类具有指向可变对象的域，必须确保该类的客户端无法获得指向这些对象的引用。因此如果需要修改对象，提供set方法。</p>
</li>
</ol>
<p>不可变对象比较简单，只有一种状态，即被创建时的状态，本质上是线程安全的，它们不要求同步。并发访问时不会破坏属性，因此可以被自由的共享，同时也不需要进行保护性拷贝。</p>
<p>不仅可以共享不可变对象，甚至也可以共享它们的内部信息。</p>
<p>不可变对象的唯一的缺点是，对于每个不同的值都要一个单独的对象。由于创建对象的代价可能很大，对于大型的对象，这样操作实在是损耗太大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Complex&#123;</span><br><span class="line">	private final double re;</span><br><span class="line">	private final double im;</span><br><span class="line"></span><br><span class="line">	private Complex(double re, double im)&#123;</span><br><span class="line">		this.re = re;</span><br><span class="line">		this.im = im;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static Complex valueOf(double re, double im)&#123;</span><br><span class="line">		return new Complex(re, im);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复合优先于继承"><a href="#复合优先于继承" class="headerlink" title="复合优先于继承"></a>复合优先于继承</h3><p>继承打破了封装性，当版本的升级导致父类的变化，会造成子类的破坏。因此需要进行复合。</p>
<p>复合的意义是：不拓展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例，这种设计被称作复合。</p>
<p>现有的类变成了新类的一个组件，新类的每个实例方法都可以调用被包含的现有实例中对应的方法，并返回他的结果，这种方式称为转发。新的类被称为包装类。</p>
<p>缺点：包装类不适合用于回调框架</p>
<h3 id="要么为继承而设计，并提供文档说明，要么就禁止继承"><a href="#要么为继承而设计，并提供文档说明，要么就禁止继承" class="headerlink" title="要么为继承而设计，并提供文档说明，要么就禁止继承"></a>要么为继承而设计，并提供文档说明，要么就禁止继承</h3><p>不是为了继承而设计，并且没有文档说明，会导致子类的继承出现破坏性的问题。</p>
<p>文档必须要精确的描述覆盖每个方法所带来的影响。</p>
<h3 id="接口优于抽象类"><a href="#接口优于抽象类" class="headerlink" title="接口优于抽象类"></a>接口优于抽象类</h3><ol>
<li><p>现有的类可以很容易被更新，以实现新的接口</p>
</li>
<li><p>接口是定义mixin(混合类型)的理想选择</p>
</li>
<li><p>接口允许构造非层次接口的类型框架</p>
</li>
</ol>
<p>鉴于上上条“复合优先于继承”，如果使用接口的方式实现，包装类仍然完美使用</p>
<h3 id="接口只用于定义类型"><a href="#接口只用于定义类型" class="headerlink" title="接口只用于定义类型"></a>接口只用于定义类型</h3><p>接口仅仅用于定义引用这个实例的类型，因此除此之外的接口都是不恰当的。</p>
<h3 id="类层次由于标签类"><a href="#类层次由于标签类" class="headerlink" title="类层次由于标签类"></a>类层次由于标签类</h3><p>标签类很少有适用的时候，当编写一个包含显式标签域的类时，应当考虑是否应该不使用标签类，而是将标签放到同一个层次的结构中去。</p>
<h3 id="用函数对象表示策略"><a href="#用函数对象表示策略" class="headerlink" title="用函数对象表示策略"></a>用函数对象表示策略</h3><p>java虽然没有高阶语言的函数式编程，也没有c语言类似的函数指针，但是可以使用对象引用来实现同样的功能。</p>
<p>如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class StringLengthComparator&#123;</span><br><span class="line">	public int compare(String s1, String s2)&#123;</span><br><span class="line">		return s1.length() - s2.length();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class StringLengthComparator&#123;</span><br><span class="line">	private StringLengthComparator()&#123;&#125;;</span><br><span class="line">	public static final StringLengthComparator INSTANCE = new StringLengthComparator();</span><br><span class="line">	public int compare(String s1, String s2)&#123;</span><br><span class="line">		return s1.length() - s2.length();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>典型的具体策略类，是无状态的，没有域，所以所有的实例在功能上面都是等价的。</p>
<h3 id="优先考虑静态成员类"><a href="#优先考虑静态成员类" class="headerlink" title="优先考虑静态成员类"></a>优先考虑静态成员类</h3><p>嵌套类是指被定义在另一个类的内部的类。嵌套类存在的目的应该只是为他的外围类提供服务。</p>
<p>嵌套类分为四种：静态成员类，非静态成员类，匿名类和局部类，除了第一种之外，其他三种都被称为内部类。</p>
<p>非静态成员类的每个实例都隐含着与外围类的一个外围实例相关联，创建需要外围类的存在。没有外围实例，想创建非静态成员类是基本上不存在的。</p>
<p>一般非静态成员类都是使用常见的adapter来实现，他允许外部类的实例被看做是另一个不相关的类的实例。</p>
<p>因此，成员类不要求访问外部实例，希望外部实例以外的对象调用，就需要将static修饰符放在声明中。</p>
<h4 id="私有静态成员类"><a href="#私有静态成员类" class="headerlink" title="私有静态成员类"></a>私有静态成员类</h4><p>私有静态成员类的一中常见用法是用来代表外围类所代表的对象的组件。</p>
<p>例如一个map实例，它把键和值对应起来，许多map实现的内部都有一个entry对象，对应于map中的每个键值对。虽然每个entry都与一个map关联，但是entry上的方法并不需要访问该map，因此，使用非静态成员来标识entry是很浪费的，如果不用static修饰，那么每个entry中将会包含一个指向该map的引用。</p>
<h4 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h4><p>匿名类没有名字，他不是外围类的成员，他并不与其他的成员一起被申明，匿名类除了被申明的时候之外，是无法实例化的，无法进行instanceof测试，或者任何需要命名类的其他事情。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abstract class Father()&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">   Father f1 = new Father()&#123; .... &#125;  //这里就是有个匿名内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h4><p>局部类用的很少，局部类只在本地范围内有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        class AA&#123;&#125;//块内局部类</span><br><span class="line">    &#125;</span><br><span class="line">    public Test()&#123;</span><br><span class="line">        class AA&#123;&#125;//构造器内局部类</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        class AA&#123;&#125;//方法内局部类</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>局部类最多只能有final修饰，但不同的是，块内局部类有enclose class属性，而构造器局部类有enclose constructor属性，方法局部类有enclose method属性，嘛，其实很好理解的吧，一看就知道。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="请不要在新代码中使用原生态类型"><a href="#请不要在新代码中使用原生态类型" class="headerlink" title="请不要在新代码中使用原生态类型"></a>请不要在新代码中使用原生态类型</h3><p>每种范型其实都是一组参数化的类型，他是一种原生态类型（rawtype），即不带任何实际类型参数的泛型名称。</p>
<p>在不确定或者不在乎集合中元素类型的情况下，可以参考以下方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static int numElementsInCommon(Set s1, Set s2)&#123;</span><br><span class="line">	int result = 0;</span><br><span class="line">	for (Object o1 : s1)&#123;</span><br><span class="line">		if(s2.contains(o1))&#123;</span><br><span class="line">			result ++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用原生类型是可以在不关心参数类型的情况下替代泛型，缺很危险，不过泛型也提供了一种安全的替代方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;E&gt;   ---&gt;   Set&lt;?&gt; //可以持有任何集合</span><br></pre></td></tr></table></figure>
<p>对于泛型使用instanceof的首选方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (o instanceof Set)&#123;</span><br><span class="line">	Set&lt;?&gt; m = (Set&lt;?&gt;)o;</span><br><span class="line">	//一旦确定这个o是个set，就必须将它装换位通配符类型Set&lt;?&gt;而不是原生的Set，这是个受检的转换。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="消除非受检警告"><a href="#消除非受检警告" class="headerlink" title="消除非受检警告"></a>消除非受检警告</h3><p>类似非受检警告如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Lark&gt; exaltation = new HashSet();</span><br><span class="line"></span><br><span class="line">[unchecked] unchecked conversion</span><br></pre></td></tr></table></figure></p>
<p>需要改为如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Lark&gt; exaltation = new HashSet&lt;Lark&gt;();</span><br></pre></td></tr></table></figure></p>
<p> 无法消除的时候，可以使用注解来压制这条警告。但是压制的时候代表仍然可能是有问题的，所以最好做一些备注或者catch</p>
<h3 id="列表优先于数组"><a href="#列表优先于数组" class="headerlink" title="列表优先于数组"></a>列表优先于数组</h3><p>数组是covariant的，代表如果某个对象a是对象b的子类型，那么a[]也一定是b[]的子类型。</p>
<p>而数组就是invariant的，对于任意两个不同的类型ab，并不能说a的list是b的list的子类，也不能说b的list是a的list的父类。</p>
<p>事实上，本来就应该是如同list这样，数组这样反而是有缺陷的。</p>
<p>数组会在运行时才知道并检查他们的类型，而泛型则是通过擦除来实现的。正因如此，泛型可以与没有使用泛型的代码随意进行互用。</p>
<p>而泛型数组则是不建议创建的，每个不可具化的数组会得到一条警告，除了禁止并且避免在api中混合使用泛型和可变参数之外，别无他法。</p>
<p>创建泛型数组，可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];</span><br></pre></td></tr></table></figure></p>
<h3 id="优先使用泛型"><a href="#优先使用泛型" class="headerlink" title="优先使用泛型"></a>优先使用泛型</h3><p>使用泛型的步骤，可以先使用object，在不使用任何object内在方法以及实例方法的时候，可以完整实现一个类，即可替换使用泛型。</p>
<h3 id="优先考虑泛型方法"><a href="#优先考虑泛型方法" class="headerlink" title="优先考虑泛型方法"></a>优先考虑泛型方法</h3><p>核心步骤是使用泛型单例工厂方法，不单单可以通过泛型进行类型擦除，也适配了针对不同对象进行不同创建的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt;&#123;</span><br><span class="line">	int compareTo(T o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;T&gt;&gt; T max(List&lt;T&gt; list)&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似上述这种，就解决了不同类型的对象比较的问题，所需要的对象仅仅需要在编译过程中实现了comparable，即可参与到比较中来。而回避了类似string和int之间的比较类型。</p>
<h3 id="利用有限的通配符来提升api的灵活性"><a href="#利用有限的通配符来提升api的灵活性" class="headerlink" title="利用有限的通配符来提升api的灵活性"></a>利用有限的通配符来提升api的灵活性</h3><p>在部分情况下面，使用&lt;? extends E&gt;的方式来进行处理参数类型，有效的避免了部分不兼容接口的数据问题。和上一章讲的类似。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void pushAll(Iterable&lt;? extends E&gt; src)&#123;</span><br><span class="line">	for (E e: src)&#123;</span><br><span class="line">		push(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外提到了一个&lt;? super E&gt;的方式，同上面的不同，这种方式是指?是E的超类<br>对应的方法就是popAll<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void popAll(Collection&lt;? super E&gt; dst)&#123;</span><br><span class="line">	while(!isEmpty())&#123;</span><br><span class="line">		dst.add(pop());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要记得步骤PECS： producer-extends, consumer-super</p>
<p>针对既可以消费，也可以生产的，可以使用下述方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &lt;E&gt; E reduce(List&lt;? extends E&gt; list, Function&lt;E&gt; f, E initVal);</span><br></pre></td></tr></table></figure></p>
<p>这样基本上可以确保，list的值可以被f消费，同时list又可以作为一个消费者返回正确的结果。</p>
<p>ps:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &lt;E&gt; E reduce(List&lt;E&gt; list, Function&lt;? super E&gt; f, E initVal);</span><br></pre></td></tr></table></figure>
<p>应该也是可以的，相同的意义</p>
<h3 id="优先考虑类型安全的异构容器"><a href="#优先考虑类型安全的异构容器" class="headerlink" title="优先考虑类型安全的异构容器"></a>优先考虑类型安全的异构容器</h3><p>一般来讲，泛型用于实现一些容器，这些容器大部分包含了单个参数或者类似map的2个参数。如果想要实现更多参数，就需要使用到这章的内容。</p>
<p>实现一个简单的多参数泛型结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Favorites&#123;</span><br><span class="line">	public &lt;T&gt; void putFavourite(Class&lt;T&gt; type, T instance);</span><br><span class="line">	public &lt;T&gt; getFavourite(Class&lt;T&gt; type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">	Favourite f = new Favourites();</span><br><span class="line">	f.putFavourite(String.class, &quot;Java&quot;);</span><br><span class="line">	f.putFavourite(Integer.class, 0x000fffff);</span><br><span class="line">	f.putFavourite(Class.class, Favourite.class);</span><br><span class="line">	String favouritString = f.getFavourite(String.class);</span><br><span class="line">	int favouriteInteger = f.getFavourite(Integer.class);</span><br><span class="line">	Class&lt;?&gt; favouritClass = f.getFavourite(Class.class);</span><br><span class="line">	System.out.printf(&quot;%s %x %s %n&quot;, favouritString, favouriteInteger, favouritClass.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中涉及到了Favourites的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Favourites&#123;</span><br><span class="line">	private Map&lt;Class&lt;?&gt;, Object&gt; favourites = new HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">	public &lt;T&gt; void putFavourite(Class&lt;T&gt; type, T instance)&#123;</span><br><span class="line">		if(type == null)&#123;</span><br><span class="line">			throw new NullPointerException(&quot;Type is null&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		favourites.put(type, instance);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public &lt;T&gt; T getFavourite(Class&lt;T&gt; type)&#123;</span><br><span class="line">		return type.cast(favourites.get(type));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种模式是单key的，所以一个类，只可以对应一个值，实现一个数据库的单列是可以的</p>
<p>其中注意到一点，type.cast()方法，是Class的方法，通过这个方法基本上可以活用泛型。这种type被称为类型，type token被称为类型令牌</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public T cast(Object obj) &#123;</span><br><span class="line">    if (obj != null &amp;&amp; !isInstance(obj))</span><br><span class="line">        throw new ClassCastException(cannotCastMsg(obj));</span><br><span class="line">    return (T) obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps: Class类中自带了很多有用的方法，有空的时候可以看看</p>
<h2 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h2><p>枚举和注解都是jdk1.5发布的</p>
<h3 id="用enum代替int常量"><a href="#用enum代替int常量" class="headerlink" title="用enum代替int常量"></a>用enum代替int常量</h3><p>一般情况下使用int常量来做flag，会出现常量重复的现象，尤其是自己不注意的时候，可能两个命名不同的变量，却有相同的int值。在部分情况下会导致判断失误的现象</p>
<p>而采用枚举类型则可以完全避免这些问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Apple&#123; FUJI, PIPPIN, GRANNY_SMITH &#125;</span><br><span class="line"></span><br><span class="line">public enum Orange&#123; NAVEL, TEMPLE, BLOOD &#125;</span><br></pre></td></tr></table></figure>
<p>枚举的本质是通过公有的静态final域为每个枚举常量导出类型的类，由于没有可以访问的构造器，枚举类型是真正的final，并且是实例受控的，不可能进行拓展。他们是单例的泛型化，本质上是单元素的枚举</p>
<p>枚举还提供了多个同名常量的在多个枚举类型中可以有自己的命名空间，可以和平相处。</p>
<p>一个正常的有些复杂度的枚举类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public enum Planet&#123;</span><br><span class="line">	MERCURY(3.302e+23, 2.439e6),</span><br><span class="line">	VENUS(4.869e+24, 6.052e6),</span><br><span class="line">	EARTH(5.975e+24, 6.378e6);</span><br><span class="line">	private final double mass;</span><br><span class="line">	private final double radius;</span><br><span class="line">	private final double surfaceGravity;</span><br><span class="line">	private static final double G = 6.67300e-11;</span><br><span class="line"></span><br><span class="line">	Planet(double mass, double radius)&#123;</span><br><span class="line">		this.mass = mass;</span><br><span class="line">		this.radius = radius;</span><br><span class="line">		surfaceGravity = G * mass / (radius * radius);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public double mass()&#123;</span><br><span class="line">		return mass;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public double radius()&#123;</span><br><span class="line">		return radius;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public double surfaceGravity()&#123;</span><br><span class="line">		return surfaceGravity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public double surfaceWeight(double mass)&#123;</span><br><span class="line">		return mass * surfaceGravity;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class WeightTable&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		double earthWeight = Double.parseDouble(args[0]);</span><br><span class="line">		double nass = earthWeight/ Planet.EARTH.surfaceGravity();</span><br><span class="line">		for  (Planet p : Planet.values())&#123;</span><br><span class="line">			System.out.printf(&quot;Weight on %s is %f%n&quot;,p, p.surfaceWeight(mass));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外枚举类覆盖toString方法，亦可以直接在String中进行处理，这样在算术表达式中比较好处理</p>
<p>ps:尝试了一下，枚举类也可以有多态构造方法，内部类也是可以的，但是枚举实例只能放在头部。</p>
<h3 id="用实例域代替序数"><a href="#用实例域代替序数" class="headerlink" title="用实例域代替序数"></a>用实例域代替序数</h3><p>所有的枚举都有一个方法，叫做ordinal(),代表每个枚举常量在类型中的数字位置。</p>
<p>但是实现的时候不能滥用这个方法，我们假如构造一个枚举类，千万不要无参，而通过这个方法来获取位置。而最起码应该带有一个数字参数</p>
<h3 id="用EnumSet代替位域"><a href="#用EnumSet代替位域" class="headerlink" title="用EnumSet代替位域"></a>用EnumSet代替位域</h3><p>用位域的好处是可以比较好的使用flag，类似经常用到的比如说intent的flag，textview的flag。</p>
<p>位域有一系列的缺点，尤其是当打印出来的时候，这个我深受其害，在观察view的tree结构时，很多状态位看不懂，还需要翻代码对比才能看出来。</p>
<p>使用enumset代替的确有规避这方面的好处，自己写代码的时候可以注意一下，但是framework的代码其实很难更改这个了。</p>
<h3 id="用EnumMap代替序数索引"><a href="#用EnumMap代替序数索引" class="headerlink" title="用EnumMap代替序数索引"></a>用EnumMap代替序数索引</h3><p>之前讲过用ordinal方法来进行索引，但是若是出现多个数组的情况，单ordinal就不满足了，需要进行状态的保存。</p>
<p>enummap可以规避这个问题，但是看起来其实可用性不是很高。map的使用场景在android里面不如list。不过在构造容器的时候，使用enummap比较好</p>
<h3 id="用接口模拟可伸缩的枚举"><a href="#用接口模拟可伸缩的枚举" class="headerlink" title="用接口模拟可伸缩的枚举"></a>用接口模拟可伸缩的枚举</h3><p>通过接口使得枚举拓展化，通过枚举来实现接口，这样使得枚举可以伸缩，虽然无法编写可拓展的枚举类型，但是这样却可以进行枚举的模拟</p>
<h3 id="注解优先于命名模式"><a href="#注解优先于命名模式" class="headerlink" title="注解优先于命名模式"></a>注解优先于命名模式</h3><p>命名模式有几个缺点:<br>1 文字拼写错误会导致失败，比如说测试用例需要test开头，这样就会导致写错test就失败</p>
<p>2 无法确保他们只用于相应的元素上面</p>
<p>3 没有提供参数值与程序元素关联起来的好方法</p>
<p>通过注解可以完美的处理上述问题</p>
<h3 id="坚持使用override接口"><a href="#坚持使用override接口" class="headerlink" title="坚持使用override接口"></a>坚持使用override接口</h3><p>有助于编译器检查</p>
<h3 id="用标记接口定义类型"><a href="#用标记接口定义类型" class="headerlink" title="用标记接口定义类型"></a>用标记接口定义类型</h3><p>标记接口类似于retrofit的标记方式，优点是可以精确的被锁定</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="检查参数的有效性"><a href="#检查参数的有效性" class="headerlink" title="检查参数的有效性"></a>检查参数的有效性</h3><p>对于公开的方法，可以直接使用@throws标签进行标注，然后代码中判断</p>
<p>非公开的方法，使用assert即可</p>
<h3 id="必要时进行保护性拷贝"><a href="#必要时进行保护性拷贝" class="headerlink" title="必要时进行保护性拷贝"></a>必要时进行保护性拷贝</h3><p>一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Period(Data start, Data end)&#123;</span><br><span class="line">	if(start.compareTo(end))&#123;</span><br><span class="line">		throw new IllegalArgumentException(start + &quot;after&quot; + end);</span><br><span class="line">	&#125;</span><br><span class="line">	this.start = start;</span><br><span class="line">	this.end = end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于传入的Data事实上是可变的，因此一旦在构造完之后，再次修改的话，会造成条件不成立。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Period(Data start, Data end)&#123;</span><br><span class="line">	if(start.compareTo(end))&#123;</span><br><span class="line">		throw new IllegalArgumentException(start + &quot;after&quot; + end);</span><br><span class="line">	&#125;</span><br><span class="line">	this.start = new Data(start.getTime());</span><br><span class="line">	this.end = new Data(end.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这种方式就可以避免上述问题</p>
<p>但是仍然有一种无法避免，就是暴露了相关参数，然后通过get接口获取之后直接更改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Data getStart()&#123;</span><br><span class="line">	return new Data(start.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此在get中也需要进行保护措施</p>
<h3 id="谨慎设计方法签名"><a href="#谨慎设计方法签名" class="headerlink" title="谨慎设计方法签名"></a>谨慎设计方法签名</h3><p>1 谨慎的选择方法的名称</p>
<p>2 不要过分追求提供便利的方法：主要原则是出于维护性的考虑，每个方法都应该尽其所能，而不应该过度耦合</p>
<p>3 避免过长的参数列表：最多四个参数</p>
<h3 id="慎用重载"><a href="#慎用重载" class="headerlink" title="慎用重载"></a>慎用重载</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/07/java编程思想第一章《对象导论》学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/07/java编程思想第一章《对象导论》学习笔记/" itemprop="url">java编程思想第一章《对象导论》学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-07T01:05:26+08:00">
                2018-05-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.1 抽象过程</p>
<ul>
<li><p>万物皆为对象：将对象是为奇特的变量，他可以存储数据，还可以在自身上执行操作。</p>
</li>
<li><p>程序是对象的集合，它们通过发送消息来告知彼此所要做的：可以把消息想象为对某个特定对象的方法的调用请求。</p>
</li>
<li><p>每个对象都有自己的由其他对象所构成的存储：通过创建包含现有的对象的包的方式来创建新类型的对象。</p>
</li>
<li><p>每个对象都拥有其类型：每个类最重要的区别于其他类的特性就是可以发送什么样的消息给他。</p>
</li>
<li><p>某一特定类型的所有对象都可以接收同样的消息：可替代性是oop中最强有力的概念之一。</p>
</li>
</ul>
<p>1.2 每个对象都有一个接口</p>
<p>通过设计接口的形式，将对对象的每个请求定义下来。接口确定了对某一特定对象所能发出的请求。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/03/针对activity栈启动模式进行fragment栈的引申/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/03/针对activity栈启动模式进行fragment栈的引申/" itemprop="url">针对activity栈启动模式进行fragment栈的引申</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-03T23:30:29+08:00">
                2018-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>“one activity for the whole app, you can use fragments, just don’t use the backstack with fragments”</p>
<p>— jake·warton</p>
<p>安卓开发有其独特的魅力，相对于每个页面不断的切换，事实上前端开发从安卓的角度来看可以有不同的作为。</p>
<p>比如说jake·warton所说的只使用一个activity窗口，外加很多个碎片，来组成一个app。这句话很好理解，可是后面的这半句话是什么意思呢？主要是fragment的后台管理栈比较不容易操控。</p>
<p>所以我们需要了解一下如何操控这个栈。这次就从activity的启动模式来分析。</p>
<ul>
<li>standard</li>
</ul>
<p>默认的启动模式，对fragment来讲，在basefragment中抽取activity的stackedfragments，每次新建一个fragment时，创建一个新的加入到栈顶即可。</p>
<ul>
<li>singleTop</li>
</ul>
<p>在栈顶的话，启动还是会转到自己，而不在栈顶的话就会新建。这个属性对fragment来讲不怎么实用，没怎么遇到过这种情形，如果要用的话，就判断之前的栈顶是否和新传入的相同，相同的话，就仍然返回的自身，不同就创建一个。</p>
<ul>
<li>singleTask</li>
</ul>
<p>在栈内的话，启动一个实例，就会启动栈内的。这个属性比较好用，对fragment来讲，可以用这个来做很多事情，包括回去的时候直接pop起到了cleartop的效果。</p>
<p>开发中还遇到相似的，一次传入三到四个fragment，如果有其中的fragment在栈上方，立即返回他，中断其余判断。这种操作其实就是遍历栈而已，不过能够在fragment多复用的情况下，找到当前回归路径，省了很多其他的事情。</p>
<ul>
<li>singleinstance</li>
</ul>
<p>每次开辟一个新的栈，这个在fragment中没用，因为只有唯一的一个栈在activity中。</p>
<ul>
<li>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</li>
</ul>
<p>对activity来讲，新的Activity不会在最近启动的Activity的列表中保存。对fragment来讲，就是新启动的不入栈，可以考虑设计一个固定大小的栈的时候，只有固定的几个fragment可以用于入栈，其余的都不入。不过这个设计要考虑一下，返回哪些栈。</p>
<p>实际效果可能就是切了很多个页面，最后一个回退，回退到了很久之前的一个页面。使用情景比较局限。</p>
<ul>
<li>FLAG_ACTIVITY_FORWARD_RESULT</li>
</ul>
<p>这个是startactivityforresult的标志位，同样的也可以设计一个startfragmentforresult。事实上也就是在进入这个fragment的时候，basefragment记录一下resultcode的值，然后回退的时候，将这个result值传入到栈顶即可。</p>
<ul>
<li>FLAG_ACTIVITY_NO_HISTORY</li>
</ul>
<p>单纯的不入栈的操作。</p>
<ul>
<li>FLAG_ACTIVITY_REORDER_TO_FRONT</li>
</ul>
<p>该标志位是用于启动时挪动activity栈的，对fragment同样可以设计，不过较为复杂，可以从栈内取出，重新排序之后插入。比较不好的是可能会遗漏状态。</p>
<ul>
<li>FLAG_ACTIVITY_NEW_TASK</li>
</ul>
<p>同 singinstance</p>
<ul>
<li>FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET</li>
</ul>
<p>对activity来讲，是当新进入的activity携带这个标志时，就会清理栈。fragment同样可以设计，若有个携带该标记的进入，也可以清空。虽然我目前仍然是使用老的回到最起初的fragment，不过效果可能没这个设计的好。</p>
<p>大致就这些。针对fragment设计一个单独的有特征的栈，我个人觉得是使用fragment代替activity的第一步。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/01/2018第十七周工作小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/01/2018第十七周工作小结/" itemprop="url">2018第十七周工作小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-01T23:45:39+08:00">
                2018-05-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近实在是太忙了，忙到github都忘了更新博客了。每天都在忙着需求，改bug，然后项目追着上线。累的半死不活的。</p>
<p>好消息是项目终于给整上线了，坏消息是项目上线之后可能会更忙。</p>
<p>来公司2个月还没到，一下子回到了刚毕业的时候在传音那种加班加点很累的生活方式。不过好的是，起码现在自己是在做自己的事情。</p>
<p>上周来了个大牛，技术比我厉害，也跟着他学习到了不少东西。需要整理一下。主要是http/https，okhttp工作原理，还有序列化原理等等。这些是学到的东西。</p>
<p>工作上面的总结感觉没啥好说的，有两个要写一下，一个是activity栈的工作原理，一个是fragment栈的工作原理。目前了解一些，但是不够深入。</p>
<p>明天开始仍然是进入学习的阶段。就先这样吧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/2018第十六周工作小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/2018第十六周工作小结/" itemprop="url">2018第十六周工作小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-22T17:01:05+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这周简直是崩溃的一周。</p>
<p>首先是上一周没有休息，加上上周由于假期多上了一天，导致连着9点到晚上10点多（甚至凌晨）13天，身体在周三的时候报警，整个人精神状态十分不佳，加上深陷在我写的bug中无法自拔，整个人基本上是废了的状态。</p>
<p>昨天整整睡了一天，今天精神才缓过来。</p>
<p>这一周的工作情况也不容乐观，一边开发加需求，一边修改bug，压力是在是太大，所有的东西都要我来改，十分十分的蛋疼。产品那边催，技术总监那边也在催，就是周五上线周五上线。</p>
<p>可是我能怎么办呢？我除了硬着头皮上还能做什么呢？</p>
<p>算了，额外的话不说了，说一下这周做了什么吧。</p>
<p>这周重写了购物车的缓存，针对目前的需求针对化的重写了一些方法。但是bug太多，购物车和订单2个互联的东西，写起来说实话坑还蛮多的。目前还有关于购物车的删除事件的处理行为，这个很麻烦，不知道用什么来删除，目前使用的是遍历，效率十分的低。</p>
<p>这周说实话就做了这么一些东西，下周就是埋点和功能的设计，今天还要解一些bug。难受</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/16/2018第十五周工作小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/16/2018第十五周工作小结/" itemprop="url">2018第十五周工作小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-16T14:08:02+08:00">
                2018-04-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>14周的工作小结没写，也就不写了。总结一下上一周，也就是十五周吧。</p>
<p>15周周二的时候，完成了手头的开发任务，进入到了debug状态，面对的头上很多很多的bug，亚历山大。</p>
<p>具体的bug，其实已经忘了差不多了，印象深刻的就2个，一个是当时butterknife的snapshot版本的bug，巨蛋疼，昨天能用的代码今天不能用了，还没办法搞，当时折腾了好久好久，连事件传递过程都全部debug一边，还是没查出问题。最后是涛哥反编译之后对比，才忽然发现bindviews导致的bug。</p>
<p>由于这个bug，让我的开发周期硬生生拖慢了一天，然后无休无止的折腾后续的bug，后续的bug大多数都是流程的问题，流程相关导致的bug。总体上分为两种，一种是activity切换fragment，一种是activity切activity然后切fragment，目前用的是eventbus和arouter，加上startactivity和startfragment，总结下来发现关于activity管理的fragment栈我还是不是很懂。后续需要加强。</p>
<p>其余的没啥好说的了。这一周很累，不过和在传音的时候那种没事做还被逼着加班的累却不同。</p>
<p>在其位必谋其政，有所失也必然有所得。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/12/记一次“代码过期”错误/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/记一次“代码过期”错误/" itemprop="url">记一次“代码过期”错误</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-12T23:42:00+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近太忙了，每天加班到十一点，都来不及写博客了。</p>
<p>昨天晚上9点，我完成了一个feature，结果编译结束发现apk的hosttab点击事件无效了。</p>
<p>懵逼，因为4点还是好的。</p>
<p>于是回退代码，回退到4点，发现编译好了还是这个问题。懵逼。</p>
<p>然后继续回退，回退到上次释放正确版本的地方，发现还是有这个问题，继续懵逼。</p>
<p>继续回退，回退到上个人离职的时候，发现还是有这个问题。超级懵逼。</p>
<p>也就是原本有用的代码，突然没用了。</p>
<p>排查，发现tabhost的点击事件没传下去，继续排查，发现tabhost各个子tab的点击事件没接收到，然后写父类的ontouch事件，发现父类并没有拦截，而是返回给在上面的父类了。而各个父类都没有拦截。</p>
<p>什么情况？</p>
<p>然后不知道怎么回事了，彻底懵逼了。</p>
<p>然后技术总监和我讲这种情况就应该对比二进制文件。</p>
<p>于是反编译上个版本释放的apk，对比相同代码生成的apk，发现真有问题，butterknife生成代码的时候覆盖了之前的按钮。蛋疼</p>
<p>原因是因为butterknife版本是snapshot，而有个人提交了一个错误的代码到butterknife中，导致我错误了。难受。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/05/2018第十三周工作小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/05/2018第十三周工作小结/" itemprop="url">2018第十三周工作小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-05T21:59:54+08:00">
                2018-04-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上周实在是太忙了，周六加班，周日睡了一天，结果工作小结都没有来的及写。</p>
<p>不过还是写一下吧。</p>
<p>上周主要任务是适配接口，当时想了一套wrapper来封装接口的做法。但是现在想想，那也只是一种取巧而已。其实数据结构的使用并没有那么复杂，而且在调整数据结构的时候也可以更大程度的理解流程。</p>
<p>上周整周都在调试接口中度过，刚开始还差点没来得及，后来王洋回来调，才来的及的。</p>
<p>这周他走了，在20号之前，整个项目是我一个人负责了。难受。想哭。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/04/java克隆、浅克隆、深克隆/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/04/java克隆、浅克隆、深克隆/" itemprop="url">java克隆、浅克隆、深克隆</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-04T14:29:51+08:00">
                2018-04-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h1><p>当我们需要有一个当前对象的克隆体，和当前对象完全相同的属性、功能，但又不想去仅仅创建一个对象的引用时，我们就需要对对象进行克隆。</p>
<p>克隆clone，是创建了一个一摸一样的对象。该方法是object的方法，平时用不到是因为这个方法是protect属性的。</p>
<p>需要用到clone方法的时候，直接覆盖父类的方法，定义成public，然后写super.clone()。或者直接自己写一个clone方法也可以。同时不要忘了记成clonable接口。</p>
<h1 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h1><p>被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。</p>
<p>继承自object的clone方法，就是浅克隆，除非对引用也使用clone的方法。</p>
<p>没啥大用。</p>
<h1 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h1><p>被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。</p>
<p>深克隆可以使用序列化的方法。</p>
<p>精髓主要是将对象写入流中，然后在从流中都取出来。这样就实现了一个对象的深克隆。</p>
<p>前提是对象都是序列化的，不论成员还是引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Object deepClone() throws IOException,OptionalDataException,ClassNotFoundException&#123;//将对象写到流里</span><br><span class="line">ByteArrayOutoutStream bo=new ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream oo=new ObjectOutputStream(bo);</span><br><span class="line">oo.writeObject(this);//从流里读出来</span><br><span class="line">ByteArrayInputStream bi=new ByteArrayInputStream(bo.toByteArray());</span><br><span class="line">ObjectInputStream oi=new ObjectInputStream(bi);</span><br><span class="line">return(oi.readObject());</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/01/LruCache缓存源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/01/LruCache缓存源码解析/" itemprop="url">LruCache缓存源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-01T12:26:43+08:00">
                2018-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以前曾经在volley中使用networkimageview的时候使用过lrucache，当时以为这只是一个第三方的开源框架。昨天在网上找安卓的缓存框架的时候看到了lrucache，居然是android.util包下面的。所以这次就着源码看看是个怎么缓存的原理。</p>
<h1 id="类解释"><a href="#类解释" class="headerlink" title="类解释"></a>类解释</h1><p>首先看一下这个类官方的解释。</p>
<ul>
<li>A cache that holds strong references to a limited number of values. Each time</li>
<li>a value is accessed, it is moved to the head of a queue. When a value is</li>
<li>added to a full cache, the value at the end of that queue is evicted and may</li>
<li>become eligible for garbage collection.</li>
</ul>
<p>这个类是一个用于对有限的值持有强引用的缓存类。</p>
<p>每次一个值被获取了，它将被挪到队列的头部。</p>
<p>每当一个值被加入完全缓存（full-cache,完全缓存模式，讲一个对象完全的加载到内存中，而非只加载其映射关系。对应的还有Partial Cache，部分缓存模式，部分缓存模式多数用于加载对象的部分，用于判断对象是否曾经加载过，或者是否需要再次加载），缓存队列末尾的值将会被驱逐，丢失了强引用的关系，就会变得可以被gc清除。</p>
<ul>
<li><p>If your cached values hold resources that need to be explicitly released,</p></li>
<li>override {@link #entryRemoved}.</li>
</ul>
<p>如果希望避免部分资源被lrucache缓存，可以继承entryremoved</p>
<ul>
<li><p>If a cache miss should be computed on demand for the corresponding keys,</p></li>
<li>override {@link #create}. This simplifies the calling code, allowing it to</li>
<li>assume a value will always be returned, even when there’s a cache miss.</li>
</ul>
<p>如果需要对一个响应返回一个完整的缓存，但是这个缓存目前是缺失状态，可以继承create方法，这样可以使得针对这个响应总是可以有回应，即时目前是缓存缺失的状态，也可以构造一个回应。</p>
<ul>
<li><p>By default, the cache size is measured in the number of entries. Override</p></li>
<li>{@link #sizeOf} to size the cache in different units. For example, this cache</li>
<li>is limited to 4MiB of bitmaps:</li>
<li><pre>   {@code</pre></li>
<li>int cacheSize = 4 <em> 1024 </em> 1024; // 4MiB</li>
<li>LruCache&lt;String, Bitmap&gt; bitmapCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {</li>
<li>protected int sizeOf(String key, Bitmap value) {</li>
<li>return value.getByteCount();</li>
<li>}</li>
<li>}}</li>
</ul>
<p>缓存的数量是通过对象的数量来确定的。继承sizeOf方法可以使用不同的单位来计算缓存。（该方法提供的例子是用于限制缓存，那缓存不够怎么办？一张bitmap一般有8m啊？事实上它并不会精确计算占用的内存，只能说你说a有3m，总共给30m的缓存的话，他就会放最多10个a，事实上a并不一定只有3m，当然这也没必要关心，在不同的地方自己精确赋一下就好了）</p>
<ul>
<li><p>This class is thread-safe. Perform multiple cache operations atomically by</p></li>
<li>synchronizing on the cache: <pre>   {@code</pre></li>
<li>synchronized (cache) {</li>
<li>if (cache.get(key) == null) {</li>
<li>cache.put(key, value);</li>
<li>}</li>
<li>}}</li>
</ul>
<p>该类是线程安全的，主要是对缓存操作的部分都加了锁。</p>
<ul>
<li><p>This class does not allow null to be used as a key or value. A return</p></li>
<li>value of null from {@link #get}, {@link #put} or {@link #remove} is</li>
<li>unambiguous: the key was not in the cache.</li>
</ul>
<p>该类不允许空指针被使用作为key或者value。</p>
<ul>
<li><p>This class appeared in Android 3.1 (Honeycomb MR1); it’s available as part</p></li>
<li>of <a href="http://developer.android.com/sdk/compatibility-library.html" target="_blank" rel="noopener">Android’s</a></li>
<li>Support Package for earlier releases.</li>
</ul>
<p>该类在android3.1出现。</p>
<h1 id="源码探究"><a href="#源码探究" class="headerlink" title="源码探究"></a>源码探究</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final LinkedHashMap&lt;K, V&gt; map;</span><br></pre></td></tr></table></figure>
<p> 使用了linkedHashMap的方法来存储数据。有向图就是强引用方式，key在，value在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/** Size of this cache in units. Not necessarily the number of elements. */</span><br><span class="line">private int size;</span><br><span class="line">   private int maxSize;</span><br><span class="line"></span><br><span class="line">   private int putCount;</span><br><span class="line">   private int createCount;</span><br><span class="line">   private int evictionCount;</span><br><span class="line">   private int hitCount;</span><br><span class="line">   private int missCount;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param maxSize for caches that do not override &#123;@link #sizeOf&#125;, this is</span><br><span class="line"> *     the maximum number of entries in the cache. For all other caches,</span><br><span class="line"> *     this is the maximum sum of the sizes of the entries in this cache.</span><br><span class="line"> */</span><br><span class="line">public LruCache(int maxSize) &#123;</span><br><span class="line">    if (maxSize &lt;= 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.maxSize = maxSize;</span><br><span class="line">    this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方面需要给一个maxSize，该参数是用于在为定义sizeof的对象计算容量大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Sets the size of the cache.</span><br><span class="line"> *</span><br><span class="line"> * @param maxSize The new maximum size.</span><br><span class="line"> */</span><br><span class="line">public void resize(int maxSize) &#123;</span><br><span class="line">    if (maxSize &lt;= 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    trimToSize(maxSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新设计maxsize</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns the value for &#123;@code key&#125; if it exists in the cache or can be</span><br><span class="line"> * created by &#123;@code #create&#125;. If a value was returned, it is moved to the</span><br><span class="line"> * head of the queue. This returns null if a value is not cached and cannot</span><br><span class="line"> * be created.</span><br><span class="line"> */</span><br><span class="line">public final V get(K key) &#123;</span><br><span class="line">    if (key == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;key == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V mapValue;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        mapValue = map.get(key);</span><br><span class="line">        if (mapValue != null) &#123;</span><br><span class="line">            hitCount++;</span><br><span class="line">            return mapValue;</span><br><span class="line">        &#125;</span><br><span class="line">        missCount++;</span><br><span class="line">    &#125;</span><br><span class="line">     /*</span><br><span class="line">     * Attempt to create a value. This may take a long time, and the map</span><br><span class="line">     * may be different when create() returns. If a conflicting value was</span><br><span class="line">     * added to the map while create() was working, we leave that value in</span><br><span class="line">     * the map and release the created value.</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    V createdValue = create(key);</span><br><span class="line">    if (createdValue == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        createCount++;</span><br><span class="line">        mapValue = map.put(key, createdValue);</span><br><span class="line"></span><br><span class="line">        if (mapValue != null) &#123;</span><br><span class="line">            // There was a conflict so undo that last put</span><br><span class="line">            map.put(key, mapValue);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            size += safeSizeOf(key, createdValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mapValue != null) &#123;</span><br><span class="line">        entryRemoved(false, key, createdValue, mapValue);</span><br><span class="line">        return mapValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        trimToSize(maxSize);</span><br><span class="line">        return createdValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get的时候加锁，每次有返回的话，hitcount自增。没有返回代表是缺失缓存，misscount自增。</p>
<p>若找不到值，会调用createvalue来创建，创建成功，createcount自增，失败就代表没有该缓存内容，直接终端。创建成功同时加入到map里面，map的size会增加。</p>
<p>创建出来的mapvalue会执行entryremoved的检查，对有设置过不加入的参数进行操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Called for entries that have been evicted or removed. This method is</span><br><span class="line"> * invoked when a value is evicted to make space, removed by a call to</span><br><span class="line"> * &#123;@link #remove&#125;, or replaced by a call to &#123;@link #put&#125;. The default</span><br><span class="line"> * implementation does nothing.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;The method is called without synchronization: other threads may</span><br><span class="line"> * access the cache while this method is executing.</span><br><span class="line"> *</span><br><span class="line"> * @param evicted true if the entry is being removed to make space, false</span><br><span class="line"> *     if the removal was caused by a &#123;@link #put&#125; or &#123;@link #remove&#125;.</span><br><span class="line"> * @param newValue the new value for &#123;@code key&#125;, if it exists. If non-null,</span><br><span class="line"> *     this removal was caused by a &#123;@link #put&#125;. Otherwise it was caused by</span><br><span class="line"> *     an eviction or a &#123;@link #remove&#125;.</span><br><span class="line"> */</span><br><span class="line">protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>entryRemoved的方法准确的说法是用于吊起被驱逐和移除的对象。确保key对应的value可以是正确的，newvalue为空的话就代表是移除老的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Remove the eldest entries until the total of remaining entries is at or</span><br><span class="line"> * below the requested size.</span><br><span class="line"> *</span><br><span class="line"> * @param maxSize the maximum size of the cache before returning. May be -1</span><br><span class="line"> *            to evict even 0-sized elements.</span><br><span class="line"> */</span><br><span class="line">public void trimToSize(int maxSize) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123;</span><br><span class="line">                throw new IllegalStateException(getClass().getName()</span><br><span class="line">                        + &quot;.sizeOf() is reporting inconsistent results!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (size &lt;= maxSize) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Map.Entry&lt;K, V&gt; toEvict = map.eldest();</span><br><span class="line">            if (toEvict == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            key = toEvict.getKey();</span><br><span class="line">            value = toEvict.getValue();</span><br><span class="line">            map.remove(key);</span><br><span class="line">            size -= safeSizeOf(key, value);</span><br><span class="line">            evictionCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        entryRemoved(true, key, value, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>trimToSize方法是针对目前队列中的对象，移除最老的。移除的操作就是移除了key，去掉强引用的部分。移除完之后要减去移除的大小，之后移除数自增，确保安全之后将之前的key，映射关系改为一个null，这个移除的数量并不是固定的，这是一个死循环，会移除到size小于maxsize，或者最老的是空。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Removes the entry for &#123;@code key&#125; if it exists.</span><br><span class="line"> *</span><br><span class="line"> * @return the previous value mapped by &#123;@code key&#125;.</span><br><span class="line"> */</span><br><span class="line">public final V remove(K key) &#123;</span><br><span class="line">    if (key == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;key == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V previous;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        previous = map.remove(key);</span><br><span class="line">        if (previous != null) &#123;</span><br><span class="line">            size -= safeSizeOf(key, previous);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (previous != null) &#123;</span><br><span class="line">        entryRemoved(false, key, previous, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>remove操作和之前的那个操作几乎一样，移除，如果曾经存在就在此赋空。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Clear the cache, calling &#123;@link #entryRemoved&#125; on each removed entry.</span><br><span class="line"> */</span><br><span class="line">public final void evictAll() &#123;</span><br><span class="line">    trimToSize(-1); // -1 will evict 0-sized elements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是移除所有的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override public synchronized final String toString() &#123;</span><br><span class="line">    int accesses = hitCount + missCount;</span><br><span class="line">    int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;</span><br><span class="line">    return String.format(&quot;LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]&quot;,</span><br><span class="line">            maxSize, hitCount, missCount, hitPercent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>toString方法可以看到状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns a copy of the current contents of the cache, ordered from least</span><br><span class="line"> * recently accessed to most recently accessed.</span><br><span class="line"> */</span><br><span class="line">public synchronized final Map&lt;K, V&gt; snapshot() &#123;</span><br><span class="line">    return new LinkedHashMap&lt;K, V&gt;(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>snapshot直接一个以自己map构造的对象。（这种避免返回自身的操作值得学习）</p>
<h1 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h1><p>整个LruCache的作用，说到底就是针对gc的树状搜索删除算法的一种方案。<br>但是我们平时使用的时候，需要针对几个地方进行定制，一是sizeof,二是removeentry。</p>
<p>整个缓存还是在内存中的，所以lrucache是一种内存缓存框架。</p>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>value最好放软应用对象，确保释放之后的第一次gc就可以回收。<br>设置maxsize，可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().maxMemory()</span><br></pre></td></tr></table></figure></p>
<p>也可针对不同情况进行设置。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sample</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">99</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sample</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
