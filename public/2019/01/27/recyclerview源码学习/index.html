<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="android," />










<meta name="description" content="绘制过程绘制过程需要理解的是如何一个itemview一个itemview的绘制 onMeasure12345678910111213141516171819202122232425262728293031323334353637383940414243protected void onMeasure(int widthSpec, int heightSpec) &amp;#123;        if (">
<meta name="keywords" content="android">
<meta property="og:type" content="article">
<meta property="og:title" content="recyclerview源码学习">
<meta property="og:url" content="http://yoursite.com/2019/01/27/recyclerview源码学习/index.html">
<meta property="og:site_name" content="记录者">
<meta property="og:description" content="绘制过程绘制过程需要理解的是如何一个itemview一个itemview的绘制 onMeasure12345678910111213141516171819202122232425262728293031323334353637383940414243protected void onMeasure(int widthSpec, int heightSpec) &amp;#123;        if (">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/android/recyclerview缓存模型.jpg">
<meta property="og:updated_time" content="2019-02-12T13:42:33.434Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="recyclerview源码学习">
<meta name="twitter:description" content="绘制过程绘制过程需要理解的是如何一个itemview一个itemview的绘制 onMeasure12345678910111213141516171819202122232425262728293031323334353637383940414243protected void onMeasure(int widthSpec, int heightSpec) &amp;#123;        if (">
<meta name="twitter:image" content="http://yoursite.com/images/android/recyclerview缓存模型.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/01/27/recyclerview源码学习/"/>





  <title>recyclerview源码学习 | 记录者</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">记录者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/27/recyclerview源码学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">recyclerview源码学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-27T17:50:30+08:00">
                2019-01-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="绘制过程"><a href="#绘制过程" class="headerlink" title="绘制过程"></a>绘制过程</h1><p>绘制过程需要理解的是如何一个itemview一个itemview的绘制</p>
<h2 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">protected void onMeasure(int widthSpec, int heightSpec) &#123;</span><br><span class="line">        if (mLayout == null) &#123;</span><br><span class="line">            //layoutManager没有设置的话，直接走default的方法，所以会为空白</span><br><span class="line">            defaultOnMeasure(widthSpec, heightSpec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mLayout.mAutoMeasure) &#123;</span><br><span class="line">            final boolean skipMeasure = widthMode == MeasureSpec.EXACTLY</span><br><span class="line">                    &amp;&amp; heightMode == MeasureSpec.EXACTLY;</span><br><span class="line">            //如果测量是绝对值，则跳过measure过程直接走layout</span><br><span class="line">            if (skipMeasure || mAdapter == null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">                //mLayoutStep默认值是 State.STEP_START</span><br><span class="line">                dispatchLayoutStep1();</span><br><span class="line">                //执行完dispatchLayoutStep1()后是State.STEP_LAYOUT</span><br><span class="line">            &#125;</span><br><span class="line">             ..........</span><br><span class="line">            //真正执行LayoutManager绘制的地方</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">            //执行完后是State.STEP_ANIMATIONS</span><br><span class="line">             ..........</span><br><span class="line">            //宽高都不确定的时候，会绘制两次</span><br><span class="line">            // if RecyclerView has non-exact width and height and if there is at least one child</span><br><span class="line">            // which also has non-exact width &amp; height, we have to re-measure.</span><br><span class="line">            if (mLayout.shouldMeasureTwice()) &#123;</span><br><span class="line">             ..........</span><br><span class="line">                dispatchLayoutStep2();</span><br><span class="line">             ..........            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (mHasFixedSize) &#123;</span><br><span class="line">                mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">             ..........</span><br><span class="line">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">             ..........</span><br><span class="line">            mState.mInPreLayout = false; // clear</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">--------------------- </span><br><span class="line">别人概括的measure过程</span><br></pre></td></tr></table></figure>
<p>从这里大概分为三步，毕竟三个else</p>
<h3 id="layout-null"><a href="#layout-null" class="headerlink" title="layout == null"></a>layout == null</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void defaultOnMeasure(int widthSpec, int heightSpec) &#123;</span><br><span class="line">        // calling LayoutManager here is not pretty but that API is already public and it is better</span><br><span class="line">        // than creating another method since this is internal.</span><br><span class="line">        final int width = LayoutManager.chooseSize(widthSpec,</span><br><span class="line">                getPaddingLeft() + getPaddingRight(),</span><br><span class="line">                ViewCompat.getMinimumWidth(this));</span><br><span class="line">        final int height = LayoutManager.chooseSize(heightSpec,</span><br><span class="line">                getPaddingTop() + getPaddingBottom(),</span><br><span class="line">                ViewCompat.getMinimumHeight(this));</span><br><span class="line">        setMeasuredDimension(width, height);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static int chooseSize(int spec, int desired, int min) &#123;</span><br><span class="line">            int mode = MeasureSpec.getMode(spec);</span><br><span class="line">            int size = MeasureSpec.getSize(spec);</span><br><span class="line">            switch(mode) &#123;</span><br><span class="line">            case -2147483648:</span><br><span class="line">                return Math.min(size, Math.max(desired, min));</span><br><span class="line">            case 0:</span><br><span class="line">            default:</span><br><span class="line">                return Math.max(desired, min);</span><br><span class="line">            case 1073741824:</span><br><span class="line">                return size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下面其实是处理了一下高度的问题，如果有padding的话，会将padding归入计算</p>
<h3 id="mlayout-null-amp-amp-mLayout-isAutoMeasureEnabled"><a href="#mlayout-null-amp-amp-mLayout-isAutoMeasureEnabled" class="headerlink" title="mlayout != null &amp;&amp;  mLayout.isAutoMeasureEnabled()"></a>mlayout != null &amp;&amp;  mLayout.isAutoMeasureEnabled()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean isAutoMeasureEnabled() &#123;</span><br><span class="line">            return mAutoMeasure;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">         * Defines whether the measuring pass of layout should use the AutoMeasure mechanism of</span><br><span class="line">         * &#123;@link RecyclerView&#125; or if it should be done by the LayoutManager&apos;s implementation of</span><br><span class="line">         * &#123;@link LayoutManager#onMeasure(Recycler, State, int, int)&#125;.</span><br><span class="line">         *</span><br><span class="line">         * @param enabled &lt;code&gt;True&lt;/code&gt; if layout measurement should be done by the</span><br><span class="line">         *                RecyclerView, &lt;code&gt;false&lt;/code&gt; if it should be done by this</span><br><span class="line">         *                LayoutManager.</span><br><span class="line">         *</span><br><span class="line">         * @see #isAutoMeasureEnabled()</span><br><span class="line">         *</span><br><span class="line">         * @deprecated Implementors of LayoutManager should define whether or not it uses</span><br><span class="line">         *             AutoMeasure by overriding &#123;@link #isAutoMeasureEnabled()&#125;.</span><br><span class="line">         */</span><br><span class="line">        @Deprecated</span><br><span class="line">        public void setAutoMeasureEnabled(boolean enabled) &#123;</span><br><span class="line">            mAutoMeasure = enabled;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这个api是deprecate的，其功能主要是设置自动测量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">if (mLayout.mAutoMeasure) &#123;</span><br><span class="line">            final int widthMode = MeasureSpec.getMode(widthSpec);</span><br><span class="line">            final int heightMode = MeasureSpec.getMode(heightSpec);</span><br><span class="line">            final boolean skipMeasure = widthMode == MeasureSpec.EXACTLY</span><br><span class="line">                    &amp;&amp; heightMode == MeasureSpec.EXACTLY;</span><br><span class="line">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">            if (skipMeasure || mAdapter == null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">                dispatchLayoutStep1();</span><br><span class="line">            &#125;</span><br><span class="line">            // set dimensions in 2nd step. Pre-layout should happen with old dimensions for</span><br><span class="line">            // consistency</span><br><span class="line">            mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class="line">            mState.mIsMeasuring = true;</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line"></span><br><span class="line">            // now we can get the width and height from the children.</span><br><span class="line">            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">            // if RecyclerView has non-exact width and height and if there is at least one child</span><br><span class="line">            // which also has non-exact width &amp; height, we have to re-measure.</span><br><span class="line">            if (mLayout.shouldMeasureTwice()) &#123;</span><br><span class="line">                mLayout.setMeasureSpecs(</span><br><span class="line">                        MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),</span><br><span class="line">                        MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));</span><br><span class="line">                mState.mIsMeasuring = true;</span><br><span class="line">                dispatchLayoutStep2();</span><br><span class="line">                // now we can get the width and height from the children.</span><br><span class="line">                mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>如果测量是绝对值，则不再进行measure而直接layout，毕竟EXACTLY是写死了面积了，recyclerview的父类会直接获取面积来摆放</p>
</li>
<li><p>STATE变量为start时</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final int STEP_START = 1;</span><br><span class="line">static final int STEP_LAYOUT = 1 &lt;&lt; 1;</span><br><span class="line">static final int STEP_ANIMATIONS = 1 &lt;&lt; 2;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * The first step of a layout where we;</span><br><span class="line">     * - process adapter updates</span><br><span class="line">     * - decide which animation should run</span><br><span class="line">     * - save information about current views</span><br><span class="line">     * - If necessary, run predictive layout and save its information</span><br><span class="line">     */</span><br><span class="line">    private void dispatchLayoutStep1() &#123;</span><br><span class="line">        mState.assertLayoutStep(State.STEP_START);</span><br><span class="line">        fillRemainingScrollValues(mState);</span><br><span class="line">        mState.mIsMeasuring = false;</span><br><span class="line">        startInterceptRequestLayout();</span><br><span class="line">        mViewInfoStore.clear();</span><br><span class="line">        onEnterLayoutOrScroll();</span><br><span class="line">        processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">        saveFocusInfo();</span><br><span class="line">        mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations &amp;&amp; mItemsChanged;</span><br><span class="line">        mItemsAddedOrRemoved = mItemsChanged = false;</span><br><span class="line">        mState.mInPreLayout = mState.mRunPredictiveAnimations;</span><br><span class="line">        mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">        findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);</span><br><span class="line"></span><br><span class="line">        if (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">            // Step 0: Find out where all non-removed items are, pre-layout</span><br><span class="line">            int count = mChildHelper.getChildCount();</span><br><span class="line">            for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">                final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">                if (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                final ItemHolderInfo animationInfo = mItemAnimator</span><br><span class="line">                        .recordPreLayoutInformation(mState, holder,</span><br><span class="line">                                ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),</span><br><span class="line">                                holder.getUnmodifiedPayloads());</span><br><span class="line">                mViewInfoStore.addToPreLayout(holder, animationInfo);</span><br><span class="line">                if (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved()</span><br><span class="line">                        &amp;&amp; !holder.shouldIgnore() &amp;&amp; !holder.isInvalid()) &#123;</span><br><span class="line">                    long key = getChangedHolderKey(holder);</span><br><span class="line">                    // This is NOT the only place where a ViewHolder is added to old change holders</span><br><span class="line">                    // list. There is another case where:</span><br><span class="line">                    //    * A VH is currently hidden but not deleted</span><br><span class="line">                    //    * The hidden item is changed in the adapter</span><br><span class="line">                    //    * Layout manager decides to layout the item in the pre-Layout pass (step1)</span><br><span class="line">                    // When this case is detected, RV will un-hide that view and add to the old</span><br><span class="line">                    // change holders list.</span><br><span class="line">                    mViewInfoStore.addToOldChangeHolders(key, holder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">            // Step 1: run prelayout: This will use the old positions of items. The layout manager</span><br><span class="line">            // is expected to layout everything, even removed items (though not to add removed</span><br><span class="line">            // items back to the container). This gives the pre-layout position of APPEARING views</span><br><span class="line">            // which come into existence as part of the real layout.</span><br><span class="line"></span><br><span class="line">            // Save old positions so that LayoutManager can run its mapping logic.</span><br><span class="line">            saveOldPositions();</span><br><span class="line">            final boolean didStructureChange = mState.mStructureChanged;</span><br><span class="line">            mState.mStructureChanged = false;</span><br><span class="line">            // temporarily disable flag because we are asking for previous layout</span><br><span class="line">            mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">            mState.mStructureChanged = didStructureChange;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; mChildHelper.getChildCount(); ++i) &#123;</span><br><span class="line">                final View child = mChildHelper.getChildAt(i);</span><br><span class="line">                final ViewHolder viewHolder = getChildViewHolderInt(child);</span><br><span class="line">                if (viewHolder.shouldIgnore()) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!mViewInfoStore.isInPreLayout(viewHolder)) &#123;</span><br><span class="line">                    int flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder);</span><br><span class="line">                    boolean wasHidden = viewHolder</span><br><span class="line">                            .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</span><br><span class="line">                    if (!wasHidden) &#123;</span><br><span class="line">                        flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;</span><br><span class="line">                    &#125;</span><br><span class="line">                    final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(</span><br><span class="line">                            mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads());</span><br><span class="line">                    if (wasHidden) &#123;</span><br><span class="line">                        recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // we don&apos;t process disappearing list because they may re-appear in post layout pass.</span><br><span class="line">            clearOldPositions();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            clearOldPositions();</span><br><span class="line">        &#125;</span><br><span class="line">        onExitLayoutOrScroll();</span><br><span class="line">        stopInterceptRequestLayout(false);</span><br><span class="line">        mState.mLayoutStep = State.STEP_LAYOUT;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从备注的内容中可以知道，这个步骤有四个功能</p>
<ul>
<li>处理adapter的更新</li>
<li>决定哪些动画需要执行</li>
<li>保存当前view的信息</li>
<li>如果必要的情况下，执行上一个layout的操作并且保存他的信息</li>
</ul>
<p>该步骤只是做了准备工作</p>
<ol>
<li>state不为start时</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * The second layout step where we do the actual layout of the views for the final state.</span><br><span class="line">    * This step might be run multiple times if necessary (e.g. measure).</span><br><span class="line">    */</span><br><span class="line">   private void dispatchLayoutStep2() &#123;</span><br><span class="line">       startInterceptRequestLayout();</span><br><span class="line">       onEnterLayoutOrScroll();</span><br><span class="line">       mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);</span><br><span class="line">       mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">       mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">       mState.mDeletedInvisibleItemCountSincePreviousLayout = 0;</span><br><span class="line"></span><br><span class="line">       // Step 2: Run layout</span><br><span class="line">       mState.mInPreLayout = false;</span><br><span class="line">       mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line"></span><br><span class="line">       mState.mStructureChanged = false;</span><br><span class="line">       mPendingSavedState = null;</span><br><span class="line"></span><br><span class="line">       // onLayoutChildren may have caused client code to disable item animations; re-check</span><br><span class="line">       mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != null;</span><br><span class="line">       mState.mLayoutStep = State.STEP_ANIMATIONS;</span><br><span class="line">       onExitLayoutOrScroll();</span><br><span class="line">       stopInterceptRequestLayout(false);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里的分析需要细致一些，着重点在mLayout.onLayoutChildren()内，绘制的工作交给了layoutmanager</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</span><br><span class="line">        // layout algorithm:</span><br><span class="line">        //找寻锚点</span><br><span class="line">        // 1) by checking children and other variables, find an anchor coordinate and an anchor</span><br><span class="line">        // item position.</span><br><span class="line">        //两个方向填充，从锚点往上，从锚点往下</span><br><span class="line">        // 2) fill towards start, stacking from bottom</span><br><span class="line">        // 3) fill towards end, stacking from top</span><br><span class="line">        // 4) scroll to fulfill requirements like stack from bottom.</span><br><span class="line">        // create layout state</span><br><span class="line">        ....</span><br><span class="line">        // resolve layout direction</span><br><span class="line">        //判断绘制方向,给mShouldReverseLayout赋值,默认是正向绘制，则mShouldReverseLayout是false</span><br><span class="line">        resolveShouldLayoutReverse();</span><br><span class="line">        final View focused = getFocusedChild();</span><br><span class="line">        //mValid的默认值是false，一次测量之后设为true，onLayout完成后会回调执行reset方法，又变为false</span><br><span class="line">        if (!mAnchorInfo.mValid || mPendingScrollPosition != NO_POSITION</span><br><span class="line">                || mPendingSavedState != null) &#123;</span><br><span class="line">        ....</span><br><span class="line">            //mStackFromEnd默认是false，除非手动调用setStackFromEnd()方法，两个都会false，异或则为false</span><br><span class="line">            mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;</span><br><span class="line">            // calculate anchor position and coordinate</span><br><span class="line">            //计算锚点的位置和偏移量</span><br><span class="line">            updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</span><br><span class="line">        ....</span><br><span class="line">        &#125; else if (focused != null &amp;&amp; (mOrientationHelper.getDecoratedStart(focused)</span><br><span class="line">                &gt;= mOrientationHelper.getEndAfterPadding()</span><br><span class="line">                || mOrientationHelper.getDecoratedEnd(focused)</span><br><span class="line">                &lt;= mOrientationHelper.getStartAfterPadding())) &#123;</span><br><span class="line">         ....</span><br><span class="line">        &#125;</span><br><span class="line">         ....</span><br><span class="line">        //mLayoutFromEnd为false</span><br><span class="line">        if (mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">            //倒着绘制的话，先往上绘制，再往下绘制</span><br><span class="line">            // fill towards start</span><br><span class="line">            // 从锚点到往上</span><br><span class="line">            updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">            ....</span><br><span class="line">            fill(recycler, mLayoutState, state, false);</span><br><span class="line">            ....</span><br><span class="line">            // 从锚点到往下</span><br><span class="line">            // fill towards end</span><br><span class="line">            updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">            ....</span><br><span class="line">            //调两遍fill方法</span><br><span class="line">            fill(recycler, mLayoutState, state, false);</span><br><span class="line">            ....</span><br><span class="line">            if (mLayoutState.mAvailable &gt; 0) &#123;</span><br><span class="line">                // end could not consume all. add more items towards start</span><br><span class="line">            ....</span><br><span class="line">                updateLayoutStateToFillStart(firstElement, startOffset);</span><br><span class="line">                mLayoutState.mExtra = extraForStart;</span><br><span class="line">                fill(recycler, mLayoutState, state, false);</span><br><span class="line">             ....</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //正常绘制流程的话，先往下绘制，再往上绘制</span><br><span class="line">            // fill towards end</span><br><span class="line">            updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">            ....</span><br><span class="line">            fill(recycler, mLayoutState, state, false);</span><br><span class="line">             ....</span><br><span class="line">            // fill towards start</span><br><span class="line">            updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">            ....</span><br><span class="line">            fill(recycler, mLayoutState, state, false);</span><br><span class="line">             ....</span><br><span class="line">            if (mLayoutState.mAvailable &gt; 0) &#123;</span><br><span class="line">                ....</span><br><span class="line">                // start could not consume all it should. add more items towards end</span><br><span class="line">                updateLayoutStateToFillEnd(lastElement, endOffset);</span><br><span class="line">                 ....</span><br><span class="line">                fill(recycler, mLayoutState, state, false);</span><br><span class="line">                ....</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">        layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);</span><br><span class="line">        //完成后重置参数</span><br><span class="line">        if (!state.isPreLayout()) &#123;</span><br><span class="line">            mOrientationHelper.onLayoutComplete();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mAnchorInfo.reset();</span><br><span class="line">        &#125;</span><br><span class="line">        mLastStackFromEnd = mStackFromEnd;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>摘抄了别人分析的内容，很明显，这是linearlayoutmanager一个完整的layout的过程，说实话真的很复杂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">先寻找页面当前的锚点 </span><br><span class="line">以这个锚点未基准，向上和向下分别填充 </span><br><span class="line">填充完后，如果还有剩余的可填充大小，再填充一次</span><br></pre></td></tr></table></figure>
<p>从这个角度来讲，可以大致理解为绘制的顺序，是首先绘制可见区域及以下的内容，而后绘制可见区域以上的内容，这个上下会依据重心来变化</p>
<p>以前listview的绘制，大概也是差不多的，不过listview有个细节，是不设定数量的情况下，只绘制可见区域及上下加起来7个大小。分析recyclerview的源码发现，其绘制的区域仅仅是可见区域，如果需要预先绘制的话，需要自己制定预先加载的数量，其中的差别体现的还是比较明显的，因为layoutmanager需要考虑绘制的时候的动画。</p>
<h3 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    if (mHasFixedSize) &#123;</span><br><span class="line">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // custom onMeasure</span><br><span class="line">    if (mAdapterUpdateDuringMeasure) &#123;</span><br><span class="line">        startInterceptRequestLayout();</span><br><span class="line">        onEnterLayoutOrScroll();</span><br><span class="line">        processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">        onExitLayoutOrScroll();</span><br><span class="line"></span><br><span class="line">        if (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">            mState.mInPreLayout = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // consume remaining updates to provide a consistent state with the layout pass.</span><br><span class="line">            mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">            mState.mInPreLayout = false;</span><br><span class="line">        &#125;</span><br><span class="line">        mAdapterUpdateDuringMeasure = false;</span><br><span class="line">        stopInterceptRequestLayout(false);</span><br><span class="line">    &#125; else if (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">        // If mAdapterUpdateDuringMeasure is false and mRunPredictiveAnimations is true:</span><br><span class="line">        // this means there is already an onMeasure() call performed to handle the pending</span><br><span class="line">        // adapter change, two onMeasure() calls can happen if RV is a child of LinearLayout</span><br><span class="line">        // with layout_width=MATCH_PARENT. RV cannot call LM.onMeasure() second time</span><br><span class="line">        // because getViewForPosition() will crash when LM uses a child to measure.</span><br><span class="line">        setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight());</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mAdapter != null) &#123;</span><br><span class="line">        mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mState.mItemCount = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    startInterceptRequestLayout();</span><br><span class="line">    mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">    stopInterceptRequestLayout(false);</span><br><span class="line">    mState.mInPreLayout = false; // clear</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一步是当recyclerview没有设置<strong>mLayout.isAutoMeasureEnabled()</strong>的时候出现的，默认情况下走的就是这一步。</p>
<p>这一步的含义是将绘制权直接交于layoutmanager来绘制，有个细节，就是如果期望绘制的过程由recyclerview内部来进行的话，就不要再重写layoutmanager的onmeasure了。不过对于我们这种大多数时候直接调用linearlayoutmanager的，平时不会太注意这个。</p>
<p>回到这一步上来，大概做了这样几件事</p>
<ol>
<li>当设置了hasfixedsize时</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * RecyclerView can perform several optimizations if it can know in advance that RecyclerView&apos;s</span><br><span class="line">     * size is not affected by the adapter contents. RecyclerView can still change its size based</span><br><span class="line">     * on other factors (e.g. its parent&apos;s size) but this size calculation cannot depend on the</span><br><span class="line">     * size of its children or contents of its adapter (except the number of items in the adapter).</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * If your use of RecyclerView falls into this category, set this to &#123;@code true&#125;. It will allow</span><br><span class="line">     * RecyclerView to avoid invalidating the whole layout when its adapter contents change.</span><br><span class="line">     *</span><br><span class="line">     * @param hasFixedSize true if adapter changes cannot affect the size of the RecyclerView.</span><br><span class="line">     */</span><br></pre></td></tr></table></figure>
<p>也就是当item的大小是固定的，不会出现根据adapter的内容变化的布局，这样recyclerview就会依据某些参数固定下来他的尺寸，并不会在参考其内部数据变化而计算出来的尺寸。算是<strong>优化</strong>的一个注意点</p>
<p>设置了这个参数之后，就会直接甩手给layoutmanager进行onmeasure操作</p>
<ol>
<li>未设置hasfixedsize时 &amp;&amp; adapter在onmeasure过程中正在更新</li>
</ol>
<p>此时只会做一些状态的更改，lock的重入这样。其lock的标记位实在是太多了，不过的确没有做什么事情，不过此过程如果进行，会跳转到第四步继续下去</p>
<ol>
<li>未设置hasfixedsize时 &amp;&amp; adapter 不在更新 &amp;&amp; 目前的状态处在更新之前的动画时</li>
</ol>
<p>此时会在更新完前一个item动画之后在更新自己，所以此时只做了一个动作，就是提前将宽高的measurespec设置完毕</p>
<ol>
<li>以上都没有的情况下</li>
</ol>
<p>首先会调用layoutmanager的onmeasure，之后会清除状态位。</p>
<h4 id="最后一步的一个总结"><a href="#最后一步的一个总结" class="headerlink" title="最后一步的一个总结"></a>最后一步的一个总结</h4><p>为什么hasfixedsize起作用呢？</p>
<p>因为当未设置这个的时候，会等待adapter更新结束才会绘制，而adapter的更新会有一系列的等待，等待数据处理结束之后，才会再次做一个更新的操作。<br>而设置了hasfixedsize之后，就不会等待更新了，而是会直接进行绘制。</p>
<p>另外拷一份关于这个的别人的总结</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">总结：当我们确定Item的改变不会影响RecyclerView的宽高的时候可以设置setHasFixedSize(true)，并通过Adapter的增删改插方法去刷新RecyclerView，而不是通过notifyDataSetChanged()。（其实可以直接设置为true，当需要改变宽高的时候就用notifyDataSetChanged()去整体刷新一下）</span><br><span class="line">--------------------- </span><br><span class="line">作者：wsdaijianjun </span><br><span class="line">来源：CSDN </span><br><span class="line">原文：https://blog.csdn.net/wsdaijianjun/article/details/74735039 </span><br><span class="line">版权声明：本文为博主原创文章，转载请附上博文链接！</span><br></pre></td></tr></table></figure>
<h2 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">    ...</span><br><span class="line">    dispatchLayout();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Wrapper around layoutChildren() that handles animating changes caused by layout.</span><br><span class="line">     * Animations work on the assumption that there are five different kinds of items</span><br><span class="line">     * in play:</span><br><span class="line">     * PERSISTENT: items are visible before and after layout</span><br><span class="line">     * REMOVED: items were visible before layout and were removed by the app</span><br><span class="line">     * ADDED: items did not exist before layout and were added by the app</span><br><span class="line">     * DISAPPEARING: items exist in the data set before/after, but changed from</span><br><span class="line">     * visible to non-visible in the process of layout (they were moved off</span><br><span class="line">     * screen as a side-effect of other changes)</span><br><span class="line">     * APPEARING: items exist in the data set before/after, but changed from</span><br><span class="line">     * non-visible to visible in the process of layout (they were moved on</span><br><span class="line">     * screen as a side-effect of other changes)</span><br><span class="line">     * The overall approach figures out what items exist before/after layout and</span><br><span class="line">     * infers one of the five above states for each of the items. Then the animations</span><br><span class="line">     * are set up accordingly:</span><br><span class="line">     * PERSISTENT views are animated via</span><br><span class="line">     * &#123;@link ItemAnimator#animatePersistence(ViewHolder, ItemHolderInfo, ItemHolderInfo)&#125;</span><br><span class="line">     * DISAPPEARING views are animated via</span><br><span class="line">     * &#123;@link ItemAnimator#animateDisappearance(ViewHolder, ItemHolderInfo, ItemHolderInfo)&#125;</span><br><span class="line">     * APPEARING views are animated via</span><br><span class="line">     * &#123;@link ItemAnimator#animateAppearance(ViewHolder, ItemHolderInfo, ItemHolderInfo)&#125;</span><br><span class="line">     * and changed views are animated via</span><br><span class="line">     * &#123;@link ItemAnimator#animateChange(ViewHolder, ViewHolder, ItemHolderInfo, ItemHolderInfo)&#125;.</span><br><span class="line">     */</span><br><span class="line">    void dispatchLayout() &#123;</span><br><span class="line">        if (mAdapter == null) &#123;</span><br><span class="line">            Log.e(TAG, &quot;No adapter attached; skipping layout&quot;);</span><br><span class="line">            // leave the state in START</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mLayout == null) &#123;</span><br><span class="line">            Log.e(TAG, &quot;No layout manager attached; skipping layout&quot;);</span><br><span class="line">            // leave the state in START</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mState.mIsMeasuring = false;</span><br><span class="line">        if (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">            dispatchLayoutStep1();</span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">        &#125; else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()</span><br><span class="line">                || mLayout.getHeight() != getHeight()) &#123;</span><br><span class="line">            // First 2 steps are done in onMeasure but looks like we have to run again due to</span><br><span class="line">            // changed size.</span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // always make sure we sync them (to ensure mode is exact)</span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatchLayoutStep3();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>onlayout的过程相对比较简单，即是直接通过state的状态，来设置目前需要走到哪一步。其中dispatchlayoutstep1和dispatchlayoutstep2都是onmeasure过程中使用到的。</p>
<p>唯一不知道的是dispatchlayoutstep3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * The final step of the layout where we save the information about views for animations,</span><br><span class="line">    * trigger animations and do any necessary cleanup.</span><br><span class="line">    */</span><br><span class="line">   private void dispatchLayoutStep3() &#123;</span><br><span class="line">       mState.assertLayoutStep(State.STEP_ANIMATIONS);</span><br><span class="line">       eatRequestLayout();</span><br><span class="line">       onEnterLayoutOrScroll();</span><br><span class="line">       mState.mLayoutStep = State.STEP_START;</span><br><span class="line">       if (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">           // Step 3: Find out where things are now, and process change animations.</span><br><span class="line">           // traverse list in reverse because we may call animateChange in the loop which may</span><br><span class="line">           // remove the target view holder.</span><br><span class="line">           for (int i = mChildHelper.getChildCount() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">               ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">               if (holder.shouldIgnore()) &#123;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">               long key = getChangedHolderKey(holder);</span><br><span class="line">               final ItemHolderInfo animationInfo = mItemAnimator</span><br><span class="line">                       .recordPostLayoutInformation(mState, holder);</span><br><span class="line">               ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key);</span><br><span class="line">               if (oldChangeViewHolder != null &amp;&amp; !oldChangeViewHolder.shouldIgnore()) &#123;</span><br><span class="line">                   // run a change animation</span><br><span class="line"></span><br><span class="line">                   // If an Item is CHANGED but the updated version is disappearing, it creates</span><br><span class="line">                   // a conflicting case.</span><br><span class="line">                   // Since a view that is marked as disappearing is likely to be going out of</span><br><span class="line">                   // bounds, we run a change animation. Both views will be cleaned automatically</span><br><span class="line">                   // once their animations finish.</span><br><span class="line">                   // On the other hand, if it is the same view holder instance, we run a</span><br><span class="line">                   // disappearing animation instead because we are not going to rebind the updated</span><br><span class="line">                   // VH unless it is enforced by the layout manager.</span><br><span class="line">                   final boolean oldDisappearing = mViewInfoStore.isDisappearing(</span><br><span class="line">                           oldChangeViewHolder);</span><br><span class="line">                   final boolean newDisappearing = mViewInfoStore.isDisappearing(holder);</span><br><span class="line">                   if (oldDisappearing &amp;&amp; oldChangeViewHolder == holder) &#123;</span><br><span class="line">                       // run disappear animation instead of change</span><br><span class="line">                       mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       final ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout(</span><br><span class="line">                               oldChangeViewHolder);</span><br><span class="line">                       // we add and remove so that any post info is merged.</span><br><span class="line">                       mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">                       ItemHolderInfo postInfo = mViewInfoStore.popFromPostLayout(holder);</span><br><span class="line">                       if (preInfo == null) &#123;</span><br><span class="line">                           handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder);</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           animateChange(oldChangeViewHolder, holder, preInfo, postInfo,</span><br><span class="line">                                   oldDisappearing, newDisappearing);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Step 4: Process view info lists and trigger animations</span><br><span class="line">           mViewInfoStore.process(mViewInfoProcessCallback);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mLayout.removeAndRecycleScrapInt(mRecycler);</span><br><span class="line">       mState.mPreviousLayoutItemCount = mState.mItemCount;</span><br><span class="line">       mDataSetHasChangedAfterLayout = false;</span><br><span class="line">       mState.mRunSimpleAnimations = false;</span><br><span class="line"></span><br><span class="line">       mState.mRunPredictiveAnimations = false;</span><br><span class="line">       mLayout.mRequestedSimpleAnimations = false;</span><br><span class="line">       if (mRecycler.mChangedScrap != null) &#123;</span><br><span class="line">           mRecycler.mChangedScrap.clear();</span><br><span class="line">       &#125;</span><br><span class="line">       if (mLayout.mPrefetchMaxObservedInInitialPrefetch) &#123;</span><br><span class="line">           // Initial prefetch has expanded cache, so reset until next prefetch.</span><br><span class="line">           // This prevents initial prefetches from expanding the cache permanently.</span><br><span class="line">           mLayout.mPrefetchMaxCountObserved = 0;</span><br><span class="line">           mLayout.mPrefetchMaxObservedInInitialPrefetch = false;</span><br><span class="line">           mRecycler.updateViewCacheSize();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mLayout.onLayoutCompleted(mState);</span><br><span class="line">       onExitLayoutOrScroll();</span><br><span class="line">       resumeRequestLayout(false);</span><br><span class="line">       mViewInfoStore.clear();</span><br><span class="line">       if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) &#123;</span><br><span class="line">           dispatchOnScrolled(0, 0);</span><br><span class="line">       &#125;</span><br><span class="line">       recoverFocusFromState();</span><br><span class="line">       resetFocusInfo();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里看上去，能了解几个信息点，首先是处理了动画，在然后是reset了一些状态。这一步和布局没有什么必然的关系。</p>
<h2 id="全布局总结"><a href="#全布局总结" class="headerlink" title="全布局总结"></a>全布局总结</h2><p>这里我就直接抄了，我的言语也最多总结成这样。</p>
<p>第一步：<br>处理Adapter的更新<br>决定哪些动画播放<br>保存当前View的信息<br>如果有必要的话再进行上一布局操作，并保存它的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void dispatchLayoutStep1() &#123;</span><br><span class="line">    …… // 省略代码，该部分判断状态和更改状态以及保存一些信息</span><br><span class="line">    // 下面这个方法很重要，那么我们先略过，看下下面的内容。哎~我就这么调皮!哈哈，</span><br><span class="line">    // 其实是，在没有讲动画流程之前，根本讲不清。这个是动画流程的中间过程。所以</span><br><span class="line">    // ，在这里只要先知道，这里是处理Adapter更新，并计算动画类型的即可。</span><br><span class="line">    processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">    …… // 设置一些状态，保存一些信息。</span><br><span class="line"></span><br><span class="line">    // 下面的内容是需要运行动画的情况下进行的，主要做的事情就是找出那些要需要进</span><br><span class="line">    // 行上一布局操作的ViewHolder，并且保存它们的边界信息。如果有更新操作(这个更新</span><br><span class="line">    // 指的是内容的更新，不是插入删除的这种更新)，然后保存这些更新的ViewHolder</span><br><span class="line">    if (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        …… // 看上面的解释，这里代码都是和动画相关的，暂时懒得放，太占地方</span><br><span class="line">    &#125;</span><br><span class="line">    // 下面的内容是需要在布局结束之后运行动画的情况下执行的。主要做的事情就是</span><br><span class="line">    // 执行上一布局操作，上一布局操作其实就是先以上一次的状态执行一边LayoutManager</span><br><span class="line">    // 的onLayoutChildren方法，其实RecyclerView的布局策略就是在</span><br><span class="line">    // LayoutManager的onLayoutChildren方法中。执行一次它就获得了所有</span><br><span class="line">    // ViewHolder的边界信息。只不过，这次获得的是之前状态下的ViewHolder的</span><br><span class="line">    // 边界信息。不过这个应该是要在LayoutManager中，根据state的isPreLayout</span><br><span class="line">    // 的返回值，选择使用新的还是旧的position。但我在系统给的几个LayoutManager中</span><br><span class="line">    // 都没有看到。</span><br><span class="line">    if (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">        …… </span><br><span class="line">        mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">    …… //恢复状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二步：真正的布局</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void dispatchLayoutStep2() &#123;</span><br><span class="line">    …… // 设置状态</span><br><span class="line">    mState.mInPreLayout = false; // 更改此状态，确保不是会执行上一布局操作</span><br><span class="line">    // 真正布局就是这一句话，布局的具体策略交给了LayoutManager，哈哈!这篇的主角讲完了!</span><br><span class="line">    mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">    …… // 设置和恢复状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步：</p>
<p>保存信息，触发动画，清除垃圾<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void dispatchLayoutStep3() &#123;</span><br><span class="line">    …… // 设置状态</span><br><span class="line">    if (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        …… // 需要动画的情况。找出ViewHolder现在的位置，并且处理改变动画。最后触发动画。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …… // 清除状态和清除无用的信息</span><br><span class="line">    mLayout.onLayoutCompleted(mState); // 给LayoutManager的布局完成的回调</span><br><span class="line">    …… // 清除状体和清楚无用的信息，最后在恢复一些信息信息，比如焦点。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h1><p>recyclerview的缓存主要在view的复用</p>
<p>其依赖于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final View view = recycler.getViewForPosition(mCurrentPosition);</span><br></pre></td></tr></table></figure></p>
<p>该方法获取了viewholder的itemview</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">         * Obtain a view initialized for the given position.</span><br><span class="line">         *</span><br><span class="line">         * This method should be used by &#123;@link LayoutManager&#125; implementations to obtain</span><br><span class="line">         * views to represent data from an &#123;@link Adapter&#125;.</span><br><span class="line">         * &lt;p&gt;</span><br><span class="line">         * The Recycler may reuse a scrap or detached view from a shared pool if one is</span><br><span class="line">         * available for the correct view type. If the adapter has not indicated that the</span><br><span class="line">         * data at the given position has changed, the Recycler will attempt to hand back</span><br><span class="line">         * a scrap view that was previously initialized for that data without rebinding.</span><br><span class="line">         *</span><br><span class="line">         * @param position Position to obtain a view for</span><br><span class="line">         * @return A view representing the data at &lt;code&gt;position&lt;/code&gt; from &lt;code&gt;adapter&lt;/code&gt;</span><br><span class="line">         */</span><br><span class="line">        public View getViewForPosition(int position) &#123;</span><br><span class="line">            return getViewForPosition(position, false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        View getViewForPosition(int position, boolean dryRun) &#123;</span><br><span class="line">            return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Attempts to get the ViewHolder for the given position, either from the Recycler scrap,</span><br><span class="line">         * cache, the RecycledViewPool, or creating it directly.</span><br><span class="line">         * &lt;p&gt;</span><br><span class="line">         * If a deadlineNs other than &#123;@link #FOREVER_NS&#125; is passed, this method early return</span><br><span class="line">         * rather than constructing or binding a ViewHolder if it doesn&apos;t think it has time.</span><br><span class="line">         * If a ViewHolder must be constructed and not enough time remains, null is returned. If a</span><br><span class="line">         * ViewHolder is aquired and must be bound but not enough time remains, an unbound holder is</span><br><span class="line">         * returned. Use &#123;@link ViewHolder#isBound()&#125; on the returned object to check for this.</span><br><span class="line">         *</span><br><span class="line">         * @param position Position of ViewHolder to be returned.</span><br><span class="line">         * @param dryRun True if the ViewHolder should not be removed from scrap/cache/</span><br><span class="line">         * @param deadlineNs Time, relative to getNanoTime(), by which bind/create work should</span><br><span class="line">         *                   complete. If FOREVER_NS is passed, this method will not fail to</span><br><span class="line">         *                   create/bind the holder if needed.</span><br><span class="line">         *</span><br><span class="line">         * @return ViewHolder for requested position</span><br><span class="line">         */</span><br><span class="line">        @Nullable</span><br><span class="line">        ViewHolder tryGetViewHolderForPositionByDeadline(int position,</span><br><span class="line">                boolean dryRun, long deadlineNs) &#123;</span><br><span class="line">            if (position &lt; 0 || position &gt;= mState.getItemCount()) &#123;</span><br><span class="line">                throw new IndexOutOfBoundsException(&quot;Invalid item position &quot; + position</span><br><span class="line">                        + &quot;(&quot; + position + &quot;). Item count:&quot; + mState.getItemCount()</span><br><span class="line">                        + exceptionLabel());</span><br><span class="line">            &#125;</span><br><span class="line">            boolean fromScrapOrHiddenOrCache = false;</span><br><span class="line">            ViewHolder holder = null;</span><br><span class="line">            // 0) If there is a changed scrap, try to find from there</span><br><span class="line">            if (mState.isPreLayout()) &#123;</span><br><span class="line">                holder = getChangedScrapViewForPosition(position);</span><br><span class="line">                fromScrapOrHiddenOrCache = holder != null;</span><br><span class="line">            &#125;</span><br><span class="line">            // 1) Find by position from scrap/hidden list/cache</span><br><span class="line">            if (holder == null) &#123;</span><br><span class="line">                holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</span><br><span class="line">                if (holder != null) &#123;</span><br><span class="line">                    if (!validateViewHolderForOffsetPosition(holder)) &#123;</span><br><span class="line">                        // recycle holder (and unscrap if relevant) since it can&apos;t be used</span><br><span class="line">                        if (!dryRun) &#123;</span><br><span class="line">                            // we would like to recycle this but need to make sure it is not used by</span><br><span class="line">                            // animation logic etc.</span><br><span class="line">                            holder.addFlags(ViewHolder.FLAG_INVALID);</span><br><span class="line">                            if (holder.isScrap()) &#123;</span><br><span class="line">                                removeDetachedView(holder.itemView, false);</span><br><span class="line">                                holder.unScrap();</span><br><span class="line">                            &#125; else if (holder.wasReturnedFromScrap()) &#123;</span><br><span class="line">                                holder.clearReturnedFromScrapFlag();</span><br><span class="line">                            &#125;</span><br><span class="line">                            recycleViewHolderInternal(holder);</span><br><span class="line">                        &#125;</span><br><span class="line">                        holder = null;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        fromScrapOrHiddenOrCache = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (holder == null) &#123;</span><br><span class="line">                final int offsetPosition = mAdapterHelper.findPositionOffset(position);</span><br><span class="line">                if (offsetPosition &lt; 0 || offsetPosition &gt;= mAdapter.getItemCount()) &#123;</span><br><span class="line">                    throw new IndexOutOfBoundsException(&quot;Inconsistency detected. Invalid item &quot;</span><br><span class="line">                            + &quot;position &quot; + position + &quot;(offset:&quot; + offsetPosition + &quot;).&quot;</span><br><span class="line">                            + &quot;state:&quot; + mState.getItemCount() + exceptionLabel());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int type = mAdapter.getItemViewType(offsetPosition);</span><br><span class="line">                // 2) Find from scrap/cache via stable ids, if exists</span><br><span class="line">                if (mAdapter.hasStableIds()) &#123;</span><br><span class="line">                    holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</span><br><span class="line">                            type, dryRun);</span><br><span class="line">                    if (holder != null) &#123;</span><br><span class="line">                        // update position</span><br><span class="line">                        holder.mPosition = offsetPosition;</span><br><span class="line">                        fromScrapOrHiddenOrCache = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (holder == null &amp;&amp; mViewCacheExtension != null) &#123;</span><br><span class="line">                    // We are NOT sending the offsetPosition because LayoutManager does not</span><br><span class="line">                    // know it.</span><br><span class="line">                    final View view = mViewCacheExtension</span><br><span class="line">                            .getViewForPositionAndType(this, position, type);</span><br><span class="line">                    if (view != null) &#123;</span><br><span class="line">                        holder = getChildViewHolder(view);</span><br><span class="line">                        if (holder == null) &#123;</span><br><span class="line">                            throw new IllegalArgumentException(&quot;getViewForPositionAndType returned&quot;</span><br><span class="line">                                    + &quot; a view which does not have a ViewHolder&quot;</span><br><span class="line">                                    + exceptionLabel());</span><br><span class="line">                        &#125; else if (holder.shouldIgnore()) &#123;</span><br><span class="line">                            throw new IllegalArgumentException(&quot;getViewForPositionAndType returned&quot;</span><br><span class="line">                                    + &quot; a view that is ignored. You must call stopIgnoring before&quot;</span><br><span class="line">                                    + &quot; returning this view.&quot; + exceptionLabel());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (holder == null) &#123; // fallback to pool</span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        Log.d(TAG, &quot;tryGetViewHolderForPositionByDeadline(&quot;</span><br><span class="line">                                + position + &quot;) fetching from shared pool&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    holder = getRecycledViewPool().getRecycledView(type);</span><br><span class="line">                    if (holder != null) &#123;</span><br><span class="line">                        holder.resetInternal();</span><br><span class="line">                        if (FORCE_INVALIDATE_DISPLAY_LIST) &#123;</span><br><span class="line">                            invalidateDisplayListInt(holder);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (holder == null) &#123;</span><br><span class="line">                    long start = getNanoTime();</span><br><span class="line">                    if (deadlineNs != FOREVER_NS</span><br><span class="line">                            &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123;</span><br><span class="line">                        // abort - we have a deadline we can&apos;t meet</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    holder = mAdapter.createViewHolder(RecyclerView.this, type);</span><br><span class="line">                    if (ALLOW_THREAD_GAP_WORK) &#123;</span><br><span class="line">                        // only bother finding nested RV if prefetching</span><br><span class="line">                        RecyclerView innerView = findNestedRecyclerView(holder.itemView);</span><br><span class="line">                        if (innerView != null) &#123;</span><br><span class="line">                            holder.mNestedRecyclerView = new WeakReference&lt;&gt;(innerView);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    long end = getNanoTime();</span><br><span class="line">                    mRecyclerPool.factorInCreateTime(type, end - start);</span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        Log.d(TAG, &quot;tryGetViewHolderForPositionByDeadline created new ViewHolder&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码写的还是比较容易懂得，其实就是按照顺序去缓存里面寻找viewholder。</p>
<p>缓存的顺序是</p>
<ol>
<li><p>状态为预加载时：</p>
<p> getChangedScrapViewForPosition() -&gt; 从mChangedScrap中找</p>
</li>
<li><p>没找着或者压根没走预加载：</p>
<p> getScrapOrHiddenOrCachedHolderForPosition() -&gt; </p>
<pre><code>从mAttachedScrap中找layoutposition等于该position的
-&gt;还没找着-&gt;从mCachedViews中寻找
</code></pre></li>
<li><p>还没找着：</p>
<p> adapter里面有stable id：</p>
<pre><code>getScrapOrCachedViewForId() -&gt; 从mAttachedScrap中找itemid等于id的
</code></pre><p> 没找着或adapter里面没有stable id:</p>
<pre><code>mViewCacheExtension.getViewForPositionAndType() -&gt; 在viewCacheExtension存在的前提下，从对用户扩展的viewCacheExtension中找
</code></pre><p> 还没找着：</p>
<pre><code>getRecycledViewPool().getRecycledView() -&gt; 从循环view池里面获取被循环的viewholder，这个循环view池默认也就存5个
</code></pre><p> 再没找着：</p>
<pre><code>mAdapter.createViewHolder() -&gt;创建一个viewholder
</code></pre></li>
</ol>
<p>//吐槽一下：明明是一个问题，为什么if还不嵌套…</p>
<p><img src="/images/android/recyclerview缓存模型.jpg" alt="缓存的顺序图，copy自bugly"></p>
<h2 id="总结一下：三层缓存"><a href="#总结一下：三层缓存" class="headerlink" title="总结一下：三层缓存"></a>总结一下：三层缓存</h2><p>View的detach和remove: </p>
<p><strong>detach</strong>: 在ViewGroup中的实现很简单，只是将ChildView<strong>从ParentView的ChildView数组中移除，ChildView的mParent设置为null, 可以理解为轻量级的临时remove, 因为View此时和View树还是藕断丝连, 这个函数被经常用来改变ChildView在ChildView数组中的次序。</strong>View被detach一般是临时的，在后面会被重新attach。</p>
<p><strong>remove</strong>: 真正的移除，不光被从ChildView数组中除名，其他和View树各项联系也会被彻底斩断(不考虑Animation/LayoutTransition这种特殊情况)， 比如焦点被清除，从TouchTarget中被移除等。</p>
<blockquote>
<blockquote>
<p>Scrap View指的是在RecyclerView中，处于根据数据刷新界面等行为, ChildView被detach(注意这个detach指的是1中介绍的detach行为，而不是RecyclerView一部分注释中的”detach”，RecyclerView一部分注释中的”detach”其实指得是上面的remove)，并且被存储到了Recycler中，这部分ChildView就是Scrap View。</p>
</blockquote>
</blockquote>
<ol>
<li>第一级缓存</li>
</ol>
<p>Scrap View: mAttachedScrap和mChangedScrap<br>Removeed View: mCachedViews</p>
<ol>
<li>第二级缓存</li>
</ol>
<p>ViewCacheExtension(可选可配置)： 供使用者自行扩展，让使用者可以控制缓存</p>
<ol>
<li>第三级缓存</li>
</ol>
<p>RecycledViewPool(可配置): RecyclerView之间共享ViewHolder的缓存池</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/android/" rel="tag"># android</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/16/looper的message分发方式/" rel="next" title="looper的message分发方式">
                <i class="fa fa-chevron-left"></i> looper的message分发方式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/28/tinker机制学习/" rel="prev" title="tinker机制学习">
                tinker机制学习 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sample</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">124</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#绘制过程"><span class="nav-number">1.</span> <span class="nav-text">绘制过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#onMeasure"><span class="nav-number">1.1.</span> <span class="nav-text">onMeasure</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#layout-null"><span class="nav-number">1.1.1.</span> <span class="nav-text">layout == null</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mlayout-null-amp-amp-mLayout-isAutoMeasureEnabled"><span class="nav-number">1.1.2.</span> <span class="nav-text">mlayout != null &amp;&amp;  mLayout.isAutoMeasureEnabled()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最后一步"><span class="nav-number">1.1.3.</span> <span class="nav-text">最后一步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最后一步的一个总结"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">最后一步的一个总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#onLayout"><span class="nav-number">1.2.</span> <span class="nav-text">onLayout</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全布局总结"><span class="nav-number">1.3.</span> <span class="nav-text">全布局总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#缓存机制"><span class="nav-number">2.</span> <span class="nav-text">缓存机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#总结一下：三层缓存"><span class="nav-number">2.1.</span> <span class="nav-text">总结一下：三层缓存</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sample</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
