---
title: volatile的作用及其原理
date: 2019-01-09 19:03:23
tags: java
---

# 作用

## 缓存一致性

背景：计算机执行程序时，每条指令都是在cpu中执行的，执行过程中会涉及到数据的读取和写入，由于程序运行过程中的临时数据时存放在主存中（物理内存），这就产生了一个问题，cpu执行速度很快，而从内存读取数据和向内写入数据的过程比cpu执行的速度慢，因此计算机在cpu里面增加了高速缓存

cpu运行过程中，会讲运算需要的数据从主存中复制一份到cpu的高速缓存当中，那么当cpu进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，运算结束之后，再将高速缓存中的数据刷行到主存当中。

譬如
```
i = i + 1;
```

当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后cpu执行指令对i进行+1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存中。

这个代码在多线程中会出现问题，由于多核cpu环境下，每条线程可能运行于不同的cpu中，因此每个线程运行时有自己的高速缓存。当a和b同时执行这条语句的时候，a将i拷贝到了高速缓存中，执行+1操作，此时如果b线程也拷贝到高速缓存中，此时读取的值还是a未+1的值

此时就出现了缓存不一致的问题，这也是著名的缓存一致性问题，通常这种被多个线程访问的变量称为共享变量。

## 解决方法

解决方法有两种，一种是在总线加lock锁的方式，二是通过缓存一致性协议

### 总线加lock

总线加lock的方式可以阻塞主所有其他cpu对其他部件的访问（如内存），从而使得只有一个cpu能使用这个变量的内存。

上述的例子，a在执行i = i + 1的时候，在总线上面发出lock的信号，那么只有等这段代码执行完毕之后，其他cpu才能在i所在的内存读取变量

也就是sychronize在代码块上面加个锁

### 通过缓存一致性协议

当cpu写数据时，如果发现操作的变量是共享变量，即在其他cpu中也存在该变量的副本，会发出信号通知其他cpu将该变量的缓存行为设置为无效状态，因此当其他cpu需要读取这个变量时，发现自己缓存中缓存该变量的缓存时无效的，那么它就会从内存中重新读取

# 并发编程三大特性

## 原子性

java中对基本数据类型的读取和赋值操作是原子性操作，要么执行要么不执行。

```
x = 10;//原子性操作

y = x;//非原子性，先读取x的值，再将x的值写入工作内存，这两个过程都是原子性，但是合起来不是

x ++;//读取x的值，加1，写入新的值，也是合起来就不是原子性了

x = x + 1;//同x++
```

## 可见性

可见性就是使用volatile关键字来保证

当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存中，当有其他线程需要读取时，他会去内存中读取新值。

对于一个没有被volatile修饰的普通共享变量，因为普通共享变量被修改之后，什么时候被写入主存时不确定的，当其他线程去读取时，此时内存可能还是原来的旧值，因此无法保证可见性。

另外，通过sychronized和lock也可以保证可见性，sychronized和lock能保证同一时刻只有一个线程获取锁，然后执行同步代码，并且释放锁之前会将对变量的修改刷行到主存当中，因此可以保证可见性

## 有序性

在java内存模型中，允许编译器和处理器对指令进行重排序，但是排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性

在java里面可以通过volatile关键字来保证一定的“有序性”，另外可以通过sychronized和lock来保证有序性，sychronized和lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性

另外，java内存模型具备一些先天的“有序性”，即不需要任何手段就能保证的有序性

### happens - before原则

#### 程序次序规则

```
一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
```

#### 锁定规则

```
一个unlock操作先行发生于后面对同一个锁unlock操作
```

#### volatile变量规则

```
对一个变量的写操作先行发生于后面对这个变量的读操作
```

#### 传递规则

```
如果操作a先行发生于操作b，而操作b又先行发生于操作c，则可以得出操作a先行发生于操作c
```

#### 线程启动规则

```
thread对象的start()方法先行发生于此线程的每一个动作
```

#### 线程终结规则

```
线程中的所有操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
```

#### 对象终结规则

```
一个对象的初始化完成先行发生于它的finalize()方法的开始
```

# volatile

一个共享变量被volatile修饰之后，就具备了两层语义

1. 保证了不同线程对这个变量进行操作时的**可见性**，即一个线程修改了某个变量的值，这新值对其他线程来说时立即可见的

2. 禁止进行指令重排序

一个例子

```
//A
boolean stop = false;
while(!stop){
	doSomething();
}
//B
stop = true;
```

假如stop没有被volatile修饰的话，当a线程在执行A段语句的时候，b线程执行了B语句，此时可能由于没有来得及写入主存，导致a线程不知道b线程做了修改，就会造成死循环

## 原理和实现机制

```
观察加入volatile关键字和没有加入volatile关键字时所生成的会变代码发现，加入volatile关键字时，会多出一个lock前缀指令
 										----《深入理解java虚拟机》
```

lock前缀指令实际上相当于一个内存屏障(也称内存栅栏)

其提供了三个功能

1. 确保指令重排序时不会吧后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在他前面的操作已经全部完成

2. 他会强制对缓存的操作修改立即写入主存

3. 如果是写操作，他会导致其他cpu中对应的缓存行无效

## 使用场景

sychronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于sychronized，但是要注意volatile关键字是**无法替代**sychronized关键字的，因为**volatile关键字无法保证操作的原子性**

一般使用时需要具备2个条件：

1. 对变量的写操作不依赖于当前值

2. 该变量没有包含在具有其他变量的不变式中

### 场景一：状态标记量

```
volatile boolean flag = false;

while(!flag){
	doSomething();
}

public void setFlag(){
	flag = true;
}
```

```
volatile boolean inited = false;
//线程1:
context = loadContext();
inited = true;

//线程2:
while(!inited){
	sleep();
}
doSomethingWithConfig(context);
```

### 场景二：double check

```
class Singleton{
	private volatile static Singleton instance = null;
	private Singleton(){

	}

	public static Singleton getInstance(){
		if(instance == null){
			sychronized(Singleton.class){
				if(instance == null){
					instance = new Singleton();
				}
			}
		}
		return instance;
	}
}
```

# Q&A

## volatile如何保证有序性？

首先，volatile禁止指令重排序，这代表两层意思

1.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，而在其后面的操作还没有执行

2.在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行，这也就是上面说的内存栅栏

譬如

```
//x、y为非volatile变量
//flag为volatile变量
 
x = 2;        //语句1
y = 0;        //语句2
flag = true;  //语句3
x = 4;         //语句4
y = -1;       //语句5
```

由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会将语句3放到语句4、语句5后面，但是语句1和语句2的顺序、语句4和语句5的顺序是不做任何保证的。

再譬如

```
//线程1:
context = loadContext();   //语句1
inited = true;             //语句2
 
//线程2:
while(!inited ){
  sleep()
}
doSomethingwithconfig(context);
```
加入inited没有被volatile修饰的话，那么就有可能语句2再语句1之前执行，就会导致线程2崩溃。








