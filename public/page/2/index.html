<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="记录者">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="记录者">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="记录者">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>记录者</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">记录者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/30/2018-3-2018-12记产品死亡总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/2018-3-2018-12记产品死亡总结/" itemprop="url">2018.3-2018.12记产品死亡总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T18:59:13+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近一阵没有写工作小结。并不是不想写，其实是发生了一些没有想到的事情。</p>
<p>总而言之产品挂掉了。</p>
<p>在我们这个团队，产品每日都想的是怎么往后推进，从来没有想过之前的行为为什么有问题。而对于我们开发来讲，基本上也都是上行下效，重心总是在技术上，而不会对产品产生质疑。关于失败的总结一直都是避而不谈，开会的话语中永远都是美好的未来。其实这也是失败的一个因素。</p>
<p>我希望以我全程参与的开发者的身份，来对产品的死亡做一个总结。</p>
<h1 id="3月，开始"><a href="#3月，开始" class="headerlink" title="3月，开始"></a>3月，开始</h1><p>3月的我加入了好搭，当时项目还没有改名为好搭盒子，app的版本停留在1.9.3，当时做的是导购的模式，通过淘宝客，租赁衣服进来生成模型，然后通过提供服务给用户，通过淘宝客来获取佣金。<br>由于老模式竞争很大，需要比较多的投入才能达到比较好的传播的目的，另外在用户上面，其实在当时的传播模式在当时是很有吸引力的，但是当时的效果做的并不是很好。再加上天使轮融资成功，需要抓紧从好买衣脱离，所以仿照了国外Stitch Fix上市的盒子模式，期望能通过虚拟形象加上盒子模式，给虚拟形象带来一个有效的传播。</p>
<h1 id="4月，2-0版本上线"><a href="#4月，2-0版本上线" class="headerlink" title="4月，2.0版本上线"></a>4月，2.0版本上线</h1><p>由于以前从好买衣转来的后台，和上头吵翻了，因此上头决定新招一个后台，但是只招了一个后台。重构当时给了2周，但是到三月末还是没有好，后来又给了两周，一个月整后端接口好了。在4月中旬我们开启了app的大规模改版计划。</p>
<p>起初是加上盒子，盒子模式需要增加加盒、地址、押金、付款、订单等模块，后续又加上了会员系统，另外在商品的展示阶段，刚开始使用的是单品+合集的模式，商品结合的是medel+单品展示的。改版很大，对于我来讲就是不日不夜的加了两周班。</p>
<p>改版上线前遗留几个比较严重的问题，一个是盒子模式的本地保存和服务端保存冲突模式，服务端保存会导致加盒的模式很卡顿，加盒的过程需要验证服务器库存+操作本地盒子增加删减+push新的盒子到服务器+拉新的盒子到本地更新本地的衣服状态+本地存储新的盒子到sp。由于盒子的操作是一个很高频的模式，但是操作盒子带来的网络操作以及本地操作，当时验证需要大约400ms，而一次增加就会带来400ms的卡顿感，其实对用户来讲是十分不友好的。</p>
<p>由于着急上线，盒子的模式就被直接忽略而直接在4月30号上线了。</p>
<p>从现在的角度来看，当时如果能多用2天的时间，将整个盒子的模式改变一下，应该就不会有2.0版本评分从4.3掉到3.0的问题了。市场对2.0版本最大的评价就是卡。</p>
<h1 id="5月-正式由好搭虚拟试衣变更为好搭盒子"><a href="#5月-正式由好搭虚拟试衣变更为好搭盒子" class="headerlink" title="5月,正式由好搭虚拟试衣变更为好搭盒子"></a>5月,正式由好搭虚拟试衣变更为好搭盒子</h1><p>5月的产品计划是增加了芝麻信用免押金、加入了人工客服、增加了引导页面，同时对于订单模块进行了较大规模的优化。</p>
<p>这个版本是正式更名为好搭盒子，同时也进行了一定规模的投放。由于客户量增加导致暴露出了一个问题，就是由于信用免押金用户开始通过免押金进行订盒子，然后却不购买不退盒子。针对这个问题，当时唯一的号称“联系芝麻信用进行处罚”的措施，只有打电话追着用户。其实押金模式被ofo搞得臭名昭著，而不用押金，对我们这种小型公司，很难说控制用户的诚信度。我并不知道出问题的人的数量，但是我当时和产品沟通的时候，间接了解到了违规的人数其实不少。</p>
<p>说实话小公司在扩大市场这一方面真的难，像衣盒这些，通过强制要求用户提交几百块的押金，然后还有钱进行市场投放，这样用户规模就算增长不快，起码不会出现这种大规模违规的现象。然而我们公司无法这样，如果加了押金一定会导致用户抵抗情绪上升，因此也会导致用户接受能力降低。不得已才采用免押的模式，然而没想到这个模式这么快就被打脸了。</p>
<p>另外这个版本的商品展示，是机械的随机展示，权重并没有按照用户的喜好来。下拉过程中大概率出现是重复的商品。不过这个版本我将盒子的模式完全更改为内存存储的方式，优化掉了卡顿的问题。</p>
<p>这个版本的评价不再是卡卡卡，而是商品数目不够，想买的一下子就没了。</p>
<h1 id="6月，app由简陋转变为精致"><a href="#6月，app由简陋转变为精致" class="headerlink" title="6月，app由简陋转变为精致"></a>6月，app由简陋转变为精致</h1><p>整个六月，在连续更换2位ui之后，我们终于定下了ui的风格，并以此将页面逐个更新为新的风格。同时增加了专题和图文专题作为商品的展示模式。</p>
<p>整个六月只发了一个版本，但是针对这个版本提交了300多笔。不过ui定稿总算是完成了，大家都很开心，风格的统一应该会带来用户的提升。</p>
<p>至少当时都是这么想的。</p>
<p>但是发出去之后，6月的数据并不是很好看，至少没有达到想象的那种程度。一方面是因为数据量上去了，但是货品并没有上去，二来是仓库物流erp系统有些问题，造成了比较多的延迟发货问题。当时在确认订货的时候，并不支持取消订单，大量用户操作失误寄出了盒子，但是并不想要，好的人直接退了，不好的就不管，或者收到了衣服拿出来。主打的学生人群感觉更容易出现这种情况，反正是造成了数据并不好看。</p>
<p>6月出了一场比较严重的事故，由于在首页使用fragmentPageAdapter并且没有将缓存数据处理，导致app的内存在首页被消耗太多，因此导致了app极度卡顿。记忆中这个版本的anr达到了10%。事实上当时在测试的过程中就已经发现了这个问题，但是由于需要着急发版。每次卡着时间必须在周五发版，导致改版问题只看数量不看质量，这种质量事故其实很严重，但是产品很着急，老板很着急，开发很疲惫，测试很疲惫。</p>
<p>说实话其实对于小型开发公司来讲，讲究质量是一件很不靠谱的事情，在质量做上来之前，说不定市场就转向了。我们要求是周一给任务，周二出图和接口，周三周四开始做，周五提测测试完毕。如果周五提测不行，周六就加班，最迟最迟是周六提版本。这种进度在一般时候其实是ok的，但是在大改动的时候，尤其是ui改了2周才给设计稿的时候，第三周要求我们弄出来，就会导致这种情况发生。</p>
<p>当时我想了很多，发现其实无解，我们在提高自身效率，提升代码质量的时候，绝大部分时间都是在业务上面，而这种架构方面的问题真的很难发现并处理。很蛋疼。另外就是这种问题需要依赖测试的问题，在我们开发任务结束，开始进行bug修补的时候，这时候应该关注性能方面，然而没办法，这个时候都是和产品测试确定bug以及修改bug。这种性能优化的问题，每次都只能在发版之后，只有任务但是并没有接口和设计图的周一。于是乎我们因此发布了很多hotfix版本。</p>
<h1 id="7月，app增加了很多实用的功能"><a href="#7月，app增加了很多实用的功能" class="headerlink" title="7月，app增加了很多实用的功能"></a>7月，app增加了很多实用的功能</h1><p>首先是增加的功能，这个版本增加了收藏单品、2件打包、商品状态、匿名状态使用等功能。基本上每个都是在痛点上面的设计。另外移除了强制登陆的逻辑，这个也是痛点。</p>
<p>这个版本的主要改动还是针对用户在使用产品的阶段遇到的问题。以前的用户由于刚开始使用，需要强制登陆，强制设置medel，成本比较高，这样会造成用户第一次使用成本过大，另外由于之前无法收藏，导致用户看到想要的不小心刷新之后再也没办法回到原来的状态，2件打包也是为了让用户更方便的打包盒子。整个设计的逻辑这个月都很简单明了，就是为了增加寄盒率。</p>
<p>这个月我们的盒子也突破了1000个/月。app的uv也突破了1w。</p>
<h1 id="8月，人脸升级"><a href="#8月，人脸升级" class="headerlink" title="8月，人脸升级"></a>8月，人脸升级</h1><p>8月是融资之前的一个月，这个月紧锣密鼓的进行了很多的事情。具体在我8月份的git基本上没有任何提交就可以看出来。我们把ux完完整整的优化了一遍，同时将人脸也进行了一次升级作为一次融资的噱头。整个ux的优化持续了一个月，这次优化的细节主要体现在订单流程上面，订单流程增加了很多状态，同时对于用户退货的流程做了很大规模的退货。主要的初心我个人猜测就是因为之前退货的流程太过突兀，用户一来可能看不到退货的入口，二来退货过程中细节不好，导致用户可能不一定在这个页面会进行下去。</p>
<p>总之这一版主要功能还是为了保障以购用户退货的过程能够顺畅而做出的优化，另外人脸识别算法部门提供了一个v2的版本，这个版本主要是将人脸从建模变成抠图，看起来仿佛是更好了。</p>
<p>另外这个月是融资之前的一个月，8月末就正式启动了融资。</p>
<h1 id="9月，数据爆炸"><a href="#9月，数据爆炸" class="headerlink" title="9月，数据爆炸"></a>9月，数据爆炸</h1><p>9月份市场做了很多推广的努力，外加运营部门做了一些调整，优化了搜索引擎，导致app那一阵用户量猛增，由平时的1万ui猛升到了8wuv，当时在appstore排行榜还占到了最热区域。但是服务器重建人脸的效率实在是太慢了，重建队列很多都是堵死状态，我们太依赖好买衣导致他们的缺点在我们这边无限的暴露。而且这个月好买衣的后端leader跑路，前端leader跑路，走之前特地嘱咐了我们服务器的问题。但是当时我们这边重心没有放在这个上面，服务器出现人脸丢失，黑脸，没头，还有没头发的问题，在之后的几个月基本上是无限爆出，我们这边后端压根不涉及这些，核心竞争力没法把握好，导致后续在后端的稳定性上面吃了大亏。</p>
<p>不过9月是进入好搭之后感觉最兴奋的一个月，这一个月数据不断的刷新，让人感觉8月的加班是有意义的，而且这个月的盒子数也顺利的从之前的几百个，突破到了2000+个，至少对我们来讲，这一阶段的里程碑是达成了。</p>
<h1 id="10月，a轮找到金主"><a href="#10月，a轮找到金主" class="headerlink" title="10月，a轮找到金主"></a>10月，a轮找到金主</h1><p>10月由于是国庆节，外加母亲动手术，我大约半个月没有工作，这个月最繁忙的一周是a轮找到了金主之后的一周，投资人对我们提出了很多的要求，数据当时比较中庸，主要是加盒率和购买复购率比较低，而盒子数量和使用用户则比较好看。当时产品那边的想法是提高会员数量，这样可以使的会员转化率增加，会员的表现一直有比较高的复购和加盒转化率。</p>
<p>当时介于商品本来缺货断码就比较严重，因此开辟了一个会员专区，专门提供给会员特供的商品。这个版本上去之后的数据并没有显示，但是uv开始逐渐的降低了，十月份到最后的时候，我记得uv从2万掉到了1万2左右。</p>
<h1 id="11月，强制用户登陆"><a href="#11月，强制用户登陆" class="headerlink" title="11月，强制用户登陆"></a>11月，强制用户登陆</h1><p>由于之前将强制登陆和设计medel的步骤给去掉了，导致很多用户在很低的时间成本下，反复叫盒子，然后不够买不寄回，这样导致很多衣服被薅羊毛薅走了。这个现象持续了好几个月，但是这个月开始对这个现象做处理。</p>
<p>我们将新的强制登陆逻辑加上，为此付出了2周的开发周期，并且还delay了一次。但是中途也遇到了很多的问题，问题主要展现在关于medel的接口我们这边不是很了解，需要和好买衣沟通，另外就是服务器不稳定，导致线上环境建模总是失败，导致这样的强制引导很容易出现劝退现象。不过为了能够将羊毛党拒之门外，貌似我们在信用体系下可以做的也就是这样了。</p>
<h1 id="12月，融资失败"><a href="#12月，融资失败" class="headerlink" title="12月，融资失败"></a>12月，融资失败</h1><p>到了12月，仿佛寒冬一下子来临了，各处裁员。</p>
<p>刚开始以为融资都进入ts了，应该可以稳定，结果还是没躲过，12号的时候说投资人因为一些问题准备不投了，这就很蛋疼了，毕竟已经等了超过一个月的ts了，最后说不投，基本上就是断炊了。然后ceo去跑了一趟，回来之后说又融到了。但是比较神奇的是开始要求我们砍业务。砍掉盒子模式。</p>
<p>很奇怪，融到了为什么要砍。结果吃饭的时候技术leader说其实并没有融到，ceo只是不想说而已。砍业务是因为吃不消损耗了，每个盒子都是亏的，用户热情还很高，这样钱吃不消使用。</p>
<p>于是连我们12月在做的功能都连根拔掉了，砍掉了订单，盒子，支付，会员等等，最后要接上淘宝客，等于我们的版本绕了一圈，回到了1.9.3的版本了。</p>
<p>哎。这样子，我们的好搭盒子就彻彻底底的死了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从开发者客观来讲，对这个产品是有感情的，当我来的时候，安卓组那个人准备离职，我在2个月的时间里面独自支撑着并不熟悉的项目。</p>
<p>加班加点在好搭仿佛都是家常便饭，年中的时候统计了一下已经累计了10天的调休。</p>
<p>可是有什么用呢？开发者仅仅是一把刀子，这个刀子或许锋利，或许迟钝，但是如果将锋利的刀子不断砍伐一些无用的东西，这有什么意义呢？</p>
<p>刚开始的时候说我们暂时不需要考虑基础建设的问题，后端，前端，移动端，都是走一步看一步。后期发现基础建设出了问题的时候，却又浪费了大批量的时间来重构。创业公司感觉永远逃离不了这个魔咒。</p>
<p>当听到一直维护的项目突然被砍掉，转成别的项目的时候。心里只有一声叹息。</p>
<h1 id="问题出在哪里？"><a href="#问题出在哪里？" class="headerlink" title="问题出在哪里？"></a>问题出在哪里？</h1><p>最近一直在想，leader离职的时候说过一句话，“论盒子模式，我们绝对是数据跑的好的”，但是为什么落的如此下场？</p>
<h2 id="信用模式"><a href="#信用模式" class="headerlink" title="信用模式"></a>信用模式</h2><p>盒子模式首先将衣服寄到了用户手里，然后让用户选择购买或者退回。这中间给了用户极大的自由，前期我们尚且能通过小规模投放来控制风险，后期接入了小红书推广，导致大量学生涌入，很多人仿佛占到了便宜似的拼命下盒子，下完了拿到货不退不购买，导致大量订单逾期坏单。造成了巨量的成本亏损。</p>
<h2 id="商品量不足"><a href="#商品量不足" class="headerlink" title="商品量不足"></a>商品量不足</h2><p>由于是商城模式的app，对商品量的把控一定要比较高，但是从数据上来看，常年缺码SPU高达40%，造成了好衣服没货，坏衣服卖不出去的问题。加上前期并没有做好消息推送这个环节，对缺货商品的订阅上的过慢，也导致了大量用户的流失现象。</p>
<h2 id="medel不够稳定"><a href="#medel不够稳定" class="headerlink" title="medel不够稳定"></a>medel不够稳定</h2><p>medel不够稳定是一直存在的问题，首先渲染消耗太多，最高每日光服务器就要跑掉2w块。其次是就算这样仍然不够稳定，不清楚是算法还是好买衣的问题，总是出现光头，绘制失败，没脸的问题。这个问题其实很严重，特别是我们这种主打虚拟试衣模式的app，基本上就是断腿了。</p>
<p>这个问题其实是有解的，开始的时候就可以选择重构那边的代码。但是怎么讲呢，兵熊熊一个，将熊熊一窝，关于这个问题从我入职的时候每次会议必谈，直到leader来了之后禁止我们开会讨论这个。从开始leader就没有想重构，他或许想的是在半年内我们可以拿到a轮融资，之后可以选择完整的重构，或者是想着干脆就不重构了，等着别人来</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/30/二路归并排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/二路归并排序/" itemprop="url">二路归并排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T16:30:42+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>利用递归，将原始序列不断两两分块，直到每块剩下一个元素，这个元素肯定是有序的。然后利用递归的原理合并即可</p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>空间复杂度应该从拆分上面来看，第一次拆分是1块拆成2快，第二次是2块拆成4块，第三次是4块拆成8块…第n次就是2^(n-1)拆成2^(n)块，总和应该是2^0+2^1+2^2…+2^n为O(n)</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>O(nlgn)</p>
<p>每层需要合并的总数为n，一共有logn层，故为nlogn</p>
<h1 id="算法实现思想"><a href="#算法实现思想" class="headerlink" title="算法实现思想"></a>算法实现思想</h1><p>首先使用类似于后序遍历的方式，将数组不断的分割，最后在进行归并。</p>
<p>归并的过程是：使用三根指针，第一根指向第一个子表首位元素，第二根指向第一个子表末尾元素，最后一根指向第二个子表末尾元素元素。<br>在确保第一根位置小于第二根，第二根+1小于第三根的情况下，不断比较第一根和第二根的大小并做相应的替换，替换完毕之后2根指针同时++,直到第一根指针到达左侧最末尾或者第二根指针到达第三根指针位置，即可中断。</p>
<h1 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private static void mergeSort(int[] arr) &#123;</span><br><span class="line">       mergeSort(arr, new int[arr.length], 0, arr.length - 1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static void mergeSort(int[] arr, int[] temp, int left, int right) &#123;</span><br><span class="line">       if (left &lt; right) &#123;</span><br><span class="line">           int center = (left + right) / 2;</span><br><span class="line">           mergeSort(arr, temp, left, center); // 左边</span><br><span class="line">           mergeSort(arr, temp, center + 1, right); // 右边</span><br><span class="line">           merge(arr, temp, left, center + 1, right); // 合并两个有序 ett</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static void merge(int[] arr, int[] temp, int leftPos, int rightPos, int rightEnd) &#123;</span><br><span class="line">       int leftEnd = rightPos - 1; // 左边结束下标</span><br><span class="line">       int tempPos = leftPos; // 从左边开始算</span><br><span class="line">       int numEle = rightEnd - leftPos + 1; // 元素个数</span><br><span class="line">       while (leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd) &#123;</span><br><span class="line">           if (arr[leftPos] &lt;= arr[rightPos])</span><br><span class="line">           	//通过一个临时数组做存储，这样不需要使用temp对象做临时存储做转换，而是直接从最小的区块开始拷贝进去</span><br><span class="line">               temp[tempPos++] = arr[leftPos++];</span><br><span class="line">           else</span><br><span class="line">               temp[tempPos++] = arr[rightPos++];</span><br><span class="line">       &#125;</span><br><span class="line">       while (leftPos &lt;= leftEnd) &#123;  // 左边如果有剩余</span><br><span class="line">           temp[tempPos++] = arr[leftPos++];</span><br><span class="line">       &#125;</span><br><span class="line">       while (rightPos &lt;= rightEnd) &#123; // 右边如果有剩余</span><br><span class="line">           temp[tempPos++] = arr[rightPos++];</span><br><span class="line">       &#125;</span><br><span class="line">       // 最后一步进行复制，复制的只有更改的几个数字</span><br><span class="line">       for (int i = 0; i &lt; numEle; i++) &#123;</span><br><span class="line">           arr[rightEnd] = temp[rightEnd];</span><br><span class="line">           rightEnd--;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="c实现"><a href="#c实现" class="headerlink" title="c实现"></a>c实现</h1><h1 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/27/动态规划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/27/动态规划/" itemprop="url">动态规划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-27T22:57:33+08:00">
                2018-12-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><ul>
<li>将多阶段决策过程划分阶段，恰当的选取状态变量、决策变量及定义最优指标函数，从而把问题化成同一族同类型的子问题，然后逐个求解。</li>
<li>求解时从边界条件开始，逆（或顺）过程进行方向，逐段递推寻优。在每一个子问题的求解时，都要使用它前面求出的子问题最优结果，最后一个子问题的最优解，就是真个问题的最优解。</li>
<li>动态规划方法是既把当前一段与未来各段分开，又把当前效益和未来效益结合起来考虑的一种最优化方法，因此每段的最优决策选取是从全局考虑的，与该段的最优选择一般是不同的。</li>
</ul>
<h1 id="建立动态规划模型的要点"><a href="#建立动态规划模型的要点" class="headerlink" title="建立动态规划模型的要点"></a>建立动态规划模型的要点</h1><ul>
<li>识别问题的多阶段特性，按时间或空间的先后顺序适当的划分为满足递推关系的若干阶段，对非时序的静态问题要认为的赋予“时段”概念</li>
<li>正确的选择状态变量，使其具备两个必要特征：</li>
</ul>
<ol>
<li>可知性：过程演变的各阶段状态变量的取值，能直接或间接的确定</li>
<li>能够确切的描述过程的演变且满足无后效性。即由第k阶段的状态Sk出发的后部子过程，可以看作是一个以Sk为初始状态的独立过程。这一点不是很容易满足，需要尝试把握。</li>
</ol>
<ul>
<li>根据状态变量与决策变量的含义，正确写出状态转移方程S(k+1) = Tk(Sk, Uk)或转移规则</li>
<li>根据题意明确指标函数V(k,n),最优指标函数Fk(Sk)以及k阶段指标Vk(Sk,Uk)的含义，并正确列出最优指标函数的递推关系及边界条件</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/26/焦虑感的排解方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/26/焦虑感的排解方式/" itemprop="url">焦虑感的排解方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-26T00:27:45+08:00">
                2018-12-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="焦虑感的由来"><a href="#焦虑感的由来" class="headerlink" title="焦虑感的由来"></a>焦虑感的由来</h1><p>当一个人希望掌控自己的生活，他就会自主的创建一系列的计划和安排，希望依靠这些计划和安排来带来目标的靠近。</p>
<p>但是计划和安排并不一定会和期望的一样，一来是不一定生活一下子迈上了正轨，计划执行的不一定完全，二来是变化大于计划，安排的不够仔细，没有考虑到的细节，决定了计划无法实施，三是计划的过程中产生了新的计划，堆积在老的计划上面，形成了过多的计划。三方面都很有可能导致计划的流产。流产就会造成目前情况并不会有任何好转，没有好转，就会带来挫折感，失败感，这些感觉在平时不会有任何反馈，但是到了deadline，新的周期开始或者老的周期结束时，会突然涌现，成堆的失败感形成了巨大的压迫力，衍生成为了焦虑。</p>
<h1 id="焦虑感的坏处"><a href="#焦虑感的坏处" class="headerlink" title="焦虑感的坏处"></a>焦虑感的坏处</h1><p>焦虑一定程度上能促进人思想的转变，但是过多焦虑，会引发焦虑症，忧郁症，抑郁症，情节程度由低至高。</p>
<h2 id="焦虑症"><a href="#焦虑症" class="headerlink" title="焦虑症"></a>焦虑症</h2><p>焦虑症是神经过多沉浸在焦虑中引起的一种神经疾病，分为急性焦虑症和广泛性焦虑症。</p>
<h3 id="广泛性焦虑症"><a href="#广泛性焦虑症" class="headerlink" title="广泛性焦虑症"></a>广泛性焦虑症</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">没有明显诱因的情况下，会出现与现实情境不符的过分担心，并且这种担心没有任何明显的对象和来由。表现为头晕、心慌、呼吸急促、尿频等。</span><br></pre></td></tr></table></figure>
<h3 id="急性焦虑症"><a href="#急性焦虑症" class="headerlink" title="急性焦虑症"></a>急性焦虑症</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">突然出现极度恐惧的心理，对自己产生严重的失控感和濒死感。</span><br></pre></td></tr></table></figure>
<h2 id="忧郁症"><a href="#忧郁症" class="headerlink" title="忧郁症"></a>忧郁症</h2><p>忧郁症是轻度抑郁症，主要表现是持久的心情低落</p>
<h2 id="抑郁症"><a href="#抑郁症" class="headerlink" title="抑郁症"></a>抑郁症</h2><p>对生活失去了希望，觉得很痛苦，觉得自己毫无用处。</p>
<h1 id="焦虑感的排解方式"><a href="#焦虑感的排解方式" class="headerlink" title="焦虑感的排解方式"></a>焦虑感的排解方式</h1><h2 id="订踏实靠谱的目标"><a href="#订踏实靠谱的目标" class="headerlink" title="订踏实靠谱的目标"></a>订踏实靠谱的目标</h2><p>对目标进行量化操作，不能订泛泛而谈的目标，比如说我现在要想成为一个全栈大牛，我需要先把android弄好，然后在在别的地方慢慢开花。另外把android弄好也需要对”好”有个界定，比如说能完整的单挑一个项目等等。</p>
<h2 id="良好的生活作息"><a href="#良好的生活作息" class="headerlink" title="良好的生活作息"></a>良好的生活作息</h2><p>每天晚上很晚睡，就会导致第二天很晚起，这样就会错过早上的时间。早上其实思想比较光明，不会像晚上一样接受了太多信息而聚不了神。反而是晚上很容易就想现在，一下子弄到了凌晨。以后要定个时间，超过一定时间就不搞了，准时洗洗睡了。</p>
<p>先定11点半吧，大学熄灯时间。</p>
<h2 id="良好的沟通"><a href="#良好的沟通" class="headerlink" title="良好的沟通"></a>良好的沟通</h2><p>产生焦虑感的人群，大多都是单身工作者，或者夫妻关系不和谐的成年人，还有就是学业重的青少年。目前对于我来讲，是第一种，将来可能是第二种，所以要增加切实有效的沟通对象。<br>其实这个很难，人生在世，太多事情是自己不得不做，每个人在不同的位置并不能理解对方。甚至自己的烦恼在别人眼里可能是炫耀。这一方面只能说是锦上添花的事情。<br>如果焦虑感发展成为焦虑症，需要增加心理医生为沟通对象。</p>
<h2 id="删除-精简计划"><a href="#删除-精简计划" class="headerlink" title="删除/精简计划"></a>删除/精简计划</h2><p>这个地方需要做的比较多，以往订计划，往往是以季度，以月，甚至以周为时间单位来做计划，这样太散乱了，而且对职场规划没有任何作为，我需要做一个以人生10年为单位的大计划，不过这个计划的谋划很难，而且需要思考的事情太多，目前的水平很难说能思考仔细。这个需要仔细考虑。</p>
<h2 id="不要接触负面事物-情绪-人"><a href="#不要接触负面事物-情绪-人" class="headerlink" title="不要接触负面事物/情绪/人"></a>不要接触负面事物/情绪/人</h2><p>屏蔽关键词。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/13/java各种锁学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/13/java各种锁学习/" itemprop="url">java各种锁学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-13T12:13:59+08:00">
                2018-12-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>该片摘抄自慕课</p>
<h1 id="一-synchronized"><a href="#一-synchronized" class="headerlink" title="一. synchronized"></a>一. synchronized</h1><p>在 JDK 1.6 之前，synchronized 是重量级锁，效率低下。从 JDK 1.6 开始，synchronized 做了很多优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。synchronized 同步锁一共包含四种状态：无锁、偏向锁、轻量级锁、重量级锁，它会随着竞争情况逐渐升级。synchronized 同步锁可以升级但是不可以降级，目的是为了提高获取锁和释放锁的效率。</p>
<h2 id="synchronized-修饰的代码块"><a href="#synchronized-修饰的代码块" class="headerlink" title="synchronized 修饰的代码块"></a>synchronized 修饰的代码块</h2><p>通过反编译.class文件，通过查看字节码可以得到：在代码块中使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令指明同步代码块的结束位置。</p>
<h2 id="synchronized-修饰的方法"><a href="#synchronized-修饰的方法" class="headerlink" title="synchronized 修饰的方法"></a>synchronized 修饰的方法</h2><p>同样查看字节码可以得到：在同步方法中会包含 ACC_SYNCHRONIZED 标记符。该标记符指明了该方法是一个同步方法，从而执行相应的同步调用。</p>
<h1 id="二-对象锁、类锁、私有锁"><a href="#二-对象锁、类锁、私有锁" class="headerlink" title="二. 对象锁、类锁、私有锁"></a>二. 对象锁、类锁、私有锁</h1><p>对象锁：使用 synchronized 修饰非静态的方法以及 synchronized(this) 同步代码块使用的锁是对象锁。</p>
<p>类锁：使用 synchronized 修饰静态的方法以及 synchronized(class) 同步代码块使用的锁是类锁。</p>
<p>私有锁：在类内部声明一个私有属性如private Object lock，在需要加锁的同步块使用 synchronized(lock）</p>
<p>它们的特性：</p>
<ul>
<li>对象锁具有可重入性。</li>
<li>当一个线程获得了某个对象的对象锁，则该线程仍然可以调用其他任何需要该对象锁的 synchronized 方法或 synchronized(this) 同步代码块。</li>
<li>当一个线程访问某个对象的一个 synchronized(this) 同步代码块时，其他线程对该对象中所有其它 synchronized(this) 同步代码块的访问将被阻塞，因为访问的是同一个对象锁。</li>
<li>每个类只有一个类锁，但是类可以实例化成对象，因此每一个对象对应一个对象锁。</li>
<li>类锁和对象锁不会产生竞争。</li>
<li>私有锁和对象锁也不会产生竞争。</li>
<li>使用私有锁可以减小锁的细粒度，减少由锁产生的开销。</li>
</ul>
<p>由私有锁实现的等待/通知机制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Object lock = new Object();// 由等待方线程实现</span><br><span class="line">synchronized (lock) &#123;</span><br><span class="line">    while (条件不满足) &#123;</span><br><span class="line">       lock.wait();</span><br><span class="line">    &#125;                         </span><br><span class="line">   &#125;// 由通知方线程实现</span><br><span class="line">   synchronized (lock) &#123;</span><br><span class="line">   条件发生改变</span><br><span class="line">   lock.notify();                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三-ReentrantLock"><a href="#三-ReentrantLock" class="headerlink" title="三. ReentrantLock"></a>三. ReentrantLock</h1><p>ReentrantLock 是一个独占/排他锁。相对于 synchronized，它更加灵活。但是需要自己写出加锁和解锁的过程。它的灵活性在于它拥有很多特性。</p>
<blockquote>
<blockquote>
<p>ReentrantLock 需要显示地进行释放锁。特别是在程序异常时，synchronized 会自动释放锁，而 ReentrantLock 并不会自动释放锁，所以必须在 finally 中进行释放锁。</p>
</blockquote>
</blockquote>
<p>它的特性：</p>
<ul>
<li>公平性：支持公平锁和非公平锁。默认使用了非公平锁。</li>
<li>可重入</li>
<li>可中断：相对于 synchronized，它是可中断的锁，能够对中断作出响应。</li>
<li>超时机制：超时后不能获得锁，因此不会造成死锁。</li>
</ul>
<p>ReentrantLock 是很多类的基础，例如 ConcurrentHashMap 内部使用的 Segment 就是继承 ReentrantLock，CopyOnWriteArrayList 也使用了 ReentrantLock。</p>
<h1 id="四-ReentrantReadWriteLock"><a href="#四-ReentrantReadWriteLock" class="headerlink" title="四. ReentrantReadWriteLock"></a>四. ReentrantReadWriteLock</h1><p>它拥有读锁(ReadLock)和写锁(WriteLock)，读锁是一个共享锁，写锁是一个排他锁。</p>
<p>它的特性：</p>
<ul>
<li>公平性：支持公平锁和非公平锁。默认使用了非公平锁。</li>
<li>可重入：读线程在获取读锁之后能够再次获取读锁。写线程在获取写锁之后能够再次获取写锁，同时也可以获取读锁（锁降级）。</li>
<li>锁降级：先获取写锁，再获取读锁，然后再释放写锁的过程。锁降级是为了保证数据的可见性。</li>
</ul>
<h1 id="五-CAS"><a href="#五-CAS" class="headerlink" title="五. CAS"></a>五. CAS</h1><p>上面提到的 ReentrantLock、ReentrantReadWriteLock 都是基于 AbstractQueuedSynchronizer (AQS)，而 AQS 又是基于 CAS。CAS 的全称是 Compare And Swap（比较与交换），它是一种无锁算法。</p>
<p>synchronized、Lock 都采用了悲观锁的机制，而 CAS 是一种乐观锁的实现。</p>
<p>CAS 的特性：</p>
<ul>
<li>通过调用 JNI 的代码实现</li>
<li>非阻塞算法</li>
<li>非独占锁</li>
</ul>
<p>CAS 存在的问题：</p>
<ul>
<li>ABA</li>
<li>循环时间长开销大</li>
<li>只能保证一个共享变量的原子操作</li>
</ul>
<h1 id="六-Condition"><a href="#六-Condition" class="headerlink" title="六. Condition"></a>六. Condition</h1><p>Condition 用于替代传统的 Object 的 wait()、notify() 实现线程间的协作。</p>
<blockquote>
<blockquote>
<p>在 Condition 对象中，与 wait、notify、notifyAll 方法对应的分别是 await、signal 和 signalAll。</p>
</blockquote>
</blockquote>
<p>Condition 必须要配合 Lock 一起使用，一个 Condition 的实例必须与一个 Lock 绑定。</p>
<p>它的特性：</p>
<ul>
<li>一个 Lock 对象可以创建多个 Condition 实例，所以可以支持多个等待队列。</li>
<li>Condition 在使用 await、signal 或 signalAll 方法时，必须先获得 Lock 的 lock()</li>
<li>支持响应中断</li>
<li>支持的定时唤醒功能</li>
</ul>
<h1 id="七-Semaphore"><a href="#七-Semaphore" class="headerlink" title="七. Semaphore"></a>七. Semaphore</h1><p>Semaphore、CountDownLatch、CyclicBarrier 都是并发工具类。</p>
<p>Semaphore 可以指定多个线程同时访问某个资源，而 synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源。由于 Semaphore 适用于限制访问某些资源的线程数目，因此可以使用它来做限流。</p>
<blockquote>
<blockquote>
<p>Semaphore 并不会实现数据的同步，数据的同步还是需要使用 synchronized、Lock 等实现。</p>
</blockquote>
</blockquote>
<p>它的特性：</p>
<ul>
<li>基于 AQS 的共享模式</li>
<li>公平性：支持公平模式和非公平模式。默认使用了非公平模式。</li>
</ul>
<h1 id="八-CountDownLatch"><a href="#八-CountDownLatch" class="headerlink" title="八. CountDownLatch"></a>八. CountDownLatch</h1><p>CountDownLatch 可以看成是一个倒计数器，它允许一个或多个线程等待其他线程完成操作。因此，CountDownLatch 是共享锁。CountDownLatch 的 countDown() 方法将计数器减1，await() 方法会阻塞当前线程直到计数器变为0。</p>
<h1 id="九-锁的分类"><a href="#九-锁的分类" class="headerlink" title="九. 锁的分类"></a>九. 锁的分类</h1><p><img src="/images/java/java锁图.png" alt="java锁图"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/okio学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/okio学习/" itemprop="url">okio学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-11T14:36:35+08:00">
                2018-12-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="io"><a href="#io" class="headerlink" title="io"></a>io</h1><p>io是java使用进行读取和写入的方式，i是input，o是output，走向是以内存为基准，内存中读数据是输入流，内存中往外写是输出流。</p>
<p>io又分为字节流和字符流。字节流是直接对文件进行读写，是不中断的操作，不关闭字节流的话，操作仍然可以成功。而字符流是将文件的读写进行在缓冲区，当关闭的时候才会进行操作。</p>
<p>字节流使用stream结尾，字符流使用reader和writer结尾。</p>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>缓冲区是一段内存区域，由于频繁的操作资源，会导致性能很低，而将数据存储到内存区域之后，之后的可以直接从区域中读取数据，读取内存数据的速度比较快，这样可以提升性能。</p>
<p>字符流由于所有的数据都是暂存在内存中，如果想要清空缓存区，需要使用到flush操作，flush操作可以强制清空缓存区，因此会将缓存区的数据全部取出进行操作后清空。</p>
<h2 id="字节流和字符流优缺点"><a href="#字节流和字符流优缺点" class="headerlink" title="字节流和字符流优缺点"></a>字节流和字符流优缺点</h2><ul>
<li>字节流优点</li>
</ul>
<p>字节流的优点是使用到了缓存区，通过内存的使用加快了效率。字节流多用于处理图片，处理成为二进制字节。</p>
<ul>
<li>字符流优点</li>
</ul>
<p>字符流的优点是操作比较方便，提供了一些方便的例如readline这种功能。字符流多用于处理文字。</p>
<h1 id="nio"><a href="#nio" class="headerlink" title="nio"></a>nio</h1><p>nio使用了缓存区、通道、管道来实现多线程io通信的问题</p>
<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><p>通道的存在大大提升了对buffer区域的操作空间，获取buffer的操作不再是由buffer提供，而是由channel进行代理提供，类似于stream对象，但是channel是由selector管理的。selector提供了可以监听多个通道的功能，因此单线程中使用selector可以监听多个channel，而stream则需要每个开一个线程才能达到不阻塞的行为。这样就解决了需要多线程io的问题</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>两个线程之间进行单项数据连接，会建立一个管道，数据被写到sink通道，读取的时候从source通道读取。</p>
<h3 id="管道的原理"><a href="#管道的原理" class="headerlink" title="管道的原理"></a>管道的原理</h3><p>管道写函数时，通过将字节复制到VFS索引节点指向的物理内存而写入数据，管道读函数则通过复制物理内存中的字节而读出数据。缓冲区不需要很大，一般为4k大小，它被设计为环形的结构，以便能够循环利用，当管道没有信息的时候，从管道中读取的进程会等待，知道另一端的进程放入信息。当管道被放满信息的时候，放入信息的进程会等待，直到另一端的进程取出信息。</p>
<h2 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h2><p>selector又被称为多路复用器，用于检查一个NIO channel的状态是否处于可读和可写。</p>
<p>与selector一起使用的channel必须是非阻塞模式的，filechannel和selector就不能一起使用</p>
<h3 id="selector原理"><a href="#selector原理" class="headerlink" title="selector原理"></a>selector原理</h3><p>channel通过注册，使得selector可以统一管理多个channel，这样一个线程只需要通过一个selector就可以管理多个channel。注册是使用注册表的方式来进行。</p>
<h3 id="selector多路复用的机制"><a href="#selector多路复用的机制" class="headerlink" title="selector多路复用的机制"></a>selector多路复用的机制</h3><p>介于cpu目前多任务越来越快，因此selector效率也越来越高，多个任务同时触发，每个任务的阻塞设置超时时间，因此可以比较好的实现多路复用的机制</p>
<h1 id="okio"><a href="#okio" class="headerlink" title="okio"></a>okio</h1><p>okio和nio的原理差不多，加上了buffer,信道，但是进行了优化，另外由于okio是设计用于网络请求的，所以加上了超时机制</p>
<h2 id="sink构造"><a href="#sink构造" class="headerlink" title="sink构造"></a>sink构造</h2><p>sink是okio的信道,用于写入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private static Sink sink(final OutputStream out, final Timeout timeout) &#123;</span><br><span class="line">    if (out == null) throw new IllegalArgumentException(&quot;out == null&quot;);</span><br><span class="line">    if (timeout == null) throw new IllegalArgumentException(&quot;timeout == null&quot;);</span><br><span class="line"></span><br><span class="line">    return new Sink() &#123;</span><br><span class="line">      @Override public void write(Buffer source, long byteCount) throws IOException &#123;</span><br><span class="line">        checkOffsetAndCount(source.size, 0, byteCount);</span><br><span class="line">        while (byteCount &gt; 0) &#123;</span><br><span class="line">          timeout.throwIfReached();</span><br><span class="line">          Segment head = source.head;</span><br><span class="line">          int toCopy = (int) Math.min(byteCount, head.limit - head.pos);</span><br><span class="line">          out.write(head.data, head.pos, toCopy);</span><br><span class="line"></span><br><span class="line">          head.pos += toCopy;</span><br><span class="line">          byteCount -= toCopy;</span><br><span class="line">          source.size -= toCopy;</span><br><span class="line"></span><br><span class="line">          if (head.pos == head.limit) &#123;</span><br><span class="line">            source.head = head.pop();</span><br><span class="line">            SegmentPool.recycle(head);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override public void flush() throws IOException &#123;</span><br><span class="line">        out.flush();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override public void close() throws IOException &#123;</span><br><span class="line">        out.close();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override public Timeout timeout() &#123;</span><br><span class="line">        return timeout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override public String toString() &#123;</span><br><span class="line">        return &quot;sink(&quot; + out + &quot;)&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>source是用于读取的信道</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private static Source source(final InputStream in, final Timeout timeout) &#123;</span><br><span class="line">    if (in == null) throw new IllegalArgumentException(&quot;in == null&quot;);</span><br><span class="line">    if (timeout == null) throw new IllegalArgumentException(&quot;timeout == null&quot;);</span><br><span class="line"></span><br><span class="line">    return new Source() &#123;</span><br><span class="line">      @Override public long read(Buffer sink, long byteCount) throws IOException &#123;</span><br><span class="line">        if (byteCount &lt; 0) throw new IllegalArgumentException(&quot;byteCount &lt; 0: &quot; + byteCount);</span><br><span class="line">        if (byteCount == 0) return 0;</span><br><span class="line">        try &#123;</span><br><span class="line">          timeout.throwIfReached();</span><br><span class="line">          Segment tail = sink.writableSegment(1);</span><br><span class="line">          int maxToCopy = (int) Math.min(byteCount, Segment.SIZE - tail.limit);</span><br><span class="line">          int bytesRead = in.read(tail.data, tail.limit, maxToCopy);</span><br><span class="line">          if (bytesRead == -1) return -1;</span><br><span class="line">          tail.limit += bytesRead;</span><br><span class="line">          sink.size += bytesRead;</span><br><span class="line">          return bytesRead;</span><br><span class="line">        &#125; catch (AssertionError e) &#123;</span><br><span class="line">          if (isAndroidGetsocknameError(e)) throw new IOException(e);</span><br><span class="line">          throw e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override public void close() throws IOException &#123;</span><br><span class="line">        in.close();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override public Timeout timeout() &#123;</span><br><span class="line">        return timeout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override public String toString() &#123;</span><br><span class="line">        return &quot;source(&quot; + in + &quot;)&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这种信道机制都是队列模式，关于超时判定永远在最先，超时是不在乎io的速度，而只关注io开始时是否超时，而这种读取和写入的方法都基本是一层while搞定。</p>
<p>从source和sink可以看出来，okio通过Segment来做数据的处理单元，这是一种双链表结构。写入的时候将依照节点顺序写入，读的时候也是从缓存池里面取出头节点进行读取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">final class SegmentPool &#123;</span><br><span class="line">  /** The maximum number of bytes to pool. */</span><br><span class="line">  // TODO: Is 64 KiB a good maximum size? Do we ever have that many idle segments?</span><br><span class="line">  static final long MAX_SIZE = 64 * 1024; // 64 KiB.</span><br><span class="line"></span><br><span class="line">  /** Singly-linked list of segments. */</span><br><span class="line">  static @Nullable Segment next;</span><br><span class="line"></span><br><span class="line">  /** Total bytes in this pool. */</span><br><span class="line">  static long byteCount;</span><br><span class="line"></span><br><span class="line">  private SegmentPool() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static Segment take() &#123;</span><br><span class="line">    synchronized (SegmentPool.class) &#123;</span><br><span class="line">      if (next != null) &#123;</span><br><span class="line">        Segment result = next;</span><br><span class="line">        next = result.next;</span><br><span class="line">        result.next = null;</span><br><span class="line">        byteCount -= Segment.SIZE;</span><br><span class="line">        return result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Segment(); // Pool is empty. Don&apos;t zero-fill while holding a lock.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void recycle(Segment segment) &#123;</span><br><span class="line">    if (segment.next != null || segment.prev != null) throw new IllegalArgumentException();</span><br><span class="line">    if (segment.shared) return; // This segment cannot be recycled.</span><br><span class="line">    synchronized (SegmentPool.class) &#123;</span><br><span class="line">      if (byteCount + Segment.SIZE &gt; MAX_SIZE) return; // Pool is full.</span><br><span class="line">      byteCount += Segment.SIZE;</span><br><span class="line">      segment.next = next;</span><br><span class="line">      segment.pos = segment.limit = 0;</span><br><span class="line">      next = segment;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个缓存池并不知道能不能说是一个池，说是一个管理类感觉更好点，读取的时候通过sink.writableSegment(1)来获取,这是通过操作sink的buffer来做的处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Segment writableSegment(int minimumCapacity) &#123;</span><br><span class="line">    if (minimumCapacity &lt; 1 || minimumCapacity &gt; Segment.SIZE) throw new IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">    if (head == null) &#123;</span><br><span class="line">      head = SegmentPool.take(); // Acquire a first segment.</span><br><span class="line">      return head.next = head.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Segment tail = head.prev;</span><br><span class="line">    if (tail.limit + minimumCapacity &gt; Segment.SIZE || !tail.owner) &#123;</span><br><span class="line">      tail = tail.push(SegmentPool.take()); // Append a new empty segment to fill up.</span><br><span class="line">    &#125;</span><br><span class="line">    return tail;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里比较抽象，有部分的操作是进行链表的判空等，空链表做了一些处理，最终返回的是可处理的队列的尾部（其实是指向队列头的引用，不过由于是push方式，所以头在底下，因此叫做尾部）</p>
<p>获取了尾部之后就开始通过io进行读取，这就是读取的过程。</p>
<p>相对于io来讲，这部分由于使用了自己的缓存，缓存直接取出来使用，对比拷贝效率更高效一些。</p>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>okio在最终的写入和读出上面，都使用的原生io机制，但是okio维护了自己的buffer，这个buffer相对于原生来讲不需要在source时进行拷贝，也就是直接使用引用，效果更快。另外okio是针对网络相关的，所以okio增加了超时机制也是比原生更有优势的地方。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/06/Butterknife源码学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/Butterknife源码学习/" itemprop="url">Butterknife源码学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-06T18:56:37+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目中用的butterknife是8.8.1版本，引入了两个包，一个是Butterknife,一个是ButterKnife-Annotations。</p>
<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>butterknife的基本原理其实很好理解，就是注入，通过代码中的注解，编译时进行解析，生成大量的代码，这些代码在运行时帮助提供对象</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@NonNull @UiThread</span><br><span class="line">public static Unbinder bind(@NonNull Activity target) &#123;</span><br><span class="line">  View sourceView = target.getWindow().getDecorView();</span><br><span class="line">  return createBinding(target, sourceView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是默认的绑定代码，其调用了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static Unbinder createBinding(@NonNull Object target, @NonNull View source) &#123;</span><br><span class="line">    Class&lt;?&gt; targetClass = target.getClass();</span><br><span class="line">    if (debug) Log.d(TAG, &quot;Looking up binding for &quot; + targetClass.getName());</span><br><span class="line">    Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);</span><br><span class="line"></span><br><span class="line">    if (constructor == null) &#123;</span><br><span class="line">      return Unbinder.EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //noinspection TryWithIdenticalCatches Resolves to API 19+ only type.</span><br><span class="line">    try &#123;</span><br><span class="line">      return constructor.newInstance(target, source);</span><br><span class="line">    &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">      throw new RuntimeException(&quot;Unable to invoke &quot; + constructor, e);</span><br><span class="line">    &#125; catch (InstantiationException e) &#123;</span><br><span class="line">      throw new RuntimeException(&quot;Unable to invoke &quot; + constructor, e);</span><br><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">      Throwable cause = e.getCause();</span><br><span class="line">      if (cause instanceof RuntimeException) &#123;</span><br><span class="line">        throw (RuntimeException) cause;</span><br><span class="line">      &#125;</span><br><span class="line">      if (cause instanceof Error) &#123;</span><br><span class="line">        throw (Error) cause;</span><br><span class="line">      &#125;</span><br><span class="line">      throw new RuntimeException(&quot;Unable to create binding instance.&quot;, cause);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这段话只是执行了findBindingConstructorForClass这个方法，返回了一个unbind</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Nullable @CheckResult @UiThread</span><br><span class="line">private static Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123;</span><br><span class="line">  Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);</span><br><span class="line">  if (bindingCtor != null) &#123;</span><br><span class="line">    if (debug) Log.d(TAG, &quot;HIT: Cached in binding map.&quot;);</span><br><span class="line">    return bindingCtor;</span><br><span class="line">  &#125;</span><br><span class="line">  String clsName = cls.getName();</span><br><span class="line">  if (clsName.startsWith(&quot;android.&quot;) || clsName.startsWith(&quot;java.&quot;)) &#123;</span><br><span class="line">    if (debug) Log.d(TAG, &quot;MISS: Reached framework class. Abandoning search.&quot;);</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + &quot;_ViewBinding&quot;);</span><br><span class="line">    //noinspection unchecked</span><br><span class="line">    bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);</span><br><span class="line">    if (debug) Log.d(TAG, &quot;HIT: Loaded binding class and constructor.&quot;);</span><br><span class="line">  &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    if (debug) Log.d(TAG, &quot;Not found. Trying superclass &quot; + cls.getSuperclass().getName());</span><br><span class="line">    bindingCtor = findBindingConstructorForClass(cls.getSuperclass());</span><br><span class="line">  &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">    throw new RuntimeException(&quot;Unable to find binding constructor for &quot; + clsName, e);</span><br><span class="line">  &#125;</span><br><span class="line">  BINDINGS.put(cls, bindingCtor);</span><br><span class="line">  return bindingCtor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findBindingConstructorForClass这个方法通过一个map存储下来由cls作为key的Constructor。构建过程主要是通过classloader来创建一个带有_ViewBinding后缀的java文件，同时通过class的getConstructor方法，返回的是指定的，或者是cls的参数类型构造器，或者是View.class的参数类型构造器。然后在createBinding中会通过这个构造器来构造这个类。传入的参数就是我们在调用Butterknife.bind（）中传入的两个参数，当然也可能是一个。</p>
<h1 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h1><p>当一个程序走到Butterknife.bind(this, rootview)的时候，此时正是编译时，annotation processing 会读取写出来的注解，通过butterknife processor 生成一个对应于这个类名的viewbinder内部类，这个viewbinder类包含了所有的findviewbyid和onclicklistener等方法。然后在调用Bind方法的时候，butterknife会去加载对应的viewbinder类，并调用他们的bind方法。</p>
<h1 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h1><p>通过阅读butterknife的代码，发现一个问题，什么是butterknife processor，他是如何工作的，他在哪儿？</p>
<h2 id="annotation-processor-注解处理器"><a href="#annotation-processor-注解处理器" class="headerlink" title="annotation processor - 注解处理器"></a>annotation processor - 注解处理器</h2><p>注解处理器(Annotation Processor)是javac内置的一个用于编译时扫描和处理注解(Annotation)的工具</p>
<p>由于注解处理器可以在程序编译阶段工作，所以我们可以在编译期间通过注解处理器进行我们需要的操作。比较常用的用法就是在编译期间获取相关注解数据，然后动态生成.java源文件</p>
<h2 id="为什么butterknife-processor-在项目中不存在"><a href="#为什么butterknife-processor-在项目中不存在" class="headerlink" title="为什么butterknife processor 在项目中不存在"></a>为什么butterknife processor 在项目中不存在</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">annotationProcessor &apos;com.jakewharton:butterknife-compiler:9.0.0-rc2&apos;</span><br></pre></td></tr></table></figure>
<p>这段话的意义是调用butterknife-compiler作为一个编译处理器。在编译的时候，会自动调用butterknife-compiler的代码，来协助进行编译。</p>
<p>由于调用的代码没有直接使用的意义，且没有提供开放的api，因此在studio中使用annotationprocessor，并不会看到相应的代码。</p>
<h2 id="butterknife-processor-是在扫描完注解之后执行，还是在扫描注解之前执行"><a href="#butterknife-processor-是在扫描完注解之后执行，还是在扫描注解之前执行" class="headerlink" title="butterknife processor 是在扫描完注解之后执行，还是在扫描注解之前执行"></a>butterknife processor 是在扫描完注解之后执行，还是在扫描注解之前执行</h2><p>很明显，扫描完注解之后是生成viewbinder，这一步就已经用到了butterknife processor，而之后的bind，仅仅是调用了生成的代码类</p>
<h1 id="通过annotation-processor来实现一个butterknife框架"><a href="#通过annotation-processor来实现一个butterknife框架" class="headerlink" title="通过annotation-processor来实现一个butterknife框架"></a>通过annotation-processor来实现一个butterknife框架</h1><p>自己实现原理也差不多，会加几层包装</p>
<p><a href="https://blog.csdn.net/android_jianbo/article/details/79180907" target="_blank" rel="noopener">实现方式</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/06/2018年第四十七周工作小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/2018年第四十七周工作小结/" itemprop="url">2018年第四十七周工作小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-06T18:56:13+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上周比较累，一个版本发了两周，而且上周结束还没有完成发版的任务。</p>
<p>多人开发本来就有很多问题，但是最关键的问题还是大锅饭的问题。</p>
<p>三个人每个人都有两个任务，从上上周开始做，由于任务比较重，所以要了两周的工时，我从上上周三接口对接了开始做，直到上周二全部完成正式提测。而他们是怎么做的呢？一个上上周全部宕机，直到上周一才开始做，做到周四结束提测。另一个是每天下午做一点，到点跑路。也是周四提测。</p>
<p>也就是一个组，我周三测试完毕全部通过后，等到周四他们才提测。</p>
<p>结果呢？如果能力足够，确保bug不多的话，多晚提测都没问题，但是出了30多个bug是个什么鬼。</p>
<p>我心里简直日了狗，本来准备周五发版，结果周四晚上出了30多个bug，而且在一个人身上就有25个。没办法，因为我手上没活，被迫帮人收拾摊子。搞到了周六凌晨三点多。各种奇奇怪怪的bug，有逻辑错误的，有移植过程参数丢失的，而且还有接口错误的，神奇，接口对接的时候在玩猴子啊。真是想吐槽一车的。</p>
<p>说回大锅饭，多人开发，多人协助是没错的，但是前期各种拖，各种没事找事，到后期deadline了，开始抢工期，表现的很勤奋，真不知道是给谁看。最后需要做的快的人来帮忙收拾摊子。做的东西难吗？搞了两周，逻辑错误还是外人一眼就能看出来的，这是认真搞了？</p>
<p>神烦是周五晚上，两个人都像是宕机了，看着我在debug，一个在看博客，另一个在盯着我改bug。我心里简直是日了狗，非我的模块，非我的职责，最后变成了我来维护。这也罢了，我帮忙做事，能不能给点面子表现的好点，看着我改是什么鬼？</p>
<p>大锅饭真是让人疲惫的事情，没有必要的激励，出问题大家抗，没问题就当无事发生。这种不健全的制度，怎么可能留得住想好好发展的人。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/28/项目卡顿问题优化专题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/28/项目卡顿问题优化专题/" itemprop="url">项目卡顿问题优化专题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-28T11:07:03+08:00">
                2018-11-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>公司做了一波推广，卡顿问题比较明显的显示了出来。华为荣耀系列的卡顿问题尤其明显，很多用户反映在看上新的时候卡顿比较严重，还有用户说在使用时间较长之后，就比较卡顿。</p>
<p>刚好这周把需求做完并且全部提测通过了，因此有三天的时间来做轻度优化。不过这个专题需要常驻，因为app需要优化的地方实在是太多了。</p>
<h1 id="商品详情"><a href="#商品详情" class="headerlink" title="商品详情"></a>商品详情</h1><p>商品详情页面是所有spu最终展示的地方，这个地方是所有用户必然经过的地方，商品详情页不是所有页面的终点，不是唯一的，所以商品详情页面有很多可以优化的地方。</p>
<h2 id="无限跳转优化"><a href="#无限跳转优化" class="headerlink" title="无限跳转优化"></a>无限跳转优化</h2><p>商品详情页面作为展示spu的地方，其中却又展示了很多不同的spu，另外相同spu之间也是支持跳转的。</p>
<p>我对比了淘宝和微博，淘宝只支持保留三个spu，但是相同spu是可以跳转的，而微博支持无限跳转，我试了超过10个都可以返回，但是微博不支持在一个人主页里面仍然跳进这个人主页，也就是不支持相同spu的跳转。</p>
<p>和产品讨论了一下，这个地方相同spu仍然支持跳转，但是最多保留5个。</p>
<p>我设计这地方的方案是在application里面持有activity的引用，在activity启动的时候，进行判断，如果是详情页面，就放入数组里面，否则就不管。放进数组里面之后会判断是否数组长度是否超过4个，超过的话就会进行移除的操作，手动执行finish。</p>
<p>另外在destroy的时候，也这样判断，决定是否直接移除。</p>
<p>操作的入口比较好找，直接套用application的registerActivityLifecycleCallbacks即可。</p>
<p>在这个地方有一个问题，关于对activity的持有是否需要使用weakreference。</p>
<p>registerActivityLifecycleCallbacks的源码在application里面，主要的操作通过collectActivityLifecycleCallbacks来反馈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private Object[] collectActivityLifecycleCallbacks() &#123;</span><br><span class="line">        Object[] callbacks = null;</span><br><span class="line">        synchronized (mActivityLifecycleCallbacks) &#123;</span><br><span class="line">            if (mActivityLifecycleCallbacks.size() &gt; 0) &#123;</span><br><span class="line">                callbacks = mActivityLifecycleCallbacks.toArray();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return callbacks;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要是在各activity生命周期开始的时候进行执行</p>
<p>启动的时候如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* package */ void dispatchActivityCreated(Activity activity, Bundle savedInstanceState) &#123;</span><br><span class="line">       Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">       if (callbacks != null) &#123;</span><br><span class="line">           for (int i=0; i&lt;callbacks.length; i++) &#123;</span><br><span class="line">               ((ActivityLifecycleCallbacks)callbacks[i]).onActivityCreated(activity,</span><br><span class="line">                       savedInstanceState);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>关闭的时候如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* package */ void dispatchActivityDestroyed(Activity activity) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i=0; i&lt;callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks)callbacks[i]).onActivityDestroyed(activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>问题就在actvity是在走destroy之前执行该方法，还是走完之后执行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">protected void onDestroy() &#123;</span><br><span class="line">       if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onDestroy &quot; + this);</span><br><span class="line">       mCalled = true;</span><br><span class="line"></span><br><span class="line">       // dismiss any dialogs we are managing.</span><br><span class="line">       if (mManagedDialogs != null) &#123;</span><br><span class="line">           final int numDialogs = mManagedDialogs.size();</span><br><span class="line">           for (int i = 0; i &lt; numDialogs; i++) &#123;</span><br><span class="line">               final ManagedDialog md = mManagedDialogs.valueAt(i);</span><br><span class="line">               if (md.mDialog.isShowing()) &#123;</span><br><span class="line">                   md.mDialog.dismiss();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           mManagedDialogs = null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // close any cursors we are managing.</span><br><span class="line">       synchronized (mManagedCursors) &#123;</span><br><span class="line">           int numCursors = mManagedCursors.size();</span><br><span class="line">           for (int i = 0; i &lt; numCursors; i++) &#123;</span><br><span class="line">               ManagedCursor c = mManagedCursors.get(i);</span><br><span class="line">               if (c != null) &#123;</span><br><span class="line">                   c.mCursor.close();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           mManagedCursors.clear();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Close any open search dialog</span><br><span class="line">       if (mSearchManager != null) &#123;</span><br><span class="line">           mSearchManager.stopSearch();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (mActionBar != null) &#123;</span><br><span class="line">           mActionBar.onDestroy();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       getApplication().dispatchActivityDestroyed(this);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>因此就证明了，destroy是在分发之前执行的，此时使用弱引用其实并不碍事，即使destroy的时候发生了gc，也没有太大的问题，只要之后的过程中将被回收的值对应的key清除即可。</p>
<p>weakreference在这边如果使用的话，需要考虑到contain的写法，需要判断的比较多，经过尝试，其实效率和直接强引用差不多。</p>
<h2 id="详情页面泄露问题"><a href="#详情页面泄露问题" class="headerlink" title="详情页面泄露问题"></a>详情页面泄露问题</h2><h1 id="lt-lt-lt-lt-lt-lt-lt-HEAD"><a href="#lt-lt-lt-lt-lt-lt-lt-HEAD" class="headerlink" title="&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</h1><h2 id="详情页面启动速度慢的问题"><a href="#详情页面启动速度慢的问题" class="headerlink" title="详情页面启动速度慢的问题"></a>详情页面启动速度慢的问题</h2><blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b118970018c3a2c7fcdae0b7c13c257f3c14c202</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h1 id="订单发起页面"><a href="#订单发起页面" class="headerlink" title="订单发起页面"></a>订单发起页面</h1><p>订单发起页面和普通页面不同，主要差别在于订单发起页面在很多地方都可以发起，但是其作用是唯一的，就是发起这个订单，并且继续后续的流程。但是由于在很多地方都可以发起订单，且订单页面又可以发起去很多地方。所以订单发起页面事实上也是无限的页面。</p>
<p>但是订单发起页面不需要保留用户的返回路径，仅仅只需要一个活着的页面反复调用即可。</p>
<p>因此我的做法是，在订单发起页面的start函数中，添加flag为FLAG_ACTIVITY_REORDER_TO_FRONT</p>
<p>因为试了一下发现FLAG_ACTIVITY_BROUGHT_TO_FRONT并无效，所以只可以尝试FLAG_ACTIVITY_REORDER_TO_FRONT</p>
<p>详细代码为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void start(Activity activity)&#123;</span><br><span class="line">        Intent intent = new Intent(activity, OrderConfirmActivity.class);</span><br><span class="line">        intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);</span><br><span class="line">        activity.startActivity(intent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="splash页优化"><a href="#splash页优化" class="headerlink" title="splash页优化"></a>splash页优化</h1><p>splash页面是app的进入时必走的页面，从leaks上面看，也有泄露的问题，检查发现泄露在lambda表达式中，而所有的lambda都是rxjava写的回调表达式，因此所做的是将这个页面所有的observable与该splashactivity的lifecycle绑定，另外eventbus也加了一些强判断（其实没啥必要），为了保险。</p>
<h2 id="引导页面"><a href="#引导页面" class="headerlink" title="引导页面"></a>引导页面</h2><p>2.8.0版本增加了引导页面，引导用户去设置medel，最近出现oom的现象，排查发现整个设置流程都没有进入destroy。因此在登录成功之后，启动了新的task来load，这样可以强制删除这些无用的流程。</p>
<h1 id="vipZoon页面"><a href="#vipZoon页面" class="headerlink" title="vipZoon页面"></a>vipZoon页面</h1><p>vipzone是会员专区，这个页面是滑动式，每个请求发现都没有捆绑住lifecycle，进行了捆绑处理</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/25/2018年第四十六周工作小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/25/2018年第四十六周工作小结/" itemprop="url">2018年第四十六周工作小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-25T22:55:08+08:00">
                2018-11-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本周的主要工作是完成了medel放大，手势滑动，以及分享到app等功能。</p>
<p>medel放大主要使用的是photoview的改写版本，因为产品要求不支持反转，因此读了一下代码去掉了反转的操作，放大的弹性指数用的是正常的2.5倍。medel放大，手势等等业务逻辑写的都比较简单。</p>
<p>这次medel的放大页面，需要使用viewpager进行滑动更改，因此这就需要了进行medel的bitmap缓存，按照以往的写法，这个地方应该写一个lrucache，配套SoftReference<bitmap>来使用，但是调试过程中发现了一些问题。</bitmap></p>
<p>softreference是当内存不足的时候会被强制回收，lrucache里面携带的是linkedlist，直接使用key指向该软引用，lrucache里面会记录目前保留下来的数量，然后作对比。但是比较神奇的是，发现了lrucache里面记录的数量大于0，但是linkedlist里面size却为0了。做了两个对比，当不使用软引用，直接使用携带bitmap，发现并不会出现这种情况。关于这个问题查了一下，其实jvm并不希望我们使用软引用，因为无法确定何时回收比较好，因此此处回收的机制并不是当内存不足的时候才回收，由于给了1/8最大可用内存，因此此处应该是触发了一个最大内存限制，导致直接被强制回收了所有软引用的地方，导致发生了这个问题。另外实验了一下，在recyclerview中，当view被回收复用的时候，此时使用软引用就不会触发这个问题，因为当view被回收复用的时候，此时就会释放该部分指向，当这部分到了内存限制的时候回被自然的回收，但是viewpager中view不会被回收，而且我没有设置最大页面的offset，导致这个问题发生。</p>
<p>因此以后使用到软引用的时候，不能光认为是内存不足就会被回收，要做好直接被回收的准备，否则就不应该使用软引用。</p>
<p>另外这次关于medel的设计，是在spu详情页面，spu详情页面跳出medel预览，然后medel预览还可以跳转详情，这涉及一个无限跳转的问题，测试发现一个详情页面占用起码300M内存，但是如果是相同的大概只会增加100M，但是如果无限跳转肯定会导致内存不足的问题，从淘宝测试了一下，淘宝最多只允许三个页面跳转，因此我们也需要考虑到这个问题。</p>
<p>下个版本需要设计一下页面多级跳转的问题。目前思想是在activty栈里面做一些设置，在相同activity过多的时候，采取旧页面强制销毁的方式，然后启动新的页面，这样应该可以解决这个问题</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sample</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">123</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sample</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
