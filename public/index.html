<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="记录者">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="记录者">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="记录者">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>记录者</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">记录者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/15/设计模式以及java举例/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/15/设计模式以及java举例/" itemprop="url">设计模式以及java举例</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-15T00:13:47+08:00">
                2019-02-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h1><ol>
<li>开闭原则</li>
</ol>
<p>对拓展开放，对修改关闭。</p>
<ol>
<li>里氏替换原则</li>
</ol>
<p>只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正的被复用，而衍生类也能在基类的基础上增加新的行为。</p>
<ol>
<li>依赖倒转原则</li>
</ol>
<p>对接口编程，依赖于抽象而不依赖于具体。</p>
<ol>
<li>接口隔离原则</li>
</ol>
<p>使用多个隔离的接口来降低耦合度</p>
<ol>
<li>迪米特法则</li>
</ol>
<p>一个实体应该尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立</p>
<ol>
<li>合成复用原则</li>
</ol>
<p>尽量使用合成/聚合的方式，而不是使用继承，继承实际上破坏了类的封装性，超类的方法可能被子类修改</p>
<h1 id="三大类"><a href="#三大类" class="headerlink" title="三大类"></a>三大类</h1><p>基于6个设计原则，衍生为3大类23种设计模式</p>
<h2 id="创造型模式"><a href="#创造型模式" class="headerlink" title="创造型模式"></a>创造型模式</h2><ul>
<li><p>工厂方法模式</p>
</li>
<li><p>抽象工厂模式</p>
</li>
<li><p>单例模式</p>
</li>
<li><p>建造者模式</p>
</li>
<li><p>原型模式</p>
</li>
</ul>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><ul>
<li><p>适配器模式</p>
</li>
<li><p>装饰器模式</p>
</li>
<li><p>代理模式</p>
</li>
<li><p>外观模式</p>
</li>
<li><p>桥接模式</p>
</li>
<li><p>组合模式</p>
</li>
<li><p>享元模式</p>
</li>
</ul>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><ul>
<li><p>策略模式</p>
</li>
<li><p>模版方法模式</p>
</li>
<li><p>观察者模式</p>
</li>
<li><p>迭代子模式</p>
</li>
<li><p>责任链模式</p>
</li>
<li><p>命令模式</p>
</li>
<li><p>备忘录模式</p>
</li>
<li><p>状态模式</p>
</li>
<li><p>访问者模式</p>
</li>
<li><p>中介者模式</p>
</li>
<li><p>解释器模式</p>
</li>
</ul>
<h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>通过new创建一个对象，大部分时候需要传入构造参数，或者生成对象之前需要先生成一些辅助功能的对象。<br>这样可以抽象的认为一个对象的构建如同机器中的齿轮转动，最后通过生成了很多对象之后，生成了一个最终的对象。</p>
<h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>不关心对象实例构造的细节和复杂过程，而轻松的创建实例</p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>实例构建过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//声明抽象接口类</span><br><span class="line">interface food&#123;&#125;</span><br><span class="line"></span><br><span class="line">//需要的实体类需要继承该接口</span><br><span class="line">class A implements food&#123;&#125;</span><br><span class="line">class B implements food&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>工厂过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface produce&#123; food get();&#125;</span><br><span class="line"></span><br><span class="line">class FactoryForA implements produce&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public food get() &#123;</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class FactoryForB implements produce&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public food get() &#123;</span><br><span class="line">        return new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>抽象工厂过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AbstractFactory &#123;</span><br><span class="line">    public void ClientCode(String name)&#123;</span><br><span class="line">        if(name.equals(&quot;A&quot;))&#123;</span><br><span class="line">            food x= new FactoryForA().get();</span><br><span class="line">            x = new FactoryForB().get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>工厂过程其实可以直接合成一个Factory使用，但是工厂过程一般都是静态方法，不支持动态更改。<br>而转变为抽象工厂模式，每次需要增加一个实例的话只需要增加一个工厂类，然后抽象工厂方法可以直接</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/28/tinker机制学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/28/tinker机制学习/" itemprop="url">tinker机制学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-28T13:06:52+08:00">
                2019-01-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/27/recyclerview源码学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/27/recyclerview源码学习/" itemprop="url">recyclerview源码学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-27T17:50:30+08:00">
                2019-01-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="绘制过程"><a href="#绘制过程" class="headerlink" title="绘制过程"></a>绘制过程</h1><p>绘制过程需要理解的是如何一个itemview一个itemview的绘制</p>
<h2 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">protected void onMeasure(int widthSpec, int heightSpec) &#123;</span><br><span class="line">        if (mLayout == null) &#123;</span><br><span class="line">            //layoutManager没有设置的话，直接走default的方法，所以会为空白</span><br><span class="line">            defaultOnMeasure(widthSpec, heightSpec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mLayout.mAutoMeasure) &#123;</span><br><span class="line">            final boolean skipMeasure = widthMode == MeasureSpec.EXACTLY</span><br><span class="line">                    &amp;&amp; heightMode == MeasureSpec.EXACTLY;</span><br><span class="line">            //如果测量是绝对值，则跳过measure过程直接走layout</span><br><span class="line">            if (skipMeasure || mAdapter == null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">                //mLayoutStep默认值是 State.STEP_START</span><br><span class="line">                dispatchLayoutStep1();</span><br><span class="line">                //执行完dispatchLayoutStep1()后是State.STEP_LAYOUT</span><br><span class="line">            &#125;</span><br><span class="line">             ..........</span><br><span class="line">            //真正执行LayoutManager绘制的地方</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">            //执行完后是State.STEP_ANIMATIONS</span><br><span class="line">             ..........</span><br><span class="line">            //宽高都不确定的时候，会绘制两次</span><br><span class="line">            // if RecyclerView has non-exact width and height and if there is at least one child</span><br><span class="line">            // which also has non-exact width &amp; height, we have to re-measure.</span><br><span class="line">            if (mLayout.shouldMeasureTwice()) &#123;</span><br><span class="line">             ..........</span><br><span class="line">                dispatchLayoutStep2();</span><br><span class="line">             ..........            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (mHasFixedSize) &#123;</span><br><span class="line">                mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">             ..........</span><br><span class="line">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">             ..........</span><br><span class="line">            mState.mInPreLayout = false; // clear</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">--------------------- </span><br><span class="line">别人概括的measure过程</span><br></pre></td></tr></table></figure>
<p>从这里大概分为三步，毕竟三个else</p>
<h3 id="layout-null"><a href="#layout-null" class="headerlink" title="layout == null"></a>layout == null</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void defaultOnMeasure(int widthSpec, int heightSpec) &#123;</span><br><span class="line">        // calling LayoutManager here is not pretty but that API is already public and it is better</span><br><span class="line">        // than creating another method since this is internal.</span><br><span class="line">        final int width = LayoutManager.chooseSize(widthSpec,</span><br><span class="line">                getPaddingLeft() + getPaddingRight(),</span><br><span class="line">                ViewCompat.getMinimumWidth(this));</span><br><span class="line">        final int height = LayoutManager.chooseSize(heightSpec,</span><br><span class="line">                getPaddingTop() + getPaddingBottom(),</span><br><span class="line">                ViewCompat.getMinimumHeight(this));</span><br><span class="line">        setMeasuredDimension(width, height);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static int chooseSize(int spec, int desired, int min) &#123;</span><br><span class="line">            int mode = MeasureSpec.getMode(spec);</span><br><span class="line">            int size = MeasureSpec.getSize(spec);</span><br><span class="line">            switch(mode) &#123;</span><br><span class="line">            case -2147483648:</span><br><span class="line">                return Math.min(size, Math.max(desired, min));</span><br><span class="line">            case 0:</span><br><span class="line">            default:</span><br><span class="line">                return Math.max(desired, min);</span><br><span class="line">            case 1073741824:</span><br><span class="line">                return size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下面其实是处理了一下高度的问题，如果有padding的话，会将padding归入计算</p>
<h3 id="mlayout-null-amp-amp-mLayout-isAutoMeasureEnabled"><a href="#mlayout-null-amp-amp-mLayout-isAutoMeasureEnabled" class="headerlink" title="mlayout != null &amp;&amp;  mLayout.isAutoMeasureEnabled()"></a>mlayout != null &amp;&amp;  mLayout.isAutoMeasureEnabled()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean isAutoMeasureEnabled() &#123;</span><br><span class="line">            return mAutoMeasure;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">         * Defines whether the measuring pass of layout should use the AutoMeasure mechanism of</span><br><span class="line">         * &#123;@link RecyclerView&#125; or if it should be done by the LayoutManager&apos;s implementation of</span><br><span class="line">         * &#123;@link LayoutManager#onMeasure(Recycler, State, int, int)&#125;.</span><br><span class="line">         *</span><br><span class="line">         * @param enabled &lt;code&gt;True&lt;/code&gt; if layout measurement should be done by the</span><br><span class="line">         *                RecyclerView, &lt;code&gt;false&lt;/code&gt; if it should be done by this</span><br><span class="line">         *                LayoutManager.</span><br><span class="line">         *</span><br><span class="line">         * @see #isAutoMeasureEnabled()</span><br><span class="line">         *</span><br><span class="line">         * @deprecated Implementors of LayoutManager should define whether or not it uses</span><br><span class="line">         *             AutoMeasure by overriding &#123;@link #isAutoMeasureEnabled()&#125;.</span><br><span class="line">         */</span><br><span class="line">        @Deprecated</span><br><span class="line">        public void setAutoMeasureEnabled(boolean enabled) &#123;</span><br><span class="line">            mAutoMeasure = enabled;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这个api是deprecate的，其功能主要是设置自动测量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">if (mLayout.mAutoMeasure) &#123;</span><br><span class="line">            final int widthMode = MeasureSpec.getMode(widthSpec);</span><br><span class="line">            final int heightMode = MeasureSpec.getMode(heightSpec);</span><br><span class="line">            final boolean skipMeasure = widthMode == MeasureSpec.EXACTLY</span><br><span class="line">                    &amp;&amp; heightMode == MeasureSpec.EXACTLY;</span><br><span class="line">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">            if (skipMeasure || mAdapter == null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">                dispatchLayoutStep1();</span><br><span class="line">            &#125;</span><br><span class="line">            // set dimensions in 2nd step. Pre-layout should happen with old dimensions for</span><br><span class="line">            // consistency</span><br><span class="line">            mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class="line">            mState.mIsMeasuring = true;</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line"></span><br><span class="line">            // now we can get the width and height from the children.</span><br><span class="line">            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">            // if RecyclerView has non-exact width and height and if there is at least one child</span><br><span class="line">            // which also has non-exact width &amp; height, we have to re-measure.</span><br><span class="line">            if (mLayout.shouldMeasureTwice()) &#123;</span><br><span class="line">                mLayout.setMeasureSpecs(</span><br><span class="line">                        MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),</span><br><span class="line">                        MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));</span><br><span class="line">                mState.mIsMeasuring = true;</span><br><span class="line">                dispatchLayoutStep2();</span><br><span class="line">                // now we can get the width and height from the children.</span><br><span class="line">                mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>如果测量是绝对值，则不再进行measure而直接layout，毕竟EXACTLY是写死了面积了，recyclerview的父类会直接获取面积来摆放</p>
</li>
<li><p>STATE变量为start时</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final int STEP_START = 1;</span><br><span class="line">static final int STEP_LAYOUT = 1 &lt;&lt; 1;</span><br><span class="line">static final int STEP_ANIMATIONS = 1 &lt;&lt; 2;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * The first step of a layout where we;</span><br><span class="line">     * - process adapter updates</span><br><span class="line">     * - decide which animation should run</span><br><span class="line">     * - save information about current views</span><br><span class="line">     * - If necessary, run predictive layout and save its information</span><br><span class="line">     */</span><br><span class="line">    private void dispatchLayoutStep1() &#123;</span><br><span class="line">        mState.assertLayoutStep(State.STEP_START);</span><br><span class="line">        fillRemainingScrollValues(mState);</span><br><span class="line">        mState.mIsMeasuring = false;</span><br><span class="line">        startInterceptRequestLayout();</span><br><span class="line">        mViewInfoStore.clear();</span><br><span class="line">        onEnterLayoutOrScroll();</span><br><span class="line">        processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">        saveFocusInfo();</span><br><span class="line">        mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations &amp;&amp; mItemsChanged;</span><br><span class="line">        mItemsAddedOrRemoved = mItemsChanged = false;</span><br><span class="line">        mState.mInPreLayout = mState.mRunPredictiveAnimations;</span><br><span class="line">        mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">        findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);</span><br><span class="line"></span><br><span class="line">        if (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">            // Step 0: Find out where all non-removed items are, pre-layout</span><br><span class="line">            int count = mChildHelper.getChildCount();</span><br><span class="line">            for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">                final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">                if (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                final ItemHolderInfo animationInfo = mItemAnimator</span><br><span class="line">                        .recordPreLayoutInformation(mState, holder,</span><br><span class="line">                                ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),</span><br><span class="line">                                holder.getUnmodifiedPayloads());</span><br><span class="line">                mViewInfoStore.addToPreLayout(holder, animationInfo);</span><br><span class="line">                if (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved()</span><br><span class="line">                        &amp;&amp; !holder.shouldIgnore() &amp;&amp; !holder.isInvalid()) &#123;</span><br><span class="line">                    long key = getChangedHolderKey(holder);</span><br><span class="line">                    // This is NOT the only place where a ViewHolder is added to old change holders</span><br><span class="line">                    // list. There is another case where:</span><br><span class="line">                    //    * A VH is currently hidden but not deleted</span><br><span class="line">                    //    * The hidden item is changed in the adapter</span><br><span class="line">                    //    * Layout manager decides to layout the item in the pre-Layout pass (step1)</span><br><span class="line">                    // When this case is detected, RV will un-hide that view and add to the old</span><br><span class="line">                    // change holders list.</span><br><span class="line">                    mViewInfoStore.addToOldChangeHolders(key, holder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">            // Step 1: run prelayout: This will use the old positions of items. The layout manager</span><br><span class="line">            // is expected to layout everything, even removed items (though not to add removed</span><br><span class="line">            // items back to the container). This gives the pre-layout position of APPEARING views</span><br><span class="line">            // which come into existence as part of the real layout.</span><br><span class="line"></span><br><span class="line">            // Save old positions so that LayoutManager can run its mapping logic.</span><br><span class="line">            saveOldPositions();</span><br><span class="line">            final boolean didStructureChange = mState.mStructureChanged;</span><br><span class="line">            mState.mStructureChanged = false;</span><br><span class="line">            // temporarily disable flag because we are asking for previous layout</span><br><span class="line">            mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">            mState.mStructureChanged = didStructureChange;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; mChildHelper.getChildCount(); ++i) &#123;</span><br><span class="line">                final View child = mChildHelper.getChildAt(i);</span><br><span class="line">                final ViewHolder viewHolder = getChildViewHolderInt(child);</span><br><span class="line">                if (viewHolder.shouldIgnore()) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!mViewInfoStore.isInPreLayout(viewHolder)) &#123;</span><br><span class="line">                    int flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder);</span><br><span class="line">                    boolean wasHidden = viewHolder</span><br><span class="line">                            .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</span><br><span class="line">                    if (!wasHidden) &#123;</span><br><span class="line">                        flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;</span><br><span class="line">                    &#125;</span><br><span class="line">                    final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(</span><br><span class="line">                            mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads());</span><br><span class="line">                    if (wasHidden) &#123;</span><br><span class="line">                        recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // we don&apos;t process disappearing list because they may re-appear in post layout pass.</span><br><span class="line">            clearOldPositions();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            clearOldPositions();</span><br><span class="line">        &#125;</span><br><span class="line">        onExitLayoutOrScroll();</span><br><span class="line">        stopInterceptRequestLayout(false);</span><br><span class="line">        mState.mLayoutStep = State.STEP_LAYOUT;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从备注的内容中可以知道，这个步骤有四个功能</p>
<ul>
<li>处理adapter的更新</li>
<li>决定哪些动画需要执行</li>
<li>保存当前view的信息</li>
<li>如果必要的情况下，执行上一个layout的操作并且保存他的信息</li>
</ul>
<p>该步骤只是做了准备工作</p>
<ol>
<li>state不为start时</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * The second layout step where we do the actual layout of the views for the final state.</span><br><span class="line">    * This step might be run multiple times if necessary (e.g. measure).</span><br><span class="line">    */</span><br><span class="line">   private void dispatchLayoutStep2() &#123;</span><br><span class="line">       startInterceptRequestLayout();</span><br><span class="line">       onEnterLayoutOrScroll();</span><br><span class="line">       mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);</span><br><span class="line">       mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">       mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">       mState.mDeletedInvisibleItemCountSincePreviousLayout = 0;</span><br><span class="line"></span><br><span class="line">       // Step 2: Run layout</span><br><span class="line">       mState.mInPreLayout = false;</span><br><span class="line">       mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line"></span><br><span class="line">       mState.mStructureChanged = false;</span><br><span class="line">       mPendingSavedState = null;</span><br><span class="line"></span><br><span class="line">       // onLayoutChildren may have caused client code to disable item animations; re-check</span><br><span class="line">       mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != null;</span><br><span class="line">       mState.mLayoutStep = State.STEP_ANIMATIONS;</span><br><span class="line">       onExitLayoutOrScroll();</span><br><span class="line">       stopInterceptRequestLayout(false);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里的分析需要细致一些，着重点在mLayout.onLayoutChildren()内，绘制的工作交给了layoutmanager</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</span><br><span class="line">        // layout algorithm:</span><br><span class="line">        //找寻锚点</span><br><span class="line">        // 1) by checking children and other variables, find an anchor coordinate and an anchor</span><br><span class="line">        // item position.</span><br><span class="line">        //两个方向填充，从锚点往上，从锚点往下</span><br><span class="line">        // 2) fill towards start, stacking from bottom</span><br><span class="line">        // 3) fill towards end, stacking from top</span><br><span class="line">        // 4) scroll to fulfill requirements like stack from bottom.</span><br><span class="line">        // create layout state</span><br><span class="line">        ....</span><br><span class="line">        // resolve layout direction</span><br><span class="line">        //判断绘制方向,给mShouldReverseLayout赋值,默认是正向绘制，则mShouldReverseLayout是false</span><br><span class="line">        resolveShouldLayoutReverse();</span><br><span class="line">        final View focused = getFocusedChild();</span><br><span class="line">        //mValid的默认值是false，一次测量之后设为true，onLayout完成后会回调执行reset方法，又变为false</span><br><span class="line">        if (!mAnchorInfo.mValid || mPendingScrollPosition != NO_POSITION</span><br><span class="line">                || mPendingSavedState != null) &#123;</span><br><span class="line">        ....</span><br><span class="line">            //mStackFromEnd默认是false，除非手动调用setStackFromEnd()方法，两个都会false，异或则为false</span><br><span class="line">            mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;</span><br><span class="line">            // calculate anchor position and coordinate</span><br><span class="line">            //计算锚点的位置和偏移量</span><br><span class="line">            updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</span><br><span class="line">        ....</span><br><span class="line">        &#125; else if (focused != null &amp;&amp; (mOrientationHelper.getDecoratedStart(focused)</span><br><span class="line">                &gt;= mOrientationHelper.getEndAfterPadding()</span><br><span class="line">                || mOrientationHelper.getDecoratedEnd(focused)</span><br><span class="line">                &lt;= mOrientationHelper.getStartAfterPadding())) &#123;</span><br><span class="line">         ....</span><br><span class="line">        &#125;</span><br><span class="line">         ....</span><br><span class="line">        //mLayoutFromEnd为false</span><br><span class="line">        if (mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">            //倒着绘制的话，先往上绘制，再往下绘制</span><br><span class="line">            // fill towards start</span><br><span class="line">            // 从锚点到往上</span><br><span class="line">            updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">            ....</span><br><span class="line">            fill(recycler, mLayoutState, state, false);</span><br><span class="line">            ....</span><br><span class="line">            // 从锚点到往下</span><br><span class="line">            // fill towards end</span><br><span class="line">            updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">            ....</span><br><span class="line">            //调两遍fill方法</span><br><span class="line">            fill(recycler, mLayoutState, state, false);</span><br><span class="line">            ....</span><br><span class="line">            if (mLayoutState.mAvailable &gt; 0) &#123;</span><br><span class="line">                // end could not consume all. add more items towards start</span><br><span class="line">            ....</span><br><span class="line">                updateLayoutStateToFillStart(firstElement, startOffset);</span><br><span class="line">                mLayoutState.mExtra = extraForStart;</span><br><span class="line">                fill(recycler, mLayoutState, state, false);</span><br><span class="line">             ....</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //正常绘制流程的话，先往下绘制，再往上绘制</span><br><span class="line">            // fill towards end</span><br><span class="line">            updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">            ....</span><br><span class="line">            fill(recycler, mLayoutState, state, false);</span><br><span class="line">             ....</span><br><span class="line">            // fill towards start</span><br><span class="line">            updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">            ....</span><br><span class="line">            fill(recycler, mLayoutState, state, false);</span><br><span class="line">             ....</span><br><span class="line">            if (mLayoutState.mAvailable &gt; 0) &#123;</span><br><span class="line">                ....</span><br><span class="line">                // start could not consume all it should. add more items towards end</span><br><span class="line">                updateLayoutStateToFillEnd(lastElement, endOffset);</span><br><span class="line">                 ....</span><br><span class="line">                fill(recycler, mLayoutState, state, false);</span><br><span class="line">                ....</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">        layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);</span><br><span class="line">        //完成后重置参数</span><br><span class="line">        if (!state.isPreLayout()) &#123;</span><br><span class="line">            mOrientationHelper.onLayoutComplete();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mAnchorInfo.reset();</span><br><span class="line">        &#125;</span><br><span class="line">        mLastStackFromEnd = mStackFromEnd;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>摘抄了别人分析的内容，很明显，这是linearlayoutmanager一个完整的layout的过程，说实话真的很复杂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">先寻找页面当前的锚点 </span><br><span class="line">以这个锚点未基准，向上和向下分别填充 </span><br><span class="line">填充完后，如果还有剩余的可填充大小，再填充一次</span><br></pre></td></tr></table></figure>
<p>从这个角度来讲，可以大致理解为绘制的顺序，是首先绘制可见区域及以下的内容，而后绘制可见区域以上的内容，这个上下会依据重心来变化</p>
<p>以前listview的绘制，大概也是差不多的，不过listview有个细节，是不设定数量的情况下，只绘制可见区域及上下加起来7个大小。分析recyclerview的源码发现，其绘制的区域仅仅是可见区域，如果需要预先绘制的话，需要自己制定预先加载的数量，其中的差别体现的还是比较明显的，因为layoutmanager需要考虑绘制的时候的动画。</p>
<h3 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    if (mHasFixedSize) &#123;</span><br><span class="line">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // custom onMeasure</span><br><span class="line">    if (mAdapterUpdateDuringMeasure) &#123;</span><br><span class="line">        startInterceptRequestLayout();</span><br><span class="line">        onEnterLayoutOrScroll();</span><br><span class="line">        processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">        onExitLayoutOrScroll();</span><br><span class="line"></span><br><span class="line">        if (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">            mState.mInPreLayout = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // consume remaining updates to provide a consistent state with the layout pass.</span><br><span class="line">            mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">            mState.mInPreLayout = false;</span><br><span class="line">        &#125;</span><br><span class="line">        mAdapterUpdateDuringMeasure = false;</span><br><span class="line">        stopInterceptRequestLayout(false);</span><br><span class="line">    &#125; else if (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">        // If mAdapterUpdateDuringMeasure is false and mRunPredictiveAnimations is true:</span><br><span class="line">        // this means there is already an onMeasure() call performed to handle the pending</span><br><span class="line">        // adapter change, two onMeasure() calls can happen if RV is a child of LinearLayout</span><br><span class="line">        // with layout_width=MATCH_PARENT. RV cannot call LM.onMeasure() second time</span><br><span class="line">        // because getViewForPosition() will crash when LM uses a child to measure.</span><br><span class="line">        setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight());</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mAdapter != null) &#123;</span><br><span class="line">        mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mState.mItemCount = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    startInterceptRequestLayout();</span><br><span class="line">    mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">    stopInterceptRequestLayout(false);</span><br><span class="line">    mState.mInPreLayout = false; // clear</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一步是当recyclerview没有设置<strong>mLayout.isAutoMeasureEnabled()</strong>的时候出现的，默认情况下走的就是这一步。</p>
<p>这一步的含义是将绘制权直接交于layoutmanager来绘制，有个细节，就是如果期望绘制的过程由recyclerview内部来进行的话，就不要再重写layoutmanager的onmeasure了。不过对于我们这种大多数时候直接调用linearlayoutmanager的，平时不会太注意这个。</p>
<p>回到这一步上来，大概做了这样几件事</p>
<ol>
<li>当设置了hasfixedsize时</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * RecyclerView can perform several optimizations if it can know in advance that RecyclerView&apos;s</span><br><span class="line">     * size is not affected by the adapter contents. RecyclerView can still change its size based</span><br><span class="line">     * on other factors (e.g. its parent&apos;s size) but this size calculation cannot depend on the</span><br><span class="line">     * size of its children or contents of its adapter (except the number of items in the adapter).</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * If your use of RecyclerView falls into this category, set this to &#123;@code true&#125;. It will allow</span><br><span class="line">     * RecyclerView to avoid invalidating the whole layout when its adapter contents change.</span><br><span class="line">     *</span><br><span class="line">     * @param hasFixedSize true if adapter changes cannot affect the size of the RecyclerView.</span><br><span class="line">     */</span><br></pre></td></tr></table></figure>
<p>也就是当item的大小是固定的，不会出现根据adapter的内容变化的布局，这样recyclerview就会依据某些参数固定下来他的尺寸，并不会在参考其内部数据变化而计算出来的尺寸。算是<strong>优化</strong>的一个注意点</p>
<p>设置了这个参数之后，就会直接甩手给layoutmanager进行onmeasure操作</p>
<ol>
<li>未设置hasfixedsize时 &amp;&amp; adapter在onmeasure过程中正在更新</li>
</ol>
<p>此时只会做一些状态的更改，lock的重入这样。其lock的标记位实在是太多了，不过的确没有做什么事情，不过此过程如果进行，会跳转到第四步继续下去</p>
<ol>
<li>未设置hasfixedsize时 &amp;&amp; adapter 不在更新 &amp;&amp; 目前的状态处在更新之前的动画时</li>
</ol>
<p>此时会在更新完前一个item动画之后在更新自己，所以此时只做了一个动作，就是提前将宽高的measurespec设置完毕</p>
<ol>
<li>以上都没有的情况下</li>
</ol>
<p>首先会调用layoutmanager的onmeasure，之后会清除状态位。</p>
<h4 id="最后一步的一个总结"><a href="#最后一步的一个总结" class="headerlink" title="最后一步的一个总结"></a>最后一步的一个总结</h4><p>为什么hasfixedsize起作用呢？</p>
<p>因为当未设置这个的时候，会等待adapter更新结束才会绘制，而adapter的更新会有一系列的等待，等待数据处理结束之后，才会再次做一个更新的操作。<br>而设置了hasfixedsize之后，就不会等待更新了，而是会直接进行绘制。</p>
<p>另外拷一份关于这个的别人的总结</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">总结：当我们确定Item的改变不会影响RecyclerView的宽高的时候可以设置setHasFixedSize(true)，并通过Adapter的增删改插方法去刷新RecyclerView，而不是通过notifyDataSetChanged()。（其实可以直接设置为true，当需要改变宽高的时候就用notifyDataSetChanged()去整体刷新一下）</span><br><span class="line">--------------------- </span><br><span class="line">作者：wsdaijianjun </span><br><span class="line">来源：CSDN </span><br><span class="line">原文：https://blog.csdn.net/wsdaijianjun/article/details/74735039 </span><br><span class="line">版权声明：本文为博主原创文章，转载请附上博文链接！</span><br></pre></td></tr></table></figure>
<h2 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">    ...</span><br><span class="line">    dispatchLayout();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Wrapper around layoutChildren() that handles animating changes caused by layout.</span><br><span class="line">     * Animations work on the assumption that there are five different kinds of items</span><br><span class="line">     * in play:</span><br><span class="line">     * PERSISTENT: items are visible before and after layout</span><br><span class="line">     * REMOVED: items were visible before layout and were removed by the app</span><br><span class="line">     * ADDED: items did not exist before layout and were added by the app</span><br><span class="line">     * DISAPPEARING: items exist in the data set before/after, but changed from</span><br><span class="line">     * visible to non-visible in the process of layout (they were moved off</span><br><span class="line">     * screen as a side-effect of other changes)</span><br><span class="line">     * APPEARING: items exist in the data set before/after, but changed from</span><br><span class="line">     * non-visible to visible in the process of layout (they were moved on</span><br><span class="line">     * screen as a side-effect of other changes)</span><br><span class="line">     * The overall approach figures out what items exist before/after layout and</span><br><span class="line">     * infers one of the five above states for each of the items. Then the animations</span><br><span class="line">     * are set up accordingly:</span><br><span class="line">     * PERSISTENT views are animated via</span><br><span class="line">     * &#123;@link ItemAnimator#animatePersistence(ViewHolder, ItemHolderInfo, ItemHolderInfo)&#125;</span><br><span class="line">     * DISAPPEARING views are animated via</span><br><span class="line">     * &#123;@link ItemAnimator#animateDisappearance(ViewHolder, ItemHolderInfo, ItemHolderInfo)&#125;</span><br><span class="line">     * APPEARING views are animated via</span><br><span class="line">     * &#123;@link ItemAnimator#animateAppearance(ViewHolder, ItemHolderInfo, ItemHolderInfo)&#125;</span><br><span class="line">     * and changed views are animated via</span><br><span class="line">     * &#123;@link ItemAnimator#animateChange(ViewHolder, ViewHolder, ItemHolderInfo, ItemHolderInfo)&#125;.</span><br><span class="line">     */</span><br><span class="line">    void dispatchLayout() &#123;</span><br><span class="line">        if (mAdapter == null) &#123;</span><br><span class="line">            Log.e(TAG, &quot;No adapter attached; skipping layout&quot;);</span><br><span class="line">            // leave the state in START</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mLayout == null) &#123;</span><br><span class="line">            Log.e(TAG, &quot;No layout manager attached; skipping layout&quot;);</span><br><span class="line">            // leave the state in START</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mState.mIsMeasuring = false;</span><br><span class="line">        if (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">            dispatchLayoutStep1();</span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">        &#125; else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()</span><br><span class="line">                || mLayout.getHeight() != getHeight()) &#123;</span><br><span class="line">            // First 2 steps are done in onMeasure but looks like we have to run again due to</span><br><span class="line">            // changed size.</span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // always make sure we sync them (to ensure mode is exact)</span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatchLayoutStep3();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>onlayout的过程相对比较简单，即是直接通过state的状态，来设置目前需要走到哪一步。其中dispatchlayoutstep1和dispatchlayoutstep2都是onmeasure过程中使用到的。</p>
<p>唯一不知道的是dispatchlayoutstep3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * The final step of the layout where we save the information about views for animations,</span><br><span class="line">    * trigger animations and do any necessary cleanup.</span><br><span class="line">    */</span><br><span class="line">   private void dispatchLayoutStep3() &#123;</span><br><span class="line">       mState.assertLayoutStep(State.STEP_ANIMATIONS);</span><br><span class="line">       eatRequestLayout();</span><br><span class="line">       onEnterLayoutOrScroll();</span><br><span class="line">       mState.mLayoutStep = State.STEP_START;</span><br><span class="line">       if (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">           // Step 3: Find out where things are now, and process change animations.</span><br><span class="line">           // traverse list in reverse because we may call animateChange in the loop which may</span><br><span class="line">           // remove the target view holder.</span><br><span class="line">           for (int i = mChildHelper.getChildCount() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">               ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">               if (holder.shouldIgnore()) &#123;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">               long key = getChangedHolderKey(holder);</span><br><span class="line">               final ItemHolderInfo animationInfo = mItemAnimator</span><br><span class="line">                       .recordPostLayoutInformation(mState, holder);</span><br><span class="line">               ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key);</span><br><span class="line">               if (oldChangeViewHolder != null &amp;&amp; !oldChangeViewHolder.shouldIgnore()) &#123;</span><br><span class="line">                   // run a change animation</span><br><span class="line"></span><br><span class="line">                   // If an Item is CHANGED but the updated version is disappearing, it creates</span><br><span class="line">                   // a conflicting case.</span><br><span class="line">                   // Since a view that is marked as disappearing is likely to be going out of</span><br><span class="line">                   // bounds, we run a change animation. Both views will be cleaned automatically</span><br><span class="line">                   // once their animations finish.</span><br><span class="line">                   // On the other hand, if it is the same view holder instance, we run a</span><br><span class="line">                   // disappearing animation instead because we are not going to rebind the updated</span><br><span class="line">                   // VH unless it is enforced by the layout manager.</span><br><span class="line">                   final boolean oldDisappearing = mViewInfoStore.isDisappearing(</span><br><span class="line">                           oldChangeViewHolder);</span><br><span class="line">                   final boolean newDisappearing = mViewInfoStore.isDisappearing(holder);</span><br><span class="line">                   if (oldDisappearing &amp;&amp; oldChangeViewHolder == holder) &#123;</span><br><span class="line">                       // run disappear animation instead of change</span><br><span class="line">                       mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       final ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout(</span><br><span class="line">                               oldChangeViewHolder);</span><br><span class="line">                       // we add and remove so that any post info is merged.</span><br><span class="line">                       mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">                       ItemHolderInfo postInfo = mViewInfoStore.popFromPostLayout(holder);</span><br><span class="line">                       if (preInfo == null) &#123;</span><br><span class="line">                           handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder);</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           animateChange(oldChangeViewHolder, holder, preInfo, postInfo,</span><br><span class="line">                                   oldDisappearing, newDisappearing);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Step 4: Process view info lists and trigger animations</span><br><span class="line">           mViewInfoStore.process(mViewInfoProcessCallback);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mLayout.removeAndRecycleScrapInt(mRecycler);</span><br><span class="line">       mState.mPreviousLayoutItemCount = mState.mItemCount;</span><br><span class="line">       mDataSetHasChangedAfterLayout = false;</span><br><span class="line">       mState.mRunSimpleAnimations = false;</span><br><span class="line"></span><br><span class="line">       mState.mRunPredictiveAnimations = false;</span><br><span class="line">       mLayout.mRequestedSimpleAnimations = false;</span><br><span class="line">       if (mRecycler.mChangedScrap != null) &#123;</span><br><span class="line">           mRecycler.mChangedScrap.clear();</span><br><span class="line">       &#125;</span><br><span class="line">       if (mLayout.mPrefetchMaxObservedInInitialPrefetch) &#123;</span><br><span class="line">           // Initial prefetch has expanded cache, so reset until next prefetch.</span><br><span class="line">           // This prevents initial prefetches from expanding the cache permanently.</span><br><span class="line">           mLayout.mPrefetchMaxCountObserved = 0;</span><br><span class="line">           mLayout.mPrefetchMaxObservedInInitialPrefetch = false;</span><br><span class="line">           mRecycler.updateViewCacheSize();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mLayout.onLayoutCompleted(mState);</span><br><span class="line">       onExitLayoutOrScroll();</span><br><span class="line">       resumeRequestLayout(false);</span><br><span class="line">       mViewInfoStore.clear();</span><br><span class="line">       if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) &#123;</span><br><span class="line">           dispatchOnScrolled(0, 0);</span><br><span class="line">       &#125;</span><br><span class="line">       recoverFocusFromState();</span><br><span class="line">       resetFocusInfo();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里看上去，能了解几个信息点，首先是处理了动画，在然后是reset了一些状态。这一步和布局没有什么必然的关系。</p>
<h2 id="全布局总结"><a href="#全布局总结" class="headerlink" title="全布局总结"></a>全布局总结</h2><p>这里我就直接抄了，我的言语也最多总结成这样。</p>
<p>第一步：<br>处理Adapter的更新<br>决定哪些动画播放<br>保存当前View的信息<br>如果有必要的话再进行上一布局操作，并保存它的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void dispatchLayoutStep1() &#123;</span><br><span class="line">    …… // 省略代码，该部分判断状态和更改状态以及保存一些信息</span><br><span class="line">    // 下面这个方法很重要，那么我们先略过，看下下面的内容。哎~我就这么调皮!哈哈，</span><br><span class="line">    // 其实是，在没有讲动画流程之前，根本讲不清。这个是动画流程的中间过程。所以</span><br><span class="line">    // ，在这里只要先知道，这里是处理Adapter更新，并计算动画类型的即可。</span><br><span class="line">    processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">    …… // 设置一些状态，保存一些信息。</span><br><span class="line"></span><br><span class="line">    // 下面的内容是需要运行动画的情况下进行的，主要做的事情就是找出那些要需要进</span><br><span class="line">    // 行上一布局操作的ViewHolder，并且保存它们的边界信息。如果有更新操作(这个更新</span><br><span class="line">    // 指的是内容的更新，不是插入删除的这种更新)，然后保存这些更新的ViewHolder</span><br><span class="line">    if (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        …… // 看上面的解释，这里代码都是和动画相关的，暂时懒得放，太占地方</span><br><span class="line">    &#125;</span><br><span class="line">    // 下面的内容是需要在布局结束之后运行动画的情况下执行的。主要做的事情就是</span><br><span class="line">    // 执行上一布局操作，上一布局操作其实就是先以上一次的状态执行一边LayoutManager</span><br><span class="line">    // 的onLayoutChildren方法，其实RecyclerView的布局策略就是在</span><br><span class="line">    // LayoutManager的onLayoutChildren方法中。执行一次它就获得了所有</span><br><span class="line">    // ViewHolder的边界信息。只不过，这次获得的是之前状态下的ViewHolder的</span><br><span class="line">    // 边界信息。不过这个应该是要在LayoutManager中，根据state的isPreLayout</span><br><span class="line">    // 的返回值，选择使用新的还是旧的position。但我在系统给的几个LayoutManager中</span><br><span class="line">    // 都没有看到。</span><br><span class="line">    if (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">        …… </span><br><span class="line">        mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">    …… //恢复状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二步：真正的布局</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void dispatchLayoutStep2() &#123;</span><br><span class="line">    …… // 设置状态</span><br><span class="line">    mState.mInPreLayout = false; // 更改此状态，确保不是会执行上一布局操作</span><br><span class="line">    // 真正布局就是这一句话，布局的具体策略交给了LayoutManager，哈哈!这篇的主角讲完了!</span><br><span class="line">    mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">    …… // 设置和恢复状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步：</p>
<p>保存信息，触发动画，清除垃圾<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void dispatchLayoutStep3() &#123;</span><br><span class="line">    …… // 设置状态</span><br><span class="line">    if (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        …… // 需要动画的情况。找出ViewHolder现在的位置，并且处理改变动画。最后触发动画。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …… // 清除状态和清除无用的信息</span><br><span class="line">    mLayout.onLayoutCompleted(mState); // 给LayoutManager的布局完成的回调</span><br><span class="line">    …… // 清除状体和清楚无用的信息，最后在恢复一些信息信息，比如焦点。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h1><p>recyclerview的缓存主要在view的复用</p>
<p>其依赖于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final View view = recycler.getViewForPosition(mCurrentPosition);</span><br></pre></td></tr></table></figure></p>
<p>该方法获取了viewholder的itemview</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">         * Obtain a view initialized for the given position.</span><br><span class="line">         *</span><br><span class="line">         * This method should be used by &#123;@link LayoutManager&#125; implementations to obtain</span><br><span class="line">         * views to represent data from an &#123;@link Adapter&#125;.</span><br><span class="line">         * &lt;p&gt;</span><br><span class="line">         * The Recycler may reuse a scrap or detached view from a shared pool if one is</span><br><span class="line">         * available for the correct view type. If the adapter has not indicated that the</span><br><span class="line">         * data at the given position has changed, the Recycler will attempt to hand back</span><br><span class="line">         * a scrap view that was previously initialized for that data without rebinding.</span><br><span class="line">         *</span><br><span class="line">         * @param position Position to obtain a view for</span><br><span class="line">         * @return A view representing the data at &lt;code&gt;position&lt;/code&gt; from &lt;code&gt;adapter&lt;/code&gt;</span><br><span class="line">         */</span><br><span class="line">        public View getViewForPosition(int position) &#123;</span><br><span class="line">            return getViewForPosition(position, false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        View getViewForPosition(int position, boolean dryRun) &#123;</span><br><span class="line">            return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Attempts to get the ViewHolder for the given position, either from the Recycler scrap,</span><br><span class="line">         * cache, the RecycledViewPool, or creating it directly.</span><br><span class="line">         * &lt;p&gt;</span><br><span class="line">         * If a deadlineNs other than &#123;@link #FOREVER_NS&#125; is passed, this method early return</span><br><span class="line">         * rather than constructing or binding a ViewHolder if it doesn&apos;t think it has time.</span><br><span class="line">         * If a ViewHolder must be constructed and not enough time remains, null is returned. If a</span><br><span class="line">         * ViewHolder is aquired and must be bound but not enough time remains, an unbound holder is</span><br><span class="line">         * returned. Use &#123;@link ViewHolder#isBound()&#125; on the returned object to check for this.</span><br><span class="line">         *</span><br><span class="line">         * @param position Position of ViewHolder to be returned.</span><br><span class="line">         * @param dryRun True if the ViewHolder should not be removed from scrap/cache/</span><br><span class="line">         * @param deadlineNs Time, relative to getNanoTime(), by which bind/create work should</span><br><span class="line">         *                   complete. If FOREVER_NS is passed, this method will not fail to</span><br><span class="line">         *                   create/bind the holder if needed.</span><br><span class="line">         *</span><br><span class="line">         * @return ViewHolder for requested position</span><br><span class="line">         */</span><br><span class="line">        @Nullable</span><br><span class="line">        ViewHolder tryGetViewHolderForPositionByDeadline(int position,</span><br><span class="line">                boolean dryRun, long deadlineNs) &#123;</span><br><span class="line">            if (position &lt; 0 || position &gt;= mState.getItemCount()) &#123;</span><br><span class="line">                throw new IndexOutOfBoundsException(&quot;Invalid item position &quot; + position</span><br><span class="line">                        + &quot;(&quot; + position + &quot;). Item count:&quot; + mState.getItemCount()</span><br><span class="line">                        + exceptionLabel());</span><br><span class="line">            &#125;</span><br><span class="line">            boolean fromScrapOrHiddenOrCache = false;</span><br><span class="line">            ViewHolder holder = null;</span><br><span class="line">            // 0) If there is a changed scrap, try to find from there</span><br><span class="line">            if (mState.isPreLayout()) &#123;</span><br><span class="line">                holder = getChangedScrapViewForPosition(position);</span><br><span class="line">                fromScrapOrHiddenOrCache = holder != null;</span><br><span class="line">            &#125;</span><br><span class="line">            // 1) Find by position from scrap/hidden list/cache</span><br><span class="line">            if (holder == null) &#123;</span><br><span class="line">                holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</span><br><span class="line">                if (holder != null) &#123;</span><br><span class="line">                    if (!validateViewHolderForOffsetPosition(holder)) &#123;</span><br><span class="line">                        // recycle holder (and unscrap if relevant) since it can&apos;t be used</span><br><span class="line">                        if (!dryRun) &#123;</span><br><span class="line">                            // we would like to recycle this but need to make sure it is not used by</span><br><span class="line">                            // animation logic etc.</span><br><span class="line">                            holder.addFlags(ViewHolder.FLAG_INVALID);</span><br><span class="line">                            if (holder.isScrap()) &#123;</span><br><span class="line">                                removeDetachedView(holder.itemView, false);</span><br><span class="line">                                holder.unScrap();</span><br><span class="line">                            &#125; else if (holder.wasReturnedFromScrap()) &#123;</span><br><span class="line">                                holder.clearReturnedFromScrapFlag();</span><br><span class="line">                            &#125;</span><br><span class="line">                            recycleViewHolderInternal(holder);</span><br><span class="line">                        &#125;</span><br><span class="line">                        holder = null;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        fromScrapOrHiddenOrCache = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (holder == null) &#123;</span><br><span class="line">                final int offsetPosition = mAdapterHelper.findPositionOffset(position);</span><br><span class="line">                if (offsetPosition &lt; 0 || offsetPosition &gt;= mAdapter.getItemCount()) &#123;</span><br><span class="line">                    throw new IndexOutOfBoundsException(&quot;Inconsistency detected. Invalid item &quot;</span><br><span class="line">                            + &quot;position &quot; + position + &quot;(offset:&quot; + offsetPosition + &quot;).&quot;</span><br><span class="line">                            + &quot;state:&quot; + mState.getItemCount() + exceptionLabel());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int type = mAdapter.getItemViewType(offsetPosition);</span><br><span class="line">                // 2) Find from scrap/cache via stable ids, if exists</span><br><span class="line">                if (mAdapter.hasStableIds()) &#123;</span><br><span class="line">                    holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</span><br><span class="line">                            type, dryRun);</span><br><span class="line">                    if (holder != null) &#123;</span><br><span class="line">                        // update position</span><br><span class="line">                        holder.mPosition = offsetPosition;</span><br><span class="line">                        fromScrapOrHiddenOrCache = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (holder == null &amp;&amp; mViewCacheExtension != null) &#123;</span><br><span class="line">                    // We are NOT sending the offsetPosition because LayoutManager does not</span><br><span class="line">                    // know it.</span><br><span class="line">                    final View view = mViewCacheExtension</span><br><span class="line">                            .getViewForPositionAndType(this, position, type);</span><br><span class="line">                    if (view != null) &#123;</span><br><span class="line">                        holder = getChildViewHolder(view);</span><br><span class="line">                        if (holder == null) &#123;</span><br><span class="line">                            throw new IllegalArgumentException(&quot;getViewForPositionAndType returned&quot;</span><br><span class="line">                                    + &quot; a view which does not have a ViewHolder&quot;</span><br><span class="line">                                    + exceptionLabel());</span><br><span class="line">                        &#125; else if (holder.shouldIgnore()) &#123;</span><br><span class="line">                            throw new IllegalArgumentException(&quot;getViewForPositionAndType returned&quot;</span><br><span class="line">                                    + &quot; a view that is ignored. You must call stopIgnoring before&quot;</span><br><span class="line">                                    + &quot; returning this view.&quot; + exceptionLabel());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (holder == null) &#123; // fallback to pool</span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        Log.d(TAG, &quot;tryGetViewHolderForPositionByDeadline(&quot;</span><br><span class="line">                                + position + &quot;) fetching from shared pool&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    holder = getRecycledViewPool().getRecycledView(type);</span><br><span class="line">                    if (holder != null) &#123;</span><br><span class="line">                        holder.resetInternal();</span><br><span class="line">                        if (FORCE_INVALIDATE_DISPLAY_LIST) &#123;</span><br><span class="line">                            invalidateDisplayListInt(holder);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (holder == null) &#123;</span><br><span class="line">                    long start = getNanoTime();</span><br><span class="line">                    if (deadlineNs != FOREVER_NS</span><br><span class="line">                            &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123;</span><br><span class="line">                        // abort - we have a deadline we can&apos;t meet</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    holder = mAdapter.createViewHolder(RecyclerView.this, type);</span><br><span class="line">                    if (ALLOW_THREAD_GAP_WORK) &#123;</span><br><span class="line">                        // only bother finding nested RV if prefetching</span><br><span class="line">                        RecyclerView innerView = findNestedRecyclerView(holder.itemView);</span><br><span class="line">                        if (innerView != null) &#123;</span><br><span class="line">                            holder.mNestedRecyclerView = new WeakReference&lt;&gt;(innerView);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    long end = getNanoTime();</span><br><span class="line">                    mRecyclerPool.factorInCreateTime(type, end - start);</span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        Log.d(TAG, &quot;tryGetViewHolderForPositionByDeadline created new ViewHolder&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码写的还是比较容易懂得，其实就是按照顺序去缓存里面寻找viewholder。</p>
<p>缓存的顺序是</p>
<ol>
<li><p>状态为预加载时：</p>
<p> getChangedScrapViewForPosition() -&gt; 从mChangedScrap中找</p>
</li>
<li><p>没找着或者压根没走预加载：</p>
<p> getScrapOrHiddenOrCachedHolderForPosition() -&gt; </p>
<pre><code>从mAttachedScrap中找layoutposition等于该position的
-&gt;还没找着-&gt;从mCachedViews中寻找
</code></pre></li>
<li><p>还没找着：</p>
<p> adapter里面有stable id：</p>
<pre><code>getScrapOrCachedViewForId() -&gt; 从mAttachedScrap中找itemid等于id的
</code></pre><p> 没找着或adapter里面没有stable id:</p>
<pre><code>mViewCacheExtension.getViewForPositionAndType() -&gt; 在viewCacheExtension存在的前提下，从对用户扩展的viewCacheExtension中找
</code></pre><p> 还没找着：</p>
<pre><code>getRecycledViewPool().getRecycledView() -&gt; 从循环view池里面获取被循环的viewholder，这个循环view池默认也就存5个
</code></pre><p> 再没找着：</p>
<pre><code>mAdapter.createViewHolder() -&gt;创建一个viewholder
</code></pre></li>
</ol>
<p>//吐槽一下：明明是一个问题，为什么if还不嵌套…</p>
<p><img src="/images/android/recyclerview缓存模型.jpg" alt="缓存的顺序图，copy自bugly"></p>
<h2 id="总结一下：三层缓存"><a href="#总结一下：三层缓存" class="headerlink" title="总结一下：三层缓存"></a>总结一下：三层缓存</h2><p>View的detach和remove: </p>
<p><strong>detach</strong>: 在ViewGroup中的实现很简单，只是将ChildView<strong>从ParentView的ChildView数组中移除，ChildView的mParent设置为null, 可以理解为轻量级的临时remove, 因为View此时和View树还是藕断丝连, 这个函数被经常用来改变ChildView在ChildView数组中的次序。</strong>View被detach一般是临时的，在后面会被重新attach。</p>
<p><strong>remove</strong>: 真正的移除，不光被从ChildView数组中除名，其他和View树各项联系也会被彻底斩断(不考虑Animation/LayoutTransition这种特殊情况)， 比如焦点被清除，从TouchTarget中被移除等。</p>
<blockquote>
<blockquote>
<p>Scrap View指的是在RecyclerView中，处于根据数据刷新界面等行为, ChildView被detach(注意这个detach指的是1中介绍的detach行为，而不是RecyclerView一部分注释中的”detach”，RecyclerView一部分注释中的”detach”其实指得是上面的remove)，并且被存储到了Recycler中，这部分ChildView就是Scrap View。</p>
</blockquote>
</blockquote>
<ol>
<li>第一级缓存</li>
</ol>
<p>Scrap View: mAttachedScrap和mChangedScrap<br>Removeed View: mCachedViews</p>
<ol>
<li>第二级缓存</li>
</ol>
<p>ViewCacheExtension(可选可配置)： 供使用者自行扩展，让使用者可以控制缓存</p>
<ol>
<li>第三级缓存</li>
</ol>
<p>RecycledViewPool(可配置): RecyclerView之间共享ViewHolder的缓存池</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/16/looper的message分发方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/16/looper的message分发方式/" itemprop="url">looper的message分发方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-16T18:47:19+08:00">
                2019-01-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前一阵遇到一个问题，就是looper在循环调用messageQueue中的message的时候，如何判断message的来源，并分发到对应的handler对象中的？</p>
<p>当时认为是message中附带了对应的来源，或者说在发送message时使用了类似eventbus的方式进行了注册。</p>
<p>直到今天看了源码…</p>
<h1 id="loop"><a href="#loop" class="headerlink" title="loop()"></a>loop()</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">for (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); // might block</span><br><span class="line">            if (msg == null) &#123;</span><br><span class="line">                // No message indicates that the message queue is quitting.</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // This must be in a local variable, in case a UI event sets the logger</span><br><span class="line">            final Printer logging = me.mLogging;</span><br><span class="line">            if (logging != null) &#123;</span><br><span class="line">                logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                        msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line"></span><br><span class="line">            final long traceTag = me.mTraceTag;</span><br><span class="line">            if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">            &#125;</span><br><span class="line">            final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">            final long end;</span><br><span class="line">            try &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (traceTag != 0) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (slowDispatchThresholdMs &gt; 0) &#123;</span><br><span class="line">                final long time = end - start;</span><br><span class="line">                if (time &gt; slowDispatchThresholdMs) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot;</span><br><span class="line">                            + Thread.currentThread().getName() + &quot;, h=&quot; +</span><br><span class="line">                            msg.target + &quot; cb=&quot; + msg.callback + &quot; msg=&quot; + msg.what);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (logging != null) &#123;</span><br><span class="line">                logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Make sure that during the course of dispatching the</span><br><span class="line">            // identity of the thread wasn&apos;t corrupted.</span><br><span class="line">            final long newIdent = Binder.clearCallingIdentity();</span><br><span class="line">            if (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</span><br><span class="line">                        + Long.toHexString(ident) + &quot; to 0x&quot;</span><br><span class="line">                        + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</span><br><span class="line">                        + msg.target.getClass().getName() + &quot; &quot;</span><br><span class="line">                        + msg.callback + &quot; what=&quot; + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>loop的过程看起来还是比较简单的，核心在于一个时延和分发。</p>
<p>当检测到messagequeue中有消息的时候，会执行该消息的dispatchmessage()方法</p>
<h1 id="msg-target"><a href="#msg-target" class="headerlink" title="msg.target"></a>msg.target</h1><p>该target对象是handler，也就是message中封了一个handler对像</p>
<h1 id="dispatchmessage"><a href="#dispatchmessage" class="headerlink" title="dispatchmessage()"></a>dispatchmessage()</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">        if (msg.callback != null) &#123;</span><br><span class="line">            // 当 Message 存在回调方法，回调 msg.callback.run() 方法</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (mCallback != null) &#123;</span><br><span class="line">                // 当 Handler 存在 Callback 成员变量时，回调方法 handleMessage()</span><br><span class="line">                if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // Handler 自身的回调方法 handleMessage()</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从这里可以看出，针对msg有三种处理方式</p>
<h2 id="单独处理callback"><a href="#单独处理callback" class="headerlink" title="单独处理callback"></a>单独处理callback</h2><p>当callback不为空的时候，会优先处理callback，这个callback的就是在post的时候的runnable对象</p>
<h2 id="构造处理msg"><a href="#构造处理msg" class="headerlink" title="构造处理msg"></a>构造处理msg</h2><p>当不是调用post方法进行的操作，会处理msg。如果构造的时候传入了callback，就会调用传入的callback方法的handlemessage方法</p>
<h2 id="自身处理msg"><a href="#自身处理msg" class="headerlink" title="自身处理msg"></a>自身处理msg</h2><p>如果没有传入callback，那么就会调用handler自身的hanldeMessage方法。</p>
<p>该方法默认是一个空方法，需要重写handlemessage方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果是直接post一个runnable对象的话，当处理这个massage的时候，会直接调用该msg携带的runnable直接进行。</p>
<p>如果是使用message方式来传递的话，需要处理该message，则需要两种方式</p>
<p>1.向Hanlder的构造函数传入一个Handler.Callback对象，并实现Handler.Callback的handleMessage方法<br>2.无需向Hanlder的构造函数传入Handler.Callback对象，但是需要重写Handler本身的handleMessage方法</p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>message分发判断是否传入到对应的handler中，其实是message自身携带的handler对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static Message getPostMessage(Runnable r) &#123;</span><br><span class="line">       Message m = Message.obtain();</span><br><span class="line">       m.callback = r;</span><br><span class="line">       return m;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>post的时候会通过这个方法对runnable对象进行封装，这样就顺利的将一个runnable与message联系起来，之后looper执行的时候仍然可以以message为对象进行处理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/16/神策埋点reftype踩坑记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/16/神策埋点reftype踩坑记/" itemprop="url">神策埋点reftype踩坑记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-16T15:30:27+08:00">
                2019-01-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目需要上报埋点，但是部分埋点需要携带reftype，而reftype却需要从上个页面报到下个页面来。</p>
<p>从安卓上面来讲，一个页面是一个activity的形式，而reftype需要传递，有两种方式，一种是reftype以intent的bundle参数传入，第二种是在长于activity的生命周期保存这个reftype实现存储存取方式。</p>
<p>第一种可以完全完美的解决的问题，但是带来的是过于繁琐的步骤，每个启动的intent都需要加，这样十分复杂，在新加的页面中这样写start()函数还是可以的，但是在我们这种有多路径，而且很多老页面中无法这样使用。并且如果单加一个reftype还可以，如果需要加上refid，from等参数，带来的更改复杂度几何度上升。</p>
<p>第二种是借助第三方进行传递。这个是上个版本使用的，当时是通过静态变量进行传递。在当时reftype报的不是很多的情况下，尤其是只希望观察reftype是某个过程的行为的情况下使用比较合适。</p>
<p>不过新的产品每次的埋点方案都很神奇，是单页面多过程埋点，需要兼顾返回清除问题，同时还需要报页面停留时长。</p>
<p>相对于老的静态变量存储行为就不可以这么改了。当这个变量没有和页面的部分方法捆绑的时候，这个操作会造成不可逆的效果。而如果和方法捆绑的话，则又会造成大量的逻辑重构，更加麻烦。</p>
<p>组内进行了一次神策的讨论（吐槽一下，其实很久之前就立项想动刀这个了，只是动刀的人一直懒着不动，终于拖到让我来弄了）。大致想法如下：</p>
<ol>
<li>仍然沿用静态变量的行为</li>
<li>在页面中保留静态变量的实例，oncreate的时候获取，onresume的时候对全局的静态变量进行覆盖</li>
<li>更改页面reftype的地方由之前的点击变为oncreate的时候直接获取</li>
</ol>
<p>这样可以完全完成A-&gt;B-&gt;C-&gt;B，这么一个过程中，B记录了A的reftype，回到b的时候onresume虽然全局是B，但是由于B记录了A，onresume的时候就会使得A覆盖B。同时在没有更改reftype的时候，会保证全局reftype的行为可以传递。</p>
<p>思路上面比较简单，用这个来实现一些数据阶段性传递比较有意义。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/13/java对象的三种状态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/13/java对象的三种状态/" itemprop="url">java对象的三种状态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-13T22:13:03+08:00">
                2019-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近被问到一个问题，java对象有几种状态？<br>没有接触过这个，说实话被问到的时候连一点可说的都没有。</p>
<p>因此总结一下网上对java对象的几种状态：可触及态、可复活态、不可触及态</p>
<h1 id="可触及态（可达状态）"><a href="#可触及态（可达状态）" class="headerlink" title="可触及态（可达状态）"></a>可触及态（可达状态）</h1><p>从根节点开始，可以搜索到这个状态，也就是可以访问到这个状态</p>
<h1 id="可复活态（可恢复态）"><a href="#可复活态（可恢复态）" class="headerlink" title="可复活态（可恢复态）"></a>可复活态（可恢复态）</h1><p>从根节点开始，无论如何都不能访问到这个对象，也就是说这个对象的所有引用都被释放，没有任何变量引用该对象了，<br>但是该对象有可能在finalize()方法中再次被引用，从而复活。</p>
<p>垃圾回收器在准备回收垃圾时，调用finalize方法，在finalize方法中，系统有可能重新让一个或多个引用指向该对象，那么这个对象就由可恢复状态变为可达状态。 </p>
<h1 id="不可触及态（不可恢复态）"><a href="#不可触及态（不可恢复态）" class="headerlink" title="不可触及态（不可恢复态）"></a>不可触及态（不可恢复态）</h1><p>在finalize()方法中没有复活，这样这个对象就消失在了内存堆中</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/09/volatile的作用及其原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/09/volatile的作用及其原理/" itemprop="url">volatile的作用及其原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-09T19:03:23+08:00">
                2019-01-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>背景：计算机执行程序时，每条指令都是在cpu中执行的，执行过程中会涉及到数据的读取和写入，由于程序运行过程中的临时数据时存放在主存中（物理内存），这就产生了一个问题，cpu执行速度很快，而从内存读取数据和向内写入数据的过程比cpu执行的速度慢，因此计算机在cpu里面增加了高速缓存</p>
<p>cpu运行过程中，会讲运算需要的数据从主存中复制一份到cpu的高速缓存当中，那么当cpu进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，运算结束之后，再将高速缓存中的数据刷行到主存当中。</p>
<p>譬如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i + 1;</span><br></pre></td></tr></table></figure></p>
<p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后cpu执行指令对i进行+1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存中。</p>
<p>这个代码在多线程中会出现问题，由于多核cpu环境下，每条线程可能运行于不同的cpu中，因此每个线程运行时有自己的高速缓存。当a和b同时执行这条语句的时候，a将i拷贝到了高速缓存中，执行+1操作，此时如果b线程也拷贝到高速缓存中，此时读取的值还是a未+1的值</p>
<p>此时就出现了缓存不一致的问题，这也是著名的缓存一致性问题，通常这种被多个线程访问的变量称为共享变量。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决方法有两种，一种是在总线加lock锁的方式，二是通过缓存一致性协议</p>
<h3 id="总线加lock"><a href="#总线加lock" class="headerlink" title="总线加lock"></a>总线加lock</h3><p>总线加lock的方式可以阻塞主所有其他cpu对其他部件的访问（如内存），从而使得只有一个cpu能使用这个变量的内存。</p>
<p>上述的例子，a在执行i = i + 1的时候，在总线上面发出lock的信号，那么只有等这段代码执行完毕之后，其他cpu才能在i所在的内存读取变量</p>
<p>也就是sychronize在代码块上面加个锁</p>
<h3 id="通过缓存一致性协议"><a href="#通过缓存一致性协议" class="headerlink" title="通过缓存一致性协议"></a>通过缓存一致性协议</h3><p>当cpu写数据时，如果发现操作的变量是共享变量，即在其他cpu中也存在该变量的副本，会发出信号通知其他cpu将该变量的缓存行为设置为无效状态，因此当其他cpu需要读取这个变量时，发现自己缓存中缓存该变量的缓存时无效的，那么它就会从内存中重新读取</p>
<h1 id="并发编程三大特性"><a href="#并发编程三大特性" class="headerlink" title="并发编程三大特性"></a>并发编程三大特性</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>java中对基本数据类型的读取和赋值操作是原子性操作，要么执行要么不执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = 10;//原子性操作</span><br><span class="line"></span><br><span class="line">y = x;//非原子性，先读取x的值，再将x的值写入工作内存，这两个过程都是原子性，但是合起来不是</span><br><span class="line"></span><br><span class="line">x ++;//读取x的值，加1，写入新的值，也是合起来就不是原子性了</span><br><span class="line"></span><br><span class="line">x = x + 1;//同x++</span><br></pre></td></tr></table></figure>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性就是使用volatile关键字来保证</p>
<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存中，当有其他线程需要读取时，他会去内存中读取新值。</p>
<p>对于一个没有被volatile修饰的普通共享变量，因为普通共享变量被修改之后，什么时候被写入主存时不确定的，当其他线程去读取时，此时内存可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，通过sychronized和lock也可以保证可见性，sychronized和lock能保证同一时刻只有一个线程获取锁，然后执行同步代码，并且释放锁之前会将对变量的修改刷行到主存当中，因此可以保证可见性</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>在java内存模型中，允许编译器和处理器对指令进行重排序，但是排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性</p>
<p>在java里面可以通过volatile关键字来保证一定的“有序性”，另外可以通过sychronized和lock来保证有序性，sychronized和lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性</p>
<p>另外，java内存模型具备一些先天的“有序性”，即不需要任何手段就能保证的有序性</p>
<h3 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens - before原则"></a>happens - before原则</h3><h4 id="程序次序规则"><a href="#程序次序规则" class="headerlink" title="程序次序规则"></a>程序次序规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</span><br></pre></td></tr></table></figure>
<h4 id="锁定规则"><a href="#锁定规则" class="headerlink" title="锁定规则"></a>锁定规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个unlock操作先行发生于后面对同一个锁unlock操作</span><br></pre></td></tr></table></figure>
<h4 id="volatile变量规则"><a href="#volatile变量规则" class="headerlink" title="volatile变量规则"></a>volatile变量规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对一个变量的写操作先行发生于后面对这个变量的读操作</span><br></pre></td></tr></table></figure>
<h4 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果操作a先行发生于操作b，而操作b又先行发生于操作c，则可以得出操作a先行发生于操作c</span><br></pre></td></tr></table></figure>
<h4 id="线程启动规则"><a href="#线程启动规则" class="headerlink" title="线程启动规则"></a>线程启动规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread对象的start()方法先行发生于此线程的每一个动作</span><br></pre></td></tr></table></figure>
<h4 id="线程终结规则"><a href="#线程终结规则" class="headerlink" title="线程终结规则"></a>线程终结规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程中的所有操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</span><br></pre></td></tr></table></figure>
<h4 id="对象终结规则"><a href="#对象终结规则" class="headerlink" title="对象终结规则"></a>对象终结规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个对象的初始化完成先行发生于它的finalize()方法的开始</span><br></pre></td></tr></table></figure>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>一个共享变量被volatile修饰之后，就具备了两层语义</p>
<ol>
<li><p>保证了不同线程对这个变量进行操作时的<strong>可见性</strong>，即一个线程修改了某个变量的值，这新值对其他线程来说时立即可见的</p>
</li>
<li><p>禁止进行指令重排序</p>
</li>
</ol>
<p>一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//A</span><br><span class="line">boolean stop = false;</span><br><span class="line">while(!stop)&#123;</span><br><span class="line">	doSomething();</span><br><span class="line">&#125;</span><br><span class="line">//B</span><br><span class="line">stop = true;</span><br></pre></td></tr></table></figure>
<p>假如stop没有被volatile修饰的话，当a线程在执行A段语句的时候，b线程执行了B语句，此时可能由于没有来得及写入主存，导致a线程不知道b线程做了修改，就会造成死循环</p>
<h2 id="原理和实现机制"><a href="#原理和实现机制" class="headerlink" title="原理和实现机制"></a>原理和实现机制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">观察加入volatile关键字和没有加入volatile关键字时所生成的会变代码发现，加入volatile关键字时，会多出一个lock前缀指令</span><br><span class="line"> 										----《深入理解java虚拟机》</span><br></pre></td></tr></table></figure>
<p>lock前缀指令实际上相当于一个内存屏障(也称内存栅栏)</p>
<p>其提供了三个功能</p>
<ol>
<li><p>确保指令重排序时不会吧后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在他前面的操作已经全部完成</p>
</li>
<li><p>他会强制对缓存的操作修改立即写入主存</p>
</li>
<li><p>如果是写操作，他会导致其他cpu中对应的缓存行无效</p>
</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>sychronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于sychronized，但是要注意volatile关键字是<strong>无法替代</strong>sychronized关键字的，因为<strong>volatile关键字无法保证操作的原子性</strong></p>
<p>一般使用时需要具备2个条件：</p>
<ol>
<li><p>对变量的写操作不依赖于当前值</p>
</li>
<li><p>该变量没有包含在具有其他变量的不变式中</p>
</li>
</ol>
<h3 id="场景一：状态标记量"><a href="#场景一：状态标记量" class="headerlink" title="场景一：状态标记量"></a>场景一：状态标记量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">volatile boolean flag = false;</span><br><span class="line"></span><br><span class="line">while(!flag)&#123;</span><br><span class="line">	doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setFlag()&#123;</span><br><span class="line">	flag = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">volatile boolean inited = false;</span><br><span class="line">//线程1:</span><br><span class="line">context = loadContext();</span><br><span class="line">inited = true;</span><br><span class="line"></span><br><span class="line">//线程2:</span><br><span class="line">while(!inited)&#123;</span><br><span class="line">	sleep();</span><br><span class="line">&#125;</span><br><span class="line">doSomethingWithConfig(context);</span><br></pre></td></tr></table></figure>
<h3 id="场景二：double-check"><a href="#场景二：double-check" class="headerlink" title="场景二：double check"></a>场景二：double check</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">	private volatile static Singleton instance = null;</span><br><span class="line">	private Singleton()&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static Singleton getInstance()&#123;</span><br><span class="line">		if(instance == null)&#123;</span><br><span class="line">			sychronized(Singleton.class)&#123;</span><br><span class="line">				if(instance == null)&#123;</span><br><span class="line">					instance = new Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="volatile如何保证有序性？"><a href="#volatile如何保证有序性？" class="headerlink" title="volatile如何保证有序性？"></a>volatile如何保证有序性？</h2><p>首先，volatile禁止指令重排序，这代表两层意思</p>
<p>1.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，而在其后面的操作还没有执行</p>
<p>2.在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行，这也就是上面说的内存栅栏</p>
<p>譬如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//x、y为非volatile变量</span><br><span class="line">//flag为volatile变量</span><br><span class="line"> </span><br><span class="line">x = 2;        //语句1</span><br><span class="line">y = 0;        //语句2</span><br><span class="line">flag = true;  //语句3</span><br><span class="line">x = 4;         //语句4</span><br><span class="line">y = -1;       //语句5</span><br></pre></td></tr></table></figure>
<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会将语句3放到语句4、语句5后面，但是语句1和语句2的顺序、语句4和语句5的顺序是不做任何保证的。</p>
<p>再譬如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//线程1:</span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"> </span><br><span class="line">//线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>
<p>加入inited没有被volatile修饰的话，那么就有可能语句2再语句1之前执行，就会导致线程2崩溃。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/07/threadlocal学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/07/threadlocal学习/" itemprop="url">threadlocal学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-07T13:36:26+08:00">
                2019-01-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>threadlocal是java.lang包下面的，其作用通过类注释可以看出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This class provides thread-local variables.  These variables differ from</span><br><span class="line"> * their normal counterparts in that each thread that accesses one (via its</span><br><span class="line"> * &#123;@code get&#125; or &#123;@code set&#125; method) has its own, independently initialized</span><br><span class="line"> * copy of the variable.  &#123;@code ThreadLocal&#125; instances are typically private</span><br><span class="line"> * static fields in classes that wish to associate state with a thread (e.g.,</span><br><span class="line"> * a user ID or Transaction ID).</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;For example, the class below generates unique identifiers local to each</span><br><span class="line"> * thread.</span><br><span class="line"> * A thread&apos;s id is assigned the first time it invokes &#123;@code ThreadId.get()&#125;</span><br><span class="line"> * and remains unchanged on subsequent calls.</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"> *</span><br><span class="line"> * public class ThreadId &#123;</span><br><span class="line"> *     // Atomic integer containing the next thread ID to be assigned</span><br><span class="line"> *     private static final AtomicInteger nextId = new AtomicInteger(0);</span><br><span class="line"> *</span><br><span class="line"> *     // Thread local variable containing each thread&apos;s ID</span><br><span class="line"> *     private static final ThreadLocal&amp;lt;Integer&amp;gt; threadId =</span><br><span class="line"> *         new ThreadLocal&amp;lt;Integer&amp;gt;() &#123;</span><br><span class="line"> *             &amp;#64;Override protected Integer initialValue() &#123;</span><br><span class="line"> *                 return nextId.getAndIncrement();</span><br><span class="line"> *         &#125;</span><br><span class="line"> *     &#125;;</span><br><span class="line"> *</span><br><span class="line"> *     // Returns the current thread&apos;s unique ID, assigning it if necessary</span><br><span class="line"> *     public static int get() &#123;</span><br><span class="line"> *         return threadId.get();</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> * &lt;p&gt;Each thread holds an implicit reference to its copy of a thread-local</span><br><span class="line"> * variable as long as the thread is alive and the &#123;@code ThreadLocal&#125;</span><br><span class="line"> * instance is accessible; after a thread goes away, all of its copies of</span><br><span class="line"> * thread-local instances are subject to garbage collection (unless other</span><br><span class="line"> * references to these copies exist).</span><br><span class="line"> *</span><br><span class="line"> * @author  Josh Bloch and Doug Lea</span><br><span class="line"> * @since   1.2</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>翻译一下：<br>这个类提供了一个本地线程变量，这些变量在不同线程中有不同的副本，都是独立的原始变量的拷贝。其实例是希望与线程连接状态的独立的field。</p>
<p>因此就是在不同的thread中保留不同的值的类型。</p>
<h1 id="api"><a href="#api" class="headerlink" title="api"></a>api</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Creates a thread local variable.</span><br><span class="line">    * @see #withInitial(java.util.function.Supplier)</span><br><span class="line">    */</span><br><span class="line">   public ThreadLocal() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Returns the value in the current thread&apos;s copy of this</span><br><span class="line">    * thread-local variable.  If the variable has no value for the</span><br><span class="line">    * current thread, it is first initialized to the value returned</span><br><span class="line">    * by an invocation of the &#123;@link #initialValue&#125; method.</span><br><span class="line">    *</span><br><span class="line">    * @return the current thread&apos;s value of this thread-local</span><br><span class="line">    */</span><br><span class="line">   public T get() &#123;</span><br><span class="line">   	...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Sets the current thread&apos;s copy of this thread-local variable</span><br><span class="line">    * to the specified value.  Most subclasses will have no need to</span><br><span class="line">    * override this method, relying solely on the &#123;@link #initialValue&#125;</span><br><span class="line">    * method to set the values of thread-locals.</span><br><span class="line">    *</span><br><span class="line">    * @param value the value to be stored in the current thread&apos;s copy of</span><br><span class="line">    *        this thread-local.</span><br><span class="line">    */</span><br><span class="line">   public void set(T value) &#123;</span><br><span class="line">   	...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Removes the current thread&apos;s value for this thread-local</span><br><span class="line">    * variable.  If this thread-local variable is subsequently</span><br><span class="line">    * &#123;@linkplain #get read&#125; by the current thread, its value will be</span><br><span class="line">    * reinitialized by invoking its &#123;@link #initialValue&#125; method,</span><br><span class="line">    * unless its value is &#123;@linkplain #set set&#125; by the current thread</span><br><span class="line">    * in the interim.  This may result in multiple invocations of the</span><br><span class="line">    * &#123;@code initialValue&#125; method in the current thread.</span><br><span class="line">    *</span><br><span class="line">    * @since 1.5</span><br><span class="line">    */</span><br><span class="line">    public void remove() &#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>public 的接口就这几个。</p>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null)</span><br><span class="line">            map.set(this, value);</span><br><span class="line">        else</span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Get the map associated with a ThreadLocal. Overridden in</span><br><span class="line">     * InheritableThreadLocal.</span><br><span class="line">     *</span><br><span class="line">     * @param  t the current thread</span><br><span class="line">     * @return the map</span><br><span class="line">     */</span><br><span class="line">    ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">        return t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Create the map associated with a ThreadLocal. Overridden in</span><br><span class="line">     * InheritableThreadLocal.</span><br><span class="line">     *</span><br><span class="line">     * @param t the current thread</span><br><span class="line">     * @param firstValue value for the initial entry of the map</span><br><span class="line">     */</span><br><span class="line">    void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">        t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>set的时候会获取当前的map，如果没有就会创建，有的话就会调用map的set</p>
<p>其中有个概念，是threadlocalmap，既然是map，看看键值对是什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value)</span><br></pre></td></tr></table></figure>
<p>也就是用threadlocal作为key，其余的作为value进行存储的。</p>
<h2 id="总结一下set"><a href="#总结一下set" class="headerlink" title="总结一下set"></a>总结一下set</h2><p>1.每个thread中有一个threadlocalmap<br>2.threadlocalmap是以threadlocal为key，目标值为value的map结构<br>3.当希望存储这个threadlocal的时候，会先从线程中取出这个threadlocalmap，然后以这个threadlocal为key，将目标值传入进去。<br>4.如果当前线程没有threadlocalmap的话，会主动创建一个塞进去。</p>
<h1 id="get"><a href="#get" class="headerlink" title="get"></a>get</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Returns the value in the current thread&apos;s copy of this</span><br><span class="line">     * thread-local variable.  If the variable has no value for the</span><br><span class="line">     * current thread, it is first initialized to the value returned</span><br><span class="line">     * by an invocation of the &#123;@link #initialValue&#125; method.</span><br><span class="line">     *</span><br><span class="line">     * @return the current thread&apos;s value of this thread-local</span><br><span class="line">     */</span><br><span class="line">    public T get() &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">            if (e != null) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">            int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            if (e != null &amp;&amp; e.get() == key)</span><br><span class="line">                return e;</span><br><span class="line">            else</span><br><span class="line">                return getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            int len = tab.length;</span><br><span class="line"></span><br><span class="line">            while (e != null) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                if (k == key)</span><br><span class="line">                    return e;</span><br><span class="line">                if (k == null)</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                else</span><br><span class="line">                    i = nextIndex(i, len);</span><br><span class="line">                e = tab[i];</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">    private int expungeStaleEntry(int staleSlot) &#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            int len = tab.length;</span><br><span class="line"></span><br><span class="line">            // expunge entry at staleSlot</span><br><span class="line">            tab[staleSlot].value = null;</span><br><span class="line">            tab[staleSlot] = null;</span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">            // Rehash until we encounter null</span><br><span class="line">            Entry e;</span><br><span class="line">            int i;</span><br><span class="line">            for (i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != null;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                if (k == null) &#123;</span><br><span class="line">                    e.value = null;</span><br><span class="line">                    tab[i] = null;</span><br><span class="line">                    size--;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    int h = k.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">                    if (h != i) &#123;</span><br><span class="line">                        tab[i] = null;</span><br><span class="line"></span><br><span class="line">                        // Unlike Knuth 6.4 Algorithm R, we must scan until</span><br><span class="line">                        // null because multiple entries could have been stale.</span><br><span class="line">                        while (tab[h] != null)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        tab[h] = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;  </span><br><span class="line">        </span><br><span class="line">    private static int nextIndex(int i, int len) &#123;</span><br><span class="line">            return ((i + 1 &lt; len) ? i + 1 : 0);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>从流程上面其实就是一个map寻址操作，有个注意点，由于threadlocalmap的entry，是一个weakreference，所以有可能会出现获取的时候发现为null，此时需要擦除这个值。不过源码中擦除不单单这个值，把别的空的也同时擦除了。</p>
<h1 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         if (m != null)</span><br><span class="line">             m.remove(this);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>擦除了这个key</p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="ThreadLocalMap里Entry为何声明为WeakReference？"><a href="#ThreadLocalMap里Entry为何声明为WeakReference？" class="headerlink" title="ThreadLocalMap里Entry为何声明为WeakReference？"></a>ThreadLocalMap里Entry为何声明为WeakReference？</h2><p>引用关系是这样的</p>
<p>ThreadLocalRef持有对ThreadLocal的引用，同时map的entry也持有对threadlocal的引用，而map的引用是在Current Thread手里，这样就会造成当清除ThreadLocalRef的时候出现泄漏的情况。</p>
<p>将entry声明为weakreference，这样在上述这种情况时，就不会产生泄漏现象，但是value仍然存在，只是索引不到，map仍然持有这个对象。</p>
<p>threadlocalmap针对这个问题，特意在get和set、remove的时候，执行了擦除所有key为null的值。</p>
<h2 id="threadlocalmap避免出现内存泄漏的情况"><a href="#threadlocalmap避免出现内存泄漏的情况" class="headerlink" title="threadlocalmap避免出现内存泄漏的情况"></a>threadlocalmap避免出现内存泄漏的情况</h2><p>1.尽量避免使用static修饰，会拉伸threadlocal声明周期<br>2.分配使用了threadlocal后，如果不需要了，记得要使用remove操作擦除这块数据。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/动态代理的好处/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/动态代理的好处/" itemprop="url">动态代理的好处</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T00:00:42+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>先有设计的思想，后才有设计的手段</p>
</blockquote>
<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>代理模式是java设计模式的一种。代理类具有和委托类相同的接口，代理类主要负责为委托类预处理消息、过滤消息、消息转发、以及事后处理消息等。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>由程序员创建或由特定工具自动生成源代码，在对其编译。在程序运行前，代理类的.class文件就已经存在</p>
<p>静态代理通常只代理一个类。同时静态代理需要明白代理的是什么</p>
<p>sample:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//定义代理接口</span><br><span class="line">public interface ProxyInterface&#123;</span><br><span class="line">	void doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class A implements ProxyInterface&#123;</span><br><span class="line">	@Override</span><br><span class="line">	void doSomething()&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AProxy implements ProxyInterface&#123;</span><br><span class="line">	private ProxyInterface a;</span><br><span class="line">	public AProxy(ProxyInterface a)&#123;</span><br><span class="line">		this.a = a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	void doSomething()&#123;</span><br><span class="line">		a.doSomething();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>静态代理从我们日常开发的角度来看，就是一个封装类，比较简单</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>局限性很大，尤其是限于对代理类的了解。在接手一个项目，发生问题的时候或许可以使用这种代理方式来进行优化</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理类的字节码由java反射机制动态生成，无需手动编写源代码。</p>
<p>sample:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建InvocationHandler</span><br><span class="line">InvocationHandler handler = new MyInvocationHandler(...);</span><br><span class="line">//创建动态代理类</span><br><span class="line">Class proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(),new Class[]&#123;Foo.class&#125;);</span><br><span class="line">//创建动态代理类的实例</span><br><span class="line">Foo foo = (Foo)proxyClass.getConstructor(new Class[]&#123;InvocationHandler.class&#125;).newInstance(new Object[]&#123;handler&#125;);</span><br></pre></td></tr></table></figure>
<p>这样就获取了类了。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h3 id="newProxyInstance"><a href="#newProxyInstance" class="headerlink" title="newProxyInstance"></a>newProxyInstance</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                                          Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                          InvocationHandler h)</span><br><span class="line">        throws IllegalArgumentException</span><br><span class="line">    &#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        final Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        // Android-changed: sm is always null</span><br><span class="line">        // final SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        // if (sm != null) &#123;</span><br><span class="line">        //     checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        // &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Look up or generate the designated proxy class.</span><br><span class="line">         */</span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Invoke its constructor with the designated invocation handler.</span><br><span class="line">         */</span><br><span class="line">        try &#123;</span><br><span class="line">            // Android-changed: sm is always null</span><br><span class="line">            // if (sm != null) &#123;</span><br><span class="line">            //     checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            // &#125;</span><br><span class="line"></span><br><span class="line">            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            final InvocationHandler ih = h;</span><br><span class="line">            if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                // Android-changed: Removed AccessController.doPrivileged</span><br><span class="line">                cons.setAccessible(true);</span><br><span class="line">            &#125;</span><br><span class="line">            return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class="line">        &#125; catch (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            throw new InternalError(e.toString(), e);</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            if (t instanceof RuntimeException) &#123;</span><br><span class="line">                throw (RuntimeException) t;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            throw new InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>细致的看这个方法的内容</p>
<p>第一步 检查handler是否是空，这个没得说的</p>
<p>第二步 通过传入进去的classloader和class的方法来生成一个新的代理类（这中间有缓存）（class层级）</p>
<p>第三步 调用代理的构造器，将handler传入，构造了一个相应的类。</p>
<h3 id="getProxyClass0-：就是用来生产代理类的类对象"><a href="#getProxyClass0-：就是用来生产代理类的类对象" class="headerlink" title="getProxyClass0()：就是用来生产代理类的类对象"></a>getProxyClass0()：就是用来生产代理类的类对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    // 当目标类实现的接口数量大于 65535</span><br><span class="line">    if (interfaces.length &gt; 65535) &#123;</span><br><span class="line">	    // 抛异常</span><br><span class="line">        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 关键2：获取代理类，使用了缓存机制</span><br><span class="line">    return proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WeakCache-get"><a href="#WeakCache-get" class="headerlink" title="WeakCache#get()"></a>WeakCache#get()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">// 缓存的底层实现，key 为一级缓存，value 为二级缓存，一级缓存 key 类型为 Object，支持 null</span><br><span class="line">private final ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map</span><br><span class="line">    = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// key：classloader</span><br><span class="line">// parameter：interfaces</span><br><span class="line">public V get(K key, P parameter) &#123;</span><br><span class="line">	// 判断接口数组是否为空，为空抛异常，不为空返回接口对应类型</span><br><span class="line">	Objects.requireNonNull(parameter);</span><br><span class="line"></span><br><span class="line">	// 清除过期的缓存</span><br><span class="line">	expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">	// 将传入的 classloader 包装成 CacheKey，作为一级缓存</span><br><span class="line">	Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class="line"></span><br><span class="line">	// 根据一级缓存 cacheKey 获取二级缓存 valuesMap</span><br><span class="line">	ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">	// 如果根据 classLoader 没有获取到对应的值</span><br><span class="line">	if (valuesMap == null) &#123;</span><br><span class="line">		// 以 CAS 方式放入，如果不存在则放入，否则返回原先的值</span><br><span class="line">		ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey,</span><br><span class="line">                              valuesMap = new ConcurrentHashMap&lt;&gt;());</span><br><span class="line">		// 如果 oldValuesMap 有值，说明放入失败</span><br><span class="line">		if (oldValuesMap != null) &#123;</span><br><span class="line">			// valuesMap 设置为原来的 oldValuesMap</span><br><span class="line">			valuesMap = oldValuesMap;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    // subKeyFactory 通过 WeakCache 构造函数传入，实际为 KeyFactory</span><br><span class="line">    // subKeyFactory.apply(key, parameter)：KeyFactory 根据代理类实现的接口数组来生成二级缓存 key</span><br><span class="line">	// Objects.requireNonNull()：判断得到的二级缓存 key 是否为空，为空抛异常，不为空返回二级缓存 key 对应类型 Object</span><br><span class="line">	Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">	// 根据二级缓存的 key 获取二级缓存的值 supplier</span><br><span class="line">	Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">	Factory factory = null;</span><br><span class="line"></span><br><span class="line">	while (true) &#123;</span><br><span class="line">		// 如果二级缓存的值 supplier 不为 null</span><br><span class="line">		if (supplier != null) &#123;</span><br><span class="line">			// 调用 get() 方法</span><br><span class="line">			// 关键4：Factory implements Supplier，则此处实际调用的是 Factory#get()</span><br><span class="line">			V value = supplier.get();</span><br><span class="line">			// value 不为空</span><br><span class="line">			if (value != null) &#123;</span><br><span class="line">				// 返回 value</span><br><span class="line">				return value;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// else no supplier in cache</span><br><span class="line">		// or a supplier that returned null (could be a cleared CacheValue</span><br><span class="line">		// or a Factory that wasn&apos;t successful in installing the CacheValue)</span><br><span class="line"></span><br><span class="line">		// 如果 factory 等于 null</span><br><span class="line">		if (factory == null) &#123;</span><br><span class="line">			// 实例化一个 Factory（作为二级缓存的值），作为 subKey （二级缓存的 key）对应的 value</span><br><span class="line">			factory = new Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 如果 supplier 等于 null（根据二级缓存的 key 没有获取到二级缓存的值 supplier）</span><br><span class="line">		if (supplier == null) &#123;</span><br><span class="line">			// 将实例化的 factory 作为 subKey 对应的值传入</span><br><span class="line">			supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">			// supplier 等于 null（可能上一步成功执行后返回的是 null???）</span><br><span class="line">			if (supplier == null) &#123;</span><br><span class="line">				// successfully installed Factory</span><br><span class="line">				supplier = factory;</span><br><span class="line">			&#125;</span><br><span class="line">			// else retry with winning supplier</span><br><span class="line">		&#125; else &#123; // 可能期间有其他线程修改了值，那么就不会再继续给 subKey 赋值，而是取出来直接用</span><br><span class="line">			// 期间可能其它线程修改了值 factory，就用该值替换掉 supplier</span><br><span class="line">			if (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">				// 将 supplier 替换成 factory</span><br><span class="line">				supplier = factory;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				// 替换失败，继续使用原先的值</span><br><span class="line">				supplier = valuesMap.get(subKey);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Factory-get"><a href="#Factory-get" class="headerlink" title="Factory#get()"></a>Factory#get()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V get() &#123; // serialize access</span><br><span class="line">    // 根据二级缓存的 key 获取 supplier</span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">    // 如果获取的 supplier 不是 Factory 类型</span><br><span class="line">    if (supplier != this) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // else still us (supplier == this)</span><br><span class="line"></span><br><span class="line">    // create new value</span><br><span class="line">    V value = null;</span><br><span class="line">    try &#123;</span><br><span class="line">	    // valueFactory 通过 WeakCache 构造函数传入，实际为 ProxyClassFactory</span><br><span class="line">	    // 关键5：valueFactory.apply()-&gt;ProxyClassFactory#apply()</span><br><span class="line">        value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (value == null) &#123; // remove us on failure</span><br><span class="line">            valuesMap.remove(subKey, this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // the only path to reach here is with non-null value</span><br><span class="line">    assert value != null;</span><br><span class="line"></span><br><span class="line">    // wrap value with CacheValue (WeakReference)</span><br><span class="line">    CacheValue&lt;V&gt; cacheValue = new CacheValue&lt;&gt;(value);</span><br><span class="line"></span><br><span class="line">    // try replacing us with CacheValue (this should always succeed)</span><br><span class="line">    if (valuesMap.replace(subKey, this, cacheValue)) &#123;</span><br><span class="line">        // put also in reverseMap</span><br><span class="line">        reverseMap.put(cacheValue, Boolean.TRUE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new AssertionError(&quot;Should not reach here&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // successfully replaced us with new CacheValue -&gt; return the value</span><br><span class="line">    // wrapped by it</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ProxyClassFactory-apply"><a href="#ProxyClassFactory-apply" class="headerlink" title="ProxyClassFactory#apply()"></a>ProxyClassFactory#apply()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">// Proxy 的类名前缀</span><br><span class="line">private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;</span><br><span class="line"></span><br><span class="line">// next number to use for generation of unique proxy class names</span><br><span class="line">// 生成自增的数字</span><br><span class="line">private static final AtomicLong nextUniqueNumber = new AtomicLong();</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">    // 根据接口数组长度生成对应的 Map</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">    // 遍历接口数组</span><br><span class="line">    for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * Verify that the class loader resolves the name of this</span><br><span class="line">         * interface to the same Class object.</span><br><span class="line">         * </span><br><span class="line">         * 验证类加载器将此 interface 的名字解析成同一类对象</span><br><span class="line">         */</span><br><span class="line">        Class&lt;?&gt; interfaceClass = null;</span><br><span class="line">        try &#123;</span><br><span class="line">	        // 根据接口名获取接口对应的类对象</span><br><span class="line">            interfaceClass = Class.forName(intf.getName(), false, loader);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        // 接口类对象不等于接口，不是同一对象</span><br><span class="line">        if (interfaceClass != intf) &#123;</span><br><span class="line">	        //抛异常，接口来自不同的类加载器</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                intf + &quot; is not visible from class loader&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">         * Verify that the Class object actually represents an</span><br><span class="line">         * interface.</span><br><span class="line">         * </span><br><span class="line">         * 验证生成的类对象是否是一个接口类型</span><br><span class="line">         */</span><br><span class="line">        // 类对象不是接口类型</span><br><span class="line">        if (!interfaceClass.isInterface()) &#123;</span><br><span class="line">	        // 抛异常，类对象不是一个接口类型</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                interfaceClass.getName() + &quot; is not an interface&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">         * Verify that this interface is not a duplicate.</span><br><span class="line">         * </span><br><span class="line">         * 验证此接口不是重复的</span><br><span class="line">         */</span><br><span class="line">        // 往接口数组对应的 map 中存入类对象，返回值不为 null</span><br><span class="line">        if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;</span><br><span class="line">	        // 抛异常，来自当前类对象的接口重复</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                &quot;repeated interface: &quot; + interfaceClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String proxyPkg = null;     // package to define proxy class in</span><br><span class="line">    int accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Record the package of a non-public proxy interface so that the</span><br><span class="line">     * proxy class will be defined in the same package.  Verify that</span><br><span class="line">     * all non-public proxy interfaces are in the same package.</span><br><span class="line">     */</span><br><span class="line">    // 遍历接口数组</span><br><span class="line">    for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">		// 获取当前接口的修饰符</span><br><span class="line">        int flags = intf.getModifiers();</span><br><span class="line">        // 如果当前接口修饰符不是 public</span><br><span class="line">        if (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">			// 设置为 final</span><br><span class="line">            accessFlags = Modifier.FINAL;</span><br><span class="line">            String name = intf.getName();</span><br><span class="line">            int n = name.lastIndexOf(&apos;.&apos;);</span><br><span class="line">            String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));</span><br><span class="line">            // 包名为 null</span><br><span class="line">            if (proxyPkg == null) &#123;</span><br><span class="line">	            // 包名等于当前接口的包名</span><br><span class="line">                proxyPkg = pkg;</span><br><span class="line">            &#125; else if (!pkg.equals(proxyPkg)) &#123;// 如果包名不相等</span><br><span class="line">	            // 抛异常，非 public 的接口集合来自不同的包</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                    &quot;non-public interfaces from different packages&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 包名为 null</span><br><span class="line">    if (proxyPkg == null) &#123;</span><br><span class="line">        // if no non-public proxy interfaces, use com.sun.proxy package</span><br><span class="line">        // 如果 no non-public（即是 public）的代理接口集合，则使用包名 com.sun.proxy</span><br><span class="line">        proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Choose a name for the proxy class to generate.</span><br><span class="line">     */</span><br><span class="line">    long num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">    // 组成代理类全类名：包名 + 代理类前缀 + 唯一的自增长数字</span><br><span class="line">    String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Generate the specified proxy class.</span><br><span class="line">     * </span><br><span class="line">     * 关键6：生成指定的代理类</span><br><span class="line">     */</span><br><span class="line">    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">        proxyName, interfaces, accessFlags);</span><br><span class="line">    try &#123;</span><br><span class="line">        return defineClass0(loader, proxyName,</span><br><span class="line">                            proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">    &#125; catch (ClassFormatError e) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * A ClassFormatError here means that (barring bugs in the</span><br><span class="line">         * proxy class generation code) there was some other</span><br><span class="line">         * invalid aspect of the arguments supplied to the proxy</span><br><span class="line">         * class creation (such as virtual machine limitations</span><br><span class="line">         * exceeded).</span><br><span class="line">         */</span><br><span class="line">        throw new IllegalArgumentException(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成代理类的字节码"><a href="#生成代理类的字节码" class="headerlink" title="生成代理类的字节码"></a>生成代理类的字节码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">最终生成的代理类：</span><br><span class="line">public class Proxy0 extends Proxy implements IDinner &#123;</span><br><span class="line">	// 第一步：生成构造器</span><br><span class="line">	protected Proxy0(InvocationHandler h) &#123;</span><br><span class="line">		super(h);</span><br><span class="line">	&#125;</span><br><span class="line">	// 第二步：生成静态域</span><br><span class="line">	private static Method m1; // hashCode方法</span><br><span class="line">	private static Method m2; // equals方法</span><br><span class="line">	private static Method m3; // toString方法</span><br><span class="line">	private static Method m4; //...</span><br><span class="line">	// 第三步：生成代理方法</span><br><span class="line">	@Override</span><br><span class="line">	public int hashCode() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return (int) h.invoke(this, m1, null);</span><br><span class="line">		&#125;catch (Throwable e) &#123;</span><br><span class="line">			throw new UndeclaredThrowableException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public boolean equals(Object obj) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			Object[] args = new Object[] &#123;obj&#125;;</span><br><span class="line">			return (boolean) h.invoke(this, m2, args);</span><br><span class="line">		&#125;catch (Throwable e) &#123;</span><br><span class="line">			throw new UndeclaredThrowableException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return (String) h.invoke(this, m3, null);</span><br><span class="line">		&#125;catch (Throwable e) &#123;</span><br><span class="line">			throw new UndeclaredThrowableException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void dinner() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			// 构造参数数组，如果有多个参数往后面添加就行了</span><br><span class="line">			Object[] args = new Object[] &#123;&#125;;</span><br><span class="line">			// h 为通过构造方法传进来的 InvocationHandler，即此处调用 InvocationHandler#invoke(...) 方法</span><br><span class="line">			h.invoke(this, m4, args);</span><br><span class="line">		&#125;catch (Throwable e) &#123;</span><br><span class="line">			throw new UndeclaredThrowableException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 第四步：生成静态初始化方法</span><br><span class="line">	static &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			Class c1 = Class.forName(Object.class.getName());</span><br><span class="line">			Class c2 = Class.forName(IDinner.class.getName()); </span><br><span class="line">			m1 = c1.getMethod(&quot;hashCode&quot;, null);</span><br><span class="line">			m2 = c1.getMethod(&quot;equals&quot;, new Class[]&#123;Object.class&#125;);</span><br><span class="line">			m3 = c1.getMethod(&quot;toString&quot;, null);</span><br><span class="line">			m4 = c2.getMethod(&quot;dinner&quot;, new Class[]&#123;IDinner.class&#125;);</span><br><span class="line">			//...</span><br><span class="line">		&#125;catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &#123;@code InvocationHandler&#125; is the interface implemented by</span><br><span class="line"> * the &lt;i&gt;invocation handler&lt;/i&gt; of a proxy instance.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Each proxy instance has an associated invocation handler.</span><br><span class="line"> * When a method is invoked on a proxy instance, the method</span><br><span class="line"> * invocation is encoded and dispatched to the &#123;@code invoke&#125;</span><br><span class="line"> * method of its invocation handler.</span><br><span class="line"> *</span><br><span class="line"> * @author      Peter Jones</span><br><span class="line"> * @see         Proxy</span><br><span class="line"> * @since       1.3</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>从其类注释上面可以看出来，每一个代理实例都有一个相关的调用handler，当一个代理实例的方法被唤醒的时候，该被代理的方法将会被编码并且分发到invocation handler中</p>
<p>具体来讲事实上是个回调接口类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Processes a method invocation on a proxy instance and returns</span><br><span class="line">    * the result.  This method will be invoked on an invocation handler</span><br><span class="line">    * when a method is invoked on a proxy instance that it is</span><br><span class="line">    * associated with.</span><br><span class="line">    *</span><br><span class="line">    * @param   proxy the proxy instance that the method was invoked on</span><br><span class="line">    *</span><br><span class="line">    * @param   method the &#123;@code Method&#125; instance corresponding to</span><br><span class="line">    * the interface method invoked on the proxy instance.  The declaring</span><br><span class="line">    * class of the &#123;@code Method&#125; object will be the interface that</span><br><span class="line">    * the method was declared in, which may be a superinterface of the</span><br><span class="line">    * proxy interface that the proxy class inherits the method through.</span><br><span class="line">    *</span><br><span class="line">    * @param   args an array of objects containing the values of the</span><br><span class="line">    * arguments passed in the method invocation on the proxy instance,</span><br><span class="line">    * or &#123;@code null&#125; if interface method takes no arguments.</span><br><span class="line">    * Arguments of primitive types are wrapped in instances of the</span><br><span class="line">    * appropriate primitive wrapper class, such as</span><br><span class="line">    * &#123;@code java.lang.Integer&#125; or &#123;@code java.lang.Boolean&#125;.</span><br><span class="line">    *</span><br><span class="line">    * @return  the value to return from the method invocation on the</span><br><span class="line">    * proxy instance.  If the declared return type of the interface</span><br><span class="line">    * method is a primitive type, then the value returned by</span><br><span class="line">    * this method must be an instance of the corresponding primitive</span><br><span class="line">    * wrapper class; otherwise, it must be a type assignable to the</span><br><span class="line">    * declared return type.  If the value returned by this method is</span><br><span class="line">    * &#123;@code null&#125; and the interface method&apos;s return type is</span><br><span class="line">    * primitive, then a &#123;@code NullPointerException&#125; will be</span><br><span class="line">    * thrown by the method invocation on the proxy instance.  If the</span><br><span class="line">    * value returned by this method is otherwise not compatible with</span><br><span class="line">    * the interface method&apos;s declared return type as described above,</span><br><span class="line">    * a &#123;@code ClassCastException&#125; will be thrown by the method</span><br><span class="line">    * invocation on the proxy instance.</span><br><span class="line">    *</span><br><span class="line">    * @throws  Throwable the exception to throw from the method</span><br><span class="line">    * invocation on the proxy instance.  The exception&apos;s type must be</span><br><span class="line">    * assignable either to any of the exception types declared in the</span><br><span class="line">    * &#123;@code throws&#125; clause of the interface method or to the</span><br><span class="line">    * unchecked exception types &#123;@code java.lang.RuntimeException&#125;</span><br><span class="line">    * or &#123;@code java.lang.Error&#125;.  If a checked exception is</span><br><span class="line">    * thrown by this method that is not assignable to any of the</span><br><span class="line">    * exception types declared in the &#123;@code throws&#125; clause of</span><br><span class="line">    * the interface method, then an</span><br><span class="line">    * &#123;@link UndeclaredThrowableException&#125; containing the</span><br><span class="line">    * exception that was thrown by this method will be thrown by the</span><br><span class="line">    * method invocation on the proxy instance.</span><br><span class="line">    *</span><br><span class="line">    * @see     UndeclaredThrowableException</span><br><span class="line">    */</span><br><span class="line">   public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">       throws Throwable;</span><br></pre></td></tr></table></figure>
<p>参数的方法表现的就比较容易理解了。</p>
<p>proxy是指代理类的实例，method是指代理类的方法，每当代理类有方法经过时，这个method就会变成那个方法，args是方法的形式参数，这个地方也会截断。</p>
<p>返回值有几种情况</p>
<p>1、声明的返回类型是基础类型，返回值必须是对应的包装类实例</p>
<p>2、如果声明的返回类型是基础类型，但是返回了一个null的话，会报空指针异常</p>
<p>3、如果这个方法的返回值和声明的返回值不兼容的话，会报类型转换异常</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>类A写死持有B，就是B的静态代理。如果A代理的对象是不确定的，就是动态代理。动态代理借用反射机制，最终生成的代理类和静态代理生成的相同</p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="动态代理模式和装饰者模式的区别"><a href="#动态代理模式和装饰者模式的区别" class="headerlink" title="动态代理模式和装饰者模式的区别"></a>动态代理模式和装饰者模式的区别</h2><ul>
<li><p>装饰者模式的作用：在不使用继承、不改变原有对象的情况下增加或扩展对象行为，但是并不会禁用某个对象的行为</p>
</li>
<li><p>代理模式：控制了这个对象的访问，决定执行或者不执行</p>
</li>
</ul>
<h2 id="动态代理模式有缺点吗？"><a href="#动态代理模式有缺点吗？" class="headerlink" title="动态代理模式有缺点吗？"></a>动态代理模式有缺点吗？</h2><p>由于是反射机制，创建一个动态代理类大约需要13ms，对比与反射一个方法只需要2ms来看，如果消耗过大还是需要考虑一下的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/02/jvm内存模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/02/jvm内存模型/" itemprop="url">jvm内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-02T23:48:21+08:00">
                2019-01-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/images/android/jvm内存模型.jpg" alt="JVM内存模型示意图"></p>
<h2 id="内存计数器（PC寄存器）"><a href="#内存计数器（PC寄存器）" class="headerlink" title="内存计数器（PC寄存器）"></a>内存计数器（PC寄存器）</h2><p>由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，</p>
<p>因此，为了能够使得每个线程都在线程切换后能够恢复在切　换　之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，</p>
<p>否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，</p>
<p>因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。</p>
<p>内存计数器是context的一部分</p>
<h2 id="java-栈"><a href="#java-栈" class="headerlink" title="java 栈"></a>java 栈</h2><p>Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、</p>
<p>指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、</p>
<p>方法返回地址(Return Address)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">经常有人把Java 内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗</span><br><span class="line"></span><br><span class="line">糙，Java 内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序</span><br><span class="line"></span><br><span class="line">员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”在后</span><br><span class="line"></span><br><span class="line">面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变</span><br><span class="line"></span><br><span class="line">量表部分。</span><br><span class="line"></span><br><span class="line">局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、</span><br><span class="line"></span><br><span class="line">float、long、double）、对象引用（reference 类型，它不等同于对象本身，根据不同的虚拟</span><br><span class="line"></span><br><span class="line">机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或</span><br><span class="line"></span><br><span class="line">者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。</span><br><span class="line"></span><br><span class="line">其中64 位长度的long 和double 类型的数据会占用2 个局部变量空间（Slot），其余</span><br><span class="line"></span><br><span class="line">的数据类型只占用1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个</span><br><span class="line"></span><br><span class="line">方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间</span><br><span class="line"></span><br><span class="line">不会改变局部变量表的大小。</span><br></pre></td></tr></table></figure>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其</span><br><span class="line"></span><br><span class="line">区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则</span><br><span class="line"></span><br><span class="line">是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语</span><br><span class="line"></span><br><span class="line">言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至</span><br><span class="line"></span><br><span class="line">有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。</span><br><span class="line"></span><br><span class="line">与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError</span><br><span class="line"></span><br><span class="line">异常。</span><br></pre></td></tr></table></figure>
<h2 id="java-堆"><a href="#java-堆" class="headerlink" title="java 堆"></a>java 堆</h2><p>Java中的堆是用来存储对象本身的以及数组（数组引用是存放在Java栈中的）。堆是被所有线程共享的，在JVM中只有一个堆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的</span><br><span class="line"></span><br><span class="line">一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的</span><br><span class="line"></span><br><span class="line">唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚</span><br><span class="line"></span><br><span class="line">拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着JIT 编译器</span><br><span class="line"></span><br><span class="line">的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙</span><br><span class="line"></span><br><span class="line">的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</span><br><span class="line"></span><br><span class="line">Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（Garbage</span><br><span class="line"></span><br><span class="line">Collected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在</span><br><span class="line"></span><br><span class="line">收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；</span><br><span class="line"></span><br><span class="line">再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配</span><br><span class="line"></span><br><span class="line">的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local</span><br><span class="line"></span><br><span class="line">Allocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，</span><br><span class="line"></span><br><span class="line">存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配</span><br><span class="line"></span><br><span class="line">内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java 堆中的上述各个区域的</span><br><span class="line"></span><br><span class="line">分配和回收等细节将会是下一章的主题。</span><br><span class="line"></span><br><span class="line">根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要</span><br><span class="line"></span><br><span class="line">逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小</span><br><span class="line"></span><br><span class="line">的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx</span><br><span class="line"></span><br><span class="line">和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出</span><br><span class="line"></span><br><span class="line">OutOfMemoryError 异常。</span><br></pre></td></tr></table></figure>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。</p>
<p>在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。</p>
<p>在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，</p>
<p>对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存</span><br><span class="line"></span><br><span class="line">储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽</span><br><span class="line"></span><br><span class="line">然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-</span><br><span class="line"></span><br><span class="line">Heap（非堆），目的应该是与Java 堆区分开来。</span><br><span class="line"></span><br><span class="line">对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区</span><br><span class="line"></span><br><span class="line">称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚</span><br><span class="line"></span><br><span class="line">拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而</span><br><span class="line"></span><br><span class="line">已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。即</span><br><span class="line"></span><br><span class="line">使是HotSpot 虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”</span><br><span class="line"></span><br><span class="line">至Native Memory 来实现方法区的规划了。</span><br><span class="line"></span><br><span class="line">Java 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内</span><br><span class="line"></span><br><span class="line">存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾</span><br><span class="line"></span><br><span class="line">收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一</span><br><span class="line"></span><br><span class="line">样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸</span><br><span class="line"></span><br><span class="line">载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件</span><br><span class="line"></span><br><span class="line">相当苛刻，但是这部分区域的回收确实是有必要的。在Sun 公司的BUG 列表中，曾出</span><br><span class="line"></span><br><span class="line">现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导</span><br><span class="line"></span><br><span class="line">致内存泄漏。</span><br><span class="line"></span><br><span class="line">根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出</span><br><span class="line"></span><br><span class="line">OutOfMemoryError 异常。</span><br></pre></td></tr></table></figure>
<h2 id="静态区"><a href="#静态区" class="headerlink" title="静态区"></a>静态区</h2><p>静态区也称为运行常量池，static出来的对象都是静态的。该区域存放类和接口的常量，</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sample</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">124</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sample</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
