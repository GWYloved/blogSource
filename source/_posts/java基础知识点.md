---
title: java基础知识点
date: 2018-01-31 23:15:56
tags: java
---

感冒了好几天，昨天没有写blog，心慌慌。

这篇从java核心来讲，估计要整理一阵

# java 核心

+ oop的概念

1. 抽象

在面向对象的概念中，所有对象都是由类来描述，但是反过来，并不是所有类都是用来描述对象的。如果一个类中没有包含足够信息来描绘一个具体的对象，这样的类就是抽象类。

2. 继承

继承（英语：inheritance）是面向对象软件技术当中的一个概念。如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。 一般静态的面向对象编程语言，继承属于静态的，意即在子类别的行为在编译期就已经决定，无法在执行期扩充。 有些编程语言支持多重继承，即一个子类别可以同时有多个父类别，比如C++编程语言；而在有些编程语言中，一个子类别只能继承自一个父类别，比如Java编程语言，这时可以利用接口来实现与多重继承相似的效果。 现今面向对象程式设计技巧中，继承并非以继承类别的“行为”为主，而是继承类别的“型态”，使得元件的型态一致。另外在设计模式中提到一个守则，“多用合成，少用继承”，此守则也是用来处理继承无法在执行期动态扩充行为的遗憾。

3. 封装

从字面上理解就是包装的意思，是指利用抽象数据类型，将数据和关于数据的操作封装起来，使其成为一个不可分割的独立实体。数据将会被保护在抽象数据类型的内部，仅能够通过暴露在表面的操作（public方法，比如setter和getter）来与这个对象进行交流和交互。用户不知道对象的内部细节，但是通过该对象提供的接口来访问对象。其好处是：减少耦合，方便地在未来修改调整自己，更加有把握地（精确地）控制成员，隐藏信息，实现细节。

4. 多态

使用相同的消息，使得类作出不同的反应（继承为我们使用多态打下了基础）。Java实现多态有三个必要条件：继承、重写、向上转型。

+ 面向对象的三个基本元素和五个原则

+ 三个元素：

1. 封装： 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。

2. 继承： 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。

3. 多态： 多态性是指允许不同类的对象对同一消息作出 响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。

+ 五个基本原则：

1. 单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。

2. 开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。

3. Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。

4. 依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。

5. 接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口。

+ 抽象类和接口的区别

1. 抽象类是一个可同时包含具体方法和抽象方法(方法未被实现)的类。抽象方法必须被该抽象类的子类实现。抽象类是可以继承的。

2. 接口像是描述类的一张蓝图或者说是类的一种契约，它包含了许多空方法，这代表着它的所有的子类都应该拥有共同点。它的子类应该提供这些空方法的具体实现。一 个类需要用 implements 来实现接口，接口可以用 extends 来继承其他接口。

3. 设计模式上面来看：

抽象的层次不同：抽象类对类的整体（包括属性，行为）都可以进行抽象，接口对类的局部进行抽象，具体来说接口仅仅是对类的行为进行抽象。

跨域不同：抽象类是 从各种子类中提取相似的部分，然后泛化成抽象类，子类可以继承这样的抽象类。 实现接口是 不存在is-a的关系的类们，你不可以称同样可以飞行的飞机和鸟为同一个抽象类，但是他们可以有同样的接口fly-able。抽象类的父类和派生类在概念上一致，接口的原生类和派生类在仅仅在局部行为上一致。

设计层次不同：抽象类是从一堆在底层的子类们来进行抽象提取，从下往上，从而产生抽象类；接口是在直接定义的高度来声明的，然后从这个高度上往下实现此接口。抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。

+ 序列化是什么？如何实现？

序列化是一种将对象转换为字节流的过程，目的是为了将对象存储到内存中，等后面再次构建该对象时可以获取到该对象先前的状态和数据信息。java中，使用Serializable和parcelable接口都可以实现，不过android中使用parcel效率高，性能高出10倍。

+ 什么是单例？

单例模式指的是一个类只能被初始化一次，限定一个类只能拥有一个实例。使用一个实例来和其他模块协调工作是很实用的。

+ 什么是匿名内部类？

普通的类可以自然的实例化自己吗，相反的，内部类却需要绑定上一个外部类才能实例。匿名内部类由于没有名字，只可以使用一次。

+ 对字符串进行 == 和 equals()操作时有什么区别？

 == 主要比较的是两个字符串的地址，equals()假如不重写，也仅仅用于比较地址，重写就不是。

+ hashcode()和equals()何时使用？

hashCode()的存在主要是用于查找的快捷性，如hashtable、 hashmap等，hashcode是用来在散列存储结构中确定对象的存储地址的。

如果两个对象相同，就是适用于equals()方法，那么这两个对象的hashcode一定要相同。

如果对象的equals方法被重写，那么对象的hashcode也尽量重写，并且产生hashcode使用的对象，一定要和equals方法中使用的一致。

两个对象的hashcode相同，并不一定就表示两个对象就相同，也就是不一定适用于equals方法，只能够说明这两个对象在散列存储结构中，如hashtable，他们“存放在同一个篮子里”

+ java中 final、 finally 和finalize？

final: 修饰变量、方法、类；修饰变量时表示这对象的值不可变，不能为这个变量赋一个新的值。修饰方法时便是我们希望把这个方法锁定，以防止任何继承类修改它的含义，这样会确保在继承中，final方法的行为不会改变，并且不会覆盖。修饰类的时候表示不打算继承该类，并且也不允许别人这样做。

finally: 是异常处理中进行收场处理的代码块，不管有没有异常，finally子句中的代码都会被执行。

finalize: 垃圾回收器准备释放对象占用的存储空间的时候，将首先调用其finalize()方法

+ 什么是内存泄漏？java如何处理它？

内存泄漏就是保留下来却永远不再使用的对象引用。java通过gc进行处理

+ 垃圾回收器是什么？它是如何工作的？

所有的对象实例都在jvm管理的堆区域分配内存，只要对象被引用，jvm就会认为它还活在进程中，一旦对象不再被引用，就不能被应用程序所访问，垃圾收集器将删除它并重新声明未使用的内存。

+ 比较arrays 和arraylists

Arrays:一个包含许多和操作数组有关方法的类，比如说排序和查找。
ArrayList:一个容器，可以实现数组的大小可变，方便地增加和删除元素。

+ 比较hashset和treeset

treeset是基于二叉树实现的，其中的数据是自动排序好的，不允许放入null值
hashset是基于hash实现的，其中的数据是无序的，允许放入null值。

+ java中的类型转换

基本数据的类型转换：将一个数据范围较小的类型赋给一个数值范围较大的数值型变量，jvm在编译过程中会将此数值的类型进行自动提升。自动提升意味着数值精度至少不应该降低。而需要将数值范围较大的数值赋给数值范围较小的数值类型变量时，需要手动转换，成为强制类型转换。

引用数据类型的类型转换：由于继承和向上转型，子类向父类的转换是很自然的，但是当把父类转换为子类时，强制类型转换会在运行时检查父类的真实类型，如果引用的父类对象的真实身份是子类类型，那就可以；否则如果真的是父类的类型，就会抛出ClassCastException的异常。

+ 方法重载和重写的区别。

重载发生在编译时，重写发生在运行时，重载方法调用与其定义的绑定发生在编译时，重写方法调用与其定义的绑定在运行时发生。

静态方法可以重载，但不能重写。

最基本的区别是重载是在同一个类中完成的，重写父类的话需要子类。重写是给父类的继承方法一个具体的实现。

静态绑定用于方法重载，动态绑定用于方法重写。重载比重写更有效率，因为重写是在运行时完成的。

私有方法和用final修饰的方法可以重载但不能重写。这意味着一个类可以有多个同名的final/private方法，子类不能重写父类的private/final方法。

方法重载的情况下不关心返回值类型，他可以相同，也可以不同，重写的情况下可以有多个具体的返回值类型。

重载参数列表必须不同，方法重写时参数列表必须相同。

+ 什么是防卫修饰符？她们能做什么？

public、protected、private、这几个关键字叫做访问修饰符。
作用是控制它所定义的域或者方法的访问权。

+ 接口可以继承另一个接口吗？

可以

+ java中static关键字什么意思？

static是java里面的非访问修饰符，可以用来创建类方法和类变量。
当修饰一个变量的时候，此变量就成了独立于对象的静态变量，无论一个类实例化多少个对象，这个类只有一份这个静态变量的拷贝，所以static修饰的变量，即静态变量，也被叫做类变量。

当修饰一个方法的时候，此方法就成了独立于对象的静态方法，静态方法不能使用类的非静态方法，因为静态变量先于非静态的其他成员初始化，静态方法先出来，然后才是非静态的，

+ 什么是多态？什么是继承？

多态是：允许不同类的对象对同一消息作出响应

继承是：子类继承父类的特征和行为，使得子类具有父类的各种属性和方法

+ integer和int之间的区别

integer是int提供的封装类，而int是java的基本数据类型；integer默认值是null，而int默认值是0，声明为integer的变量需要实例化，而声明为int的变量不需要实例化，integer是对象，用一个引用指向这个对象，而int是基本类型，直接存储数据。

两个new出来的integer总是不一样的，当使用 == 时，因为其内存地址不同，所以进行 == 时返回false。

两个不是new出来的integer，而是诸如integer i = x， 如果x的范围在 -128 ～ 127，其缓存指向同一个对象，所以此时使用 == 比较返回true，x范围在 -128 ～ 127之外的话，没有缓存存在，即使他们包裹的数值相同，他们也不能使用 == 得到true。

int 和integer的比较，无论integer是否使用new， 其值和将平常与亮的一样：integer自动拆箱，然后和int比较，这里就不会被内存地址的不同所影响，该相等就相等。

+ java中的对象是否会以引用传递或者值传递？

java中的对象总是以值传递的。

+ 什么是ThreadPoolExecutor?

线程池是用于管理一个池子的工作线程，一个任务队列保持着一些等待执行的任务，这些任务由任何一个空闲的线程为止服务。任务是被生产者假如到队列的，同时，工作线程就像一个消费者，每当线程池里有空闲的线程，他就会开启一个后台的服务来执行一个任务。

ThreadPoolExecutor会使用线程池里的一个线程来执行一个任务。

```
	ThreadPoolExecutor threadPoolExecutor = 
		new ThreadPoolExecutor(int corePoolSize,
			int maximumPoolSize, long keepAliveTime, TimeUnit unit,
			BlockingQueue<Runnable> workQueue);
```

corePoolSize: 保持在池中的最小线程数量。一开始，0个线程在池中，但是随着任务加入队列中，新的线程就会被创建。有空闲的线程，但是线程的数量小于corePoolSize，新的线程就会被继续创建。

maximumPoolSize:最大能允许的待在池中的线程数量。如果这个超过了corePoolSize而且现在线程的数量大于等于corePoolSize，那么新的工作线程会被创建，直到队列满了。

keepAliveTime: 当线程数量大于核心线程数，非核心的线程（超出空闲线程）会等着新任务来，然后如果任务到了keepAliveTime还没来，这些线程就会被冻结。

unit: keepAliveTime的时间单位

workQueue:任务队列，仅仅会维持一些runnable任务，一定要是一个blockingQueue

ThreadPoolExecutor是一个强力的任务执行框架，它支持任务添加、任务取消、任务优先级。并且减少了之前的有关线程创建之类的开销，因为管理着一个给定数量的线程池。

+ 本地变量、实例变量以及类变量之间的区别？

本地变量就是局部变量，他在方法或者代码块里面被声明并使用，其内存中的位置是栈，没有默认初始化值，生命周期很短。
实例变量是没有被static修饰的成员变量，它属于一个类的一个实例。每次new一个实例，这样的变量也new一遍，其位置在堆区，有默认初始化的值，生命周期和它所在的实例一样长。
类变量，又称静态变量，它是被static修饰的成员变量，它属于一个类，被所有实例共享。每次new一个实例，这样的变量并不会被new一遍，其内存存在于方法区内，可以通过类名直接访问。有默认的初始化值，生命周期很长。

+ 什么是反射？

也就是说,在编译时,你获取了一个指向某个并不存在你的程序空间中的对象的引用;事实上在编译时你的程序无法获知这个对象所属的类

+ 在java中什么是强引用、软引用、弱引用以及虚引用？

强引用：不会被gc轻易清理，只要引用存在，垃圾回收器永远不会回收。

软引用：非必须引用，内存溢出之前进行回收

弱引用：第二次垃圾回收时回收

虚引用：垃圾回收时回收，无法通过引用取到对象值。

+ 关键字synchronized的作用是什么？

synchronized通过修饰一个方法或者代码块，从而产生一个同步对象锁，以及对应的同步代码块。每当有线程要对该同步代码块进行访问时，线程就会首先尝试获取这个对象的锁，并在成功获取到对象锁之后，对这个同步代码块进行正常的访问。在同步代码块的访问过程中，线程会一直持有这个对象锁，直到同步代码块访问完毕，然后才会释放。
在上述线程中持有同步锁并且进行同步代码块访问过程中，其他线程无法获得该对象锁，也无法访问该同步代码，这些线程都会被阻塞直到上述线程访问完毕。

+ 为什么说string不可变？

string类型在实现时，其内部变量全部使用final来修饰，保证成员变量的引用值只能通过构造函数来修改
string类型在实现时，在外部某个地方，可能修改一个string实例的内部存储值的函数实现中，在这个地方的调用返回时，一律构造新的string对象或者新的byte数组或者char数组，给赋值符号的左边变量

+ 修饰符transient和volatile的作用？

volatile：易式修饰符，带有volatile修饰的变量，就是当其在某个线程自己的工作内存中发生改变时，会被强制地，写回公共成员变量所在的公共内存处。

transient是一个类型修饰符，仅仅能用来修饰字段（变量）。在此字段所在的对象进行序列化的时候，这个字段不会被序列化。

其他没有transient修饰的变量将会被序列化，然后进行传输，或者存储到本地磁盘，transient变量就在这个过程里丢失了

