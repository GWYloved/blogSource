<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="记录者">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="记录者">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="记录者">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>记录者</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">记录者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/16/looper的message分发方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/16/looper的message分发方式/" itemprop="url">looper的message分发方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-16T18:47:19+08:00">
                2019-01-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/16/神策埋点reftype踩坑记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/16/神策埋点reftype踩坑记/" itemprop="url">神策埋点reftype踩坑记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-16T15:30:27+08:00">
                2019-01-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目需要上报埋点，但是部分埋点需要携带reftype，而reftype却需要从上个页面报到下个页面来。</p>
<p>从安卓上面来讲，一个页面是一个activity的形式，而reftype需要传递，有两种方式，一种是reftype以intent的bundle参数传入，第二种是在长于activity的生命周期保存这个reftype实现存储存取方式。</p>
<p>第一种可以完全完美的解决的问题，但是带来的是过于繁琐的步骤，每个启动的intent都需要加，这样十分复杂，在新加的页面中这样写start()函数还是可以的，但是在我们这种有多路径，而且很多老页面中无法这样使用。并且如果单加一个reftype还可以，如果需要加上refid，from等参数，带来的更改复杂度几何度上升。</p>
<p>第二种是借助第三方进行传递。这个是上个版本使用的，当时是通过静态变量进行传递。在当时reftype报的不是很多的情况下，尤其是只希望观察reftype是某个过程的行为的情况下使用比较合适。</p>
<p>不过新的产品每次的埋点方案都很神奇，是单页面多过程埋点，需要兼顾返回清除问题，同时还需要报页面停留时长。</p>
<p>相对于老的静态变量存储行为就不可以这么改了。当这个变量没有和页面的部分方法捆绑的时候，这个操作会造成不可逆的效果。而如果和方法捆绑的话，则又会造成大量的逻辑重构，更加麻烦。</p>
<p>组内进行了一次神策的讨论（吐槽一下，其实很久之前就立项想动刀这个了，只是动刀的人一直懒着不动，终于拖到让我来弄了）。大致想法如下：</p>
<ol>
<li>仍然沿用静态变量的行为</li>
<li>在页面中保留静态变量的实例，oncreate的时候获取，onresume的时候对全局的静态变量进行覆盖</li>
<li>更改页面reftype的地方由之前的点击变为oncreate的时候直接获取</li>
</ol>
<p>这样可以完全完成A-&gt;B-&gt;C-&gt;B，这么一个过程中，B记录了A的reftype，回到b的时候onresume虽然全局是B，但是由于B记录了A，onresume的时候就会使得A覆盖B。同时在没有更改reftype的时候，会保证全局reftype的行为可以传递。</p>
<p>思路上面比较简单，用这个来实现一些数据阶段性传递比较有意义。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/13/java对象的三种状态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/13/java对象的三种状态/" itemprop="url">java对象的三种状态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-13T22:13:03+08:00">
                2019-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近被问到一个问题，java对象有几种状态？<br>没有接触过这个，说实话被问到的时候连一点可说的都没有。</p>
<p>因此总结一下网上对java对象的几种状态：可触及态、可复活态、不可触及态</p>
<h1 id="可触及态（可达状态）"><a href="#可触及态（可达状态）" class="headerlink" title="可触及态（可达状态）"></a>可触及态（可达状态）</h1><p>从根节点开始，可以搜索到这个状态，也就是可以访问到这个状态</p>
<h1 id="可复活态（可恢复态）"><a href="#可复活态（可恢复态）" class="headerlink" title="可复活态（可恢复态）"></a>可复活态（可恢复态）</h1><p>从根节点开始，无论如何都不能访问到这个对象，也就是说这个对象的所有引用都被释放，没有任何变量引用该对象了，<br>但是该对象有可能在finalize()方法中再次被引用，从而复活。</p>
<p>垃圾回收器在准备回收垃圾时，调用finalize方法，在finalize方法中，系统有可能重新让一个或多个引用指向该对象，那么这个对象就由可恢复状态变为可达状态。 </p>
<h1 id="不可触及态（不可恢复态）"><a href="#不可触及态（不可恢复态）" class="headerlink" title="不可触及态（不可恢复态）"></a>不可触及态（不可恢复态）</h1><p>在finalize()方法中没有复活，这样这个对象就消失在了内存堆中</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/09/volatile的作用及其原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/09/volatile的作用及其原理/" itemprop="url">volatile的作用及其原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-09T19:03:23+08:00">
                2019-01-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>背景：计算机执行程序时，每条指令都是在cpu中执行的，执行过程中会涉及到数据的读取和写入，由于程序运行过程中的临时数据时存放在主存中（物理内存），这就产生了一个问题，cpu执行速度很快，而从内存读取数据和向内写入数据的过程比cpu执行的速度慢，因此计算机在cpu里面增加了高速缓存</p>
<p>cpu运行过程中，会讲运算需要的数据从主存中复制一份到cpu的高速缓存当中，那么当cpu进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，运算结束之后，再将高速缓存中的数据刷行到主存当中。</p>
<p>譬如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i + 1;</span><br></pre></td></tr></table></figure></p>
<p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后cpu执行指令对i进行+1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存中。</p>
<p>这个代码在多线程中会出现问题，由于多核cpu环境下，每条线程可能运行于不同的cpu中，因此每个线程运行时有自己的高速缓存。当a和b同时执行这条语句的时候，a将i拷贝到了高速缓存中，执行+1操作，此时如果b线程也拷贝到高速缓存中，此时读取的值还是a未+1的值</p>
<p>此时就出现了缓存不一致的问题，这也是著名的缓存一致性问题，通常这种被多个线程访问的变量称为共享变量。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决方法有两种，一种是在总线加lock锁的方式，二是通过缓存一致性协议</p>
<h3 id="总线加lock"><a href="#总线加lock" class="headerlink" title="总线加lock"></a>总线加lock</h3><p>总线加lock的方式可以阻塞主所有其他cpu对其他部件的访问（如内存），从而使得只有一个cpu能使用这个变量的内存。</p>
<p>上述的例子，a在执行i = i + 1的时候，在总线上面发出lock的信号，那么只有等这段代码执行完毕之后，其他cpu才能在i所在的内存读取变量</p>
<p>也就是sychronize在代码块上面加个锁</p>
<h3 id="通过缓存一致性协议"><a href="#通过缓存一致性协议" class="headerlink" title="通过缓存一致性协议"></a>通过缓存一致性协议</h3><p>当cpu写数据时，如果发现操作的变量是共享变量，即在其他cpu中也存在该变量的副本，会发出信号通知其他cpu将该变量的缓存行为设置为无效状态，因此当其他cpu需要读取这个变量时，发现自己缓存中缓存该变量的缓存时无效的，那么它就会从内存中重新读取</p>
<h1 id="并发编程三大特性"><a href="#并发编程三大特性" class="headerlink" title="并发编程三大特性"></a>并发编程三大特性</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>java中对基本数据类型的读取和赋值操作是原子性操作，要么执行要么不执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = 10;//原子性操作</span><br><span class="line"></span><br><span class="line">y = x;//非原子性，先读取x的值，再将x的值写入工作内存，这两个过程都是原子性，但是合起来不是</span><br><span class="line"></span><br><span class="line">x ++;//读取x的值，加1，写入新的值，也是合起来就不是原子性了</span><br><span class="line"></span><br><span class="line">x = x + 1;//同x++</span><br></pre></td></tr></table></figure>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性就是使用volatile关键字来保证</p>
<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存中，当有其他线程需要读取时，他会去内存中读取新值。</p>
<p>对于一个没有被volatile修饰的普通共享变量，因为普通共享变量被修改之后，什么时候被写入主存时不确定的，当其他线程去读取时，此时内存可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，通过sychronized和lock也可以保证可见性，sychronized和lock能保证同一时刻只有一个线程获取锁，然后执行同步代码，并且释放锁之前会将对变量的修改刷行到主存当中，因此可以保证可见性</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>在java内存模型中，允许编译器和处理器对指令进行重排序，但是排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性</p>
<p>在java里面可以通过volatile关键字来保证一定的“有序性”，另外可以通过sychronized和lock来保证有序性，sychronized和lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性</p>
<p>另外，java内存模型具备一些先天的“有序性”，即不需要任何手段就能保证的有序性</p>
<h3 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens - before原则"></a>happens - before原则</h3><h4 id="程序次序规则"><a href="#程序次序规则" class="headerlink" title="程序次序规则"></a>程序次序规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</span><br></pre></td></tr></table></figure>
<h4 id="锁定规则"><a href="#锁定规则" class="headerlink" title="锁定规则"></a>锁定规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个unlock操作先行发生于后面对同一个锁unlock操作</span><br></pre></td></tr></table></figure>
<h4 id="volatile变量规则"><a href="#volatile变量规则" class="headerlink" title="volatile变量规则"></a>volatile变量规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对一个变量的写操作先行发生于后面对这个变量的读操作</span><br></pre></td></tr></table></figure>
<h4 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果操作a先行发生于操作b，而操作b又先行发生于操作c，则可以得出操作a先行发生于操作c</span><br></pre></td></tr></table></figure>
<h4 id="线程启动规则"><a href="#线程启动规则" class="headerlink" title="线程启动规则"></a>线程启动规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread对象的start()方法先行发生于此线程的每一个动作</span><br></pre></td></tr></table></figure>
<h4 id="线程终结规则"><a href="#线程终结规则" class="headerlink" title="线程终结规则"></a>线程终结规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程中的所有操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</span><br></pre></td></tr></table></figure>
<h4 id="对象终结规则"><a href="#对象终结规则" class="headerlink" title="对象终结规则"></a>对象终结规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个对象的初始化完成先行发生于它的finalize()方法的开始</span><br></pre></td></tr></table></figure>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>一个共享变量被volatile修饰之后，就具备了两层语义</p>
<ol>
<li><p>保证了不同线程对这个变量进行操作时的<strong>可见性</strong>，即一个线程修改了某个变量的值，这新值对其他线程来说时立即可见的</p>
</li>
<li><p>禁止进行指令重排序</p>
</li>
</ol>
<p>一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//A</span><br><span class="line">boolean stop = false;</span><br><span class="line">while(!stop)&#123;</span><br><span class="line">	doSomething();</span><br><span class="line">&#125;</span><br><span class="line">//B</span><br><span class="line">stop = true;</span><br></pre></td></tr></table></figure>
<p>假如stop没有被volatile修饰的话，当a线程在执行A段语句的时候，b线程执行了B语句，此时可能由于没有来得及写入主存，导致a线程不知道b线程做了修改，就会造成死循环</p>
<h2 id="原理和实现机制"><a href="#原理和实现机制" class="headerlink" title="原理和实现机制"></a>原理和实现机制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">观察加入volatile关键字和没有加入volatile关键字时所生成的会变代码发现，加入volatile关键字时，会多出一个lock前缀指令</span><br><span class="line"> 										----《深入理解java虚拟机》</span><br></pre></td></tr></table></figure>
<p>lock前缀指令实际上相当于一个内存屏障(也称内存栅栏)</p>
<p>其提供了三个功能</p>
<ol>
<li><p>确保指令重排序时不会吧后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在他前面的操作已经全部完成</p>
</li>
<li><p>他会强制对缓存的操作修改立即写入主存</p>
</li>
<li><p>如果是写操作，他会导致其他cpu中对应的缓存行无效</p>
</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>sychronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于sychronized，但是要注意volatile关键字是<strong>无法替代</strong>sychronized关键字的，因为<strong>volatile关键字无法保证操作的原子性</strong></p>
<p>一般使用时需要具备2个条件：</p>
<ol>
<li><p>对变量的写操作不依赖于当前值</p>
</li>
<li><p>该变量没有包含在具有其他变量的不变式中</p>
</li>
</ol>
<h3 id="场景一：状态标记量"><a href="#场景一：状态标记量" class="headerlink" title="场景一：状态标记量"></a>场景一：状态标记量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">volatile boolean flag = false;</span><br><span class="line"></span><br><span class="line">while(!flag)&#123;</span><br><span class="line">	doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setFlag()&#123;</span><br><span class="line">	flag = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">volatile boolean inited = false;</span><br><span class="line">//线程1:</span><br><span class="line">context = loadContext();</span><br><span class="line">inited = true;</span><br><span class="line"></span><br><span class="line">//线程2:</span><br><span class="line">while(!inited)&#123;</span><br><span class="line">	sleep();</span><br><span class="line">&#125;</span><br><span class="line">doSomethingWithConfig(context);</span><br></pre></td></tr></table></figure>
<h3 id="场景二：double-check"><a href="#场景二：double-check" class="headerlink" title="场景二：double check"></a>场景二：double check</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">	private volatile static Singleton instance = null;</span><br><span class="line">	private Singleton()&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static Singleton getInstance()&#123;</span><br><span class="line">		if(instance == null)&#123;</span><br><span class="line">			sychronized(Singleton.class)&#123;</span><br><span class="line">				if(instance == null)&#123;</span><br><span class="line">					instance = new Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="volatile如何保证有序性？"><a href="#volatile如何保证有序性？" class="headerlink" title="volatile如何保证有序性？"></a>volatile如何保证有序性？</h2><p>首先，volatile禁止指令重排序，这代表两层意思</p>
<p>1.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，而在其后面的操作还没有执行</p>
<p>2.在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行，这也就是上面说的内存栅栏</p>
<p>譬如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//x、y为非volatile变量</span><br><span class="line">//flag为volatile变量</span><br><span class="line"> </span><br><span class="line">x = 2;        //语句1</span><br><span class="line">y = 0;        //语句2</span><br><span class="line">flag = true;  //语句3</span><br><span class="line">x = 4;         //语句4</span><br><span class="line">y = -1;       //语句5</span><br></pre></td></tr></table></figure>
<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会将语句3放到语句4、语句5后面，但是语句1和语句2的顺序、语句4和语句5的顺序是不做任何保证的。</p>
<p>再譬如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//线程1:</span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"> </span><br><span class="line">//线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>
<p>加入inited没有被volatile修饰的话，那么就有可能语句2再语句1之前执行，就会导致线程2崩溃。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/07/threadlocal学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/07/threadlocal学习/" itemprop="url">threadlocal学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-07T13:36:26+08:00">
                2019-01-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>threadlocal是java.lang包下面的，其作用通过类注释可以看出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This class provides thread-local variables.  These variables differ from</span><br><span class="line"> * their normal counterparts in that each thread that accesses one (via its</span><br><span class="line"> * &#123;@code get&#125; or &#123;@code set&#125; method) has its own, independently initialized</span><br><span class="line"> * copy of the variable.  &#123;@code ThreadLocal&#125; instances are typically private</span><br><span class="line"> * static fields in classes that wish to associate state with a thread (e.g.,</span><br><span class="line"> * a user ID or Transaction ID).</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;For example, the class below generates unique identifiers local to each</span><br><span class="line"> * thread.</span><br><span class="line"> * A thread&apos;s id is assigned the first time it invokes &#123;@code ThreadId.get()&#125;</span><br><span class="line"> * and remains unchanged on subsequent calls.</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"> *</span><br><span class="line"> * public class ThreadId &#123;</span><br><span class="line"> *     // Atomic integer containing the next thread ID to be assigned</span><br><span class="line"> *     private static final AtomicInteger nextId = new AtomicInteger(0);</span><br><span class="line"> *</span><br><span class="line"> *     // Thread local variable containing each thread&apos;s ID</span><br><span class="line"> *     private static final ThreadLocal&amp;lt;Integer&amp;gt; threadId =</span><br><span class="line"> *         new ThreadLocal&amp;lt;Integer&amp;gt;() &#123;</span><br><span class="line"> *             &amp;#64;Override protected Integer initialValue() &#123;</span><br><span class="line"> *                 return nextId.getAndIncrement();</span><br><span class="line"> *         &#125;</span><br><span class="line"> *     &#125;;</span><br><span class="line"> *</span><br><span class="line"> *     // Returns the current thread&apos;s unique ID, assigning it if necessary</span><br><span class="line"> *     public static int get() &#123;</span><br><span class="line"> *         return threadId.get();</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> * &lt;p&gt;Each thread holds an implicit reference to its copy of a thread-local</span><br><span class="line"> * variable as long as the thread is alive and the &#123;@code ThreadLocal&#125;</span><br><span class="line"> * instance is accessible; after a thread goes away, all of its copies of</span><br><span class="line"> * thread-local instances are subject to garbage collection (unless other</span><br><span class="line"> * references to these copies exist).</span><br><span class="line"> *</span><br><span class="line"> * @author  Josh Bloch and Doug Lea</span><br><span class="line"> * @since   1.2</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>翻译一下：<br>这个类提供了一个本地线程变量，这些变量在不同线程中有不同的副本，都是独立的原始变量的拷贝。其实例是希望与线程连接状态的独立的field。</p>
<p>因此就是在不同的thread中保留不同的值的类型。</p>
<h1 id="api"><a href="#api" class="headerlink" title="api"></a>api</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Creates a thread local variable.</span><br><span class="line">    * @see #withInitial(java.util.function.Supplier)</span><br><span class="line">    */</span><br><span class="line">   public ThreadLocal() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Returns the value in the current thread&apos;s copy of this</span><br><span class="line">    * thread-local variable.  If the variable has no value for the</span><br><span class="line">    * current thread, it is first initialized to the value returned</span><br><span class="line">    * by an invocation of the &#123;@link #initialValue&#125; method.</span><br><span class="line">    *</span><br><span class="line">    * @return the current thread&apos;s value of this thread-local</span><br><span class="line">    */</span><br><span class="line">   public T get() &#123;</span><br><span class="line">   	...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Sets the current thread&apos;s copy of this thread-local variable</span><br><span class="line">    * to the specified value.  Most subclasses will have no need to</span><br><span class="line">    * override this method, relying solely on the &#123;@link #initialValue&#125;</span><br><span class="line">    * method to set the values of thread-locals.</span><br><span class="line">    *</span><br><span class="line">    * @param value the value to be stored in the current thread&apos;s copy of</span><br><span class="line">    *        this thread-local.</span><br><span class="line">    */</span><br><span class="line">   public void set(T value) &#123;</span><br><span class="line">   	...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Removes the current thread&apos;s value for this thread-local</span><br><span class="line">    * variable.  If this thread-local variable is subsequently</span><br><span class="line">    * &#123;@linkplain #get read&#125; by the current thread, its value will be</span><br><span class="line">    * reinitialized by invoking its &#123;@link #initialValue&#125; method,</span><br><span class="line">    * unless its value is &#123;@linkplain #set set&#125; by the current thread</span><br><span class="line">    * in the interim.  This may result in multiple invocations of the</span><br><span class="line">    * &#123;@code initialValue&#125; method in the current thread.</span><br><span class="line">    *</span><br><span class="line">    * @since 1.5</span><br><span class="line">    */</span><br><span class="line">    public void remove() &#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>public 的接口就这几个。</p>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null)</span><br><span class="line">            map.set(this, value);</span><br><span class="line">        else</span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Get the map associated with a ThreadLocal. Overridden in</span><br><span class="line">     * InheritableThreadLocal.</span><br><span class="line">     *</span><br><span class="line">     * @param  t the current thread</span><br><span class="line">     * @return the map</span><br><span class="line">     */</span><br><span class="line">    ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">        return t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Create the map associated with a ThreadLocal. Overridden in</span><br><span class="line">     * InheritableThreadLocal.</span><br><span class="line">     *</span><br><span class="line">     * @param t the current thread</span><br><span class="line">     * @param firstValue value for the initial entry of the map</span><br><span class="line">     */</span><br><span class="line">    void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">        t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>set的时候会获取当前的map，如果没有就会创建，有的话就会调用map的set</p>
<p>其中有个概念，是threadlocalmap，既然是map，看看键值对是什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value)</span><br></pre></td></tr></table></figure>
<p>也就是用threadlocal作为key，其余的作为value进行存储的。</p>
<h2 id="总结一下set"><a href="#总结一下set" class="headerlink" title="总结一下set"></a>总结一下set</h2><p>1.每个thread中有一个threadlocalmap<br>2.threadlocalmap是以threadlocal为key，目标值为value的map结构<br>3.当希望存储这个threadlocal的时候，会先从线程中取出这个threadlocalmap，然后以这个threadlocal为key，将目标值传入进去。<br>4.如果当前线程没有threadlocalmap的话，会主动创建一个塞进去。</p>
<h1 id="get"><a href="#get" class="headerlink" title="get"></a>get</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Returns the value in the current thread&apos;s copy of this</span><br><span class="line">     * thread-local variable.  If the variable has no value for the</span><br><span class="line">     * current thread, it is first initialized to the value returned</span><br><span class="line">     * by an invocation of the &#123;@link #initialValue&#125; method.</span><br><span class="line">     *</span><br><span class="line">     * @return the current thread&apos;s value of this thread-local</span><br><span class="line">     */</span><br><span class="line">    public T get() &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">            if (e != null) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">            int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            if (e != null &amp;&amp; e.get() == key)</span><br><span class="line">                return e;</span><br><span class="line">            else</span><br><span class="line">                return getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            int len = tab.length;</span><br><span class="line"></span><br><span class="line">            while (e != null) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                if (k == key)</span><br><span class="line">                    return e;</span><br><span class="line">                if (k == null)</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                else</span><br><span class="line">                    i = nextIndex(i, len);</span><br><span class="line">                e = tab[i];</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">    private int expungeStaleEntry(int staleSlot) &#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            int len = tab.length;</span><br><span class="line"></span><br><span class="line">            // expunge entry at staleSlot</span><br><span class="line">            tab[staleSlot].value = null;</span><br><span class="line">            tab[staleSlot] = null;</span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">            // Rehash until we encounter null</span><br><span class="line">            Entry e;</span><br><span class="line">            int i;</span><br><span class="line">            for (i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != null;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                if (k == null) &#123;</span><br><span class="line">                    e.value = null;</span><br><span class="line">                    tab[i] = null;</span><br><span class="line">                    size--;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    int h = k.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">                    if (h != i) &#123;</span><br><span class="line">                        tab[i] = null;</span><br><span class="line"></span><br><span class="line">                        // Unlike Knuth 6.4 Algorithm R, we must scan until</span><br><span class="line">                        // null because multiple entries could have been stale.</span><br><span class="line">                        while (tab[h] != null)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        tab[h] = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;  </span><br><span class="line">        </span><br><span class="line">    private static int nextIndex(int i, int len) &#123;</span><br><span class="line">            return ((i + 1 &lt; len) ? i + 1 : 0);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>从流程上面其实就是一个map寻址操作，有个注意点，由于threadlocalmap的entry，是一个weakreference，所以有可能会出现获取的时候发现为null，此时需要擦除这个值。不过源码中擦除不单单这个值，把别的空的也同时擦除了。</p>
<h1 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         if (m != null)</span><br><span class="line">             m.remove(this);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>擦除了这个key</p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="ThreadLocalMap里Entry为何声明为WeakReference？"><a href="#ThreadLocalMap里Entry为何声明为WeakReference？" class="headerlink" title="ThreadLocalMap里Entry为何声明为WeakReference？"></a>ThreadLocalMap里Entry为何声明为WeakReference？</h2><p>引用关系是这样的</p>
<p>ThreadLocalRef持有对ThreadLocal的引用，同时map的entry也持有对threadlocal的引用，而map的引用是在Current Thread手里，这样就会造成当清除ThreadLocalRef的时候出现泄漏的情况。</p>
<p>将entry声明为weakreference，这样在上述这种情况时，就不会产生泄漏现象，但是value仍然存在，只是索引不到，map仍然持有这个对象。</p>
<p>threadlocalmap针对这个问题，特意在get和set、remove的时候，执行了擦除所有key为null的值。</p>
<h2 id="threadlocalmap避免出现内存泄漏的情况"><a href="#threadlocalmap避免出现内存泄漏的情况" class="headerlink" title="threadlocalmap避免出现内存泄漏的情况"></a>threadlocalmap避免出现内存泄漏的情况</h2><p>1.尽量避免使用static修饰，会拉伸threadlocal声明周期<br>2.分配使用了threadlocal后，如果不需要了，记得要使用remove操作擦除这块数据。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/动态代理的好处/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/动态代理的好处/" itemprop="url">动态代理的好处</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T00:00:42+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>先有设计的思想，后才有设计的手段</p>
</blockquote>
<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>代理模式是java设计模式的一种。代理类具有和委托类相同的接口，代理类主要负责为委托类预处理消息、过滤消息、消息转发、以及事后处理消息等。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>由程序员创建或由特定工具自动生成源代码，在对其编译。在程序运行前，代理类的.class文件就已经存在</p>
<p>静态代理通常只代理一个类。同时静态代理需要明白代理的是什么</p>
<p>sample:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//定义代理接口</span><br><span class="line">public interface ProxyInterface&#123;</span><br><span class="line">	void doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class A implements ProxyInterface&#123;</span><br><span class="line">	@Override</span><br><span class="line">	void doSomething()&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AProxy implements ProxyInterface&#123;</span><br><span class="line">	private ProxyInterface a;</span><br><span class="line">	public AProxy(ProxyInterface a)&#123;</span><br><span class="line">		this.a = a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	void doSomething()&#123;</span><br><span class="line">		a.doSomething();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>静态代理从我们日常开发的角度来看，就是一个封装类，比较简单</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>局限性很大，尤其是限于对代理类的了解。在接手一个项目，发生问题的时候或许可以使用这种代理方式来进行优化</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理类的字节码由java反射机制动态生成，无需手动编写源代码。</p>
<p>sample:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建InvocationHandler</span><br><span class="line">InvocationHandler handler = new MyInvocationHandler(...);</span><br><span class="line">//创建动态代理类</span><br><span class="line">Class proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(),new Class[]&#123;Foo.class&#125;);</span><br><span class="line">//创建动态代理类的实例</span><br><span class="line">Foo foo = (Foo)proxyClass.getConstructor(new Class[]&#123;InvocationHandler.class&#125;).newInstance(new Object[]&#123;handler&#125;);</span><br></pre></td></tr></table></figure>
<p>这样就获取了类了。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h3 id="newProxyInstance"><a href="#newProxyInstance" class="headerlink" title="newProxyInstance"></a>newProxyInstance</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                                          Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                          InvocationHandler h)</span><br><span class="line">        throws IllegalArgumentException</span><br><span class="line">    &#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        final Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        // Android-changed: sm is always null</span><br><span class="line">        // final SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        // if (sm != null) &#123;</span><br><span class="line">        //     checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        // &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Look up or generate the designated proxy class.</span><br><span class="line">         */</span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Invoke its constructor with the designated invocation handler.</span><br><span class="line">         */</span><br><span class="line">        try &#123;</span><br><span class="line">            // Android-changed: sm is always null</span><br><span class="line">            // if (sm != null) &#123;</span><br><span class="line">            //     checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            // &#125;</span><br><span class="line"></span><br><span class="line">            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            final InvocationHandler ih = h;</span><br><span class="line">            if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                // Android-changed: Removed AccessController.doPrivileged</span><br><span class="line">                cons.setAccessible(true);</span><br><span class="line">            &#125;</span><br><span class="line">            return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class="line">        &#125; catch (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            throw new InternalError(e.toString(), e);</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            if (t instanceof RuntimeException) &#123;</span><br><span class="line">                throw (RuntimeException) t;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            throw new InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>细致的看这个方法的内容</p>
<p>第一步 检查handler是否是空，这个没得说的</p>
<p>第二步 通过传入进去的classloader和class的方法来生成一个新的代理类（这中间有缓存）（class层级）</p>
<p>第三步 调用代理的构造器，将handler传入，构造了一个相应的类。</p>
<h3 id="getProxyClass0-：就是用来生产代理类的类对象"><a href="#getProxyClass0-：就是用来生产代理类的类对象" class="headerlink" title="getProxyClass0()：就是用来生产代理类的类对象"></a>getProxyClass0()：就是用来生产代理类的类对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    // 当目标类实现的接口数量大于 65535</span><br><span class="line">    if (interfaces.length &gt; 65535) &#123;</span><br><span class="line">	    // 抛异常</span><br><span class="line">        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 关键2：获取代理类，使用了缓存机制</span><br><span class="line">    return proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WeakCache-get"><a href="#WeakCache-get" class="headerlink" title="WeakCache#get()"></a>WeakCache#get()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">// 缓存的底层实现，key 为一级缓存，value 为二级缓存，一级缓存 key 类型为 Object，支持 null</span><br><span class="line">private final ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map</span><br><span class="line">    = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// key：classloader</span><br><span class="line">// parameter：interfaces</span><br><span class="line">public V get(K key, P parameter) &#123;</span><br><span class="line">	// 判断接口数组是否为空，为空抛异常，不为空返回接口对应类型</span><br><span class="line">	Objects.requireNonNull(parameter);</span><br><span class="line"></span><br><span class="line">	// 清除过期的缓存</span><br><span class="line">	expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">	// 将传入的 classloader 包装成 CacheKey，作为一级缓存</span><br><span class="line">	Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class="line"></span><br><span class="line">	// 根据一级缓存 cacheKey 获取二级缓存 valuesMap</span><br><span class="line">	ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">	// 如果根据 classLoader 没有获取到对应的值</span><br><span class="line">	if (valuesMap == null) &#123;</span><br><span class="line">		// 以 CAS 方式放入，如果不存在则放入，否则返回原先的值</span><br><span class="line">		ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey,</span><br><span class="line">                              valuesMap = new ConcurrentHashMap&lt;&gt;());</span><br><span class="line">		// 如果 oldValuesMap 有值，说明放入失败</span><br><span class="line">		if (oldValuesMap != null) &#123;</span><br><span class="line">			// valuesMap 设置为原来的 oldValuesMap</span><br><span class="line">			valuesMap = oldValuesMap;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    // subKeyFactory 通过 WeakCache 构造函数传入，实际为 KeyFactory</span><br><span class="line">    // subKeyFactory.apply(key, parameter)：KeyFactory 根据代理类实现的接口数组来生成二级缓存 key</span><br><span class="line">	// Objects.requireNonNull()：判断得到的二级缓存 key 是否为空，为空抛异常，不为空返回二级缓存 key 对应类型 Object</span><br><span class="line">	Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">	// 根据二级缓存的 key 获取二级缓存的值 supplier</span><br><span class="line">	Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">	Factory factory = null;</span><br><span class="line"></span><br><span class="line">	while (true) &#123;</span><br><span class="line">		// 如果二级缓存的值 supplier 不为 null</span><br><span class="line">		if (supplier != null) &#123;</span><br><span class="line">			// 调用 get() 方法</span><br><span class="line">			// 关键4：Factory implements Supplier，则此处实际调用的是 Factory#get()</span><br><span class="line">			V value = supplier.get();</span><br><span class="line">			// value 不为空</span><br><span class="line">			if (value != null) &#123;</span><br><span class="line">				// 返回 value</span><br><span class="line">				return value;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// else no supplier in cache</span><br><span class="line">		// or a supplier that returned null (could be a cleared CacheValue</span><br><span class="line">		// or a Factory that wasn&apos;t successful in installing the CacheValue)</span><br><span class="line"></span><br><span class="line">		// 如果 factory 等于 null</span><br><span class="line">		if (factory == null) &#123;</span><br><span class="line">			// 实例化一个 Factory（作为二级缓存的值），作为 subKey （二级缓存的 key）对应的 value</span><br><span class="line">			factory = new Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 如果 supplier 等于 null（根据二级缓存的 key 没有获取到二级缓存的值 supplier）</span><br><span class="line">		if (supplier == null) &#123;</span><br><span class="line">			// 将实例化的 factory 作为 subKey 对应的值传入</span><br><span class="line">			supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">			// supplier 等于 null（可能上一步成功执行后返回的是 null???）</span><br><span class="line">			if (supplier == null) &#123;</span><br><span class="line">				// successfully installed Factory</span><br><span class="line">				supplier = factory;</span><br><span class="line">			&#125;</span><br><span class="line">			// else retry with winning supplier</span><br><span class="line">		&#125; else &#123; // 可能期间有其他线程修改了值，那么就不会再继续给 subKey 赋值，而是取出来直接用</span><br><span class="line">			// 期间可能其它线程修改了值 factory，就用该值替换掉 supplier</span><br><span class="line">			if (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">				// 将 supplier 替换成 factory</span><br><span class="line">				supplier = factory;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				// 替换失败，继续使用原先的值</span><br><span class="line">				supplier = valuesMap.get(subKey);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Factory-get"><a href="#Factory-get" class="headerlink" title="Factory#get()"></a>Factory#get()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V get() &#123; // serialize access</span><br><span class="line">    // 根据二级缓存的 key 获取 supplier</span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">    // 如果获取的 supplier 不是 Factory 类型</span><br><span class="line">    if (supplier != this) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // else still us (supplier == this)</span><br><span class="line"></span><br><span class="line">    // create new value</span><br><span class="line">    V value = null;</span><br><span class="line">    try &#123;</span><br><span class="line">	    // valueFactory 通过 WeakCache 构造函数传入，实际为 ProxyClassFactory</span><br><span class="line">	    // 关键5：valueFactory.apply()-&gt;ProxyClassFactory#apply()</span><br><span class="line">        value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (value == null) &#123; // remove us on failure</span><br><span class="line">            valuesMap.remove(subKey, this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // the only path to reach here is with non-null value</span><br><span class="line">    assert value != null;</span><br><span class="line"></span><br><span class="line">    // wrap value with CacheValue (WeakReference)</span><br><span class="line">    CacheValue&lt;V&gt; cacheValue = new CacheValue&lt;&gt;(value);</span><br><span class="line"></span><br><span class="line">    // try replacing us with CacheValue (this should always succeed)</span><br><span class="line">    if (valuesMap.replace(subKey, this, cacheValue)) &#123;</span><br><span class="line">        // put also in reverseMap</span><br><span class="line">        reverseMap.put(cacheValue, Boolean.TRUE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new AssertionError(&quot;Should not reach here&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // successfully replaced us with new CacheValue -&gt; return the value</span><br><span class="line">    // wrapped by it</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ProxyClassFactory-apply"><a href="#ProxyClassFactory-apply" class="headerlink" title="ProxyClassFactory#apply()"></a>ProxyClassFactory#apply()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">// Proxy 的类名前缀</span><br><span class="line">private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;</span><br><span class="line"></span><br><span class="line">// next number to use for generation of unique proxy class names</span><br><span class="line">// 生成自增的数字</span><br><span class="line">private static final AtomicLong nextUniqueNumber = new AtomicLong();</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">    // 根据接口数组长度生成对应的 Map</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">    // 遍历接口数组</span><br><span class="line">    for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * Verify that the class loader resolves the name of this</span><br><span class="line">         * interface to the same Class object.</span><br><span class="line">         * </span><br><span class="line">         * 验证类加载器将此 interface 的名字解析成同一类对象</span><br><span class="line">         */</span><br><span class="line">        Class&lt;?&gt; interfaceClass = null;</span><br><span class="line">        try &#123;</span><br><span class="line">	        // 根据接口名获取接口对应的类对象</span><br><span class="line">            interfaceClass = Class.forName(intf.getName(), false, loader);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        // 接口类对象不等于接口，不是同一对象</span><br><span class="line">        if (interfaceClass != intf) &#123;</span><br><span class="line">	        //抛异常，接口来自不同的类加载器</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                intf + &quot; is not visible from class loader&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">         * Verify that the Class object actually represents an</span><br><span class="line">         * interface.</span><br><span class="line">         * </span><br><span class="line">         * 验证生成的类对象是否是一个接口类型</span><br><span class="line">         */</span><br><span class="line">        // 类对象不是接口类型</span><br><span class="line">        if (!interfaceClass.isInterface()) &#123;</span><br><span class="line">	        // 抛异常，类对象不是一个接口类型</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                interfaceClass.getName() + &quot; is not an interface&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">         * Verify that this interface is not a duplicate.</span><br><span class="line">         * </span><br><span class="line">         * 验证此接口不是重复的</span><br><span class="line">         */</span><br><span class="line">        // 往接口数组对应的 map 中存入类对象，返回值不为 null</span><br><span class="line">        if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;</span><br><span class="line">	        // 抛异常，来自当前类对象的接口重复</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                &quot;repeated interface: &quot; + interfaceClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String proxyPkg = null;     // package to define proxy class in</span><br><span class="line">    int accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Record the package of a non-public proxy interface so that the</span><br><span class="line">     * proxy class will be defined in the same package.  Verify that</span><br><span class="line">     * all non-public proxy interfaces are in the same package.</span><br><span class="line">     */</span><br><span class="line">    // 遍历接口数组</span><br><span class="line">    for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">		// 获取当前接口的修饰符</span><br><span class="line">        int flags = intf.getModifiers();</span><br><span class="line">        // 如果当前接口修饰符不是 public</span><br><span class="line">        if (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">			// 设置为 final</span><br><span class="line">            accessFlags = Modifier.FINAL;</span><br><span class="line">            String name = intf.getName();</span><br><span class="line">            int n = name.lastIndexOf(&apos;.&apos;);</span><br><span class="line">            String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));</span><br><span class="line">            // 包名为 null</span><br><span class="line">            if (proxyPkg == null) &#123;</span><br><span class="line">	            // 包名等于当前接口的包名</span><br><span class="line">                proxyPkg = pkg;</span><br><span class="line">            &#125; else if (!pkg.equals(proxyPkg)) &#123;// 如果包名不相等</span><br><span class="line">	            // 抛异常，非 public 的接口集合来自不同的包</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                    &quot;non-public interfaces from different packages&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 包名为 null</span><br><span class="line">    if (proxyPkg == null) &#123;</span><br><span class="line">        // if no non-public proxy interfaces, use com.sun.proxy package</span><br><span class="line">        // 如果 no non-public（即是 public）的代理接口集合，则使用包名 com.sun.proxy</span><br><span class="line">        proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Choose a name for the proxy class to generate.</span><br><span class="line">     */</span><br><span class="line">    long num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">    // 组成代理类全类名：包名 + 代理类前缀 + 唯一的自增长数字</span><br><span class="line">    String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Generate the specified proxy class.</span><br><span class="line">     * </span><br><span class="line">     * 关键6：生成指定的代理类</span><br><span class="line">     */</span><br><span class="line">    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">        proxyName, interfaces, accessFlags);</span><br><span class="line">    try &#123;</span><br><span class="line">        return defineClass0(loader, proxyName,</span><br><span class="line">                            proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">    &#125; catch (ClassFormatError e) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * A ClassFormatError here means that (barring bugs in the</span><br><span class="line">         * proxy class generation code) there was some other</span><br><span class="line">         * invalid aspect of the arguments supplied to the proxy</span><br><span class="line">         * class creation (such as virtual machine limitations</span><br><span class="line">         * exceeded).</span><br><span class="line">         */</span><br><span class="line">        throw new IllegalArgumentException(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成代理类的字节码"><a href="#生成代理类的字节码" class="headerlink" title="生成代理类的字节码"></a>生成代理类的字节码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">最终生成的代理类：</span><br><span class="line">public class Proxy0 extends Proxy implements IDinner &#123;</span><br><span class="line">	// 第一步：生成构造器</span><br><span class="line">	protected Proxy0(InvocationHandler h) &#123;</span><br><span class="line">		super(h);</span><br><span class="line">	&#125;</span><br><span class="line">	// 第二步：生成静态域</span><br><span class="line">	private static Method m1; // hashCode方法</span><br><span class="line">	private static Method m2; // equals方法</span><br><span class="line">	private static Method m3; // toString方法</span><br><span class="line">	private static Method m4; //...</span><br><span class="line">	// 第三步：生成代理方法</span><br><span class="line">	@Override</span><br><span class="line">	public int hashCode() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return (int) h.invoke(this, m1, null);</span><br><span class="line">		&#125;catch (Throwable e) &#123;</span><br><span class="line">			throw new UndeclaredThrowableException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public boolean equals(Object obj) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			Object[] args = new Object[] &#123;obj&#125;;</span><br><span class="line">			return (boolean) h.invoke(this, m2, args);</span><br><span class="line">		&#125;catch (Throwable e) &#123;</span><br><span class="line">			throw new UndeclaredThrowableException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return (String) h.invoke(this, m3, null);</span><br><span class="line">		&#125;catch (Throwable e) &#123;</span><br><span class="line">			throw new UndeclaredThrowableException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void dinner() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			// 构造参数数组，如果有多个参数往后面添加就行了</span><br><span class="line">			Object[] args = new Object[] &#123;&#125;;</span><br><span class="line">			// h 为通过构造方法传进来的 InvocationHandler，即此处调用 InvocationHandler#invoke(...) 方法</span><br><span class="line">			h.invoke(this, m4, args);</span><br><span class="line">		&#125;catch (Throwable e) &#123;</span><br><span class="line">			throw new UndeclaredThrowableException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 第四步：生成静态初始化方法</span><br><span class="line">	static &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			Class c1 = Class.forName(Object.class.getName());</span><br><span class="line">			Class c2 = Class.forName(IDinner.class.getName()); </span><br><span class="line">			m1 = c1.getMethod(&quot;hashCode&quot;, null);</span><br><span class="line">			m2 = c1.getMethod(&quot;equals&quot;, new Class[]&#123;Object.class&#125;);</span><br><span class="line">			m3 = c1.getMethod(&quot;toString&quot;, null);</span><br><span class="line">			m4 = c2.getMethod(&quot;dinner&quot;, new Class[]&#123;IDinner.class&#125;);</span><br><span class="line">			//...</span><br><span class="line">		&#125;catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &#123;@code InvocationHandler&#125; is the interface implemented by</span><br><span class="line"> * the &lt;i&gt;invocation handler&lt;/i&gt; of a proxy instance.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Each proxy instance has an associated invocation handler.</span><br><span class="line"> * When a method is invoked on a proxy instance, the method</span><br><span class="line"> * invocation is encoded and dispatched to the &#123;@code invoke&#125;</span><br><span class="line"> * method of its invocation handler.</span><br><span class="line"> *</span><br><span class="line"> * @author      Peter Jones</span><br><span class="line"> * @see         Proxy</span><br><span class="line"> * @since       1.3</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>从其类注释上面可以看出来，每一个代理实例都有一个相关的调用handler，当一个代理实例的方法被唤醒的时候，该被代理的方法将会被编码并且分发到invocation handler中</p>
<p>具体来讲事实上是个回调接口类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Processes a method invocation on a proxy instance and returns</span><br><span class="line">    * the result.  This method will be invoked on an invocation handler</span><br><span class="line">    * when a method is invoked on a proxy instance that it is</span><br><span class="line">    * associated with.</span><br><span class="line">    *</span><br><span class="line">    * @param   proxy the proxy instance that the method was invoked on</span><br><span class="line">    *</span><br><span class="line">    * @param   method the &#123;@code Method&#125; instance corresponding to</span><br><span class="line">    * the interface method invoked on the proxy instance.  The declaring</span><br><span class="line">    * class of the &#123;@code Method&#125; object will be the interface that</span><br><span class="line">    * the method was declared in, which may be a superinterface of the</span><br><span class="line">    * proxy interface that the proxy class inherits the method through.</span><br><span class="line">    *</span><br><span class="line">    * @param   args an array of objects containing the values of the</span><br><span class="line">    * arguments passed in the method invocation on the proxy instance,</span><br><span class="line">    * or &#123;@code null&#125; if interface method takes no arguments.</span><br><span class="line">    * Arguments of primitive types are wrapped in instances of the</span><br><span class="line">    * appropriate primitive wrapper class, such as</span><br><span class="line">    * &#123;@code java.lang.Integer&#125; or &#123;@code java.lang.Boolean&#125;.</span><br><span class="line">    *</span><br><span class="line">    * @return  the value to return from the method invocation on the</span><br><span class="line">    * proxy instance.  If the declared return type of the interface</span><br><span class="line">    * method is a primitive type, then the value returned by</span><br><span class="line">    * this method must be an instance of the corresponding primitive</span><br><span class="line">    * wrapper class; otherwise, it must be a type assignable to the</span><br><span class="line">    * declared return type.  If the value returned by this method is</span><br><span class="line">    * &#123;@code null&#125; and the interface method&apos;s return type is</span><br><span class="line">    * primitive, then a &#123;@code NullPointerException&#125; will be</span><br><span class="line">    * thrown by the method invocation on the proxy instance.  If the</span><br><span class="line">    * value returned by this method is otherwise not compatible with</span><br><span class="line">    * the interface method&apos;s declared return type as described above,</span><br><span class="line">    * a &#123;@code ClassCastException&#125; will be thrown by the method</span><br><span class="line">    * invocation on the proxy instance.</span><br><span class="line">    *</span><br><span class="line">    * @throws  Throwable the exception to throw from the method</span><br><span class="line">    * invocation on the proxy instance.  The exception&apos;s type must be</span><br><span class="line">    * assignable either to any of the exception types declared in the</span><br><span class="line">    * &#123;@code throws&#125; clause of the interface method or to the</span><br><span class="line">    * unchecked exception types &#123;@code java.lang.RuntimeException&#125;</span><br><span class="line">    * or &#123;@code java.lang.Error&#125;.  If a checked exception is</span><br><span class="line">    * thrown by this method that is not assignable to any of the</span><br><span class="line">    * exception types declared in the &#123;@code throws&#125; clause of</span><br><span class="line">    * the interface method, then an</span><br><span class="line">    * &#123;@link UndeclaredThrowableException&#125; containing the</span><br><span class="line">    * exception that was thrown by this method will be thrown by the</span><br><span class="line">    * method invocation on the proxy instance.</span><br><span class="line">    *</span><br><span class="line">    * @see     UndeclaredThrowableException</span><br><span class="line">    */</span><br><span class="line">   public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">       throws Throwable;</span><br></pre></td></tr></table></figure>
<p>参数的方法表现的就比较容易理解了。</p>
<p>proxy是指代理类的实例，method是指代理类的方法，每当代理类有方法经过时，这个method就会变成那个方法，args是方法的形式参数，这个地方也会截断。</p>
<p>返回值有几种情况</p>
<p>1、声明的返回类型是基础类型，返回值必须是对应的包装类实例</p>
<p>2、如果声明的返回类型是基础类型，但是返回了一个null的话，会报空指针异常</p>
<p>3、如果这个方法的返回值和声明的返回值不兼容的话，会报类型转换异常</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>类A写死持有B，就是B的静态代理。如果A代理的对象是不确定的，就是动态代理。动态代理借用反射机制，最终生成的代理类和静态代理生成的相同</p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="动态代理模式和装饰者模式的区别"><a href="#动态代理模式和装饰者模式的区别" class="headerlink" title="动态代理模式和装饰者模式的区别"></a>动态代理模式和装饰者模式的区别</h2><ul>
<li><p>装饰者模式的作用：在不使用继承、不改变原有对象的情况下增加或扩展对象行为，但是并不会禁用某个对象的行为</p>
</li>
<li><p>代理模式：控制了这个对象的访问，决定执行或者不执行</p>
</li>
</ul>
<h2 id="动态代理模式有缺点吗？"><a href="#动态代理模式有缺点吗？" class="headerlink" title="动态代理模式有缺点吗？"></a>动态代理模式有缺点吗？</h2><p>由于是反射机制，创建一个动态代理类大约需要13ms，对比与反射一个方法只需要2ms来看，如果消耗过大还是需要考虑一下的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/02/jvm内存模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/02/jvm内存模型/" itemprop="url">jvm内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-02T23:48:21+08:00">
                2019-01-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/images/android/jvm内存模型.jpg" alt="JVM内存模型示意图"></p>
<h2 id="内存计数器（PC寄存器）"><a href="#内存计数器（PC寄存器）" class="headerlink" title="内存计数器（PC寄存器）"></a>内存计数器（PC寄存器）</h2><p>由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，</p>
<p>因此，为了能够使得每个线程都在线程切换后能够恢复在切　换　之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，</p>
<p>否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，</p>
<p>因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。</p>
<p>内存计数器是context的一部分</p>
<h2 id="java-栈"><a href="#java-栈" class="headerlink" title="java 栈"></a>java 栈</h2><p>Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、</p>
<p>指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、</p>
<p>方法返回地址(Return Address)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">经常有人把Java 内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗</span><br><span class="line"></span><br><span class="line">糙，Java 内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序</span><br><span class="line"></span><br><span class="line">员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”在后</span><br><span class="line"></span><br><span class="line">面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变</span><br><span class="line"></span><br><span class="line">量表部分。</span><br><span class="line"></span><br><span class="line">局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、</span><br><span class="line"></span><br><span class="line">float、long、double）、对象引用（reference 类型，它不等同于对象本身，根据不同的虚拟</span><br><span class="line"></span><br><span class="line">机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或</span><br><span class="line"></span><br><span class="line">者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。</span><br><span class="line"></span><br><span class="line">其中64 位长度的long 和double 类型的数据会占用2 个局部变量空间（Slot），其余</span><br><span class="line"></span><br><span class="line">的数据类型只占用1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个</span><br><span class="line"></span><br><span class="line">方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间</span><br><span class="line"></span><br><span class="line">不会改变局部变量表的大小。</span><br></pre></td></tr></table></figure>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其</span><br><span class="line"></span><br><span class="line">区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则</span><br><span class="line"></span><br><span class="line">是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语</span><br><span class="line"></span><br><span class="line">言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至</span><br><span class="line"></span><br><span class="line">有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。</span><br><span class="line"></span><br><span class="line">与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError</span><br><span class="line"></span><br><span class="line">异常。</span><br></pre></td></tr></table></figure>
<h2 id="java-堆"><a href="#java-堆" class="headerlink" title="java 堆"></a>java 堆</h2><p>Java中的堆是用来存储对象本身的以及数组（数组引用是存放在Java栈中的）。堆是被所有线程共享的，在JVM中只有一个堆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的</span><br><span class="line"></span><br><span class="line">一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的</span><br><span class="line"></span><br><span class="line">唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚</span><br><span class="line"></span><br><span class="line">拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着JIT 编译器</span><br><span class="line"></span><br><span class="line">的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙</span><br><span class="line"></span><br><span class="line">的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</span><br><span class="line"></span><br><span class="line">Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（Garbage</span><br><span class="line"></span><br><span class="line">Collected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在</span><br><span class="line"></span><br><span class="line">收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；</span><br><span class="line"></span><br><span class="line">再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配</span><br><span class="line"></span><br><span class="line">的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local</span><br><span class="line"></span><br><span class="line">Allocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，</span><br><span class="line"></span><br><span class="line">存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配</span><br><span class="line"></span><br><span class="line">内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java 堆中的上述各个区域的</span><br><span class="line"></span><br><span class="line">分配和回收等细节将会是下一章的主题。</span><br><span class="line"></span><br><span class="line">根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要</span><br><span class="line"></span><br><span class="line">逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小</span><br><span class="line"></span><br><span class="line">的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx</span><br><span class="line"></span><br><span class="line">和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出</span><br><span class="line"></span><br><span class="line">OutOfMemoryError 异常。</span><br></pre></td></tr></table></figure>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。</p>
<p>在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。</p>
<p>在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，</p>
<p>对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存</span><br><span class="line"></span><br><span class="line">储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽</span><br><span class="line"></span><br><span class="line">然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-</span><br><span class="line"></span><br><span class="line">Heap（非堆），目的应该是与Java 堆区分开来。</span><br><span class="line"></span><br><span class="line">对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区</span><br><span class="line"></span><br><span class="line">称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚</span><br><span class="line"></span><br><span class="line">拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而</span><br><span class="line"></span><br><span class="line">已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。即</span><br><span class="line"></span><br><span class="line">使是HotSpot 虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”</span><br><span class="line"></span><br><span class="line">至Native Memory 来实现方法区的规划了。</span><br><span class="line"></span><br><span class="line">Java 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内</span><br><span class="line"></span><br><span class="line">存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾</span><br><span class="line"></span><br><span class="line">收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一</span><br><span class="line"></span><br><span class="line">样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸</span><br><span class="line"></span><br><span class="line">载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件</span><br><span class="line"></span><br><span class="line">相当苛刻，但是这部分区域的回收确实是有必要的。在Sun 公司的BUG 列表中，曾出</span><br><span class="line"></span><br><span class="line">现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导</span><br><span class="line"></span><br><span class="line">致内存泄漏。</span><br><span class="line"></span><br><span class="line">根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出</span><br><span class="line"></span><br><span class="line">OutOfMemoryError 异常。</span><br></pre></td></tr></table></figure>
<h2 id="静态区"><a href="#静态区" class="headerlink" title="静态区"></a>静态区</h2><p>静态区也称为运行常量池，static出来的对象都是静态的。该区域存放类和接口的常量，</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/02/okhttp+retrofit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/02/okhttp+retrofit/" itemprop="url">okhttp+retrofit分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-02T22:45:01+08:00">
                2019-01-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="retrofit的设计思路"><a href="#retrofit的设计思路" class="headerlink" title="retrofit的设计思路"></a>retrofit的设计思路</h1><p>retrofit自从接触的时候就知道是做了一层okhttp的封装，当时只知道retrofit做的，自己通过okhttp都可以做。但是细枝末节其实并未了解清楚。</p>
<h2 id="使用retrofit的方式"><a href="#使用retrofit的方式" class="headerlink" title="使用retrofit的方式"></a>使用retrofit的方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">webService = new Retrofit.Builder().baseUrl(config.getHost())</span><br><span class="line">                .addConverterFactory(MyGsonConverterFactory.create(gson))</span><br><span class="line">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">                .client(builder.build())</span><br><span class="line">                .build().create(WebService.class);</span><br></pre></td></tr></table></figure>
<p>首先是使用如上的方式创建一个retrofit实例。其中baseUrl指明的是host，ConverterFactory是指明的json转换工具，一般是使用gson。callAdapterFactory是加上了Rxjava的封装。</p>
<p>client中的builder是一个oktthp的builder，设置了一个okhttp的client，其中设置了需要的okhttp的客户端的配置。</p>
<p>最后就是调用了build来build一个Retrofit的builder。同时通过create传入了webservice.class，这个类就是我们使用的retrofit web接口类，定义了我们项目中需要的网络接口。</p>
<h2 id="retrofit-builder-build"><a href="#retrofit-builder-build" class="headerlink" title="retrofit.builder().build()"></a>retrofit.builder().build()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Builder() &#123;</span><br><span class="line">     this(Platform.get());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>builder()是构造，其中只传入了一个platform，是选择平台</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static Platform findPlatform() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      Class.forName(&quot;android.os.Build&quot;);</span><br><span class="line">      if (Build.VERSION.SDK_INT != 0) &#123;</span><br><span class="line">        return new Android();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      Class.forName(&quot;java.util.Optional&quot;);</span><br><span class="line">      return new Java8();</span><br><span class="line">    &#125; catch (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Platform();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其功能就是选择是android平台还是java平台</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public Retrofit build() &#123;</span><br><span class="line">      if (baseUrl == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Base URL required.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      okhttp3.Call.Factory callFactory = this.callFactory;</span><br><span class="line">      if (callFactory == null) &#123;</span><br><span class="line">        callFactory = new OkHttpClient();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Executor callbackExecutor = this.callbackExecutor;</span><br><span class="line">      if (callbackExecutor == null) &#123;</span><br><span class="line">        callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Make a defensive copy of the adapters and add the default Call adapter.</span><br><span class="line">      List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories);</span><br><span class="line">      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line"></span><br><span class="line">      // Make a defensive copy of the converters.</span><br><span class="line">      List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories);</span><br><span class="line"></span><br><span class="line">      return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,</span><br><span class="line">          callbackExecutor, validateEagerly);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>build的过程是将传入的参数进行赋值，如果没有传入okhttp的client会重新new一个。<br>其中的calldapter就是我们使用的rxjava2calladapter，convertfactories就是gsonconvertfactory。除此之外，calldapterfactories又增加了一个platform.defaultCallAdapterFactory(callbackExecutor)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) &#123;</span><br><span class="line">    if (callbackExecutor != null) &#123;</span><br><span class="line">      return new ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class="line">    &#125;</span><br><span class="line">    return DefaultCallAdapterFactory.INSTANCE;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>返回的是Executorcalladapter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</span><br><span class="line">    Utils.validateServiceInterface(service);</span><br><span class="line">    if (validateEagerly) &#123;</span><br><span class="line">      eagerlyValidateMethods(service);</span><br><span class="line">    &#125;</span><br><span class="line">    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        new InvocationHandler() &#123;</span><br><span class="line">          private final Platform platform = Platform.get();</span><br><span class="line"></span><br><span class="line">          @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)</span><br><span class="line">              throws Throwable &#123;</span><br><span class="line">            // If the method is a method from Object then defer to normal invocation.</span><br><span class="line">            if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">              return method.invoke(this, args);</span><br><span class="line">            &#125;</span><br><span class="line">            if (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">              return platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">            &#125;</span><br><span class="line">            ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class="line">                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">            OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">            return serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>create的过程如上，需要逐条分析。</p>
<p>首先是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Utils.validateServiceInterface(service);</span><br></pre></td></tr></table></figure></p>
<p>其功能就是分析该接口类是否有效，判断依据是否继承了额外的接口类，还有就是该类里面的接口方法数量是否大于0.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (validateEagerly) &#123;</span><br><span class="line">      eagerlyValidateMethods(service);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>名字起的很奇特，功能就是预先加载传入的接口清单的接口。默认是不预先加载</p>
<h2 id="动态代理全过程"><a href="#动态代理全过程" class="headerlink" title="动态代理全过程"></a>动态代理全过程</h2><p>首先是通过清单文件的classloader来进行hook这个清单文件，判断一下获取的class是否是object.class，就和一般的动态代理相同。</p>
<p>当确认hook的这个方法不是object.class的方法的时候，就会走一遍判断是否是该平台可用的method，不过这里默认都是返回false，貌似是准备后期扩展用。</p>
<p>万事具备之后，会走一次loadmethod，如果之前采取eagerlyValidateMethods的方式的话，此时是直接取出当时读出来的method，否则就是load一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">    ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">    if (result != null) return result;</span><br><span class="line"></span><br><span class="line">    synchronized (serviceMethodCache) &#123;</span><br><span class="line">      result = serviceMethodCache.get(method);</span><br><span class="line">      if (result == null) &#123;</span><br><span class="line">        result = new ServiceMethod.Builder&lt;&gt;(this, method).build();</span><br><span class="line">        serviceMethodCache.put(method, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>load的方法很明显做了一个cache，此处<strong>缓存下来了method和result</strong>，划重点</p>
<p>在之后就是将获取的method和清单中的方法的参数传入okhttpcall中，创建一个okhttpcall，最后通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serviceMethod.callAdapter.adapt(okHttpCall);</span><br></pre></td></tr></table></figure>
<p>来返回一个和清单类型一模一样的类型。</p>
<p>至此，retrofit的代理过程就已经结束。</p>
<h2 id="calladapter"><a href="#calladapter" class="headerlink" title="calladapter"></a>calladapter</h2><p>刚才传入的rxjava2calladapter有什么作用呢？</p>
<p>回到刚才划重点的地方，缓存下来了method和result，result怎么来的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = new ServiceMethod.Builder&lt;&gt;(this, method).build();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">Builder(Retrofit retrofit, Method method) &#123;</span><br><span class="line">     this.retrofit = retrofit;</span><br><span class="line">     this.method = method;</span><br><span class="line">     this.methodAnnotations = method.getAnnotations();</span><br><span class="line">     this.parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">     this.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public ServiceMethod build() &#123;</span><br><span class="line">     callAdapter = createCallAdapter();</span><br><span class="line">     responseType = callAdapter.responseType();</span><br><span class="line">     if (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class="line">       throw methodError(&quot;&apos;&quot;</span><br><span class="line">           + Utils.getRawType(responseType).getName()</span><br><span class="line">           + &quot;&apos; is not a valid response body type. Did you mean ResponseBody?&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     responseConverter = createResponseConverter();</span><br><span class="line"></span><br><span class="line">     for (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">       parseMethodAnnotation(annotation);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (httpMethod == null) &#123;</span><br><span class="line">       throw methodError(&quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (!hasBody) &#123;</span><br><span class="line">       if (isMultipart) &#123;</span><br><span class="line">         throw methodError(</span><br><span class="line">             &quot;Multipart can only be specified on HTTP methods with request body (e.g., @POST).&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       if (isFormEncoded) &#123;</span><br><span class="line">         throw methodError(&quot;FormUrlEncoded can only be specified on HTTP methods with &quot;</span><br><span class="line">             + &quot;request body (e.g., @POST).&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     int parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">     parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">     for (int p = 0; p &lt; parameterCount; p++) &#123;</span><br><span class="line">       Type parameterType = parameterTypes[p];</span><br><span class="line">       if (Utils.hasUnresolvableType(parameterType)) &#123;</span><br><span class="line">         throw parameterError(p, &quot;Parameter type must not include a type variable or wildcard: %s&quot;,</span><br><span class="line">             parameterType);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</span><br><span class="line">       if (parameterAnnotations == null) &#123;</span><br><span class="line">         throw parameterError(p, &quot;No Retrofit annotation found.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (relativeUrl == null &amp;&amp; !gotUrl) &#123;</span><br><span class="line">       throw methodError(&quot;Missing either @%s URL or @Url parameter.&quot;, httpMethod);</span><br><span class="line">     &#125;</span><br><span class="line">     if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</span><br><span class="line">       throw methodError(&quot;Non-body HTTP method cannot contain @Body.&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     if (isFormEncoded &amp;&amp; !gotField) &#123;</span><br><span class="line">       throw methodError(&quot;Form-encoded method must contain at least one @Field.&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     if (isMultipart &amp;&amp; !gotPart) &#123;</span><br><span class="line">       throw methodError(&quot;Multipart method must contain at least one @Part.&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return new ServiceMethod&lt;&gt;(this);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来,builder()是将注释，方法，方法的形式参数类型和方法的形式参数注释类型给记录下来。</p>
<p>build()的操作需要仔细分析</p>
<p>第一步创建calladapter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private CallAdapter&lt;T, R&gt; createCallAdapter() &#123;</span><br><span class="line">      Type returnType = method.getGenericReturnType();</span><br><span class="line">      if (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">        throw methodError(</span><br><span class="line">            &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType);</span><br><span class="line">      &#125;</span><br><span class="line">      if (returnType == void.class) &#123;</span><br><span class="line">        throw methodError(&quot;Service methods cannot return void.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      Annotation[] annotations = method.getAnnotations();</span><br><span class="line">      try &#123;</span><br><span class="line">        //noinspection unchecked</span><br><span class="line">        return (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">      &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code.</span><br><span class="line">        throw methodError(e, &quot;Unable to create call adapter for %s&quot;, returnType);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>创建的过程就是将参数传入，通过调用retrofit这个实例的calladapter方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;</span><br><span class="line">    return nextCallAdapter(null, returnType, annotations);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其中calladapter又调用了nextCallAdapter方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public CallAdapter&lt;?, ?&gt; nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,</span><br><span class="line">      Annotation[] annotations) &#123;</span><br><span class="line">    checkNotNull(returnType, &quot;returnType == null&quot;);</span><br><span class="line">    checkNotNull(annotations, &quot;annotations == null&quot;);</span><br><span class="line"></span><br><span class="line">    int start = adapterFactories.indexOf(skipPast) + 1;</span><br><span class="line">    for (int i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">      CallAdapter&lt;?, ?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, this);</span><br><span class="line">      if (adapter != null) &#123;</span><br><span class="line">        return adapter;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder builder = new StringBuilder(&quot;Could not locate call adapter for &quot;)</span><br><span class="line">        .append(returnType)</span><br><span class="line">        .append(&quot;.\n&quot;);</span><br><span class="line">    if (skipPast != null) &#123;</span><br><span class="line">      builder.append(&quot;  Skipped:&quot;);</span><br><span class="line">      for (int i = 0; i &lt; start; i++) &#123;</span><br><span class="line">        builder.append(&quot;\n   * &quot;).append(adapterFactories.get(i).getClass().getName());</span><br><span class="line">      &#125;</span><br><span class="line">      builder.append(&apos;\n&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(&quot;  Tried:&quot;);</span><br><span class="line">    for (int i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">      builder.append(&quot;\n   * &quot;).append(adapterFactories.get(i).getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    throw new IllegalArgumentException(builder.toString());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>到这里就可以发现，通过adapterFactories将我们之前放入的rxjava2adapter给取出来了</p>
<p>第二步，取出了rxjava2adapter的responseType()，这个type可以从rxjava2adapter里面查到，这里不追溯。</p>
<p>第三步，创建了responseConverter,就是通过我们传入的gsonconverter来构建解析器</p>
<p>第四步，逐个读取该方法的注释。</p>
<p>第五步，进行一系列的检查，检查request的参数是否正确</p>
<p>最后一步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return new ServiceMethod&lt;&gt;(this);</span><br></pre></td></tr></table></figure>
<p>可以看出，这个result，其实就是通过将接口的方法进行整合，最后生成的一个结果。这个结果和方法共同被存储下来</p>
<p><strong>切记，这里并没有缓存response，缓存的是result，result是对method的一个处理结果，调用的其实是rxjava2factory和gsonconvertfactory来配合处理的</strong></p>
<h2 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程"></a>请求过程</h2><p>由于之前传入了ExecutorCallAdapterFactory，此时一个retrofit的实例在app中也已经获取了。之后就看如何使用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;String&gt; resp = webService.logoutRaw().execute();</span><br></pre></td></tr></table></figure>
<p>执行execute就可以获取到了response。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Synchronously send the request and return its response.</span><br><span class="line">   *</span><br><span class="line">   * @throws IOException if a problem occurred talking to the server.</span><br><span class="line">   * @throws RuntimeException (and subclasses) if an unexpected error occurs creating the request</span><br><span class="line">   * or decoding the response.</span><br><span class="line">   */</span><br><span class="line">  Response&lt;T&gt; execute() throws IOException;</span><br></pre></td></tr></table></figure>
<p>这个方法是在retrofit的call.java类中，实现是在ExecutorCallbackCall中，具体是操作了一个okhttpcall</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line">    final Executor callbackExecutor;</span><br><span class="line">    final Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">      this.callbackExecutor = callbackExecutor;</span><br><span class="line">      this.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</span><br><span class="line">      checkNotNull(callback, &quot;callback == null&quot;);</span><br><span class="line"></span><br><span class="line">      delegate.enqueue(new Callback&lt;T&gt;() &#123;</span><br><span class="line">        @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</span><br><span class="line">          callbackExecutor.execute(new Runnable() &#123;</span><br><span class="line">            @Override public void run() &#123;</span><br><span class="line">              if (delegate.isCanceled()) &#123;</span><br><span class="line">                // Emulate OkHttp&apos;s behavior of throwing/delivering an IOException on cancellation.</span><br><span class="line">                callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                callback.onResponse(ExecutorCallbackCall.this, response);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;</span><br><span class="line">          callbackExecutor.execute(new Runnable() &#123;</span><br><span class="line">            @Override public void run() &#123;</span><br><span class="line">              callback.onFailure(ExecutorCallbackCall.this, t);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public boolean isExecuted() &#123;</span><br><span class="line">      return delegate.isExecuted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public Response&lt;T&gt; execute() throws IOException &#123;</span><br><span class="line">      return delegate.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void cancel() &#123;</span><br><span class="line">      delegate.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public boolean isCanceled() &#123;</span><br><span class="line">      return delegate.isCanceled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;CloneDoesntCallSuperClone&quot;) // Performing deep clone.</span><br><span class="line">    @Override public Call&lt;T&gt; clone() &#123;</span><br><span class="line">      return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, delegate.clone());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public Request request() &#123;</span><br><span class="line">      return delegate.request();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从这里看就知道是执行了callback的方法，这个callback是取自retrofit的rxadapter里面和okhttpcall的realcall中</p>
<p>反馈的细节在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">final class CallEnqueueObservable&lt;T&gt; extends Observable&lt;Response&lt;T&gt;&gt; &#123;</span><br><span class="line">  private final Call&lt;T&gt; originalCall;</span><br><span class="line"></span><br><span class="line">  CallEnqueueObservable(Call&lt;T&gt; originalCall) &#123;</span><br><span class="line">    this.originalCall = originalCall;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override protected void subscribeActual(Observer&lt;? super Response&lt;T&gt;&gt; observer) &#123;</span><br><span class="line">    // Since Call is a one-shot type, clone it for each new observer.</span><br><span class="line">    Call&lt;T&gt; call = originalCall.clone();</span><br><span class="line">    CallCallback&lt;T&gt; callback = new CallCallback&lt;&gt;(call, observer);</span><br><span class="line">    observer.onSubscribe(callback);</span><br><span class="line">    call.enqueue(callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static final class CallCallback&lt;T&gt; implements Disposable, Callback&lt;T&gt; &#123;</span><br><span class="line">    private final Call&lt;?&gt; call;</span><br><span class="line">    private final Observer&lt;? super Response&lt;T&gt;&gt; observer;</span><br><span class="line">    boolean terminated = false;</span><br><span class="line"></span><br><span class="line">    CallCallback(Call&lt;?&gt; call, Observer&lt;? super Response&lt;T&gt;&gt; observer) &#123;</span><br><span class="line">      this.call = call;</span><br><span class="line">      this.observer = observer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void onResponse(Call&lt;T&gt; call, Response&lt;T&gt; response) &#123;</span><br><span class="line">      if (call.isCanceled()) return;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">        observer.onNext(response);</span><br><span class="line"></span><br><span class="line">        if (!call.isCanceled()) &#123;</span><br><span class="line">          terminated = true;</span><br><span class="line">          observer.onComplete();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (Throwable t) &#123;</span><br><span class="line">        if (terminated) &#123;</span><br><span class="line">          RxJavaPlugins.onError(t);</span><br><span class="line">        &#125; else if (!call.isCanceled()) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            observer.onError(t);</span><br><span class="line">          &#125; catch (Throwable inner) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(inner);</span><br><span class="line">            RxJavaPlugins.onError(new CompositeException(t, inner));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void onFailure(Call&lt;T&gt; call, Throwable t) &#123;</span><br><span class="line">      if (call.isCanceled()) return;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">        observer.onError(t);</span><br><span class="line">      &#125; catch (Throwable inner) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(inner);</span><br><span class="line">        RxJavaPlugins.onError(new CompositeException(t, inner));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void dispose() &#123;</span><br><span class="line">      call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public boolean isDisposed() &#123;</span><br><span class="line">      return call.isCanceled();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这一步就能看懂了，后续的部分都是我们经常使用的地方</p>
<h2 id="处理response的部分"><a href="#处理response的部分" class="headerlink" title="处理response的部分"></a>处理response的部分</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response&lt;T&gt; execute() throws IOException &#123;</span><br><span class="line">    okhttp3.Call call;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);</span><br><span class="line">      executed = true;</span><br><span class="line"></span><br><span class="line">      if (creationFailure != null) &#123;</span><br><span class="line">        if (creationFailure instanceof IOException) &#123;</span><br><span class="line">          throw (IOException) creationFailure;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          throw (RuntimeException) creationFailure;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      call = rawCall;</span><br><span class="line">      if (call == null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          call = rawCall = createRawCall();</span><br><span class="line">        &#125; catch (IOException | RuntimeException e) &#123;</span><br><span class="line">          creationFailure = e;</span><br><span class="line">          throw e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (canceled) &#123;</span><br><span class="line">      call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return parseResponse(call.execute());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在执行的过程中返回结果的时候直接调用了gson来解析</p>
<p>到这里我看到了解析的过程，看到了执行rxjava的过程，也看到了执行okhttp的过程，理应串起来</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/android/Retrofit个人理解图.png" alt="retrofit个人理解图"></p>
<h1 id="okHTTP的设计思路"><a href="#okHTTP的设计思路" class="headerlink" title="okHTTP的设计思路"></a>okHTTP的设计思路</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先从使用看起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient.Builder builder = new OkHttpClient.Builder()</span><br><span class="line">                .connectTimeout(30, TimeUnit.SECONDS)</span><br><span class="line">                .writeTimeout(30, TimeUnit.SECONDS)</span><br><span class="line">                .readTimeout(30, TimeUnit.SECONDS)</span><br><span class="line">                .addInterceptor(chain -&gt; &#123;</span><br><span class="line">                    Request request = chain.request().newBuilder()</span><br><span class="line">                            //.addHeader(&quot;App&quot;, headerEncoded(ac.getName()))</span><br><span class="line">                            .addHeader(&quot;api_version&quot;, headerEncoded(Const.API_VERSION))</span><br><span class="line">                            .addHeader(&quot;App-Version&quot;, headerEncoded(ac.getVersion() + &quot;.&quot; + ac.getVersionCode()))</span><br><span class="line">                            .addHeader(&quot;PUSH-ENV&quot;, headerEncoded(ac.isBuildVersion() ? &quot;DEV&quot; : &quot;PRODUCT&quot;))</span><br><span class="line">                            .addHeader(&quot;Device-Id&quot;, headerEncoded(deviceInfo.getDeviceId()))</span><br><span class="line">                            .addHeader(&quot;cookie&quot;, headerEncoded(cookie))</span><br><span class="line">                            .addHeader(&quot;x-platform&quot;, &quot;android&quot;)</span><br><span class="line">                            .build();</span><br><span class="line">                    Response response = chain.proceed(request);</span><br><span class="line">                    context.getSharedPreferences(&quot;global&quot;, Context.MODE_PRIVATE).edit().putString(&quot;cookie&quot;, response.header(&quot;Set-Cookie&quot;)).apply();</span><br><span class="line">                    cookie = response.header(&quot;Set-Cookie&quot;);</span><br><span class="line">                    return response;</span><br><span class="line">                &#125;)</span><br><span class="line">                .addInterceptor(embedAccessTokenInterceptor);</span><br></pre></td></tr></table></figure>
<p>项目中的okhttp使用，首先需要build一个client，这个里面加了各种参数，读写和连接超时的参数，另外加了一些response处理链。这样一个builder就好了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">webService = new Retrofit.Builder().baseUrl(config.getHost())</span><br><span class="line">                .addConverterFactory(MyGsonConverterFactory.create(gson))</span><br><span class="line">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">                .client(builder.build())</span><br><span class="line">                .build().create(WebService.class);</span><br></pre></td></tr></table></figure>
<p>这之后就塞到retrofit里面去了。</p>
<p>因此我们先来看一下builder的过程是怎么样的，以此为一个入口</p>
<h2 id="builder"><a href="#builder" class="headerlink" title="builder"></a>builder</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public Builder() &#123;</span><br><span class="line">      dispatcher = new Dispatcher();</span><br><span class="line">      protocols = DEFAULT_PROTOCOLS;</span><br><span class="line">      connectionSpecs = DEFAULT_CONNECTION_SPECS;</span><br><span class="line">      eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line">      proxySelector = ProxySelector.getDefault();</span><br><span class="line">      cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">      socketFactory = SocketFactory.getDefault();</span><br><span class="line">      hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class="line">      certificatePinner = CertificatePinner.DEFAULT;</span><br><span class="line">      proxyAuthenticator = Authenticator.NONE;</span><br><span class="line">      authenticator = Authenticator.NONE;</span><br><span class="line">      connectionPool = new ConnectionPool();</span><br><span class="line">      dns = Dns.SYSTEM;</span><br><span class="line">      followSslRedirects = true;</span><br><span class="line">      followRedirects = true;</span><br><span class="line">      retryOnConnectionFailure = true;</span><br><span class="line">      connectTimeout = 10_000;</span><br><span class="line">      readTimeout = 10_000;</span><br><span class="line">      writeTimeout = 10_000;</span><br><span class="line">      pingInterval = 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>builder构造中加了很多很多参数，而整个builder事实上就是一个参数记录类，记录了所有的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Dispatcher dispatcher;</span><br><span class="line">@Nullable Proxy proxy;</span><br><span class="line">List&lt;Protocol&gt; protocols;</span><br><span class="line">List&lt;ConnectionSpec&gt; connectionSpecs;</span><br><span class="line">final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">final List&lt;Interceptor&gt; networkInterceptors = new ArrayList&lt;&gt;();</span><br><span class="line">EventListener.Factory eventListenerFactory;</span><br><span class="line">ProxySelector proxySelector;</span><br><span class="line">CookieJar cookieJar;</span><br><span class="line">@Nullable Cache cache;</span><br><span class="line">@Nullable InternalCache internalCache;</span><br><span class="line">SocketFactory socketFactory;</span><br><span class="line">@Nullable SSLSocketFactory sslSocketFactory;</span><br><span class="line">@Nullable CertificateChainCleaner certificateChainCleaner;</span><br><span class="line">HostnameVerifier hostnameVerifier;</span><br><span class="line">CertificatePinner certificatePinner;</span><br><span class="line">Authenticator proxyAuthenticator;</span><br><span class="line">Authenticator authenticator;</span><br><span class="line">ConnectionPool connectionPool;</span><br><span class="line">Dns dns;</span><br><span class="line">boolean followSslRedirects;</span><br><span class="line">boolean followRedirects;</span><br><span class="line">boolean retryOnConnectionFailure;</span><br><span class="line">int connectTimeout;</span><br><span class="line">int readTimeout;</span><br><span class="line">int writeTimeout;</span><br><span class="line">int pingInterval;</span><br></pre></td></tr></table></figure>
<p>这是其局部变量，基本上每个参数都是可以设置的。暂且掠过不表，因为这个都是可变的，默认的对我们来讲其实没有什么大作用。</p>
<h2 id="newCall-构建请求"><a href="#newCall-构建请求" class="headerlink" title="newCall:构建请求"></a>newCall:构建请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response response = client.newCall(request).execute();</span><br></pre></td></tr></table></figure>
<p>response封装起来之后，是这样调用的。</p>
<p>按流程捋下去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override public Call newCall(Request request) &#123;</span><br><span class="line">    return RealCall.newRealCall(this, request, false /* for web socket */);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123;</span><br><span class="line">    // Safely publish the Call instance to the EventListener.</span><br><span class="line">    RealCall call = new RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">    call.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">    return call;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从这里可以看到事实上构建了一个RealCall的端口，然后将其穿进去了一个叫client.eventListenerFactory()的接口里面，这个接口在builder初始化的时候添加的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br></pre></td></tr></table></figure>
<p>其内在并未做任何事情，仅仅算是将realcall的eventlistener做一层赋值。</p>
<h2 id="newCall-execute-：执行请求"><a href="#newCall-execute-：执行请求" class="headerlink" title="newCall.execute()：执行请求"></a>newCall.execute()：执行请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response execute() throws IOException &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">      executed = true;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    eventListener.callStart(this);</span><br><span class="line">    try &#123;</span><br><span class="line">      client.dispatcher().executed(this);</span><br><span class="line">      Response result = getResponseWithInterceptorChain();</span><br><span class="line">      if (result == null) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">      return result;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      eventListener.callFailed(this, e);</span><br><span class="line">      throw e;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      client.dispatcher().finished(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/30/2018-3-2018-12记产品死亡总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/2018-3-2018-12记产品死亡总结/" itemprop="url">2018.3-2018.12记产品死亡总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T18:59:13+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近一阵没有写工作小结。并不是不想写，其实是发生了一些没有想到的事情。</p>
<p>总而言之产品挂掉了。</p>
<p>在我们这个团队，产品每日都想的是怎么往后推进，从来没有想过之前的行为为什么有问题。而对于我们开发来讲，基本上也都是上行下效，重心总是在技术上，而不会对产品产生质疑。关于失败的总结一直都是避而不谈，开会的话语中永远都是美好的未来。其实这也是失败的一个因素。</p>
<p>我希望以我全程参与的开发者的身份，来对产品的死亡做一个总结。</p>
<h1 id="3月，开始"><a href="#3月，开始" class="headerlink" title="3月，开始"></a>3月，开始</h1><p>3月的我加入了好搭，当时项目还没有改名为好搭盒子，app的版本停留在1.9.3，当时做的是导购的模式，通过淘宝客，租赁衣服进来生成模型，然后通过提供服务给用户，通过淘宝客来获取佣金。<br>由于老模式竞争很大，需要比较多的投入才能达到比较好的传播的目的，另外在用户上面，其实在当时的传播模式在当时是很有吸引力的，但是当时的效果做的并不是很好。再加上天使轮融资成功，需要抓紧从好买衣脱离，所以仿照了国外Stitch Fix上市的盒子模式，期望能通过虚拟形象加上盒子模式，给虚拟形象带来一个有效的传播。</p>
<h1 id="4月，2-0版本上线"><a href="#4月，2-0版本上线" class="headerlink" title="4月，2.0版本上线"></a>4月，2.0版本上线</h1><p>由于以前从好买衣转来的后台，和上头吵翻了，因此上头决定新招一个后台，但是只招了一个后台。重构当时给了2周，但是到三月末还是没有好，后来又给了两周，一个月整后端接口好了。在4月中旬我们开启了app的大规模改版计划。</p>
<p>起初是加上盒子，盒子模式需要增加加盒、地址、押金、付款、订单等模块，后续又加上了会员系统，另外在商品的展示阶段，刚开始使用的是单品+合集的模式，商品结合的是medel+单品展示的。改版很大，对于我来讲就是不日不夜的加了两周班。</p>
<p>改版上线前遗留几个比较严重的问题，一个是盒子模式的本地保存和服务端保存冲突模式，服务端保存会导致加盒的模式很卡顿，加盒的过程需要验证服务器库存+操作本地盒子增加删减+push新的盒子到服务器+拉新的盒子到本地更新本地的衣服状态+本地存储新的盒子到sp。由于盒子的操作是一个很高频的模式，但是操作盒子带来的网络操作以及本地操作，当时验证需要大约400ms，而一次增加就会带来400ms的卡顿感，其实对用户来讲是十分不友好的。</p>
<p>由于着急上线，盒子的模式就被直接忽略而直接在4月30号上线了。</p>
<p>从现在的角度来看，当时如果能多用2天的时间，将整个盒子的模式改变一下，应该就不会有2.0版本评分从4.3掉到3.0的问题了。市场对2.0版本最大的评价就是卡。</p>
<h1 id="5月-正式由好搭虚拟试衣变更为好搭盒子"><a href="#5月-正式由好搭虚拟试衣变更为好搭盒子" class="headerlink" title="5月,正式由好搭虚拟试衣变更为好搭盒子"></a>5月,正式由好搭虚拟试衣变更为好搭盒子</h1><p>5月的产品计划是增加了芝麻信用免押金、加入了人工客服、增加了引导页面，同时对于订单模块进行了较大规模的优化。</p>
<p>这个版本是正式更名为好搭盒子，同时也进行了一定规模的投放。由于客户量增加导致暴露出了一个问题，就是由于信用免押金用户开始通过免押金进行订盒子，然后却不购买不退盒子。针对这个问题，当时唯一的号称“联系芝麻信用进行处罚”的措施，只有打电话追着用户。其实押金模式被ofo搞得臭名昭著，而不用押金，对我们这种小型公司，很难说控制用户的诚信度。我并不知道出问题的人的数量，但是我当时和产品沟通的时候，间接了解到了违规的人数其实不少。</p>
<p>说实话小公司在扩大市场这一方面真的难，像衣盒这些，通过强制要求用户提交几百块的押金，然后还有钱进行市场投放，这样用户规模就算增长不快，起码不会出现这种大规模违规的现象。然而我们公司无法这样，如果加了押金一定会导致用户抵抗情绪上升，因此也会导致用户接受能力降低。不得已才采用免押的模式，然而没想到这个模式这么快就被打脸了。</p>
<p>另外这个版本的商品展示，是机械的随机展示，权重并没有按照用户的喜好来。下拉过程中大概率出现是重复的商品。不过这个版本我将盒子的模式完全更改为内存存储的方式，优化掉了卡顿的问题。</p>
<p>这个版本的评价不再是卡卡卡，而是商品数目不够，想买的一下子就没了。</p>
<h1 id="6月，app由简陋转变为精致"><a href="#6月，app由简陋转变为精致" class="headerlink" title="6月，app由简陋转变为精致"></a>6月，app由简陋转变为精致</h1><p>整个六月，在连续更换2位ui之后，我们终于定下了ui的风格，并以此将页面逐个更新为新的风格。同时增加了专题和图文专题作为商品的展示模式。</p>
<p>整个六月只发了一个版本，但是针对这个版本提交了300多笔。不过ui定稿总算是完成了，大家都很开心，风格的统一应该会带来用户的提升。</p>
<p>至少当时都是这么想的。</p>
<p>但是发出去之后，6月的数据并不是很好看，至少没有达到想象的那种程度。一方面是因为数据量上去了，但是货品并没有上去，二来是仓库物流erp系统有些问题，造成了比较多的延迟发货问题。当时在确认订货的时候，并不支持取消订单，大量用户操作失误寄出了盒子，但是并不想要，好的人直接退了，不好的就不管，或者收到了衣服拿出来。主打的学生人群感觉更容易出现这种情况，反正是造成了数据并不好看。</p>
<p>6月出了一场比较严重的事故，由于在首页使用fragmentPageAdapter并且没有将缓存数据处理，导致app的内存在首页被消耗太多，因此导致了app极度卡顿。记忆中这个版本的anr达到了10%。事实上当时在测试的过程中就已经发现了这个问题，但是由于需要着急发版。每次卡着时间必须在周五发版，导致改版问题只看数量不看质量，这种质量事故其实很严重，但是产品很着急，老板很着急，开发很疲惫，测试很疲惫。</p>
<p>说实话其实对于小型开发公司来讲，讲究质量是一件很不靠谱的事情，在质量做上来之前，说不定市场就转向了。我们要求是周一给任务，周二出图和接口，周三周四开始做，周五提测测试完毕。如果周五提测不行，周六就加班，最迟最迟是周六提版本。这种进度在一般时候其实是ok的，但是在大改动的时候，尤其是ui改了2周才给设计稿的时候，第三周要求我们弄出来，就会导致这种情况发生。</p>
<p>当时我想了很多，发现其实无解，我们在提高自身效率，提升代码质量的时候，绝大部分时间都是在业务上面，而这种架构方面的问题真的很难发现并处理。很蛋疼。另外就是这种问题需要依赖测试的问题，在我们开发任务结束，开始进行bug修补的时候，这时候应该关注性能方面，然而没办法，这个时候都是和产品测试确定bug以及修改bug。这种性能优化的问题，每次都只能在发版之后，只有任务但是并没有接口和设计图的周一。于是乎我们因此发布了很多hotfix版本。</p>
<h1 id="7月，app增加了很多实用的功能"><a href="#7月，app增加了很多实用的功能" class="headerlink" title="7月，app增加了很多实用的功能"></a>7月，app增加了很多实用的功能</h1><p>首先是增加的功能，这个版本增加了收藏单品、2件打包、商品状态、匿名状态使用等功能。基本上每个都是在痛点上面的设计。另外移除了强制登陆的逻辑，这个也是痛点。</p>
<p>这个版本的主要改动还是针对用户在使用产品的阶段遇到的问题。以前的用户由于刚开始使用，需要强制登陆，强制设置medel，成本比较高，这样会造成用户第一次使用成本过大，另外由于之前无法收藏，导致用户看到想要的不小心刷新之后再也没办法回到原来的状态，2件打包也是为了让用户更方便的打包盒子。整个设计的逻辑这个月都很简单明了，就是为了增加寄盒率。</p>
<p>这个月我们的盒子也突破了1000个/月。app的uv也突破了1w。</p>
<h1 id="8月，人脸升级"><a href="#8月，人脸升级" class="headerlink" title="8月，人脸升级"></a>8月，人脸升级</h1><p>8月是融资之前的一个月，这个月紧锣密鼓的进行了很多的事情。具体在我8月份的git基本上没有任何提交就可以看出来。我们把ux完完整整的优化了一遍，同时将人脸也进行了一次升级作为一次融资的噱头。整个ux的优化持续了一个月，这次优化的细节主要体现在订单流程上面，订单流程增加了很多状态，同时对于用户退货的流程做了很大规模的退货。主要的初心我个人猜测就是因为之前退货的流程太过突兀，用户一来可能看不到退货的入口，二来退货过程中细节不好，导致用户可能不一定在这个页面会进行下去。</p>
<p>总之这一版主要功能还是为了保障以购用户退货的过程能够顺畅而做出的优化，另外人脸识别算法部门提供了一个v2的版本，这个版本主要是将人脸从建模变成抠图，看起来仿佛是更好了。</p>
<p>另外这个月是融资之前的一个月，8月末就正式启动了融资。</p>
<h1 id="9月，数据爆炸"><a href="#9月，数据爆炸" class="headerlink" title="9月，数据爆炸"></a>9月，数据爆炸</h1><p>9月份市场做了很多推广的努力，外加运营部门做了一些调整，优化了搜索引擎，导致app那一阵用户量猛增，由平时的1万ui猛升到了8wuv，当时在appstore排行榜还占到了最热区域。但是服务器重建人脸的效率实在是太慢了，重建队列很多都是堵死状态，我们太依赖好买衣导致他们的缺点在我们这边无限的暴露。而且这个月好买衣的后端leader跑路，前端leader跑路，走之前特地嘱咐了我们服务器的问题。但是当时我们这边重心没有放在这个上面，服务器出现人脸丢失，黑脸，没头，还有没头发的问题，在之后的几个月基本上是无限爆出，我们这边后端压根不涉及这些，核心竞争力没法把握好，导致后续在后端的稳定性上面吃了大亏。</p>
<p>不过9月是进入好搭之后感觉最兴奋的一个月，这一个月数据不断的刷新，让人感觉8月的加班是有意义的，而且这个月的盒子数也顺利的从之前的几百个，突破到了2000+个，至少对我们来讲，这一阶段的里程碑是达成了。</p>
<h1 id="10月，a轮找到金主"><a href="#10月，a轮找到金主" class="headerlink" title="10月，a轮找到金主"></a>10月，a轮找到金主</h1><p>10月由于是国庆节，外加母亲动手术，我大约半个月没有工作，这个月最繁忙的一周是a轮找到了金主之后的一周，投资人对我们提出了很多的要求，数据当时比较中庸，主要是加盒率和购买复购率比较低，而盒子数量和使用用户则比较好看。当时产品那边的想法是提高会员数量，这样可以使的会员转化率增加，会员的表现一直有比较高的复购和加盒转化率。</p>
<p>当时介于商品本来缺货断码就比较严重，因此开辟了一个会员专区，专门提供给会员特供的商品。这个版本上去之后的数据并没有显示，但是uv开始逐渐的降低了，十月份到最后的时候，我记得uv从2万掉到了1万2左右。</p>
<h1 id="11月，强制用户登陆"><a href="#11月，强制用户登陆" class="headerlink" title="11月，强制用户登陆"></a>11月，强制用户登陆</h1><p>由于之前将强制登陆和设计medel的步骤给去掉了，导致很多用户在很低的时间成本下，反复叫盒子，然后不够买不寄回，这样导致很多衣服被薅羊毛薅走了。这个现象持续了好几个月，但是这个月开始对这个现象做处理。</p>
<p>我们将新的强制登陆逻辑加上，为此付出了2周的开发周期，并且还delay了一次。但是中途也遇到了很多的问题，问题主要展现在关于medel的接口我们这边不是很了解，需要和好买衣沟通，另外就是服务器不稳定，导致线上环境建模总是失败，导致这样的强制引导很容易出现劝退现象。不过为了能够将羊毛党拒之门外，貌似我们在信用体系下可以做的也就是这样了。</p>
<h1 id="12月，融资失败"><a href="#12月，融资失败" class="headerlink" title="12月，融资失败"></a>12月，融资失败</h1><p>到了12月，仿佛寒冬一下子来临了，各处裁员。</p>
<p>刚开始以为融资都进入ts了，应该可以稳定，结果还是没躲过，12号的时候说投资人因为一些问题准备不投了，这就很蛋疼了，毕竟已经等了超过一个月的ts了，最后说不投，基本上就是断炊了。然后ceo去跑了一趟，回来之后说又融到了。但是比较神奇的是开始要求我们砍业务。砍掉盒子模式。</p>
<p>很奇怪，融到了为什么要砍。结果吃饭的时候技术leader说其实并没有融到，ceo只是不想说而已。砍业务是因为吃不消损耗了，每个盒子都是亏的，用户热情还很高，这样钱吃不消使用。</p>
<p>于是连我们12月在做的功能都连根拔掉了，砍掉了订单，盒子，支付，会员等等，最后要接上淘宝客，等于我们的版本绕了一圈，回到了1.9.3的版本了。</p>
<p>哎。这样子，我们的好搭盒子就彻彻底底的死了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从开发者客观来讲，对这个产品是有感情的，当我来的时候，安卓组那个人准备离职，我在2个月的时间里面独自支撑着并不熟悉的项目。</p>
<p>加班加点在好搭仿佛都是家常便饭，年中的时候统计了一下已经累计了10天的调休。</p>
<p>可是有什么用呢？开发者仅仅是一把刀子，这个刀子或许锋利，或许迟钝，但是如果将锋利的刀子不断砍伐一些无用的东西，这有什么意义呢？</p>
<p>刚开始的时候说我们暂时不需要考虑基础建设的问题，后端，前端，移动端，都是走一步看一步。后期发现基础建设出了问题的时候，却又浪费了大批量的时间来重构。创业公司感觉永远逃离不了这个魔咒。</p>
<p>当听到一直维护的项目突然被砍掉，转成别的项目的时候。心里只有一声叹息。</p>
<h1 id="问题出在哪里？"><a href="#问题出在哪里？" class="headerlink" title="问题出在哪里？"></a>问题出在哪里？</h1><p>最近一直在想，leader离职的时候说过一句话，“论盒子模式，我们绝对是数据跑的好的”，但是为什么落的如此下场？</p>
<h2 id="信用模式"><a href="#信用模式" class="headerlink" title="信用模式"></a>信用模式</h2><p>盒子模式首先将衣服寄到了用户手里，然后让用户选择购买或者退回。这中间给了用户极大的自由，前期我们尚且能通过小规模投放来控制风险，后期接入了小红书推广，导致大量学生涌入，很多人仿佛占到了便宜似的拼命下盒子，下完了拿到货不退不购买，导致大量订单逾期坏单。造成了巨量的成本亏损。</p>
<h2 id="商品量不足"><a href="#商品量不足" class="headerlink" title="商品量不足"></a>商品量不足</h2><p>由于是商城模式的app，对商品量的把控一定要比较高，但是从数据上来看，常年缺码SPU高达40%，造成了好衣服没货，坏衣服卖不出去的问题。加上前期并没有做好消息推送这个环节，对缺货商品的订阅上的过慢，也导致了大量用户的流失现象。</p>
<h2 id="medel不够稳定"><a href="#medel不够稳定" class="headerlink" title="medel不够稳定"></a>medel不够稳定</h2><p>medel不够稳定是一直存在的问题，首先渲染消耗太多，最高每日光服务器就要跑掉2w块。其次是就算这样仍然不够稳定，不清楚是算法还是好买衣的问题，总是出现光头，绘制失败，没脸的问题。这个问题其实很严重，特别是我们这种主打虚拟试衣模式的app，基本上就是断腿了。</p>
<p>这个问题其实是有解的，开始的时候就可以选择重构那边的代码。但是怎么讲呢，兵熊熊一个，将熊熊一窝，关于这个问题从我入职的时候每次会议必谈，直到leader来了之后禁止我们开会讨论这个。从开始leader就没有想重构，他或许想的是在半年内我们可以拿到a轮融资，之后可以选择完整的重构，或者是想着干脆就不重构了，等着别人来</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/30/二路归并排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/二路归并排序/" itemprop="url">二路归并排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T16:30:42+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>利用递归，将原始序列不断两两分块，直到每块剩下一个元素，这个元素肯定是有序的。然后利用递归的原理合并即可</p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>空间复杂度应该从拆分上面来看，第一次拆分是1块拆成2快，第二次是2块拆成4块，第三次是4块拆成8块…第n次就是2^(n-1)拆成2^(n)块，总和应该是2^0+2^1+2^2…+2^n为O(n)</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>O(nlgn)</p>
<p>每层需要合并的总数为n，一共有logn层，故为nlogn</p>
<h1 id="算法实现思想"><a href="#算法实现思想" class="headerlink" title="算法实现思想"></a>算法实现思想</h1><p>首先使用类似于后序遍历的方式，将数组不断的分割，最后在进行归并。</p>
<p>归并的过程是：使用三根指针，第一根指向第一个子表首位元素，第二根指向第一个子表末尾元素，最后一根指向第二个子表末尾元素元素。<br>在确保第一根位置小于第二根，第二根+1小于第三根的情况下，不断比较第一根和第二根的大小并做相应的替换，替换完毕之后2根指针同时++,直到第一根指针到达左侧最末尾或者第二根指针到达第三根指针位置，即可中断。</p>
<h1 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private static void mergeSort(int[] arr) &#123;</span><br><span class="line">       mergeSort(arr, new int[arr.length], 0, arr.length - 1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static void mergeSort(int[] arr, int[] temp, int left, int right) &#123;</span><br><span class="line">       if (left &lt; right) &#123;</span><br><span class="line">           int center = (left + right) / 2;</span><br><span class="line">           mergeSort(arr, temp, left, center); // 左边</span><br><span class="line">           mergeSort(arr, temp, center + 1, right); // 右边</span><br><span class="line">           merge(arr, temp, left, center + 1, right); // 合并两个有序 ett</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static void merge(int[] arr, int[] temp, int leftPos, int rightPos, int rightEnd) &#123;</span><br><span class="line">       int leftEnd = rightPos - 1; // 左边结束下标</span><br><span class="line">       int tempPos = leftPos; // 从左边开始算</span><br><span class="line">       int numEle = rightEnd - leftPos + 1; // 元素个数</span><br><span class="line">       while (leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd) &#123;</span><br><span class="line">           if (arr[leftPos] &lt;= arr[rightPos])</span><br><span class="line">           	//通过一个临时数组做存储，这样不需要使用temp对象做临时存储做转换，而是直接从最小的区块开始拷贝进去</span><br><span class="line">               temp[tempPos++] = arr[leftPos++];</span><br><span class="line">           else</span><br><span class="line">               temp[tempPos++] = arr[rightPos++];</span><br><span class="line">       &#125;</span><br><span class="line">       while (leftPos &lt;= leftEnd) &#123;  // 左边如果有剩余</span><br><span class="line">           temp[tempPos++] = arr[leftPos++];</span><br><span class="line">       &#125;</span><br><span class="line">       while (rightPos &lt;= rightEnd) &#123; // 右边如果有剩余</span><br><span class="line">           temp[tempPos++] = arr[rightPos++];</span><br><span class="line">       &#125;</span><br><span class="line">       // 最后一步进行复制，复制的只有更改的几个数字</span><br><span class="line">       for (int i = 0; i &lt; numEle; i++) &#123;</span><br><span class="line">           arr[rightEnd] = temp[rightEnd];</span><br><span class="line">           rightEnd--;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="c实现"><a href="#c实现" class="headerlink" title="c实现"></a>c实现</h1><h1 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sample</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">120</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sample</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
