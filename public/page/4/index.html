<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="记录者">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="记录者">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="记录者">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/"/>





  <title>记录者</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">记录者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/08/js语法学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/08/js语法学习/" itemprop="url">js语法学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-08T10:50:54+08:00">
                2018-02-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今年过年一周时间需要用来充电，目前目标就是啃一下<javascript dom编程艺术="">这本书。</javascript></p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ol>
<li>语句</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first statement</span><br><span class="line">second statement</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first statement; second statement;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first statement;</span><br><span class="line">second statement;</span><br></pre></td></tr></table></figure>
<p>以上三种都是可行的。</p>
<ol>
<li>注释</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 这可以代表一行注释</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这可以代表多行注释第一行 </span><br><span class="line">// 这可代表多行注释第二行</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* 多行注释</span><br><span class="line">	第二种写法*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- html风格注释，功能等同于//，不推荐使用，不需要使用html的--&gt;结尾</span><br></pre></td></tr></table></figure>
<ol>
<li>变量</li>
</ol>
<p>javascript是一个弱类型语言</p>
<p>变量声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var mood;</span><br><span class="line">var age;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var mood, age;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var mood = &quot;happy&quot;;</span><br><span class="line">var age = 33;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var mood = &quot;happy&quot;, age = 33;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var mood, age;</span><br><span class="line">mood = &quot;happy&quot;;</span><br><span class="line">age = 33;</span><br></pre></td></tr></table></figure>
<p>以上声明都可以。js区分大小写。</p>
<p>变量命名不允许包含空格或者标点符号，可以在适当的地方插入下划线。美元符号也可以。<br>也可以使用驼峰格式</p>
<ol>
<li>数据类型</li>
</ol>
<p>javascript是弱类型语言，可以在任何阶段改变变量的数据类型。</p>
<ul>
<li>字符串</li>
</ul>
<p>字符串由0个或者多个字符构成，字符包括不限于字母、数字、标点符号和空格。字符必须包在引号里面，单引号或者双引号都可以。<br>可以随意选用引号，单最好根据字符串所包含的字符来选择，如果字符串包含双引号，就将字符放入单引号里面。</p>
<p>字符的转义也是和java一样的使用\符号</p>
<ul>
<li>数值</li>
</ul>
<p>javascript允许使用带小数点的数值，并且允许任意位小数，这样的数称为浮点数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var age = 33.35;</span><br></pre></td></tr></table></figure>
<ul>
<li>布尔值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sleeping = true;</span><br></pre></td></tr></table></figure>
<ol>
<li>数组</li>
</ol>
<p>可以声明带长度的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var beatles = Array(4);</span><br></pre></td></tr></table></figure></p>
<p>也可以声明不带长度的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var beatles = Array();</span><br></pre></td></tr></table></figure></p>
<p>数据填充方式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array[index] = element;</span><br></pre></td></tr></table></figure></p>
<p>也可以声明的时候赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var beatles = Array(&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;);</span><br></pre></td></tr></table></figure></p>
<p>也可以不明确声明数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var beatles = [&apos;John&apos;, &apos;Paul&apos;, &apos;George&apos;, &apos;Ringo&apos;];</span><br></pre></td></tr></table></figure></p>
<p>数组使用方式较为灵活，可以使用变量添加数组，数组数据类型可以不固定，还可以数组中包含其他数组。</p>
<p>关联数组类似于key2value的pojo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var lennon = Array();</span><br><span class="line">lennon[&quot;name&quot;] = &quot;John&quot;;</span><br><span class="line">lennon[&quot;year&quot;] = 1940;</span><br><span class="line">lennon[&quot;living&quot;] = false;</span><br></pre></td></tr></table></figure>
<p>并不推荐使用。可以直接使用object</p>
<ol>
<li>对象</li>
</ol>
<p>对象也是使用一个名字表示一组值。对象的每个值都是对象的一个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var lennon = Object();</span><br><span class="line">lennon.name = &quot;John&quot;;</span><br><span class="line">lennon.year = 1940;</span><br><span class="line">lennon.living = false;</span><br></pre></td></tr></table></figure>
<p>或者使用一种更简洁的“花括号语法”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var lennon = &#123;name:&quot;John&quot;, year:1940, living:false&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>需要多次使用同一段代码，可以把他们封装成一个函数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function multiply(num1, num2)&#123;</span><br><span class="line">	var total = num1 * num2;</span><br><span class="line">	alert(total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function convertToCelsius(temp)&#123;</span><br><span class="line">	var result = temp - 32;</span><br><span class="line">	result = result/1.8;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>javascript里面，属性和方法都使用“点”语法来访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var jeremy = new Person;</span><br><span class="line">alert(jeremy.age);</span><br><span class="line">alert(jeremy.mood);</span><br></pre></td></tr></table></figure>
<ul>
<li>内建对象</li>
</ul>
<p>内建对象是在new的时候就会自动创建的内在对象，比如说new出一个array，就自带了length对象。</p>
<ul>
<li>宿主对象</li>
</ul>
<p>javascript脚本里面可以使用一些已经预先定义好的其他对象，这些对象不是由javascript语言本身而是由它的运行环境提供的。具体到web里面，这个环境就是浏览器，由浏览器提供的预定义对象被称为宿主对象。</p>
<h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><ul>
<li>getElementById</li>
</ul>
<p>DOM提供了一个名为getElementById的方法，这个方法将返回一个与那个有着给定id属性值的元素节点对应的对象</p>
<ul>
<li>getElementsByTagName</li>
</ul>
<p>该方法返回一个对象数组，每个对象分别对应着文档里有着给定标签的一个元素</p>
<ul>
<li>getElementsByClassName</li>
</ul>
<p>这个方法能够通过class来访问元素，返回一个具有相同类名的元素组。但是该方法需要较新的浏览器才可以使用，否则就要自己实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function getElementsByClassName(node, classname)&#123;</span><br><span class="line">	if(node.getElementsByClassName)&#123;</span><br><span class="line">		return node.getElementsByClassName(classname);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		var results = new Array();</span><br><span class="line">		var elems = node.getElementsByTagName(&quot;*&quot;);</span><br><span class="line">		for (var i = 0; i &lt; elems.length; i++)&#123;</span><br><span class="line">			if(elems[i].className.indexOf(classname) != -1)&#123;</span><br><span class="line">				results[results.length] = elems[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return results;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>getAttribute</li>
</ul>
<p>getAttribute是一个函数，它只有一个参数，打算查询的属性的姓名，getAttribute()方法不属于document对象，所以不能通过document对象调用，只能通过元素节点对象调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var paras = document.getElementsByTagName(&quot;p&quot;);</span><br><span class="line">for(var i = 0; i &lt; paras.length; i++)&#123;</span><br><span class="line">	alert(paras[i].getAttribute(&quot;title&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>setAttribute</li>
</ul>
<p>setAttribute允许对节点值进行修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var shopping = document.getElementById(&quot;purchases&quot;);</span><br><span class="line">shopping.setAttribute(&quot;title&quot;, &quot;a list of goods&quot;);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/06/2018第五周工作小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/06/2018第五周工作小结/" itemprop="url">2018第五周工作小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-06T21:16:49+08:00">
                2018-02-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上周忘了写工作小结了。</p>
<p>上周由于感冒发烧请假看病，导致工作效率十分低下。</p>
<p>之前listview卡在了动画效果之上，当时需要对新的信息做一个动画插入的效果，由于listview本身没有这方面的api，假如将动画移到getview中进行的话，会导致每次getview的时候触发动画，而假如不使用listview，使用动态添加view的话，会失去缓存层，导致卡顿。</p>
<p>之后想的是使用recyclerview自带的defaultanimation，不过使用这个需要做一些调整，也就是将新的消息切割开来，然后第一次加载是全部加载，之后的加载就是只加载新的。</p>
<p>这个牵扯到了一个关于ArrayList的contains方法，了解之后重写了一下equals方法即可。</p>
<p>上周就做了这些工作，很惭愧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/06/Android基础知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/06/Android基础知识点/" itemprop="url">Android基础知识点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-06T18:49:15+08:00">
                2018-02-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>为什么建议只使用默认的构造方法来创建 Fragment？</li>
</ul>
<p>之所以建议只使用默认的构造方式来创建fragment，是为了避免构造的过程中进行数据的设置。我们在oncreate和oncreateview的过程中可以获取bundle，这个bundle在存储fragment的时候同样可以被存储，而假如构造的模式进行设置参数的话，这些值就不会被系统存储。并且fragment的创建，其实是由fragmentmanager来初始化的，其初始化过程依靠了反射，并且是无参数反射，因此若不使用默认的构造的话会直接编译报错。</p>
<ul>
<li>为什么 Bundle 被用来传递数据，为什么不能使用简单的 Map 数据结构？</li>
</ul>
<p>Bundle内部是由ArrayMap实现的，ArrayMap的内部实现是两个数组，一个int数组是存储对象数据对应下标，一个对象数组保存key和value，内部使用二分法对key进行排序，所以在添加、删除、查找数据的时候，都会使用二分法查找，只适合于小数据量操作，如果在数据量比较大的情况下，那么它的性能将退化。而HashMap内部则是数组+链表结构，所以在数据量较少的时候，HashMap的Entry Array比ArrayMap占用更多的内存。因为使用Bundle的场景大多数为小数据量，我没见过在两个Activity之间传递10个以上数据的场景，所以相比之下，在这种情况下使用ArrayMap保存数据，在操作速度和内存占用上都具有优势，因此使用Bundle来传递数据，可以保证更快的速度和更少的内存占用。<br>另外一个原因，则是在Android中如果使用Intent来携带数据的话，需要数据是基本类型或者是可序列化类型，HashMap使用Serializable进行序列化，而Bundle则是使用Parcelable进行序列化。而在Android平台中，更推荐使用Parcelable实现序列化，虽然写法复杂，但是开销更小，所以为了更加快速的进行数据的序列化和反序列化，系统封装了Bundle类，方便我们进行数据的传输。</p>
<ul>
<li>什么是 JobScheduler ？</li>
</ul>
<p>jobscheduler提供了一种不同于alarmmanager的唤醒app的方式，其主要工作场景：应用具有您可以推迟的非面向用户的工作。/应用具有当插入设备时您希望优先执行的工作。/应用具有需要访问网络或 Wi-Fi 连接的任务。/应用具有您希望作为一个批次定期运行的许多任务。</p>
<ul>
<li>什么是 ANR ？如何避免发生 ANR ？</li>
</ul>
<p>ANR = application not response</p>
<p>anr一般有三种类型：<br>KeyDispatchTimeout(5 seconds) –主要类型按键或触摸事件在特定时间内无响应；<br>BroadcastTimeout(10 seconds) –BroadcastReceiver在特定时间内无法处理完成；<br>ServiceTimeout(20 seconds) –小概率类型 Service在特定的时间内无法处理完成</p>
<p>避免的方法：</p>
<p>UI线程尽量只做跟UI相关的工作<br>耗时的工作（比如数据库操作，I/O，连接网络或者别的有可能阻碍UI线程的操作）把它放入单独的线程处理<br>尽量用Handler来处理UIthread和别的thread之间的交互</p>
<p>措施：</p>
<p>首先分析log<br>从trace.txt文件查看调用stack.<br>看代码<br>仔细查看ANR的成因（iowait?block?memoryleak?）</p>
<ul>
<li>解释一下 broadcast 和 intent 在 app 内传递消息的工作流程。</li>
</ul>
<p>广播的注册过程 ：最终在ActivityManagerService中将远程的InnerInnerReceiver以及Intent－filter对象存储起来。<br>广播的发送以及接受：内部会首先根据传入的Intent－filter 查找出匹配的广播接受者，并将改接受者放到BroadcastQueue中，紧接着系统会遍历ArrayList中的广播，并将其发送给它们对应的广播接受者，最后调用到广播接受者的onReceiver方法。</p>
<p>Intent传递消息过程：intent在putextra的过程中将消息放入bundle中，bundle由于实现了parcel接口，故可以进行ipc通信，最后通过目标activity从parcel中恢复状态信息，这里面的parcel完成了数据的序列化传输。</p>
<ul>
<li>当 Bitmap 占用较多内存时，你是怎么处理的？</li>
</ul>
<p>由于内存管理上将外部内存完全当成了当前堆的一部分，也就是说Bitmap对象通过栈上的引用来指向堆上的Bitmap对象，而堆上的Bitmap对象又对应了一个使用了外部存储的native图像，也就是实际上使用的字节数组byte[]来存储的位图信息，因此解码之后的Bitmap的总大小就不能超过8M了。</p>
<p>设置系统的最小堆大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int newSize = 4 * 1024 * 1024 ; //设置最小堆内存大小为4MB  </span><br><span class="line">VMRuntime.getRuntime().setMinimumHeapSize(newSize);  </span><br><span class="line">VMRuntime.getRuntime().setTargetHeapUtilization(0.75); // 设置堆内存的利用率为75%</span><br></pre></td></tr></table></figure></p>
<p>对图片的大小进行控制:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.Options options = new BitmapFactory.Options();  </span><br><span class="line">options.inSampleSize = 2; //图片宽高都为原来的二分之一，即图片为原来的四分之一  </span><br><span class="line">Bitmap bitmap = BitmapFactory.decodeFile(&quot;/mnt/sdcard/a.jpg&quot;,options);</span><br></pre></td></tr></table></figure></p>
<p>对bitmapfactory解码的参数进行设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.Options options = new BitmapFactory.Options();  </span><br><span class="line">options.inTempStorage = new byte[1024*1024*5]; //5MB的临时存储空间  </span><br><span class="line">Bitmap bm = BitmapFactory.decodeFile(&quot;/mnt/sdcard/a.jpg&quot;,options);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>什么是 Dalvik 虚拟机？</li>
</ul>
<p>每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。<br>dalvik虚拟机使用dex文件的java文件格式，class文件中会附带着不少额外信息，dex文件对其进行精简，将所有的class文件整合一起，减少了文件尺寸和io操作的同时也提高了类的加载速度。</p>
<p>每一个应用都运行在一个dalvik虚拟机里面，而每一个虚拟机都有一个独立的进程空间</p>
<ul>
<li>什么是 Sticky Intent？</li>
</ul>
<p>在MainActivity里面会有sendBroadcast和sendStickyBroacat.在ReceverActivity里面通 过BroadcastReceiver来接收这两个消息，在ReceiverActivity里是通过代码来注册Recevier而不是在 Manifest里面注册的。所以通过sendBroadcast中发出的intent在ReceverActivity不处于onResume状态是无 法接受到的，即使后面再次使其处于该状态也无法接受到。而sendStickyBroadcast发出的Intent当ReceverActivity重 新处于onResume状态之后就能重新接受到其Intent.这就是the Intent will be held to be re-broadcast to future receivers这句话的表现。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Recevier处于活跃的 时候，又会接受到它。</p>
<ul>
<li>Android 的权限有多少个不同的保护等级？</li>
</ul>
<p>四种，normal，dangerous，signature，signatureOrSystem</p>
<p>普通权限 会在App安装期间被默认赋予。这类权限不需要开发人员进行额外操作。</p>
<p>危险权限是在开发6.0程序时，必须要注意的。这些权限处理不好，程序可能会直接被系统干掉。危险权限以组进行划分，对该组内的一个权限授权视为对整个组进行授权，但是对开发来讲，仍然需要正对每个需要的权限进行获取，否则后期版本的变更会导致权限组划分更改。</p>
<p>签名级别权限和系统签名级别权限需要拥有platform级别的认证才能申请。</p>
<ul>
<li>在转屏时你如何保存 Activity 的状态？</li>
</ul>
<p>不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次</p>
<p>设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次</p>
<p>设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</p>
<p>但是，自从Android 3.2（API 13），在设置Activity的android:configChanges=”orientation|keyboardHidden”后，还是一样会重新调用各个生命周期的。因为screen size也开始跟着设备的横竖切换而改变。所以，在AndroidManifest.xml里设置的MiniSdkVersion和 TargetSdkVersion属性大于等于13的情况下，如果你想阻止程序在运行时重新加载Activity，除了设置”orientation”，你还必须设置”ScreenSize”。<br>解决方法：</p>
<p>AndroidManifest.xml中设置android:configChanges=”orientation|screenSize”</p>
<ul>
<li>如何实现 XML 命名空间？</li>
</ul>
<p>常见命名空间<br>android：xmlns:android=”<a href="http://schemas.android.com/apk/res/android”" target="_blank" rel="noopener">http://schemas.android.com/apk/res/android”</a><br>解析：xmlns:即xml namespace，声明我们要开始定义一个命名空间了<br>android：称作namespace-prefix，它是命名空间的名字<br><a href="http://schemas.android.com/apk/res/android：这看起来是一个URL，但是这个地址是不可访问的。实际上这是一个URI(统一资源标识符),所以它的值是固定不变的,相当于一个常量)。" target="_blank" rel="noopener">http://schemas.android.com/apk/res/android：这看起来是一个URL，但是这个地址是不可访问的。实际上这是一个URI(统一资源标识符),所以它的值是固定不变的,相当于一个常量)。</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">   android:layout_width=&quot;match_parent&quot;</span><br><span class="line">   android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">   &lt;TextView</span><br><span class="line">       android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">       android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">       android:layout_gravity=&quot;center&quot;</span><br><span class="line">       android:text=&quot;New Text&quot;</span><br><span class="line">       android:id=&quot;@+id/textView&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<p>亦可以写成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:myns=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">   myns:layout_width=&quot;match_parent&quot;</span><br><span class="line">   myns:layout_height=&quot;match_parent&quot; &gt;</span><br><span class="line">   &lt;TextView</span><br><span class="line">       myns:layout_width=&quot;wrap_content&quot;</span><br><span class="line">       myns:layout_height=&quot;wrap_content&quot;</span><br><span class="line">       myns:layout_gravity=&quot;center&quot;</span><br><span class="line">       myns:text=&quot;New Text&quot;</span><br><span class="line">       myns:id=&quot;@+id/textView&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<p>tools:xmlns:tools=”<a href="http://schemas.android.com/tools”" target="_blank" rel="noopener">http://schemas.android.com/tools”</a></p>
<p>tools只作用于开发阶段<br>我们可以把他理解为一个工具(tools)的命名空间,它的只作用于开发阶段,当app被打包时,所有关于tools属性将都会被摒弃掉！</p>
<p>tools:context开发中查看Activity布局效果<br>context的用法，在后面跟一个Activtiy的完整包名,它有什么作用呢?</p>
<p>当我们设置一个Activity主题时,是在AndroidManifest.xml中设置中,而主题的效果又只能在运行后在Activtiy中显示</p>
<p>使用context属性, 可以在开发阶段中看到设置在Activity中的主题效果</p>
<p>tools:context=”com.littlehan.myapplication.MainActivity”</p>
<p>在布局中加入这行代码,就可以在design视图中看到与MainActivity绑定主题的效果。</p>
<p>tools:layout开发中查看fragment布局效果<br>当我们在Activity上加载一个fragment时，是需要在运行后才可以看到加载后的效果,有没有方法在测试阶段就在布局预览窗口上显示呢?</p>
<p>答案是有的,借助layout属性,例如,在布局中加入这样一行代码:<br>tools:layout=@layout/yourfragmentlayoutname<br>这样你的编写的fragment布局就会预览在指定主布局上了</p>
<p>app:xmlns:app=”<a href="http://schemas.android.com/apk/res-auto”" target="_blank" rel="noopener">http://schemas.android.com/apk/res-auto”</a></p>
<p>app命名空间为用户自定义，通过attrs进行设置，然后通过自定义view进行解析。</p>
<ul>
<li>Application 和 Activity 的 Context 对象的区别</li>
</ul>
<p>这是两种不同的context，也是最常见的两种.第一种中context的生命周期与Application的生命周期相关的，context随着Application的销毁而销毁，伴随application的一生，与activity的生命周期无关.第二种中的context跟Activity的生命周期是相关的，但是对一个Application来说，Activity可以销毁几次，那么属于Activity的context就会销毁多次.至于用哪种context，得看应用场景，个人感觉用Activity的context好一点，不过也有的时候必须使用Application的context.application context可以通过<br>Context.getApplicationContext或者Activity.getApplication方法获取.</p>
<p>还有就是，在使用context的时候，小心内存泄露，防止内存泄露，注意一下几个方面：</p>
<p>　1. 不要让生命周期长的对象引用activity context，即保证引用activity的对象要与activity本身生命周期是一样的</p>
<p>　2. 对于生命周期长的对象，可以使用application context</p>
<p>　3. 避免非静态的内部类，尽量使用静态类，避免生命周期问题，注意内部类对外部对象引用导致的生命周期变化</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/31/java基础知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/31/java基础知识点/" itemprop="url">java基础知识点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-31T23:15:56+08:00">
                2018-01-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>感冒了好几天，昨天没有写blog，心慌慌。</p>
<p>这篇从java核心来讲，估计要整理一阵</p>
<h1 id="java-核心"><a href="#java-核心" class="headerlink" title="java 核心"></a>java 核心</h1><ul>
<li>oop的概念</li>
</ul>
<ol>
<li>抽象</li>
</ol>
<p>在面向对象的概念中，所有对象都是由类来描述，但是反过来，并不是所有类都是用来描述对象的。如果一个类中没有包含足够信息来描绘一个具体的对象，这样的类就是抽象类。</p>
<ol>
<li>继承</li>
</ol>
<p>继承（英语：inheritance）是面向对象软件技术当中的一个概念。如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。 一般静态的面向对象编程语言，继承属于静态的，意即在子类别的行为在编译期就已经决定，无法在执行期扩充。 有些编程语言支持多重继承，即一个子类别可以同时有多个父类别，比如C++编程语言；而在有些编程语言中，一个子类别只能继承自一个父类别，比如Java编程语言，这时可以利用接口来实现与多重继承相似的效果。 现今面向对象程式设计技巧中，继承并非以继承类别的“行为”为主，而是继承类别的“型态”，使得元件的型态一致。另外在设计模式中提到一个守则，“多用合成，少用继承”，此守则也是用来处理继承无法在执行期动态扩充行为的遗憾。</p>
<ol>
<li>封装</li>
</ol>
<p>从字面上理解就是包装的意思，是指利用抽象数据类型，将数据和关于数据的操作封装起来，使其成为一个不可分割的独立实体。数据将会被保护在抽象数据类型的内部，仅能够通过暴露在表面的操作（public方法，比如setter和getter）来与这个对象进行交流和交互。用户不知道对象的内部细节，但是通过该对象提供的接口来访问对象。其好处是：减少耦合，方便地在未来修改调整自己，更加有把握地（精确地）控制成员，隐藏信息，实现细节。</p>
<ol>
<li>多态</li>
</ol>
<p>使用相同的消息，使得类作出不同的反应（继承为我们使用多态打下了基础）。Java实现多态有三个必要条件：继承、重写、向上转型。</p>
<ul>
<li><p>面向对象的三个基本元素和五个原则</p>
</li>
<li><p>三个元素：</p>
</li>
</ul>
<ol>
<li><p>封装： 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</p>
</li>
<li><p>继承： 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。</p>
</li>
<li><p>多态： 多态性是指允许不同类的对象对同一消息作出 响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。</p>
</li>
</ol>
<ul>
<li>五个基本原则：</li>
</ul>
<ol>
<li><p>单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。</p>
</li>
<li><p>开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。</p>
</li>
<li><p>Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。</p>
</li>
<li><p>依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。</p>
</li>
<li><p>接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口。</p>
</li>
</ol>
<ul>
<li>抽象类和接口的区别</li>
</ul>
<ol>
<li><p>抽象类是一个可同时包含具体方法和抽象方法(方法未被实现)的类。抽象方法必须被该抽象类的子类实现。抽象类是可以继承的。</p>
</li>
<li><p>接口像是描述类的一张蓝图或者说是类的一种契约，它包含了许多空方法，这代表着它的所有的子类都应该拥有共同点。它的子类应该提供这些空方法的具体实现。一 个类需要用 implements 来实现接口，接口可以用 extends 来继承其他接口。</p>
</li>
<li><p>设计模式上面来看：</p>
</li>
</ol>
<p>抽象的层次不同：抽象类对类的整体（包括属性，行为）都可以进行抽象，接口对类的局部进行抽象，具体来说接口仅仅是对类的行为进行抽象。</p>
<p>跨域不同：抽象类是 从各种子类中提取相似的部分，然后泛化成抽象类，子类可以继承这样的抽象类。 实现接口是 不存在is-a的关系的类们，你不可以称同样可以飞行的飞机和鸟为同一个抽象类，但是他们可以有同样的接口fly-able。抽象类的父类和派生类在概念上一致，接口的原生类和派生类在仅仅在局部行为上一致。</p>
<p>设计层次不同：抽象类是从一堆在底层的子类们来进行抽象提取，从下往上，从而产生抽象类；接口是在直接定义的高度来声明的，然后从这个高度上往下实现此接口。抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</p>
<ul>
<li>序列化是什么？如何实现？</li>
</ul>
<p>序列化是一种将对象转换为字节流的过程，目的是为了将对象存储到内存中，等后面再次构建该对象时可以获取到该对象先前的状态和数据信息。java中，使用Serializable和parcelable接口都可以实现，不过android中使用parcel效率高，性能高出10倍。</p>
<ul>
<li>什么是单例？</li>
</ul>
<p>单例模式指的是一个类只能被初始化一次，限定一个类只能拥有一个实例。使用一个实例来和其他模块协调工作是很实用的。</p>
<ul>
<li>什么是匿名内部类？</li>
</ul>
<p>普通的类可以自然的实例化自己吗，相反的，内部类却需要绑定上一个外部类才能实例。匿名内部类由于没有名字，只可以使用一次。</p>
<ul>
<li><p>对字符串进行 == 和 equals()操作时有什么区别？</p>
<p>== 主要比较的是两个字符串的地址，equals()假如不重写，也仅仅用于比较地址，重写就不是。</p>
</li>
<li><p>hashcode()和equals()何时使用？</p>
</li>
</ul>
<p>hashCode()的存在主要是用于查找的快捷性，如hashtable、 hashmap等，hashcode是用来在散列存储结构中确定对象的存储地址的。</p>
<p>如果两个对象相同，就是适用于equals()方法，那么这两个对象的hashcode一定要相同。</p>
<p>如果对象的equals方法被重写，那么对象的hashcode也尽量重写，并且产生hashcode使用的对象，一定要和equals方法中使用的一致。</p>
<p>两个对象的hashcode相同，并不一定就表示两个对象就相同，也就是不一定适用于equals方法，只能够说明这两个对象在散列存储结构中，如hashtable，他们“存放在同一个篮子里”</p>
<ul>
<li>java中 final、 finally 和finalize？</li>
</ul>
<p>final: 修饰变量、方法、类；修饰变量时表示这对象的值不可变，不能为这个变量赋一个新的值。修饰方法时便是我们希望把这个方法锁定，以防止任何继承类修改它的含义，这样会确保在继承中，final方法的行为不会改变，并且不会覆盖。修饰类的时候表示不打算继承该类，并且也不允许别人这样做。</p>
<p>finally: 是异常处理中进行收场处理的代码块，不管有没有异常，finally子句中的代码都会被执行。</p>
<p>finalize: 垃圾回收器准备释放对象占用的存储空间的时候，将首先调用其finalize()方法</p>
<ul>
<li>什么是内存泄漏？java如何处理它？</li>
</ul>
<p>内存泄漏就是保留下来却永远不再使用的对象引用。java通过gc进行处理</p>
<ul>
<li>垃圾回收器是什么？它是如何工作的？</li>
</ul>
<p>所有的对象实例都在jvm管理的堆区域分配内存，只要对象被引用，jvm就会认为它还活在进程中，一旦对象不再被引用，就不能被应用程序所访问，垃圾收集器将删除它并重新声明未使用的内存。</p>
<ul>
<li>比较arrays 和arraylists</li>
</ul>
<p>Arrays:一个包含许多和操作数组有关方法的类，比如说排序和查找。<br>ArrayList:一个容器，可以实现数组的大小可变，方便地增加和删除元素。</p>
<ul>
<li>比较hashset和treeset</li>
</ul>
<p>treeset是基于二叉树实现的，其中的数据是自动排序好的，不允许放入null值<br>hashset是基于hash实现的，其中的数据是无序的，允许放入null值。</p>
<ul>
<li>java中的类型转换</li>
</ul>
<p>基本数据的类型转换：将一个数据范围较小的类型赋给一个数值范围较大的数值型变量，jvm在编译过程中会将此数值的类型进行自动提升。自动提升意味着数值精度至少不应该降低。而需要将数值范围较大的数值赋给数值范围较小的数值类型变量时，需要手动转换，成为强制类型转换。</p>
<p>引用数据类型的类型转换：由于继承和向上转型，子类向父类的转换是很自然的，但是当把父类转换为子类时，强制类型转换会在运行时检查父类的真实类型，如果引用的父类对象的真实身份是子类类型，那就可以；否则如果真的是父类的类型，就会抛出ClassCastException的异常。</p>
<ul>
<li>方法重载和重写的区别。</li>
</ul>
<p>重载发生在编译时，重写发生在运行时，重载方法调用与其定义的绑定发生在编译时，重写方法调用与其定义的绑定在运行时发生。</p>
<p>静态方法可以重载，但不能重写。</p>
<p>最基本的区别是重载是在同一个类中完成的，重写父类的话需要子类。重写是给父类的继承方法一个具体的实现。</p>
<p>静态绑定用于方法重载，动态绑定用于方法重写。重载比重写更有效率，因为重写是在运行时完成的。</p>
<p>私有方法和用final修饰的方法可以重载但不能重写。这意味着一个类可以有多个同名的final/private方法，子类不能重写父类的private/final方法。</p>
<p>方法重载的情况下不关心返回值类型，他可以相同，也可以不同，重写的情况下可以有多个具体的返回值类型。</p>
<p>重载参数列表必须不同，方法重写时参数列表必须相同。</p>
<ul>
<li>什么是防卫修饰符？她们能做什么？</li>
</ul>
<p>public、protected、private、这几个关键字叫做访问修饰符。<br>作用是控制它所定义的域或者方法的访问权。</p>
<ul>
<li>接口可以继承另一个接口吗？</li>
</ul>
<p>可以</p>
<ul>
<li>java中static关键字什么意思？</li>
</ul>
<p>static是java里面的非访问修饰符，可以用来创建类方法和类变量。<br>当修饰一个变量的时候，此变量就成了独立于对象的静态变量，无论一个类实例化多少个对象，这个类只有一份这个静态变量的拷贝，所以static修饰的变量，即静态变量，也被叫做类变量。</p>
<p>当修饰一个方法的时候，此方法就成了独立于对象的静态方法，静态方法不能使用类的非静态方法，因为静态变量先于非静态的其他成员初始化，静态方法先出来，然后才是非静态的，</p>
<ul>
<li>什么是多态？什么是继承？</li>
</ul>
<p>多态是：允许不同类的对象对同一消息作出响应</p>
<p>继承是：子类继承父类的特征和行为，使得子类具有父类的各种属性和方法</p>
<ul>
<li>integer和int之间的区别</li>
</ul>
<p>integer是int提供的封装类，而int是java的基本数据类型；integer默认值是null，而int默认值是0，声明为integer的变量需要实例化，而声明为int的变量不需要实例化，integer是对象，用一个引用指向这个对象，而int是基本类型，直接存储数据。</p>
<p>两个new出来的integer总是不一样的，当使用 == 时，因为其内存地址不同，所以进行 == 时返回false。</p>
<p>两个不是new出来的integer，而是诸如integer i = x， 如果x的范围在 -128 ～ 127，其缓存指向同一个对象，所以此时使用 == 比较返回true，x范围在 -128 ～ 127之外的话，没有缓存存在，即使他们包裹的数值相同，他们也不能使用 == 得到true。</p>
<p>int 和integer的比较，无论integer是否使用new， 其值和将平常与亮的一样：integer自动拆箱，然后和int比较，这里就不会被内存地址的不同所影响，该相等就相等。</p>
<ul>
<li>java中的对象是否会以引用传递或者值传递？</li>
</ul>
<p>java中的对象总是以值传递的。</p>
<ul>
<li>什么是ThreadPoolExecutor?</li>
</ul>
<p>线程池是用于管理一个池子的工作线程，一个任务队列保持着一些等待执行的任务，这些任务由任何一个空闲的线程为止服务。任务是被生产者假如到队列的，同时，工作线程就像一个消费者，每当线程池里有空闲的线程，他就会开启一个后台的服务来执行一个任务。</p>
<p>ThreadPoolExecutor会使用线程池里的一个线程来执行一个任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = </span><br><span class="line">	new ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">		int maximumPoolSize, long keepAliveTime, TimeUnit unit,</span><br><span class="line">		BlockingQueue&lt;Runnable&gt; workQueue);</span><br></pre></td></tr></table></figure>
<p>corePoolSize: 保持在池中的最小线程数量。一开始，0个线程在池中，但是随着任务加入队列中，新的线程就会被创建。有空闲的线程，但是线程的数量小于corePoolSize，新的线程就会被继续创建。</p>
<p>maximumPoolSize:最大能允许的待在池中的线程数量。如果这个超过了corePoolSize而且现在线程的数量大于等于corePoolSize，那么新的工作线程会被创建，直到队列满了。</p>
<p>keepAliveTime: 当线程数量大于核心线程数，非核心的线程（超出空闲线程）会等着新任务来，然后如果任务到了keepAliveTime还没来，这些线程就会被冻结。</p>
<p>unit: keepAliveTime的时间单位</p>
<p>workQueue:任务队列，仅仅会维持一些runnable任务，一定要是一个blockingQueue</p>
<p>ThreadPoolExecutor是一个强力的任务执行框架，它支持任务添加、任务取消、任务优先级。并且减少了之前的有关线程创建之类的开销，因为管理着一个给定数量的线程池。</p>
<ul>
<li>本地变量、实例变量以及类变量之间的区别？</li>
</ul>
<p>本地变量就是局部变量，他在方法或者代码块里面被声明并使用，其内存中的位置是栈，没有默认初始化值，生命周期很短。<br>实例变量是没有被static修饰的成员变量，它属于一个类的一个实例。每次new一个实例，这样的变量也new一遍，其位置在堆区，有默认初始化的值，生命周期和它所在的实例一样长。<br>类变量，又称静态变量，它是被static修饰的成员变量，它属于一个类，被所有实例共享。每次new一个实例，这样的变量并不会被new一遍，其内存存在于方法区内，可以通过类名直接访问。有默认的初始化值，生命周期很长。</p>
<ul>
<li>什么是反射？</li>
</ul>
<p>也就是说,在编译时,你获取了一个指向某个并不存在你的程序空间中的对象的引用;事实上在编译时你的程序无法获知这个对象所属的类</p>
<ul>
<li>在java中什么是强引用、软引用、弱引用以及虚引用？</li>
</ul>
<p>强引用：不会被gc轻易清理，只要引用存在，垃圾回收器永远不会回收。</p>
<p>软引用：非必须引用，内存溢出之前进行回收</p>
<p>弱引用：第二次垃圾回收时回收</p>
<p>虚引用：垃圾回收时回收，无法通过引用取到对象值。</p>
<ul>
<li>关键字synchronized的作用是什么？</li>
</ul>
<p>synchronized通过修饰一个方法或者代码块，从而产生一个同步对象锁，以及对应的同步代码块。每当有线程要对该同步代码块进行访问时，线程就会首先尝试获取这个对象的锁，并在成功获取到对象锁之后，对这个同步代码块进行正常的访问。在同步代码块的访问过程中，线程会一直持有这个对象锁，直到同步代码块访问完毕，然后才会释放。<br>在上述线程中持有同步锁并且进行同步代码块访问过程中，其他线程无法获得该对象锁，也无法访问该同步代码，这些线程都会被阻塞直到上述线程访问完毕。</p>
<ul>
<li>为什么说string不可变？</li>
</ul>
<p>string类型在实现时，其内部变量全部使用final来修饰，保证成员变量的引用值只能通过构造函数来修改<br>string类型在实现时，在外部某个地方，可能修改一个string实例的内部存储值的函数实现中，在这个地方的调用返回时，一律构造新的string对象或者新的byte数组或者char数组，给赋值符号的左边变量</p>
<ul>
<li>修饰符transient和volatile的作用？</li>
</ul>
<p>volatile：易式修饰符，带有volatile修饰的变量，就是当其在某个线程自己的工作内存中发生改变时，会被强制地，写回公共成员变量所在的公共内存处。</p>
<p>transient是一个类型修饰符，仅仅能用来修饰字段（变量）。在此字段所在的对象进行序列化的时候，这个字段不会被序列化。</p>
<p>其他没有transient修饰的变量将会被序列化，然后进行传输，或者存储到本地磁盘，transient变量就在这个过程里丢失了</p>
<ul>
<li>StringBuffer和StringBuilder的区别在哪里？</li>
</ul>
<p>StringBuffer,StringBuilder和String一样，都用来代表字符串。<br>String类是不可变类，任何针对String的改变都会引起string对象的生成。而StringBuilder和StringBuffer则是可变类。StringBuilder不支持并发操作，线程不安全，不适合多线程。而StringBuffer支持并发操作，线程安全，单线程的性能低于StringBuilder</p>
<ul>
<li>StringBuilder怎么避免不可变字符串分配的问题？</li>
</ul>
<p>String类型在改变的时候都会生成一个新的string，然后指向这个string，因此经常改变内容的字符串最好不要用string，会导致gc。<br>stringbuffer则是每次结果都会对stringbuffer对象本身操作，而不是生成新的对象。</p>
<ul>
<li>什么是自动装箱和拆箱？</li>
</ul>
<p>装箱就是自动将数据类型转换为包装器类型，拆箱就是自动将包装齐类型转换为基本数据类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 100;</span><br></pre></td></tr></table></figure>
<p>这句话会被编译器执行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = Integer.valueOf(100);</span><br></pre></td></tr></table></figure>
<p>这就是自动装箱</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 10; // autoboxing</span><br><span class="line">int c = i; // unboxing</span><br></pre></td></tr></table></figure>
<ul>
<li>枚举和迭代器有什么区别？</li>
</ul>
<p>函数接口不同：枚举只有2个函数接口，只能读取集合的数据，而不能更改，迭代器有三个接口，出了读取集合的数据之外，还能进行删除操作</p>
<p>迭代器支持failfast，而枚举不支持。</p>
<ul>
<li>java中fail-fast和fail-safe的区别？</li>
</ul>
<p>fail-fast： 当遍历一个集合时，集合结构若被修改，就会抛出ConcurrentModificationException。</p>
<p>fail-safe:任何对集合的修改都会在一个复制的集合上进行修改，因此不会抛出ConcurrentModificationException。failsafe需要复制集合，产生大量的无效对象，开销大，而且无法保证读取的数据是目前原始数据结构中的数据。</p>
<ul>
<li>优先级队列</li>
</ul>
<p>priorityQueue类用来表示优先队列，优先队列是一个以集合为基础的抽象数据类型，队列中的每个元素都有一个优先级值，优先级值用来表示该元素的出列的优先级</p>
<p>java中的优先队列基于堆，堆是一个完全二叉树，所以PriorityQueue不是线性结构，而是树形结构。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/29/java动态编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/29/java动态编程/" itemprop="url">java动态编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-29T22:21:09+08:00">
                2018-01-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>动态编程，常用到的是反射，但是反射开销性能大，上线的项目上面用反射不好。有另一种和反射功能相当的，但是比反射开销低的，就是javaassit</p>
<h1 id="什么是javaassit"><a href="#什么是javaassit" class="headerlink" title="什么是javaassit"></a>什么是javaassit</h1><p>javaassit就是一个二方包，提供了运行时操作java字节码的方法。</p>
<h1 id="使用javaassit"><a href="#使用javaassit" class="headerlink" title="使用javaassit"></a>使用javaassit</h1><ul>
<li>更改某个类的父类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(&quot;test.Rectangle&quot;);</span><br><span class="line">cc.setSuperclass(pool.get(&quot;test.Point&quot;));</span><br><span class="line">cc.writeFile();</span><br></pre></td></tr></table></figure>
<ul>
<li>获取字节码和加载字节码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte[] b = cc.toBytecode();</span><br><span class="line">Class clazz = cc.toClass();</span><br></pre></td></tr></table></figure>
<ul>
<li>定义一个新类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.makeClass(&quot;Point&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>通过CtMethod和CtField构造方法和成员甚至Annotation。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.makeClass(&quot;foo&quot;);</span><br><span class="line">CtMethod mthd = CtNewMethod.make(&quot;public Integer getInteger() &#123; return null; &#125;&quot;, cc);</span><br><span class="line">cc.addMethod(mthd);</span><br><span class="line">CtField f = new CtField(CtClass.intType, &quot;i&quot;, cc);</span><br><span class="line">point.addField(f);</span><br><span class="line">clazz = cc.toClass(); Object instance = class.newInstance();</span><br></pre></td></tr></table></figure>
<ul>
<li>Javassist不仅可以生成类、变量和方法，还可以操作现有的方法，这在AOP上非常有用，比如做方法调用的埋点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Point.java</span><br><span class="line">class Point &#123;</span><br><span class="line">   	int x, y;</span><br><span class="line">   	void move(int dx, int dy) &#123; x += dx; y += dy; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对已有代码每次move执行时做埋点</span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(&quot;Point&quot;);</span><br><span class="line">CtMethod m = cc.getDeclaredMethod(&quot;move&quot;);</span><br><span class="line">m.insertBefore(&quot;&#123; System.out.println($1); System.out.println($2); &#125;&quot;);</span><br><span class="line">cc.writeFile();</span><br></pre></td></tr></table></figure>
<p>其中$1和$2表示调用栈中的第一和第二个参数，写到磁盘后的class定义类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">   	int x, y;</span><br><span class="line">   	void move(int dx, int dy) &#123;</span><br><span class="line">       	&#123; System.out.println(dx); System.out.println(dy); &#125;</span><br><span class="line">       	x += dx; y += dy;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/28/java反射/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/28/java反射/" itemprop="url">java反射</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-28T19:44:53+08:00">
                2018-01-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h1><p>反射是一种在程序运行时动态访问，修改某个类中任意属性(状态)和方法(行为)的机制</p>
<ul>
<li><p>在运行时判断任意一个对象所属的类</p>
</li>
<li><p>在运行时构造任意一个类的对象</p>
</li>
<li><p>在运行时判断任意一个类所具有的成员变量和方法</p>
</li>
<li><p>在运行时调用任意一个对象的方法</p>
</li>
</ul>
<p>设计到的四个核心类</p>
<ul>
<li><p>java.lang.Class.java:类对象</p>
</li>
<li><p>java.lang.reflect.Constructor.java:类的构造器对象</p>
</li>
<li><p>java.lang.reflect.Method.java:类的方法对象</p>
</li>
<li><p>java.lang.reflect.Field.java:类的属性对象</p>
</li>
</ul>
<h1 id="反射有什么用？"><a href="#反射有什么用？" class="headerlink" title="反射有什么用？"></a>反射有什么用？</h1><ul>
<li><p>操作因访问权限限制的属性和方法</p>
</li>
<li><p>实现自定义注解</p>
</li>
<li><p>动态加载第三方jar包，解决android中方法数不能超过65536个的问题</p>
</li>
<li><p>按需加载类，节省编译和初始化apk的时间</p>
</li>
</ul>
<h1 id="反射工作原理"><a href="#反射工作原理" class="headerlink" title="反射工作原理"></a>反射工作原理</h1><p>当编完一个java项目之后，每个java文件都会被编译成一个.class文件，这些class对象继承了这个类的所有信息，包括父类、接口、构造函数、方法、属性等，这些class文件在程序运行时会被classloader加载到虚拟机中。当一类被加载以后，java虚拟机就会在内存中自动产生一个class对象。</p>
<p>反射的原理就是借助class.java， constructor.java, method.java, field.java四个类在程序运行时动态访问和修改任何类的行为和状态。</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><ul>
<li>获取父类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void getSuperClass()&#123;</span><br><span class="line">       ProgramMonkey programMonkey = new ProgramMonkey(&quot;小明&quot;, &quot;男&quot;, 12);</span><br><span class="line">       Class&lt;?&gt; superClass = programMonkey.getClass().getSuperclass();</span><br><span class="line">       while (superClass != null) &#123;</span><br><span class="line">           LogE(&quot;programMonkey&apos;s super class is : &quot; + superClass.getName());</span><br><span class="line">           // 再获取父类的上一层父类，直到最后的 Object 类，Object 的父类为 null</span><br><span class="line">           superClass = superClass.getSuperclass();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void getInterfaces() &#123;</span><br><span class="line">       ProgramMonkey programMonkey = new ProgramMonkey(&quot;小明&quot;, &quot;男&quot;, 12);</span><br><span class="line">       Class&lt;?&gt;[] interfaceses = programMonkey.getClass().getInterfaces();</span><br><span class="line">       for (Class&lt;?&gt; class1 : interfaceses) &#123;</span><br><span class="line">           LogE(&quot;programMonkey&apos;s interface is : &quot; + class1.getName());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取当前类的所有的方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void getCurrentClassMethods() &#123;</span><br><span class="line">       ProgramMonkey programMonkey = new ProgramMonkey(&quot;小明&quot;, &quot;男&quot;, 12);</span><br><span class="line">       Method[] methods = programMonkey.getClass().getDeclaredMethods();</span><br><span class="line">       for (Method method : methods) &#123;</span><br><span class="line">           LogE(&quot;declared method name : &quot; + method.getName());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           Method getSalaryPerMonthMethod = programMonkey.getClass().getDeclaredMethod(&quot;getSalaryPerMonth&quot;);</span><br><span class="line">           getSalaryPerMonthMethod.setAccessible(true);</span><br><span class="line">           // 获取返回类型</span><br><span class="line">           Class&lt;?&gt; returnType = getSalaryPerMonthMethod.getReturnType();</span><br><span class="line">           LogE(&quot;getSalaryPerMonth 方法的返回类型 : &quot; + returnType.getName());</span><br><span class="line"></span><br><span class="line">           // 获取方法的参数类型列表</span><br><span class="line">           Class&lt;?&gt;[] paramClasses = getSalaryPerMonthMethod.getParameterTypes() ;</span><br><span class="line">           for (Class&lt;?&gt; class1 : paramClasses) &#123;</span><br><span class="line">               LogE(&quot;getSalaryPerMonth 方法的参数类型 : &quot; + class1.getName());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 是否是 private 函数，属性是否是 private 也可以使用这种方式判断</span><br><span class="line">           LogE(getSalaryPerMonthMethod.getName() + &quot; is private &quot; + Modifier.isPrivate(getSalaryPerMonthMethod.getModifiers()));</span><br><span class="line"></span><br><span class="line">           // 执行方法</span><br><span class="line">           Object result = getSalaryPerMonthMethod.invoke(programMonkey);</span><br><span class="line">           LogE(&quot;getSalaryPerMonth 方法的返回结果: &quot; + result);</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取当前类和父类的所有公有方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void getAllMethods() &#123;</span><br><span class="line">       ProgramMonkey programMonkey = new ProgramMonkey(&quot;小明&quot;, &quot;男&quot;, 12);</span><br><span class="line">       // 获取当前类和父类的所有公有方法</span><br><span class="line">       Method[] methods = programMonkey.getClass().getMethods();</span><br><span class="line">       for (Method method : methods) &#123;</span><br><span class="line">           LogE(&quot;method name : &quot; + method.getName());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           Method setmLanguageMethod = programMonkey.getClass().getMethod(&quot;setmLanguage&quot;, String.class);</span><br><span class="line">           setmLanguageMethod.setAccessible(true);</span><br><span class="line"></span><br><span class="line">           // 获取返回类型</span><br><span class="line">           Class&lt;?&gt; returnType = setmLanguageMethod.getReturnType();</span><br><span class="line">           LogE(&quot;setmLanguage 方法的返回类型 : &quot; + returnType.getName());</span><br><span class="line"></span><br><span class="line">           // 获取方法的参数类型列表</span><br><span class="line">                       Class&lt;?&gt;[] paramClasses = setmLanguageMethod.getParameterTypes() ;</span><br><span class="line">           for (Class&lt;?&gt; class1 : paramClasses) &#123;</span><br><span class="line">               LogE(&quot;setmLanguage 方法的参数类型 : &quot; + class1.getName());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 是否是 private 函数，属性是否是 private 也可以使用这种方式判断</span><br><span class="line">           LogE(setmLanguageMethod.getName() + &quot; is private &quot; + Modifier.isPrivate(setmLanguageMethod.getModifiers()));</span><br><span class="line"></span><br><span class="line">           // 执行方法</span><br><span class="line">           Object result = setmLanguageMethod.invoke(programMonkey, &quot;Java&quot;);</span><br><span class="line">           LogE(&quot;setmLanguage 方法的返回结果: &quot; + result);</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取当前类的所有实例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void getCurrentClassFields() &#123;</span><br><span class="line">       ProgramMonkey programMonkey = new ProgramMonkey(&quot;小明&quot;, &quot;男&quot;, 12);</span><br><span class="line">       // 获取当前类的所有属性</span><br><span class="line">       Field[] publicFields = programMonkey.getClass().getDeclaredFields();</span><br><span class="line">       for (Field field : publicFields) &#123;</span><br><span class="line">           LogE(&quot;declared field name : &quot; + field.getName());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           // 获取当前类的某个属性</span><br><span class="line">           Field ageField = programMonkey.getClass().getDeclaredField(&quot;mAge&quot;);</span><br><span class="line">           // 获取属性值</span><br><span class="line">           LogE(&quot; my age is : &quot; + ageField.getInt(programMonkey));</span><br><span class="line">           // 设置属性值</span><br><span class="line">           ageField.set(programMonkey, 10);</span><br><span class="line">           LogE(&quot; my age is : &quot; + ageField.getInt(programMonkey));</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取当前类和父类的所有公有属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void getAllFields() &#123;</span><br><span class="line">       ProgramMonkey programMonkey = new ProgramMonkey(&quot;小明&quot;, &quot;男&quot;, 12);</span><br><span class="line">       // 得到当前类和父类的所有公有属性</span><br><span class="line">       Field[] publicFields = programMonkey.getClass().getFields();</span><br><span class="line">       for (Field field : publicFields) &#123;</span><br><span class="line">           LogE(&quot;field name : &quot; + field.getName());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           // 获取当前类和父类的某个公有属性</span><br><span class="line">           Field ageField = programMonkey.getClass().getField(&quot;mAge&quot;);</span><br><span class="line">           LogE(&quot; age is : &quot; + ageField.getInt(programMonkey));</span><br><span class="line">           ageField.set(programMonkey, 8);</span><br><span class="line">           LogE(&quot; my age is : &quot; + ageField.getInt(programMonkey));</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/28/2018第四周工作小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/28/2018第四周工作小结/" itemprop="url">2018第四周工作小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-28T17:45:07+08:00">
                2018-01-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这周把图表的那个做完，之后就继续做微信接口登陆的问题。<br>图表的任务主要是收尾，将缓存什么的做了一下，持久层也做好了，将一些额外的feature结束，也就没任务了。没什么需要总结的。</p>
<p>微信接口的问题，目前是商量好了使用v2的接口，获取到了一次性code，然后回传，这样在得到一次性token。<br>需要继续做的事就是将返回的token想办法做一个有效期判定的措施，然后每次都根据这个进行判断。</p>
<p>下周的任务，目前来看就这一个</p>
<p>将微信token做一个持久化处理，然后针对返回的是否是404做一个注册操作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/26/使用python抓取网页内容/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/26/使用python抓取网页内容/" itemprop="url">使用python抓取网页内容</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-26T22:54:51+08:00">
                2018-01-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>进行爬虫抓取，有一个大致的思路。<br>首先是抓取当前页的关键内容，也就是我们需要的内容。<br>其次是抓取下一页的网址信息，也就是用于下一轮进行抓取的对象。</p>
<p>因此使用一个queue去存储抓取的网址信息，当queue不为空的时候执行轮次抓取关键信息的操作。<br>同时还有一个set去存储以抓取的网址的信息，确保不会重复查询某个网址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue Q</span><br><span class="line">set S</span><br><span class="line">StartPoint = &quot;http://jecvay.com&quot;</span><br><span class="line">Q.push(StartPoint)  # 经典的BFS开头</span><br><span class="line">S.insert(StartPoint)  # 访问一个页面之前先标记他为已访问</span><br><span class="line">while (Q.empty() == false)  # BFS循环体</span><br><span class="line">  T = Q.top()  # 并且pop</span><br><span class="line">  for point in PageUrl(T)  # PageUrl(T)是指页面T中所有url的集合, point是这个集合中的一个元素.</span><br><span class="line">    if (point not in S)</span><br><span class="line">      Q.push(point)</span><br><span class="line">      S.insert(point)</span><br></pre></td></tr></table></figure>
<p>大致如这个伪代码。</p>
<p>queue初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue = deque()</span><br></pre></td></tr></table></figure></p>
<p>queue添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue.append(url)</span><br></pre></td></tr></table></figure></p>
<p>queue出栈：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue.popleft()</span><br></pre></td></tr></table></figure></p>
<p>set初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visited = set()</span><br></pre></td></tr></table></figure></p>
<p>set添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visited |= &#123;url&#125;</span><br></pre></td></tr></table></figure></p>
<p>url抓取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urlop = urllib.requests.urlopen(url)</span><br></pre></td></tr></table></figure></p>
<p>数据解析:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = urlop.read().decode(&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/25/Android性能优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/25/Android性能优化/" itemprop="url">Android性能优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-25T16:00:25+08:00">
                2018-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h1><ol>
<li>ui渲染机制</li>
</ol>
<p>android中，系统通过VSYNC信号触发对ui的渲染、重绘，间隔是16ms，即每秒60帧。<br>如果系统每次渲染的时间都保持在16ms之内，那么我们看见的ui界面是非常流畅的，这需要讲所有程序的逻辑都保证在16ms之内，如果不能在16ms内完成绘制，就会造成丢帧现象。<br>导致16ms*n一直显示同一帧，产生卡顿的现象</p>
<ol>
<li>避免Overdraw</li>
</ol>
<p>过度绘制是指给布局绘制了重叠的背景，过度绘制会浪费很多的cpu、gpu资源。使用GPU OVERDRAW可以检查</p>
<ol>
<li>优化布局层级</li>
</ol>
<p>android中，系统对view进行测量、布局和绘制时，都是通过对view树的遍历来进行操作的，如果一个view树太高，就会严重影响测量、布局和绘制的速度，因此优化布局的第一个方法就是降低view树的高度，树的高度不宜超过10层。</p>
<p>使用RelativeLayout可以有效降低嵌套。</p>
<ol>
<li>避免嵌套过多无用布局</li>
</ol>
<p>嵌套的布局会让view树的高度越来越高，因此在布局时，需要根据自身布局的特点来选择不同的layout组件，从而避免通过某一种layout组件来实现功能时的局限性，从而造成嵌套过多的情况发生。</p>
<p>使用<include>可以复用标签<br>使用<viewstub>可以实现view的延迟加载。viewstub只有在显示时才会去渲染整个布局，而view.gone，在初始化布局树的时候就已经添加在布局树上面了。</viewstub></include></p>
<ol>
<li>Hierarcy Viewer</li>
</ol>
<p>使用Hierarcy可以很容易的看到布局结构，找到冗杂的布局进行优化。</p>
<h1 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h1><ol>
<li>什么是内存</li>
</ol>
<p>寄存器：速度最快的存储场所，因为寄存器位于处理器内部，在程序中无法控制<br>栈：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中<br>堆：存放由new创建的对象和数组，在堆中分配的内存，由java虚拟机的自动垃圾回收装置回收（gc）<br>静态存储区域：静态存储区域就是指在固定的位置存放应用程序运行时一直存在的数据，java专门划分了一个静态存储区来管理一些特殊的数据变量，如静态的数据变量。<br>常量池：jvm虚拟机必须为每个被装载的类型维护一个常量池，常量池就是该类型所用到常量的一个有序集合，包括直接常量和对其他类型、字段和方法的符号引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityManager manager = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">int heapSize = manager.getLargeMemoryClass();</span><br></pre></td></tr></table></figure>
<p>使用如上代码可以获取heap的大小。</p>
<ol>
<li>获取android系统内存信息</li>
</ol>
<p>Process state: 在android k 以上设置中开启该功能，进行内存的监视。</p>
<p>也可以使用 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys procstats</span><br></pre></td></tr></table></figure>
<p>Meminfo: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys meminfo</span><br></pre></td></tr></table></figure>
<ol>
<li>内存回收</li>
</ol>
<p>使用System.gc()可以建议系统进行gc，但系统是否采纳就不一定，有些对象因为算法的原因，不在回收，就会造成内存泄漏</p>
<ol>
<li>内存优化实例</li>
</ol>
<p>bitmap优化：bitmap是造成内存占用过高，甚至是oom的最大威胁。可以使用适当分辨率和大小的图片，及时使用bitmap.recycle()回收内存，使用图片缓存（内存缓存或硬盘缓存）来减少该问题的发生。</p>
<p>代码优化：</p>
<ol>
<li>对常量使用static修饰符</li>
<li>使用静态方法，静态方法会比普通方法提高15%的访问速度</li>
<li>减少不必要的成员变量</li>
<li>减少不必要的对象，使用基础类型会比使用对象更加节省资源，同时更应避免频繁创建短作用域的变量。</li>
<li>尽量不用使用枚举，少用迭代器</li>
<li>对Cursor, Receiver, Sensor, File等对象，要非常注意对他们的创建，回收与注册，解注册。</li>
<li>避免使用IOC框架，注解和反射会带来性能的下降</li>
<li>使用RenderScript, OpenGL来进行非常复杂的绘图操作</li>
<li>使用SurfaceView来替代view进行大量、频繁的绘图操作</li>
<li>尽量使用视图缓存，而不是每次都执行inflate（）方法。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/25/Android系统信息和安全机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/25/Android系统信息和安全机制/" itemprop="url">Android系统信息和安全机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-25T11:51:19+08:00">
                2018-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android系统信息获取"><a href="#Android系统信息获取" class="headerlink" title="Android系统信息获取"></a>Android系统信息获取</h1><p>获取系统的配置信息，通常从build和systemproperty两个方面获取</p>
<ol>
<li>android.os.Build</li>
</ol>
<p>该类里面的信息非常丰富，包含了系统编译时的大量设备、配置信息</p>
<ol>
<li>SystemProperty</li>
</ol>
<p>该类包含了许多系统配置属性值和参数，有一些和build是相同的。</p>
<ol>
<li>Android系统信息实例</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String board = Build.BOARD;</span><br><span class="line">String brand = Build.BRAND;</span><br><span class="line"></span><br><span class="line">String os_version = System.getProperty(&quot;os.version&quot;);</span><br><span class="line">String os_name = System.getProperty(&quot;os.name&quot;);</span><br></pre></td></tr></table></figure>
<h1 id="Android-Apk应用信息获取之PackageManager"><a href="#Android-Apk应用信息获取之PackageManager" class="headerlink" title="Android Apk应用信息获取之PackageManager"></a>Android Apk应用信息获取之PackageManager</h1><p>PM主宰着应用的包管理</p>
<ol>
<li><p>ActivityInfo: 封装了在Mainifest文件中<activity></activity>和<receiver></receiver>之间的所有信息，包括name，icon, label, launchmod等</p>
</li>
<li><p>ServiceInfo: ServiceInfo与ActivityInfo类似，封装了<service></service>之间的所有信息</p>
</li>
<li><p>ApplicationInfo: 封装了 <application></application>之间的信息，特别的是，applicationinfo包含了很多flag，通过这些flag，可以很方便的判断应用的类型</p>
</li>
<li><p>PackageInfo: 封装了所有的activity，service等信息</p>
</li>
<li><p>ResolveInfo: 封装的是包含<intent>信息的上一级信息，所以可以返回Activityinfo, ServiceInfo等包含<intent>的信息，可以用来找到含有特定intent条件的包</intent></intent></p>
</li>
</ol>
<h1 id="Android-Apk应用信息获取之ActivityMananger"><a href="#Android-Apk应用信息获取之ActivityMananger" class="headerlink" title="Android Apk应用信息获取之ActivityMananger"></a>Android Apk应用信息获取之ActivityMananger</h1><p>AM可以获取正在运行的应用程序信息。</p>
<ol>
<li>AcitivtyManager.MemoryInfo</li>
</ol>
<p>全局内存信息，availMem是系统可用内存，totalMem是总内存，threshold是低内存的阀值，lowMemory是检查是否处于低内存。</p>
<ol>
<li>Debug.MemoryInfo</li>
</ol>
<p>用于获取统计进程下的内存信息。数据是由dvm虚拟机提供的。</p>
<ol>
<li>RunningAppProcessInfo</li>
</ol>
<p>运行进程的信息</p>
<ol>
<li>RunningServiceInfo</li>
</ol>
<p>用于封装运行的服务信息。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sample</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sample</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
