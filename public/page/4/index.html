<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="记录者">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="记录者">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="记录者">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/"/>





  <title>记录者</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">记录者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/25/Android系统信息和安全机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/25/Android系统信息和安全机制/" itemprop="url">Android系统信息和安全机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-25T11:51:19+08:00">
                2018-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android系统信息获取"><a href="#Android系统信息获取" class="headerlink" title="Android系统信息获取"></a>Android系统信息获取</h1><p>获取系统的配置信息，通常从build和systemproperty两个方面获取</p>
<ol>
<li>android.os.Build</li>
</ol>
<p>该类里面的信息非常丰富，包含了系统编译时的大量设备、配置信息</p>
<ol>
<li>SystemProperty</li>
</ol>
<p>该类包含了许多系统配置属性值和参数，有一些和build是相同的。</p>
<ol>
<li>Android系统信息实例</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String board = Build.BOARD;</span><br><span class="line">String brand = Build.BRAND;</span><br><span class="line"></span><br><span class="line">String os_version = System.getProperty(&quot;os.version&quot;);</span><br><span class="line">String os_name = System.getProperty(&quot;os.name&quot;);</span><br></pre></td></tr></table></figure>
<h1 id="Android-Apk应用信息获取之PackageManager"><a href="#Android-Apk应用信息获取之PackageManager" class="headerlink" title="Android Apk应用信息获取之PackageManager"></a>Android Apk应用信息获取之PackageManager</h1><p>PM主宰着应用的包管理</p>
<ol>
<li><p>ActivityInfo: 封装了在Mainifest文件中<activity></activity>和<receiver></receiver>之间的所有信息，包括name，icon, label, launchmod等</p>
</li>
<li><p>ServiceInfo: ServiceInfo与ActivityInfo类似，封装了<service></service>之间的所有信息</p>
</li>
<li><p>ApplicationInfo: 封装了 <application></application>之间的信息，特别的是，applicationinfo包含了很多flag，通过这些flag，可以很方便的判断应用的类型</p>
</li>
<li><p>PackageInfo: 封装了所有的activity，service等信息</p>
</li>
<li><p>ResolveInfo: 封装的是包含<intent>信息的上一级信息，所以可以返回Activityinfo, ServiceInfo等包含<intent>的信息，可以用来找到含有特定intent条件的包</intent></intent></p>
</li>
</ol>
<h1 id="Android-Apk应用信息获取之ActivityMananger"><a href="#Android-Apk应用信息获取之ActivityMananger" class="headerlink" title="Android Apk应用信息获取之ActivityMananger"></a>Android Apk应用信息获取之ActivityMananger</h1><p>AM可以获取正在运行的应用程序信息。</p>
<ol>
<li>AcitivtyManager.MemoryInfo</li>
</ol>
<p>全局内存信息，availMem是系统可用内存，totalMem是总内存，threshold是低内存的阀值，lowMemory是检查是否处于低内存。</p>
<ol>
<li>Debug.MemoryInfo</li>
</ol>
<p>用于获取统计进程下的内存信息。数据是由dvm虚拟机提供的。</p>
<ol>
<li>RunningAppProcessInfo</li>
</ol>
<p>运行进程的信息</p>
<ol>
<li>RunningServiceInfo</li>
</ol>
<p>用于封装运行的服务信息。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/24/第八章Activity与Activity调用栈分析笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/24/第八章Activity与Activity调用栈分析笔记/" itemprop="url">第八章Activity与Activity调用栈分析笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-24T17:34:25+08:00">
                2018-01-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android任务栈简介"><a href="#Android任务栈简介" class="headerlink" title="Android任务栈简介"></a>Android任务栈简介</h1><p>andriod使用栈结构来管理activity</p>
<h1 id="AndroidMainifest启动模式"><a href="#AndroidMainifest启动模式" class="headerlink" title="AndroidMainifest启动模式"></a>AndroidMainifest启动模式</h1><ol>
<li>standard</li>
</ol>
<p>每次启动都会创建新的实例，覆盖在原来的activity上面</p>
<ol>
<li>singleTop</li>
</ol>
<p>每次启动时判断栈顶是否是要启动的activity，如果是则不创建新的而直接引用这个activity。不是的话则创建一个并启动。</p>
<ol>
<li>singleTask</li>
</ol>
<p>每次启动时判断整个栈是否有要启动的activity，如果有就将其以上的activity销毁（同一个app启动这个activity是销毁，不同app启动这个activity则会创建一个新的任务栈），如果activity在后台的一个栈中，后台这个任务栈将同时切换到前台。</p>
<p>这种启动模式可以用来设置主activity，这样主activity启动别的activity，退出回到主activity时可以顺便销毁别的activity。</p>
<ol>
<li>singleInstance</li>
</ol>
<p>这种启动模式常用于需要与程序分离的界面，不同应用共同享用一个activity</p>
<p>ps:不同栈是无法使用startActivityForResult()方法来获得数据的，只可以通过intent绑定来传。</p>
<h1 id="Intent-Flag启动模式"><a href="#Intent-Flag启动模式" class="headerlink" title="Intent Flag启动模式"></a>Intent Flag启动模式</h1><p>介绍一些常用的Flag</p>
<ol>
<li>Intent.FLAG_ACTIVITY_NEW_TASK</li>
</ol>
<p>使用一个新的task来启动activity，启动的每个activity都将在一个新的task中。</p>
<p>该flag通常使用在从service中启动activity的场景，由于在service中并不存在activity栈，所以使用该flag来创建一个新的activity栈，并创建新的activty实例。</p>
<ol>
<li>FLAG_ACTIVITY_SINGLE_TOP</li>
</ol>
<p>与singletop等同</p>
<ol>
<li>FLAG_ACTIVITY_CLEAR_TOP</li>
</ol>
<p>使用singletask模式来启动一个activity</p>
<ol>
<li>FLAG_ACTIVITY_NO_HISTORY</li>
</ol>
<p>使用这种模式启动activity，当该activity启动其他activity后，该activity就消失了，不会保存在栈中。</p>
<h1 id="清空任务栈"><a href="#清空任务栈" class="headerlink" title="清空任务栈"></a>清空任务栈</h1><p>可以在mainifest中activity标签中使用以下几种属性来清理任务栈</p>
<ol>
<li>clearTaskOnLaunch</li>
</ol>
<p>每次返回该activity时，都将该activity之上的所有activity清除，通过这个属性，可以让这个task每次在初始化的时候，都只有这一个activity</p>
<ol>
<li>finishOnTaskLaunch</li>
</ol>
<p>当离开这个activity所处的task，用户在返回时，该activity就会被finish掉</p>
<ol>
<li>alwaysRetainTaskState</li>
</ol>
<p>如果将这个属性设为true，那么该activity所在的task将不受任何清理命令，一直保持当前task状态</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/22/第七章动画机制与使用技巧学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/22/第七章动画机制与使用技巧学习笔记/" itemprop="url">第七章动画机制与使用技巧学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-22T22:47:31+08:00">
                2018-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android-View动画框架"><a href="#Android-View动画框架" class="headerlink" title="Android View动画框架"></a>Android View动画框架</h1><p>Animation框架定义了透明度、旋转、缩放和位移几种常见的动画，控制的是整个view，原理是每次绘制视图时view所在的viewgroup中的drawchild函数获取该view的animation的transformation值，然后调用canvas.concat(transformToApply.getMatrix())，通过矩阵换算完成动画帧，如果动画没有完成，就继续调用invalidate()函数，启动下次绘制来驱动动画，从而完成整个动画的绘制。</p>
<h2 id="视图动画"><a href="#视图动画" class="headerlink" title="视图动画"></a>视图动画</h2><p>视图动画使用简单，效果丰富，提供了四种方式，并提供了animationset动画集合，混合使用多种动画。</p>
<ol>
<li>透明度动画</li>
</ol>
<p>为视图增加透明度的变换动画。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	AlphaAnimation aa = new AlphaAnimation(0, 1);</span><br><span class="line">	aa.setDuration(1000);</span><br><span class="line">	view.startAnimation(aa);</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">2. 旋转动画</span><br><span class="line"></span><br><span class="line">为视图增加旋转的变换动画。</span><br></pre></td></tr></table></figure>
<pre><code>RotateAnimation ra = new RotateAnimation(0, 360, 100, 100);
ra.setDuration(1000);
view.startAnimation(ra);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">也可以以自身为旋转中心</span><br></pre></td></tr></table></figure>
<pre><code>RotateAnimation ra = new RotateAnimation(0, 360,
    RotateAnimation.RELATIVE_TO_SELF, 0.5F,
    RotateAnimation.RELATIVE_TO_SELF, 0.5F);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 位移动画</span><br><span class="line"></span><br><span class="line">为视图移动时增加位移动画</span><br></pre></td></tr></table></figure>
<pre><code>TranslationAnimation ta = new TranslationAnimation(0, 200, 0, 300);
ta.setDuration(1000);
view.startAnimation(ta);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 缩放动画</span><br><span class="line"></span><br><span class="line">为视图的缩放增加动画效果</span><br></pre></td></tr></table></figure>
<pre><code>ScaleAnimation sa = new ScaleAnimation(0, 2, 0, 2);
sa.setDuration(1000);
view.startAnimation(sa);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">也可以以自身为缩放中心</span><br></pre></td></tr></table></figure>
<pre><code>ScaleAnimation sa = new ScaleAnimation(0, 1, 0, 1,
    Animation.RELATIVE_TO_SELF, 0.5F,
    Animation.RELATIVE_TO_SELF, 0.5F);
sa.setDuration(1000);
view.startAnimation(sa);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. 动画合集</span><br><span class="line"></span><br><span class="line">使用AnimationSet,可以将动画以组合的形式展现出来。</span><br></pre></td></tr></table></figure>
<pre><code>AnimationSet as = new AnimationSet(true);
as.setDuration(1000);

AlphaAnimation aa = new AlphaAnimation(0, 1);
aa.setDuration(1000);
as.addAnimation(aa);

TranslateAnimation ta = new TranslateAnimation(0, 100, 0, 200);
ta.setDuration(1000);
as.addAnimation(ta);

view.startAnimation(as);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 属性动画</span><br><span class="line"></span><br><span class="line">由于视图动画改变的只是view的显示，而并不是view的属性，会导致一些问题。</span><br><span class="line"></span><br><span class="line">1. 	ObjectAnimator</span><br><span class="line"></span><br><span class="line">ObjectAnimator是属性动画框架中最重要的实体类，创建一个ObjectAnimator只需要通过他的静态工厂类直接返回一个ObjectAnimator对象。参数包括一个对象和对象的属性名字，但这个属性必须有get和set函数，内部会通过java反射机制来调用set函数修改对象属性值。</span><br></pre></td></tr></table></figure>
<pre><code>ObjectAnimator animator = ObjectAnimator.ofFloat(
    view, &quot;translationX&quot;, 300);
animator.setDuration(300);
animator.start();
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">第一个参数为要操纵的view，第二个参数为要操纵的属性，第三个三处为一个可变数组参数，需要传进该属性变化的一个取值过程。</span><br><span class="line"></span><br><span class="line">如果需要操控一个值，但是该值没有setget方法，可以使用wrapper方法来进行一层包装。</span><br></pre></td></tr></table></figure>
<pre><code>private static class WrapperView{
    private View mTarget;
    public WrapperView(View target){
        mTarget = target;
    }
    public int getWidth(){
        return mTarget.getLayoutParams().width;
    }
    public void setWidth(int width){
        mTarget.getLayoutParams().width = width;
        mTarget.requestLayout();
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>ViewWrapper wrapper = new ViewWrapper(mButton);
ObjectAnimator.ofInt(wrapper, &quot;width&quot;, 500).setDuration(5000).start();
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. PropertyValuesHolder</span><br><span class="line"></span><br><span class="line">类似视图动画中的AnimationSet,在属性动画中，如果针对同一个对象的多个属性，要同时作用多种动画，可以使用PropertyValuesHolder来实现。</span><br></pre></td></tr></table></figure>
<pre><code>PropertyValuesHolder pvh1 = PropertyValuesHolder.ofFloat(&quot;translationX&quot;, 300f);
PropertyValuesHolder pvh2 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1f, 0, 1f);
PropertyValuesHolder pvh3 = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1f, 0, 1f);
ObjectAnimator.ofPropertyValuesHolder(view, pvh1, pvh2, pvh3).setDuration(1000).start();
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. ValueAnimator</span><br><span class="line"></span><br><span class="line">ValueAnimator本身不提供任何动画效果，它更像一个数值发生器，用来产生具有一定规律的数字，从而让调用者来控制动画的实现过程。</span><br></pre></td></tr></table></figure>
<pre><code>ValueAnimator animator = ValueAnimator.ofFloat(0, 100);
animator.setTarget(view);
animator.setDuration(1000).start();
animator.addUpdateListener(new AnimatorUpdateListener(){
    @Override
    public void onAnimationUpdate(ValueAnimator animation){
        Float value = (Float) animation.getAnimatedValue();
        //TODO use the value
    }
})
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 动画事件的监听</span><br><span class="line"></span><br><span class="line">一个完整的动画具有Start, Repeat, End, Cancel四个过程，对动画使用AddListener()即可很方便的监听到这四个事件。</span><br><span class="line"></span><br><span class="line">5. AnimatorSet</span><br><span class="line"></span><br><span class="line">对于一个属性同时作用多个属性动画效果吗可以使用之前的PrpertyValuesHolder实现，而AnimatorSet不仅可以实现效果，还能控制顺序。</span><br></pre></td></tr></table></figure>
<pre><code>ObjectAnimator animator1 = ObjectAnimator.ofFloat(view, &quot;translationX&quot;, 300f);
ObjectAnimator animator2 = ObjectAnimator.ofFloat(view, &quot;scaleX&quot;, 1f, 0f, 1f);
ObjectAnimator animator3 = ObjectAnimator.ofFloat(view, &quot;scaleY&quot;, 1f, 0f, 1f);
AnimatorSet set = new AnimatorSet();
set.setDuration(1000);
set.playTogether(animator1, animator2, animator3);
set.start();
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用playTogether(), playSequentially(), animSet.play().with(),before(),after()来控制多个动画的协同工作方式。</span><br><span class="line"></span><br><span class="line">6. 在xml中使用属性动画</span><br></pre></td></tr></table></figure>
<p>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;</p>
<p><objectanimator xmlns:android="http://schemas.android.com/apk/res/android" android:duration="1000" android:propertyname="scaleX" android:valuefrom="1.0" android:valueto="2.0" android:valuetype="floatType"><br></objectanimator><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<pre><code>public void scaleX(View view){
    Animator anim = AnimatorInflater.loadAnimator(this, R.animator.scalex);
    anim.setTarget(mMv);
    anim.start();
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. View的animate方法</span><br><span class="line"></span><br><span class="line">animate方法是属性动画的一种简写方式</span><br></pre></td></tr></table></figure>
<pre><code>view.animate()
    .alpha(0)
    .y(300)
    .setDuration(300)
    .withStartAction(new Runnable(){
        @Override
        public void run(){

        }
    })
    .withEndAction(new Runnable(){
        @Override
        public void run(){

        }
    }).start();
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 布局动画</span><br><span class="line"></span><br><span class="line">布局动画是指在ViewGroup上，给ViewGroup添加view时添加一个动画过度效果。</span><br><span class="line"></span><br><span class="line">最简单的布局动画，只需要添加</span><br></pre></td></tr></table></figure>
<pre><code>android:animateLayoutChanges=&quot;true&quot;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另外，还可以通过使用LayoutAnimationController类来自定义一个子View的过度效果。</span><br></pre></td></tr></table></figure>
<pre><code>LinearLayout ll = (LinearLayout)findViewById(R.id.ll);
//设置过渡动画
ScaleAnimation sa = new ScaleAnimation(0, 1, 0, 1);
sa.setDuration(2000);
//设置布局动画的显示属性
LayoutAnimationController lac = new LayoutAnimationController(sa, 0.5F);
lac.setOrder(LayoutAnimationController.ORDER_NORMAL);
//为viewgroup设置布局动画
ll.setLayoutAnimation(lac);
</code></pre><p><code>`</code></p>
<p>上述代码可以使得子view出现时有一个缩放的效果。</p>
<h2 id="插值器"><a href="#插值器" class="headerlink" title="插值器"></a>插值器</h2><p>插值器用于定义动画变化速率。</p>
<h2 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h2><p>自定义动画是继承一个Animation然后自己写，自定义动画可以获得当前矩阵对象，然后对矩阵进行操作变化，可以实现任何效果的动画。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/21/2018第三周工作小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/21/2018第三周工作小结/" itemprop="url">2018第三周工作小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-21T21:20:48+08:00">
                2018-01-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先总结一下上周工作计划。<br>上周主要任务是进行图表的优化，添加了点击事件，处理好了相互通信的卡顿问题。<br>收获了几个重要的知识点。对于我这种喜欢使用dataservice来进行数据获取的，需要养成一个习惯就是直接在dataservice里面直接将数据处理成合适的最简洁的数据，用来进行传递。否则使用eventbus会传递速度过于慢。<br>另外就是关于处理点击事件和处理更改产生的bug，不算很大的问题。<br>周四任务完成了，但是又加了一个任务，要把多阶贝塞尔曲线融进来。贝塞尔曲线找了个demo，但是多阶的还是不怎么会，周四感冒，周五工作效率接近于0.</p>
<p>之后还是订一下下周的工作计划安排。</p>
<ol>
<li>处理完毕多阶贝塞尔算法</li>
<li>订餐管理微信登陆token回调设置完成。</li>
</ol>
<p>手上的任务就这几个了。预定周4完成，除此之外需要每天都继续学习群英传。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/16/Android绘图机制与处理技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/16/Android绘图机制与处理技巧/" itemprop="url">Android绘图机制与处理技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-16T21:53:31+08:00">
                2018-01-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本章用于做群英传第六章《Android绘图机制与处理技巧》的学习笔记。主要是整理自己不熟悉的知识点。</p>
<h1 id="屏幕的尺寸信息"><a href="#屏幕的尺寸信息" class="headerlink" title="屏幕的尺寸信息"></a>屏幕的尺寸信息</h1><ol>
<li>屏幕大小</li>
</ol>
<p>屏幕大小指对角线的长度，一般使用寸来度量，寸指英寸，一英寸为2.54cm</p>
<ol>
<li>分辨率</li>
</ol>
<p>分辨率指手机屏幕的像素点个数。1920*1080指宽有1920个像素点，高有1080个像素点</p>
<ol>
<li>ppi</li>
</ol>
<p>pixel per inch，每英寸像素，又称为dpi，为对角线的像素点除以屏幕大小得到。</p>
<h1 id="系统屏幕密度"><a href="#系统屏幕密度" class="headerlink" title="系统屏幕密度"></a>系统屏幕密度</h1><p>根据dpi大小来进行设置，系统定义了几个标准的dpi值。</p>
<p>120: ldpi<br>160: mdpi<br>240: hdpi<br>320: xhdpi<br>480: xxhdpi</p>
<h1 id="独立像素密度-dp"><a href="#独立像素密度-dp" class="headerlink" title="独立像素密度 dp"></a>独立像素密度 dp</h1><p>在mdpi，即dpi为160时， 1dp = 1px。之后顺推即可，xxhdpi为160的3倍，即1dp = 3px</p>
<p>dp涉及到像素工具类的使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class DisplayUtil&#123;</span><br><span class="line"></span><br><span class="line">	public static int px2dp(Context context, float px)&#123;</span><br><span class="line">		final float scale = context.getResource().getDisplayMetrics().density;</span><br><span class="line">		return (int)(px/scale + 0.5f);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static int dp2px(Context context, float dp)&#123;</span><br><span class="line">		final float scale = context.getResource().getDisplayMetrics().density;</span><br><span class="line">		return (int)(dp*scale + 0.5f);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static int px2sp(Context context, float px)&#123;</span><br><span class="line">		final float fontScale = context.getResource().getDisplayMetrics().scaledDensity;</span><br><span class="line">		return (int)(px/fontScale + 0.5f);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static int sp2dp(Context context, float sp)&#123;</span><br><span class="line">		final float fontScale = context.getResource().getDisplayMetrics().scaledDensity;</span><br><span class="line">		return (int)(sp*fontScale + 0.5f);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//以上为使用公式进行换算的</span><br><span class="line">	//还可以使用TypedValue进行换算</span><br><span class="line"></span><br><span class="line">	public static int dp2px(int dp)&#123;</span><br><span class="line">		return (int)TypedValue.applyDimension(</span><br><span class="line">			TypedValue.COMPLEX_UNIT_DIP,</span><br><span class="line">			dp,</span><br><span class="line">			getResources().getDisplayMetrics());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static int sp2px(int sp)&#123;</span><br><span class="line">		return (int)TypeValue.applyDimension(</span><br><span class="line">			TypedValue.COMPLEX_UNIT_SP,</span><br><span class="line">			sp,</span><br><span class="line">			getResources().getDisplayMetrics());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2D绘图基础"><a href="#2D绘图基础" class="headerlink" title="2D绘图基础"></a>2D绘图基础</h1><p>2d绘图即使用系统提供的Canvas对象来提供绘图方法，该章主要是复习一些常用的api。</p>
<ol>
<li>paint</li>
</ol>
<p>setAntiAlias():设置抗锯齿效果<br>setColor():设置画笔的颜色<br>setARGB():设置画笔的啊a,r,g,b值<br>setAlpha():设置画笔透明度<br>setTextSize():设置字体的尺寸<br>setStyle():设置画笔的风格（空心或者实心）<br>setStrokeWidth():设置空心边框的宽度</p>
<ol>
<li>canvas</li>
</ol>
<p>canvas.drawPoint(x, y, paint): 绘制点</p>
<p>canvas.drawLine(startX, startY, endX, endY, paint): 绘制直线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">float[] pts = &#123;</span><br><span class="line">	startX1, startY1, endX1, endY1,</span><br><span class="line">	... ...</span><br><span class="line">	startXn, startYn, endXn, endYn</span><br><span class="line">&#125;;</span><br><span class="line">canvas.drawLines(pts, paint);</span><br><span class="line">//画多条直线</span><br></pre></td></tr></table></figure>
<p>canvas.drawRect(left, top, right, bottom, paint): 绘制矩形</p>
<p>canvas.drawRoundRect(left, top, right, bottom, radiusX, radiuxY, paint):绘制圆角矩形</p>
<p>canvas.drawCircle(circleX, circleY, radius, paint):绘制圆</p>
<p>canvas.drawArc(left, top, right, bottom, startAngle, sweepAngle, useCenter, paint):绘制弧形，扇形，区别在于useCenter</p>
<p>canvas.drawOval(left, top, right, bottom, paint):画椭圆</p>
<p>canvas.drawText(text, startX, startY, paint):绘制文本</p>
<p>canvas.drawPosText(text, new float[]{X1, Y1, X2, Y2… … Xn, Yn}, paint):在制定位置绘制文本</p>
<p>canvas.drawPath(path, paint):绘制路径</p>
<h1 id="Android-xml绘图"><a href="#Android-xml绘图" class="headerlink" title="Android xml绘图"></a>Android xml绘图</h1><ol>
<li>Bitmap</li>
</ol>
<p>在xml中使用bitmap<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">	android:src=&quot;@drawable/ic_launcher&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Shape</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;shape xmlns:android:&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">	android:shape=[&quot;rectangle&quot; | &quot;oval&quot; | &quot;line&quot; | &quot;ring&quot;]&gt;</span><br><span class="line">	//默认为rectangle</span><br><span class="line">	&lt;corners //shape = &quot;rectangle&quot; 有用</span><br><span class="line">		// 半径，会被后面的单个半径属性覆盖，默认为1dp</span><br><span class="line">		android:radius=&quot;integer&quot;</span><br><span class="line">		android:topLeftRadius=&quot;integer&quot;</span><br><span class="line">		android:topRightRadius=&quot;integer&quot;</span><br><span class="line">		android:bottomLeftRadius=&quot;integer&quot;</span><br><span class="line">		android:bottomRightRadius=&quot;integer&quot;/&gt;</span><br><span class="line">	&lt;gradient //渐变</span><br><span class="line">		android:angle=&quot;integer&quot;</span><br><span class="line">		android:centerX=&quot;integer&quot;</span><br><span class="line">		android:centerY=&quot;integer&quot;</span><br><span class="line">		android:centerColor=&quot;integer&quot;</span><br><span class="line">		android:endColor=&quot;color&quot;</span><br><span class="line">		android:gradientRadius=&quot;integer&quot;</span><br><span class="line">		android:startColor=&quot;color&quot;</span><br><span class="line">		android:type=[&quot;linear&quot;| &quot;radius&quot; | &quot;sweep&quot;]</span><br><span class="line">		android:useLevel=[&quot;true&quot; | &quot;false&quot;]/&gt;</span><br><span class="line">	&lt;padding</span><br><span class="line">		android:left=&quot;integer&quot;</span><br><span class="line">		android:top=&quot;integer&quot;</span><br><span class="line">		android:right=&quot;integer&quot;</span><br><span class="line">		android:bottom=&quot;integer&quot;/&gt;</span><br><span class="line">	&lt;size // 指定大小，一般用在imageview配合scaletype属性使用</span><br><span class="line">		android:width=&quot;integer&quot;</span><br><span class="line">		android:height=&quot;integer&quot;/&gt;</span><br><span class="line">	&lt;solid // 填充颜色</span><br><span class="line">		android:color=&quot;color&quot;/&gt;</span><br><span class="line">	&lt;stroke //指定边框</span><br><span class="line">		android:width=&quot;integer&quot;</span><br><span class="line">		android:color=&quot;color&quot;</span><br><span class="line">		android:dashWidth=&quot;integer&quot; //虚线宽度</span><br><span class="line">		android:dashGap=&quot;integer&quot; // 虚线间隔宽度</span><br><span class="line">		/&gt;</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>Layer</li>
</ol>
<p>layer中可以使用层级来进行叠加，主要是用item，item可以使用drawable，也可使用shape</p>
<ol>
<li>Selector</li>
</ol>
<p>Selector用于帮开发者实现静态绘图中的事件反馈，通过不同的事件设置不同的图像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">	//默认时的背景图片</span><br><span class="line">	&lt;item android:drawable=&quot;@drawable/x1&quot;/&gt;</span><br><span class="line">	//没有焦点时的图片</span><br><span class="line">	&lt;item android:state_window_focused=&quot;false&quot; android:drawable=&quot;@drawable/x2&quot;/&gt;</span><br><span class="line">	//非触摸模式下获得焦点并单击时的背景图片</span><br><span class="line">	&lt;item android:state_focuse=&quot;true&quot; android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/x3&quot;/&gt;</span><br><span class="line">	//触摸模式下单击时的背景图片</span><br><span class="line">	&lt;item android:state_focuse=&quot;false&quot; android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/x4&quot;/&gt;</span><br><span class="line">	//选中时的背景图片</span><br><span class="line">	&lt;item android:state_selected=&quot;true&quot; android:drawable=&quot;@drawable/x5&quot;/&gt;</span><br><span class="line">	//获得焦点时的背景图片</span><br><span class="line">	&lt;item android:state_focused=&quot;true&quot; android:drawable=&quot;@drawable/x6&quot;/&gt;</span><br><span class="line">&lt;/selector&gt;</span><br></pre></td></tr></table></figure>
<p>以上可以用于制作view的触摸反馈。</p>
<h1 id="android-绘图技巧"><a href="#android-绘图技巧" class="headerlink" title="android 绘图技巧"></a>android 绘图技巧</h1><p>之上的是基本绘图技巧，之下的是常用绘图技巧</p>
<ol>
<li>Canvas</li>
</ol>
<p>Canvas.save(): 将之前的所有绘制图像保存起来，之后的操作就好像在一个新的图层上面操作一样。</p>
<p>Canvas.restore(): 用于合并图层，可以用于将save之后绘制的所有图像与save之前的图像合并</p>
<p>Canvas.translate():调用translate(x, y)操作可以将原点(0, 0)移动到(x, y)之后的所有操作都将以(x, y)为原点执行</p>
<p>Canvas.rotate():调用rotate(degree)之后可以将canvas调转一定的角度。</p>
<ol>
<li>Layer图层</li>
</ol>
<p>Android通过调用saveLayer()方法，saveLayerAlpha()方法将一个图层入栈，使用restore()方法,restoreToCount()方法将一个图层出栈。出栈的时候，会把图像绘制到上层Canvas上。</p>
<h1 id="画笔特效处理"><a href="#画笔特效处理" class="headerlink" title="画笔特效处理"></a>画笔特效处理</h1><ol>
<li>PorterDuffXferMode</li>
</ol>
<p>该模式控制的是两个图像间的混合显示模式。dst是先画的图形，src是后画的图形。</p>
<ol>
<li>Shader</li>
</ol>
<p>shader被称为着色器，渲染器。可以用来实现一系列的渐变、渲染效果。</p>
<p>其中shader包括：<br>BitmapShader   —  位图shader<br>LinearGradient —  线性shader<br>RadialGradient —  光束shader<br>SweepGradient  —  梯度shader<br>ComposeShader  —  混合shader</p>
<p>shader的作用就是通过paint对画布进行指定的bitmap的填充，填充时有三种模式</p>
<p>CLAMP  — 拉伸的是图片最后的那一个像素，不断重复<br>REPEAT — 横向纵向不断重复<br>MIRROR — 横向不断翻转重复，纵向不断翻转重复</p>
<ol>
<li>PathEffect</li>
</ol>
<p>patheffect是指用各种笔触效果来绘制一个路径。</p>
<p>CornerPathEffect:   将拐角处变的圆滑<br>DiscretePathEffect:    使用这个之后线段上会出现很多杂点<br>DashPathEffect:        使用这个可以绘制虚线，用一个数组来设置各个点之间的间隔，此后绘制虚线时就重复这样的间隔进行绘制，另一个参数phase可以用来绘制时数组的一个偏移量，可以通过设置值来实现路径的动态效果。<br>PathDashPathEffect: 与dashpatheffect类似，不过功能更强大，可以设置点的图形，例如方形点的虚线，圆形点的虚线<br>ComposePathEffect   可以通过composepatheffect来组合patheffect，这个方法的功能就是将任意的两种路径特性组合起来形成一个新的效果。</p>
<h1 id="SurfaceView"><a href="#SurfaceView" class="headerlink" title="SurfaceView"></a>SurfaceView</h1><ol>
<li>surfaceview 和view的区别</li>
</ol>
<p>对view来说，android系统通过发出VSYNC信号来进行屏幕的重绘，刷新的间隔为16ms，如果在16ms内view完成了所需要执行的所有操作，那么用户在视觉上就不会产生卡顿的感觉。但是执行的操作逻辑太多，在需要频繁刷新的界面上，就会阻塞主线程，因此android提供了surfaceview。</p>
<p>view主要适用于主动更新的情况下，而surfaceview主要适用于被动更新，例如频繁刷新<br>view在主线程中对画面进行刷新，surfaceview则通常会通过一个子线程来进行页面的刷新<br>view在绘图时没有使用双缓冲机制，而surfaceview在底层实现机制中就已经实现了双缓冲机制</p>
<ol>
<li>surfaceview的使用</li>
</ol>
<p>surfaceview使用有一套模版可以根据模版进行操作</p>
<h2 id="创建surfaceview："><a href="#创建surfaceview：" class="headerlink" title="创建surfaceview："></a>创建surfaceview：</h2><p>创建自定义的surfaceview需要继承SurfaceView,并实现两个接口– surfaceholder callback和 runnable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class SurfaceViewTemplate extends SurfaceView implements SurfaceHolder.Callback, Runnable</span><br></pre></td></tr></table></figure>
<p>之后需要实现这两个接口</p>
<h2 id="初始化SurfaceView"><a href="#初始化SurfaceView" class="headerlink" title="初始化SurfaceView"></a>初始化SurfaceView</h2><p>自定义surfaceview的构造方法中，需要对surfaceview进行初始化，在自定义的surfaceview中，通常需要定义三个成员变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//SurfaceHolder</span><br><span class="line">private SurfaceHolder mHolder;</span><br><span class="line">//用于绘图的Canvas</span><br><span class="line">private Canvas mCanvas;</span><br><span class="line">//子线程标识位</span><br><span class="line">private boolean mIsDrawing;</span><br></pre></td></tr></table></figure>
<p>canvas用于绘图，标志位用于控制子线程。</p>
<h2 id="使用SurfaceView"><a href="#使用SurfaceView" class="headerlink" title="使用SurfaceView"></a>使用SurfaceView</h2><p>通过surfaceholder对象的lockCanvas()方法，就可以得到当前的canvas绘图对象，接下来就可以与在view中绘制一样的操作了。<br>每次调用这个方法获取到的canvas都是继续上次的对象。清屏可以使用drawColor()操作。</p>
<p>绘制的时候，在surfaceCreated()中开启子线程进行绘制，而子线程使用一个while(mIsDrawing)的循环来不停的进行绘制。<br>绘制的具体过程，使用lockCanvas()方法获得的Canvas对象进行绘制，并通过unlockCanvasAndPost(mCanvas)方法对画布内容进行提交。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/14/2018第二周工作小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/14/2018第二周工作小结/" itemprop="url">2018第二周工作小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-14T22:15:58+08:00">
                2018-01-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这周的工作小结拖到了周末才写，不过还是写一下吧。</p>
<p>这周的主要工作还是搞那个williamchart的图表，解决了数据填充的问题，中间组件传输仍然是使用了eventbus来传输。</p>
<p>一个技术难点突破是，在响应式中做上游下游的响应操作，这次主要是了解了rxjava的map和flatmap的差别。map主要是直接将第一个参数传到下游，这有一个问题，就是假如上游是一个observable，那仍然会传一个observable。因此map的使用场景主要是用在由上游传递一些固定参数的。flatmap则是可以将上游的observable进行转换，将observable获得的东西传到下游。</p>
<p>除此之外还学到一个就是emitter，这个可以控制下游的生命周期，但是只可以控制onnext和oncomplete。但是忽略了这点会导致oncomplete无法执行。</p>
<p>大概就是学了上面两个技术点，其余大部分时间用于处理graphq的语句，返回数值的处理了，没想到居然用了一周的时间。不过周五请假也算就用了四天。</p>
<p>之后的任务，数据是好了，但是需要改ui了，点击的ui要改，滑动曲线的ui也要改，还有一些杂七杂八的ui。</p>
<p>给自己定了3天的工作计划，希望周三晚上能处理完毕吧。</p>
<p>这周开始给自己打分，以后每周都是周日开始写本周总结，并且定下下周的任务，之后按照下周的任务完成度来给自己打分。</p>
<p>本周开始的话，那我给上周打个98分吧，少两分怕自己骄傲～</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/13/androidscroll分析笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/androidscroll分析笔记/" itemprop="url">androidscroll分析笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-13T15:42:18+08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="android坐标系"><a href="#android坐标系" class="headerlink" title="android坐标系"></a>android坐标系</h1><p>在android中，将屏幕最左上角的顶点作为android坐标系的原点，往右是x轴正方向，往下是y轴正方向。</p>
<h1 id="视图坐标系"><a href="#视图坐标系" class="headerlink" title="视图坐标系"></a>视图坐标系</h1><p>视图坐标系原点以父视图左上角为坐标原点。</p>
<h1 id="触控事件-MotionEvent"><a href="#触控事件-MotionEvent" class="headerlink" title="触控事件 - MotionEvent"></a>触控事件 - MotionEvent</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static final int ACTION_DOWN = 0;//单击触摸按下动作</span><br><span class="line">public static final int ACTION_UP = 1;//单击触摸离开动作</span><br><span class="line">public static final int ACTION_MOVE = 2;//触摸点移动动作</span><br><span class="line">public static final int ACTION_CANCEL = 3;//触摸动作取消</span><br><span class="line">public static final int ACTION_OUTSIDE = 4;//触摸动作超出边界</span><br><span class="line">public static final int ACTION_POINTER_DOWN = 5;//多点触摸按下动作</span><br><span class="line">public static final int ACTION_POINTER_UP = 6;//多点离开动作</span><br></pre></td></tr></table></figure>
<h2 id="ACTION-CANCEL"><a href="#ACTION-CANCEL" class="headerlink" title="ACTION_CANCEL"></a>ACTION_CANCEL</h2><p>当你的手指（或者其它）移动屏幕的时候会触发这个事件，比如当你的手指在屏幕上拖动一个listView或者一个ScrollView而不是去按上面的按钮时会触发这个事件。</p>
<p>在设计设置页面的滑动开关时，如果不监听ACTION_CANCEL，在滑动到中间时，如果你手指上下移动，就是移动到开关控件之外，则此时会触发ACTION_CANCEL，而不是ACTION_UP，造成开关的按钮停顿在中间位置。</p>
<p>意思就是，当用户保持按下操作，并从你的控件转移到外层控件时，会触发ACTION_CANCEL，建议进行处理～</p>
<p>当前的手势被中断，不会再接收到关于它的记录。<br>推荐将这个事件作为 ACTION_UP 来看待，但是要区别于普通的 ACTION_UP</p>
<p>话说回来，平常还真碰不到这个事件，习惯上就直接当 ACTION_UP 处理了就</p>
<p>例如：上层 View 是一个 RecyclerView，它收到了一个 ACTION_DOWN 事件，由于这个可能是点击事件，所以它先传递给对应 ItemView，询问 ItemView 是否需要这个事件，然而接下来又传递过来了一个 ACTION_MOVE 事件，且移动的方向和 RecyclerView 的可滑动方向一致，所以 RecyclerView 判断这个事件是滚动事件，于是要收回事件处理权，这时候对应的 ItemView 会收到一个 ACTION_CANCEL ，并且不会再收到后续事件。</p>
<h2 id="ACTION-OUTSIDE"><a href="#ACTION-OUTSIDE" class="headerlink" title="ACTION_OUTSIDE"></a>ACTION_OUTSIDE</h2><p>一个触摸事件已经发生了UI元素的正常范围之外。因此不再提供完整的手势，只提供 运动/触摸 的初始位置。dialog,popupwindow中比较常见</p>
<h2 id="ACTION-POINTER-DOWN"><a href="#ACTION-POINTER-DOWN" class="headerlink" title="ACTION_POINTER_DOWN"></a>ACTION_POINTER_DOWN</h2><p>这个代表用户的第二根手指（之后动手的一根）触摸了屏幕，可以getactionindex获取某一根手指的数字来判断</p>
<h2 id="ACTION-POINTER-UP"><a href="#ACTION-POINTER-UP" class="headerlink" title="ACTION_POINTER_UP"></a>ACTION_POINTER_UP</h2><p>同第二根手指离开了屏幕</p>
<h1 id="获取坐标的方法"><a href="#获取坐标的方法" class="headerlink" title="获取坐标的方法"></a>获取坐标的方法</h1><h2 id="View提供的方法（以父布局为坐标系）"><a href="#View提供的方法（以父布局为坐标系）" class="headerlink" title="View提供的方法（以父布局为坐标系）"></a>View提供的方法（以父布局为坐标系）</h2><p>getTop():自身到其父布局顶点的距离<br>getLeft():<br>getRight():<br>getBottom():</p>
<h2 id="MotionEvent提供的方法"><a href="#MotionEvent提供的方法" class="headerlink" title="MotionEvent提供的方法"></a>MotionEvent提供的方法</h2><p>getX():获取点击事件距离空间左边的距离<br>getY():<br>getRawX():获取点击事件距离整个屏幕左边的距离<br>getRawY():</p>
<h1 id="实现滑动效果的7种方法"><a href="#实现滑动效果的7种方法" class="headerlink" title="实现滑动效果的7种方法"></a>实现滑动效果的7种方法</h1><ol>
<li><p>layout方法<br>在ACTION_MOVE中计算偏移量，在action_down中记录触摸点的坐标，并且在move中进行计算偏移量，然后调用view的layout方法来进行调整。</p>
</li>
<li><p>offsetLeftAndRight和offsetTopAndBottom<br>使用方法和layout一样，差别是一个需要x的偏移一个需要y的偏移</p>
</li>
<li><p>LayoutParams</p>
</li>
</ol>
<p>layoutParams保留了一个view的参数，可以改变view的layoutParams然后setLayoutParams进行更改。</p>
<ol>
<li>scrollto和scrollby</li>
</ol>
<p>scrollby(offsetx，offsety)，该方法会造成所有子view移动。因此需要对view的父view使用这个方法，</p>
<ol>
<li>Scroller</li>
</ol>
<p>scroller可以通过重写view的computeScroll方法，通过获取当前滚动值，来进行不断的瞬间移动，实现整体上的平移效果<br>ps：computeScroll方法是不会自动调用的，只能通过invalidate() -&gt; draw() -&gt; computeScroll()来间接调用该方法。<br>之后使用startScroll即可。</p>
<ol>
<li><p>属性动画</p>
</li>
<li><p>ViewDragHelper</p>
</li>
</ol>
<p>viewdraghelper是谷歌在support库中提供的drawerlayout和slidingpanelayout两个布局中使用的，用法较为复杂。</p>
<ol>
<li>初始化viewdraghelper</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mViewDragHelper = ViewDragHelper.create(this, callback);</span><br></pre></td></tr></table></figure>
<ol>
<li>拦截事件</li>
</ol>
<p>将事件传递给viewdraghelper处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onInterceptTouchEvent(MotionEvent ev)&#123;</span><br><span class="line">	return mViewDragHelper.shouldInterceptTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public boolean onTouchEvent(MotionEvent ev)&#123;</span><br><span class="line">	mViewDragHelper.processTouchEvent(event);</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>处理computeScroll()</li>
</ol>
<p>与scroller相似的，需要处理一个computescroll()方法，因为viewdraghelper内部也是使用scroller实现平滑移动的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void computeScroll()&#123;</span><br><span class="line">	if(mViewdragHelper.continueSettling(true))&#123;</span><br><span class="line">		ViewCompat.postInvalidateOnAnimation(this);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>处理回调</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private ViewDragHelper.Callback callback = new ViewDragHelper.Callback()&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public boolean tryCaptureView(View child, int pointerId)&#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用上述回调，对child进行判断，如果是需要拖动view，就可以返回true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int clampViewPositionVertical(View child, int top, int dy)&#123;</span><br><span class="line">	return top;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public int clampViewPositionHorizontal(View child, int left, int dx)&#123;</span><br><span class="line">	return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用如上方法，来对滑动效果进行设置，返回的top和left为垂直和水平方向上面的距离。dy表示比较前一次的增量</p>
<ol>
<li>拖动结束之后，子View回到原来的位置</li>
</ol>
<p>该效果可以通过监听action_up事件，并通过调用Scroller类来实现。<br>在viewdraghelper中可以重写onViewRelased()方法来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onViewReleased(View releasedChild, float xvel, float yvel)&#123;</span><br><span class="line">	super.onViewReleased(releasedChild, xvel, yvel);</span><br><span class="line">	if(mMianView.getLeft()&lt;500)&#123;</span><br><span class="line">		mViewDragHelper.smoothSlideViewTo(mMainView, 0, 0);</span><br><span class="line">		ViewCompat.postInvalidateOnAnimation(DragViewGroup.this);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		mViewDragHelper.smoothSlideViewTo(mMainView, 300, 0);</span><br><span class="line">		ViewCompat.postInvalidateOnAnimation(DragViewGroup.this);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以做到滑动距离小于500时回到原来的位置。</p>
<p>除了以上内容，还有大量的监听事件可以用来处理各种事件。<br>onViewCaptured():在用户触摸到view后回调<br>onViewDragStateChanged():在拖拽状态改变时回调<br>onViewPositionChanged():这个事件在位置改变时回调</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/12/某金融公司面试小记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/12/某金融公司面试小记/" itemprop="url">某金融公司面试小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-12T20:38:32+08:00">
                2018-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前几天在boss直聘上面接到了一个面试邀请，hr蛮真诚的，今天下午请了半天年假去试试。</p>
<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><p>首先是笔试，笔试第一题是Math.round(11.5)和Math.round(-11.5)的值,我居然没用过，当时猜的12和-11，还猜对了。</p>
<p>挑有印象的写。</p>
<p>之后是问intent能传送哪些内容，serizable，parcel，bundle，charsquence,当时忘了，就写了个parcel和bundle，回来一看其实都能..</p>
<p>之后的一些字符串处理的<br>StringBuffer str = new StringBuffer(“hello”);<br>str.append(“world”);<br>当然输出hello world了</p>
<p>List<integer> listA = new ArrayList&lt;&gt;();<br>listA.add(1);<br>listA.add(2);<br>List<integer> listB = new ArrayList&lt;&gt;(listA);<br>Collections.copy(listA, listB);<br>这时候listb还是1，2</integer></integer></p>
<p>fragment在activity中使用和fragment中使用的差别：<br>记得就是fragmentmanager的差别，context的差别。</p>
<p>解释一下DVM中的线程和linux中线程的区别：<br>DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。<br>这题不会。</p>
<p>笔试大概就这么多了。</p>
<h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><p>一面是个android的leader，刚开始还不是很打开话夹子，问我为啥走，问我做了哪些工作。居然还把我app开发说成只有6个月，丫的。<br>这个leader感觉没问啥高深的问题，我居然都想不起来了。但我的确有几个没回答的上来..汗怎么忘了。</p>
<p>感觉好像对大学学java的比较歧视，以为我没有多深的java功底。</p>
<p>后来问我kotlin的一些相关的，高阶编程，我以为是函数式编程，拿python的高阶函数去说，还居然蒙对了。<br>还问我h5会不会，我说只会一丁点，node会不会，只会搭博客，python会不会，这个有。没问c我有点诧异。</p>
<p>问了我一个问题，关于activity的启动模式的，四种我都熟了，后来问我假如这四种同时添加，栈内什么情况，我说正确的，后来问我怎么从a回退到c，我真不知道这个，只能从activitymanager获取stack这个角度来说，这样获取了实例可以直接启动。</p>
<h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><p>二面是项目经理，这是大神，上来就是一系列由浅入深的题目，让我用mvp设计一个架构，保证耦合度低和热插拔，这部分是接口分离的原则来设计，这部分真不了解。<br>之后问我一些别的内容，数据结构方面的，set vector的区别，我居然说vector是线程安全的，但是好像不止这些，其内部指责都不同。<br>还问了我一些内容，可是好多我都忘了- -汗。</p>
<h1 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h1><p>三面是个证券经理，既然是证券经理，为啥揪着我简历上面的技术栈问..蛋疼</p>
<h1 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h1><p>四面是个妹子，和我讲了一些公司的发展，薪酬方面的，大概扣多少钱五险之类的。</p>
<h1 id="五面"><a href="#五面" class="headerlink" title="五面"></a>五面</h1><p>五面是联系我去公司的hr，他和我讲了好久公司发展的内容，其实我写的预期薪资并不高啊，最后成功的从税前13扯到了税后11-12，其实还不错。不过明显的他有点慌，他的意思是希望我接到offer能早点去，不要太拖，不要被别的公司高不到5k的offer挖走。汗，加5k是他妈18k了，我哪里值这么多钱。</p>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><p>安卓开发自己还是投入了不少心血的，虽然一年半的从业经验，还是收获了不少东西，这次面试也证明了自己的能力。不再是当年在传音的时候任人宰割的那个我了。</p>
<h1 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h1><p>希望能拿到offer吧，税后12我就去，11以内我就放弃。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/11/快速排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/11/快速排序/" itemprop="url">快速排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-11T22:32:16+08:00">
                2018-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>快速排序是内部排序中交换排序的一种。</p>
<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>1）选择一个基准元素,通常选择第一个元素或者最后一个元素,</p>
<p>2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。</p>
<p>3）此时基准元素在其排好序后的正确位置</p>
<p>4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>O(1)</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>最理想 O(nlogn) 最差时间O(n^2)</p>
<h1 id="算法实现思想"><a href="#算法实现思想" class="headerlink" title="算法实现思想"></a>算法实现思想</h1><h1 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void sort(int[] a)&#123;</span><br><span class="line">	int start = 0;</span><br><span class="line">	int end = a.length-1;</span><br><span class="line">	int key = a[low];</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	while(end&gt;start)&#123;</span><br><span class="line">		//从后往前比较</span><br><span class="line">		while(end&gt;start&amp;&amp;a[end]&gt;=key)  //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较</span><br><span class="line">		end--;</span><br><span class="line">		if(a[end]&lt;=key)&#123;</span><br><span class="line">			int temp = a[end];</span><br><span class="line">			a[end] = a[start];</span><br><span class="line">			a[start] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		//从前往后比较</span><br><span class="line">		while(end&gt;start&amp;&amp;a[start]&lt;=key)//如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置</span><br><span class="line">		start++;</span><br><span class="line">		if(a[start]&gt;=key)&#123;</span><br><span class="line">			int temp = a[start];</span><br><span class="line">			a[start] = a[end];</span><br><span class="line">			a[end] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		//此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用</span><br><span class="line">	&#125;</span><br><span class="line">	//递归</span><br><span class="line">	if(start&gt;low) sort(a,low,start-1);//左边序列。第一个索引位置到关键值索引-1</span><br><span class="line">	if(end&lt;high) sort(a,end+1,high);//右边序列。从关键值索引+1到最后一个</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="c实现"><a href="#c实现" class="headerlink" title="c实现"></a>c实现</h1><h1 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/11/冒泡排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sample">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/11/冒泡排序/" itemprop="url">冒泡排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-11T21:52:24+08:00">
                2018-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>冒泡排序是内部排序中交换排序的一种。</p>
<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>对当前还未排序好的范围内的全部数，自上而下对相邻的两个数进行比较和调整，大的下沉，小的上浮。</p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>只是互换，为O(1)</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>两次循环，故为O(n^2)</p>
<h1 id="算法实现思想"><a href="#算法实现思想" class="headerlink" title="算法实现思想"></a>算法实现思想</h1><p>每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p>
<h1 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int[] bubbleSort(int[] array)&#123;</span><br><span class="line">	int[] arr = array;</span><br><span class="line">	for(int i = 0; i &lt; array.length - 1; i ++)&#123;</span><br><span class="line">		for(int j = 0; j &lt; array.length - i - 1; j ++)&#123;</span><br><span class="line">			if(arr[j] &gt; arr[j+1])&#123;</span><br><span class="line">				int temp = arr[j];</span><br><span class="line">				arr[j] = arr[j+1];</span><br><span class="line">				arr[j+1] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="c实现"><a href="#c实现" class="headerlink" title="c实现"></a>c实现</h1><h1 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sample</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sample</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
